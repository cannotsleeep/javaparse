[{"input":"","instruction":"<line1>{\n<line2>    refreshFailed.set(true);\n<line3>    continueRefreshThread.await(20, TimeUnit.SECONDS);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"sleep started due to failed refresh\");\n<line3>    refreshFailed.set(true);\n<line4>    continueRefreshThread.await(20, TimeUnit.SECONDS);\n<line5>    LOG.info(\"sleep due to failed refresh finished\");\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    continueRefreshThread.countDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"continue refresh thread\");\n<line3>    continueRefreshThread.countDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        File saslConfFile = new File(testTempDir, \"jaas.conf\");\n<line4>        FileWriter fwriter = new FileWriter(saslConfFile);\n<line5>        fwriter.write(jaasEntries);\n<line6>        fwriter.close();\n<line7>        System.setProperty(\"java.security.auth.login.config\", saslConfFile.getAbsolutePath());\n<line8>    } catch (IOException ioe) {\n<line9>    }\n<line10>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line11>    // even if other tests already have been executed and initialized the SASL configs before)\n<line12>    Configuration.getConfiguration().refresh();\n<line13>}","output":"<line1>{\n<line2>    try {\n<line3>        File saslConfFile = new File(testTempDir, \"jaas.conf\");\n<line4>        FileWriter fwriter = new FileWriter(saslConfFile);\n<line5>        fwriter.write(jaasEntries);\n<line6>        fwriter.close();\n<line7>        System.setProperty(\"java.security.auth.login.config\", saslConfFile.getAbsolutePath());\n<line8>    } catch (IOException ioe) {\n<line9>        LOG.error(\"Failed to initialize JAAS conf file\", ioe);\n<line10>    }\n<line11>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line12>    // even if other tests already have been executed and initialized the SASL configs before)\n<line13>    Configuration.getConfiguration().refresh();\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to initialize JAAS conf file\", ioe);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.setUp();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING quorum {}\", getClass().getName());\n<line3>    qb.setUp();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING quorum {}\", getClass().getName());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line3>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line4>    ZooKeeper zk = ClientBase.createZKClient(qb.hostPort, 10000);\n<line5>    SyncRequestProcessor.setSnapCount(100);\n<line6>    for (int i = 0; i < 2000; i++) {\n<line7>        zk.create(\"/0-\" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);\n<line8>    }\n<line9>    zk.close();\n<line10>    long leaderSid = 1;\n<line11>    QuorumPeer leader = null;\n<line12>    //find out who is the leader and kill it\n<line13>    for (QuorumPeer quorumPeer : Arrays.asList(qb.s1, qb.s2, qb.s3, qb.s4, qb.s5)) {\n<line14>        if (quorumPeer.getPeerState() == ServerState.LEADING) {\n<line15>            leader = quorumPeer;\n<line16>            break;\n<line17>        }\n<line18>        ++leaderSid;\n<line19>    }\n<line20>    assertNotNull(leader, \"Cannot find the leader.\");\n<line21>    leader.shutdown();\n<line22>    // now corrupt the leader's database\n<line23>    FileTxnSnapLog snapLog = leader.getTxnFactory();\n<line24>    File snapDir = snapLog.getSnapDir();\n<line25>    //corrupt all the snapshot in the snapshot directory\n<line26>    corruptAllSnapshots(snapDir);\n<line27>    qb.shutdownServers();\n<line28>    qb.setupServers();\n<line29>    if (leaderSid != 1) {\n<line30>        qb.s1.start();\n<line31>    } else {\n<line32>        leader = qb.s1;\n<line33>    }\n<line34>    if (leaderSid != 2) {\n<line35>        qb.s2.start();\n<line36>    } else {\n<line37>        leader = qb.s2;\n<line38>    }\n<line39>    if (leaderSid != 3) {\n<line40>        qb.s3.start();\n<line41>    } else {\n<line42>        leader = qb.s3;\n<line43>    }\n<line44>    if (leaderSid != 4) {\n<line45>        qb.s4.start();\n<line46>    } else {\n<line47>        leader = qb.s4;\n<line48>    }\n<line49>    if (leaderSid != 5) {\n<line50>        qb.s5.start();\n<line51>    } else {\n<line52>        leader = qb.s5;\n<line53>    }\n<line54>    try {\n<line55>        leader.start();\n<line56>        assertTrue(false);\n<line57>    } catch (RuntimeException re) {\n<line58>    }\n<line59>    //wait for servers to be up\n<line60>    String[] list = qb.hostPort.split(\",\");\n<line61>    for (int i = 0; i < 5; i++) {\n<line62>        if (leaderSid != (i + 1)) {\n<line63>            String hp = list[i];\n<line64>            assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line65>        } else {\n<line66>        }\n<line67>    }\n<line68>    zk = qb.createClient();\n<line69>    SyncRequestProcessor.setSnapCount(100);\n<line70>    for (int i = 2000; i < 4000; i++) {\n<line71>        zk.create(\"/0-\" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);\n<line72>    }\n<line73>    zk.close();\n<line74>    if (leaderSid != 1) {\n<line75>        QuorumBase.shutdown(qb.s1);\n<line76>    }\n<line77>    if (leaderSid != 2) {\n<line78>        QuorumBase.shutdown(qb.s2);\n<line79>    }\n<line80>    if (leaderSid != 3) {\n<line81>        QuorumBase.shutdown(qb.s3);\n<line82>    }\n<line83>    if (leaderSid != 4) {\n<line84>        QuorumBase.shutdown(qb.s4);\n<line85>    }\n<line86>    if (leaderSid != 5) {\n<line87>        QuorumBase.shutdown(qb.s5);\n<line88>    }\n<line89>}","output":"<line1>{\n<line2>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line3>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line4>    ZooKeeper zk = ClientBase.createZKClient(qb.hostPort, 10000);\n<line5>    SyncRequestProcessor.setSnapCount(100);\n<line6>    for (int i = 0; i < 2000; i++) {\n<line7>        zk.create(\"/0-\" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);\n<line8>    }\n<line9>    zk.close();\n<line10>    long leaderSid = 1;\n<line11>    QuorumPeer leader = null;\n<line12>    //find out who is the leader and kill it\n<line13>    for (QuorumPeer quorumPeer : Arrays.asList(qb.s1, qb.s2, qb.s3, qb.s4, qb.s5)) {\n<line14>        if (quorumPeer.getPeerState() == ServerState.LEADING) {\n<line15>            leader = quorumPeer;\n<line16>            break;\n<line17>        }\n<line18>        ++leaderSid;\n<line19>    }\n<line20>    assertNotNull(leader, \"Cannot find the leader.\");\n<line21>    leader.shutdown();\n<line22>    // now corrupt the leader's database\n<line23>    FileTxnSnapLog snapLog = leader.getTxnFactory();\n<line24>    File snapDir = snapLog.getSnapDir();\n<line25>    //corrupt all the snapshot in the snapshot directory\n<line26>    corruptAllSnapshots(snapDir);\n<line27>    qb.shutdownServers();\n<line28>    qb.setupServers();\n<line29>    if (leaderSid != 1) {\n<line30>        qb.s1.start();\n<line31>    } else {\n<line32>        leader = qb.s1;\n<line33>    }\n<line34>    if (leaderSid != 2) {\n<line35>        qb.s2.start();\n<line36>    } else {\n<line37>        leader = qb.s2;\n<line38>    }\n<line39>    if (leaderSid != 3) {\n<line40>        qb.s3.start();\n<line41>    } else {\n<line42>        leader = qb.s3;\n<line43>    }\n<line44>    if (leaderSid != 4) {\n<line45>        qb.s4.start();\n<line46>    } else {\n<line47>        leader = qb.s4;\n<line48>    }\n<line49>    if (leaderSid != 5) {\n<line50>        qb.s5.start();\n<line51>    } else {\n<line52>        leader = qb.s5;\n<line53>    }\n<line54>    try {\n<line55>        leader.start();\n<line56>        assertTrue(false);\n<line57>    } catch (RuntimeException re) {\n<line58>        LOG.info(\"Got an error: expected\", re);\n<line59>    }\n<line60>    //wait for servers to be up\n<line61>    String[] list = qb.hostPort.split(\",\");\n<line62>    for (int i = 0; i < 5; i++) {\n<line63>        if (leaderSid != (i + 1)) {\n<line64>            String hp = list[i];\n<line65>            assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line66>            LOG.info(\"{} is accepting client connections\", hp);\n<line67>        } else {\n<line68>            LOG.info(\"Skipping the leader\");\n<line69>        }\n<line70>    }\n<line71>    zk = qb.createClient();\n<line72>    SyncRequestProcessor.setSnapCount(100);\n<line73>    for (int i = 2000; i < 4000; i++) {\n<line74>        zk.create(\"/0-\" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);\n<line75>    }\n<line76>    zk.close();\n<line77>    if (leaderSid != 1) {\n<line78>        QuorumBase.shutdown(qb.s1);\n<line79>    }\n<line80>    if (leaderSid != 2) {\n<line81>        QuorumBase.shutdown(qb.s2);\n<line82>    }\n<line83>    if (leaderSid != 3) {\n<line84>        QuorumBase.shutdown(qb.s3);\n<line85>    }\n<line86>    if (leaderSid != 4) {\n<line87>        QuorumBase.shutdown(qb.s4);\n<line88>    }\n<line89>    if (leaderSid != 5) {\n<line90>        QuorumBase.shutdown(qb.s5);\n<line91>    }\n<line92>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Got an error: expected\", re);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (leaderSid != (i + 1)) {\n<line3>        String hp = list[i];\n<line4>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line5>    } else {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (leaderSid != (i + 1)) {\n<line3>        String hp = list[i];\n<line4>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line5>        LOG.info(\"{} is accepting client connections\", hp);\n<line6>    } else {\n<line7>        LOG.info(\"Skipping the leader\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    String hp = list[i];\n<line3>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line4>}","output":"<line1>{\n<line2>    String hp = list[i];\n<line3>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line4>    LOG.info(\"{} is accepting client connections\", hp);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Skipping the leader\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    setupTestEnv();\n<line3>    JMXEnv.setUp();\n<line4>    setUpAll();\n<line5>    port1 = PortAssignment.unique();\n<line6>    port2 = PortAssignment.unique();\n<line7>    portLE1 = PortAssignment.unique();\n<line8>    portLE2 = PortAssignment.unique();\n<line9>    portClient1 = PortAssignment.unique();\n<line10>    portClient2 = PortAssignment.unique();\n<line11>    hostPort = \"127.0.0.1:\" + portClient1 + \",127.0.0.1:\" + portClient2;\n<line12>    s1dir = ClientBase.createTmpDir();\n<line13>    s2dir = ClientBase.createTmpDir();\n<line14>    createOraclePath();\n<line15>    startServers();\n<line16>    OSMXBean osMbean = new OSMXBean();\n<line17>    if (osMbean.getUnix()) {\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    LOG.info(\"QuorumBase.setup {}\", getTestName());\n<line3>    setupTestEnv();\n<line4>    JMXEnv.setUp();\n<line5>    setUpAll();\n<line6>    port1 = PortAssignment.unique();\n<line7>    port2 = PortAssignment.unique();\n<line8>    portLE1 = PortAssignment.unique();\n<line9>    portLE2 = PortAssignment.unique();\n<line10>    portClient1 = PortAssignment.unique();\n<line11>    portClient2 = PortAssignment.unique();\n<line12>    hostPort = \"127.0.0.1:\" + portClient1 + \",127.0.0.1:\" + portClient2;\n<line13>    LOG.info(\"Ports are: {}\", hostPort);\n<line14>    s1dir = ClientBase.createTmpDir();\n<line15>    s2dir = ClientBase.createTmpDir();\n<line16>    createOraclePath();\n<line17>    startServers();\n<line18>    OSMXBean osMbean = new OSMXBean();\n<line19>    if (osMbean.getUnix()) {\n<line20>        LOG.info(\"Initial fdcount is: {}\", osMbean.getOpenFileDescriptorCount());\n<line21>    }\n<line22>    LOG.info(\"Setup finished\");\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Initial fdcount is: {}\", osMbean.getOpenFileDescriptorCount());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    Map<Long, QuorumPeer.QuorumServer> peers = new HashMap<>();\n<line7>    peers.put(Long.valueOf(1), new QuorumPeer.QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), QuorumPeer.LearnerType.PARTICIPANT));\n<line8>    peers.put(Long.valueOf(2), new QuorumPeer.QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), QuorumPeer.LearnerType.PARTICIPANT));\n<line9>    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_0 + mastership);\n<line10>    assertEquals(portClient1, s1.getClientPort());\n<line11>    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_1 + mastership);\n<line12>    assertEquals(portClient2, s2.getClientPort());\n<line13>    s1.enableLocalSessions(localSessionsEnabled);\n<line14>    s2.enableLocalSessions(localSessionsEnabled);\n<line15>    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line16>    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line17>    s1.start();\n<line18>    s2.start();\n<line19>    for (String hp : hostPort.split(\",\")) {\n<line20>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line21>    }\n<line22>    // interesting to see what's there...\n<line23>    JMXEnv.dump();\n<line24>    // make sure we have these 5 servers listed\n<line25>    Set<String> ensureNames = new LinkedHashSet<>();\n<line26>    for (int i = 1; i <= 2; i++) {\n<line27>        ensureNames.add(\"InMemoryDataTree\");\n<line28>    }\n<line29>    for (int i = 1; i <= 2; i++) {\n<line30>        ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line31>    }\n<line32>    for (int i = 1; i <= 2; i++) {\n<line33>        for (int j = 1; j <= 2; j++) {\n<line34>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line35>        }\n<line36>    }\n<line37>    for (int i = 1; i <= 2; i++) {\n<line38>        ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line39>    }\n<line40>    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line41>}","output":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    Map<Long, QuorumPeer.QuorumServer> peers = new HashMap<>();\n<line7>    peers.put(Long.valueOf(1), new QuorumPeer.QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), QuorumPeer.LearnerType.PARTICIPANT));\n<line8>    peers.put(Long.valueOf(2), new QuorumPeer.QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), QuorumPeer.LearnerType.PARTICIPANT));\n<line9>    LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line10>    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_0 + mastership);\n<line11>    assertEquals(portClient1, s1.getClientPort());\n<line12>    LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line13>    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_1 + mastership);\n<line14>    assertEquals(portClient2, s2.getClientPort());\n<line15>    LOG.info(\"QuorumPeer 1 voting view: {}\", s1.getVotingView());\n<line16>    LOG.info(\"QuorumPeer 2 voting view: {}\", s2.getVotingView());\n<line17>    s1.enableLocalSessions(localSessionsEnabled);\n<line18>    s2.enableLocalSessions(localSessionsEnabled);\n<line19>    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line20>    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line21>    LOG.info(\"start QuorumPeer 1\");\n<line22>    s1.start();\n<line23>    LOG.info(\"start QuorumPeer 2\");\n<line24>    s2.start();\n<line25>    LOG.info(\"Checking ports {}\", hostPort);\n<line26>    for (String hp : hostPort.split(\",\")) {\n<line27>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line28>        LOG.info(\"{} is accepting client connections\", hp);\n<line29>    }\n<line30>    // interesting to see what's there...\n<line31>    JMXEnv.dump();\n<line32>    // make sure we have these 5 servers listed\n<line33>    Set<String> ensureNames = new LinkedHashSet<>();\n<line34>    for (int i = 1; i <= 2; i++) {\n<line35>        ensureNames.add(\"InMemoryDataTree\");\n<line36>    }\n<line37>    for (int i = 1; i <= 2; i++) {\n<line38>        ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line39>    }\n<line40>    for (int i = 1; i <= 2; i++) {\n<line41>        for (int j = 1; j <= 2; j++) {\n<line42>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line43>        }\n<line44>    }\n<line45>    for (int i = 1; i <= 2; i++) {\n<line46>        ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line47>    }\n<line48>    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line3>    LOG.info(\"{} is accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    StringBuilder hosts = new StringBuilder();\n<line3>    for (QuorumPeer p : getPeerList()) {\n<line4>        if (p.getPeerState() == state) {\n<line5>            hosts.append(String.format(\"%s:%d,\", LOCALADDR, p.getClientAddress().getPort()));\n<line6>        }\n<line7>    }\n<line8>    return hosts.toString();\n<line9>}","output":"<line1>{\n<line2>    StringBuilder hosts = new StringBuilder();\n<line3>    for (QuorumPeer p : getPeerList()) {\n<line4>        if (p.getPeerState() == state) {\n<line5>            hosts.append(String.format(\"%s:%d,\", LOCALADDR, p.getClientAddress().getPort()));\n<line6>        }\n<line7>    }\n<line8>    LOG.info(\"getPeersMatching ports are {}\", hosts);\n<line9>    return hosts.toString();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    if (peers == null) {\n<line7>        peers = new HashMap<>();\n<line8>        peers.put(Long.valueOf(1), new QuorumPeer.QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), QuorumPeer.LearnerType.PARTICIPANT));\n<line9>        peers.put(Long.valueOf(2), new QuorumPeer.QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), QuorumPeer.LearnerType.PARTICIPANT));\n<line10>    }\n<line11>    switch(i) {\n<line12>        case 1:\n<line13>            s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line14>            assertEquals(portClient1, s1.getClientPort());\n<line15>            break;\n<line16>        case 2:\n<line17>            s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line18>            assertEquals(portClient2, s2.getClientPort());\n<line19>            break;\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    if (peers == null) {\n<line7>        peers = new HashMap<>();\n<line8>        peers.put(Long.valueOf(1), new QuorumPeer.QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), QuorumPeer.LearnerType.PARTICIPANT));\n<line9>        peers.put(Long.valueOf(2), new QuorumPeer.QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), QuorumPeer.LearnerType.PARTICIPANT));\n<line10>    }\n<line11>    switch(i) {\n<line12>        case 1:\n<line13>            LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line14>            s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line15>            assertEquals(portClient1, s1.getClientPort());\n<line16>            break;\n<line17>        case 2:\n<line18>            LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line19>            s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line20>            assertEquals(portClient2, s2.getClientPort());\n<line21>            break;\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    if (oracleDir != null) {\n<line3>        ClientBase.recursiveDelete(oracleDir);\n<line4>    }\n<line5>    OSMXBean osMbean = new OSMXBean();\n<line6>    if (osMbean.getUnix()) {\n<line7>    }\n<line8>    shutdownServers();\n<line9>    for (String hp : hostPort.split(\",\")) {\n<line10>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line11>    }\n<line12>    JMXEnv.tearDown();\n<line13>}","output":"<line1>{\n<line2>    LOG.info(\"TearDown started\");\n<line3>    if (oracleDir != null) {\n<line4>        ClientBase.recursiveDelete(oracleDir);\n<line5>    }\n<line6>    OSMXBean osMbean = new OSMXBean();\n<line7>    if (osMbean.getUnix()) {\n<line8>        LOG.info(\"fdcount after test is: {}\", osMbean.getOpenFileDescriptorCount());\n<line9>    }\n<line10>    shutdownServers();\n<line11>    for (String hp : hostPort.split(\",\")) {\n<line12>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line13>        LOG.info(\"{} is no longer accepting client connections\", hp);\n<line14>    }\n<line15>    JMXEnv.tearDown();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"fdcount after test is: {}\", osMbean.getOpenFileDescriptorCount());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line3>    LOG.info(\"{} is no longer accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (qp == null) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        qp.shutdown();\n<line7>        Election e = qp.getElectionAlg();\n<line8>        if (e != null) {\n<line9>            e.shutdown();\n<line10>        } else {\n<line11>        }\n<line12>        long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line13>        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line14>        long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line15>        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line16>        qp.join(maxTimeout * 2);\n<line17>        if (qp.isAlive()) {\n<line18>            fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line19>        }\n<line20>    } catch (InterruptedException e) {\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    if (qp == null) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        LOG.info(\"Shutting down quorum peer {}\", qp.getName());\n<line7>        qp.shutdown();\n<line8>        Election e = qp.getElectionAlg();\n<line9>        if (e != null) {\n<line10>            LOG.info(\"Shutting down leader election {}\", qp.getName());\n<line11>            e.shutdown();\n<line12>        } else {\n<line13>            LOG.info(\"No election available to shutdown {}\", qp.getName());\n<line14>        }\n<line15>        LOG.info(\"Waiting for {} to exit thread\", qp.getName());\n<line16>        long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line17>        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line18>        long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line19>        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line20>        qp.join(maxTimeout * 2);\n<line21>        if (qp.isAlive()) {\n<line22>            fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line23>        }\n<line24>    } catch (InterruptedException e) {\n<line25>        LOG.debug(\"QP interrupted: {}\", qp.getName(), e);\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    qp.shutdown();\n<line3>    Election e = qp.getElectionAlg();\n<line4>    if (e != null) {\n<line5>        e.shutdown();\n<line6>    } else {\n<line7>    }\n<line8>    long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line9>    long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line10>    long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line11>    maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line12>    qp.join(maxTimeout * 2);\n<line13>    if (qp.isAlive()) {\n<line14>        fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down quorum peer {}\", qp.getName());\n<line3>    qp.shutdown();\n<line4>    Election e = qp.getElectionAlg();\n<line5>    if (e != null) {\n<line6>        LOG.info(\"Shutting down leader election {}\", qp.getName());\n<line7>        e.shutdown();\n<line8>    } else {\n<line9>        LOG.info(\"No election available to shutdown {}\", qp.getName());\n<line10>    }\n<line11>    LOG.info(\"Waiting for {} to exit thread\", qp.getName());\n<line12>    long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line13>    long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line14>    long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line15>    maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line16>    qp.join(maxTimeout * 2);\n<line17>    if (qp.isAlive()) {\n<line18>        fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    e.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down leader election {}\", qp.getName());\n<line3>    e.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"No election available to shutdown {}\", qp.getName());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"QP interrupted: {}\", qp.getName(), e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        ZooKeeperServer.setDigestEnabled(true);\n<line4>        long count = 1;\n<line5>        File tmpDir = ClientBase.createTmpDir();\n<line6>        FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);\n<line7>        DataTree dt = new DataTree();\n<line8>        dt.createNode(\"/test\", new byte[0], null, 0, -1, 1, 1);\n<line9>        for (count = 1; count <= 3; count++) {\n<line10>            dt.createNode(\"/test/\" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());\n<line11>        }\n<line12>        long digestBefore = dt.getTreeDigest();\n<line13>        DataNode zk = dt.getNode(\"/test\");\n<line14>        // Make create to fail, then verify cversion.\n<line15>        doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, -1);\n<line16>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line17>        digestBefore = dt.getTreeDigest();\n<line18>        doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line19>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line20>        digestBefore = dt.getTreeDigest();\n<line21>        doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line22>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line23>        digestBefore = dt.getTreeDigest();\n<line24>        doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, -1);\n<line25>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line26>        // Make delete fo fail, then verify cversion.\n<line27>        // this doesn't happen anymore, we only set the cversion on create\n<line28>        // doOp(logFile, OpCode.delete, \"/test/\" + (count + 1), dt, zk);\n<line29>    } finally {\n<line30>        ZooKeeperServer.setDigestEnabled(false);\n<line31>    }\n<line32>}","output":"<line1>{\n<line2>    try {\n<line3>        ZooKeeperServer.setDigestEnabled(true);\n<line4>        long count = 1;\n<line5>        File tmpDir = ClientBase.createTmpDir();\n<line6>        FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);\n<line7>        DataTree dt = new DataTree();\n<line8>        dt.createNode(\"/test\", new byte[0], null, 0, -1, 1, 1);\n<line9>        for (count = 1; count <= 3; count++) {\n<line10>            dt.createNode(\"/test/\" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());\n<line11>        }\n<line12>        long digestBefore = dt.getTreeDigest();\n<line13>        DataNode zk = dt.getNode(\"/test\");\n<line14>        // Make create to fail, then verify cversion.\n<line15>        LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line16>        doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, -1);\n<line17>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line18>        LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line19>        digestBefore = dt.getTreeDigest();\n<line20>        doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line21>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line22>        LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line23>        digestBefore = dt.getTreeDigest();\n<line24>        doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line25>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line26>        LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line27>        digestBefore = dt.getTreeDigest();\n<line28>        doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, -1);\n<line29>        assertNotEquals(digestBefore, dt.getTreeDigest());\n<line30>        // Make delete fo fail, then verify cversion.\n<line31>        // this doesn't happen anymore, we only set the cversion on create\n<line32>        // LOG.info(\"Attempting to delete \" + \"/test/\" + (count + 1));\n<line33>        // doOp(logFile, OpCode.delete, \"/test/\" + (count + 1), dt, zk);\n<line34>    } finally {\n<line35>        ZooKeeperServer.setDigestEnabled(false);\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperServer.setDigestEnabled(true);\n<line3>    long count = 1;\n<line4>    File tmpDir = ClientBase.createTmpDir();\n<line5>    FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);\n<line6>    DataTree dt = new DataTree();\n<line7>    dt.createNode(\"/test\", new byte[0], null, 0, -1, 1, 1);\n<line8>    for (count = 1; count <= 3; count++) {\n<line9>        dt.createNode(\"/test/\" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());\n<line10>    }\n<line11>    long digestBefore = dt.getTreeDigest();\n<line12>    DataNode zk = dt.getNode(\"/test\");\n<line13>    // Make create to fail, then verify cversion.\n<line14>    doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, -1);\n<line15>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line16>    digestBefore = dt.getTreeDigest();\n<line17>    doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line18>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line19>    digestBefore = dt.getTreeDigest();\n<line20>    doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line21>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line22>    digestBefore = dt.getTreeDigest();\n<line23>    doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, -1);\n<line24>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line25>    // Make delete fo fail, then verify cversion.\n<line26>    // this doesn't happen anymore, we only set the cversion on create\n<line27>    // doOp(logFile, OpCode.delete, \"/test/\" + (count + 1), dt, zk);\n<line28>}","output":"<line1>{\n<line2>    ZooKeeperServer.setDigestEnabled(true);\n<line3>    long count = 1;\n<line4>    File tmpDir = ClientBase.createTmpDir();\n<line5>    FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);\n<line6>    DataTree dt = new DataTree();\n<line7>    dt.createNode(\"/test\", new byte[0], null, 0, -1, 1, 1);\n<line8>    for (count = 1; count <= 3; count++) {\n<line9>        dt.createNode(\"/test/\" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());\n<line10>    }\n<line11>    long digestBefore = dt.getTreeDigest();\n<line12>    DataNode zk = dt.getNode(\"/test\");\n<line13>    // Make create to fail, then verify cversion.\n<line14>    LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line15>    doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, -1);\n<line16>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line17>    LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line18>    digestBefore = dt.getTreeDigest();\n<line19>    doOp(logFile, ZooDefs.OpCode.create, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line20>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line21>    LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line22>    digestBefore = dt.getTreeDigest();\n<line23>    doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, zk.stat.getCversion() + 1);\n<line24>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line25>    LOG.info(\"Attempting to create /test/{}\", (count - 1));\n<line26>    digestBefore = dt.getTreeDigest();\n<line27>    doOp(logFile, ZooDefs.OpCode.multi, \"/test/\" + (count - 1), dt, zk, -1);\n<line28>    assertNotEquals(digestBefore, dt.getTreeDigest());\n<line29>    // Make delete fo fail, then verify cversion.\n<line30>    // this doesn't happen anymore, we only set the cversion on create\n<line31>    // LOG.info(\"Attempting to delete \" + \"/test/\" + (count + 1));\n<line32>    // doOp(logFile, OpCode.delete, \"/test/\" + (count + 1), dt, zk);\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    int lastSlash = path.lastIndexOf('/');\n<line3>    String parentName = path.substring(0, lastSlash);\n<line4>    int prevCversion = parent.stat.getCversion();\n<line5>    long prevPzxid = parent.stat.getPzxid();\n<line6>    List<String> child = dt.getChildren(parentName, null, null);\n<line7>    StringBuilder childStr = new StringBuilder();\n<line8>    for (String s : child) {\n<line9>        childStr.append(s).append(\" \");\n<line10>    }\n<line11>    Record txn = null;\n<line12>    TxnHeader txnHeader = null;\n<line13>    if (type == ZooDefs.OpCode.delete) {\n<line14>        txn = new DeleteTxn(path);\n<line15>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.delete);\n<line16>    } else if (type == ZooDefs.OpCode.create) {\n<line17>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);\n<line18>        txn = new CreateTxn(path, new byte[0], null, false, cversion);\n<line19>    } else if (type == ZooDefs.OpCode.multi) {\n<line20>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);\n<line21>        txn = new CreateTxn(path, new byte[0], null, false, cversion);\n<line22>        List<Txn> txnList = new ArrayList<>();\n<line23>        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line24>        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line25>        txn.serialize(boa, \"request\");\n<line26>        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line27>        Txn txact = new Txn(ZooDefs.OpCode.create, bb.array());\n<line28>        txnList.add(txact);\n<line29>        txn = new MultiTxn(txnList);\n<line30>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.multi);\n<line31>    }\n<line32>    logFile.processTransaction(txnHeader, dt, null, txn);\n<line33>    int newCversion = parent.stat.getCversion();\n<line34>    long newPzxid = parent.stat.getPzxid();\n<line35>    child = dt.getChildren(parentName, null, null);\n<line36>    childStr = new StringBuilder();\n<line37>    for (String s : child) {\n<line38>        childStr.append(s).append(\" \");\n<line39>    }\n<line40>    assertTrue((newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1), type + \" <cversion, pzxid> verification failed. Expected: <\" + (prevCversion + 1) + \", \" + (prevPzxid + 1) + \">, found: <\" + newCversion + \", \" + newPzxid + \">\");\n<line41>}","output":"<line1>{\n<line2>    int lastSlash = path.lastIndexOf('/');\n<line3>    String parentName = path.substring(0, lastSlash);\n<line4>    int prevCversion = parent.stat.getCversion();\n<line5>    long prevPzxid = parent.stat.getPzxid();\n<line6>    List<String> child = dt.getChildren(parentName, null, null);\n<line7>    StringBuilder childStr = new StringBuilder();\n<line8>    for (String s : child) {\n<line9>        childStr.append(s).append(\" \");\n<line10>    }\n<line11>    LOG.info(\"Children: {} for {}\", childStr, parentName);\n<line12>    LOG.info(\"(cverions, pzxid): {}, {}\", prevCversion, prevPzxid);\n<line13>    Record txn = null;\n<line14>    TxnHeader txnHeader = null;\n<line15>    if (type == ZooDefs.OpCode.delete) {\n<line16>        txn = new DeleteTxn(path);\n<line17>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.delete);\n<line18>    } else if (type == ZooDefs.OpCode.create) {\n<line19>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);\n<line20>        txn = new CreateTxn(path, new byte[0], null, false, cversion);\n<line21>    } else if (type == ZooDefs.OpCode.multi) {\n<line22>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);\n<line23>        txn = new CreateTxn(path, new byte[0], null, false, cversion);\n<line24>        List<Txn> txnList = new ArrayList<>();\n<line25>        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line26>        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line27>        txn.serialize(boa, \"request\");\n<line28>        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line29>        Txn txact = new Txn(ZooDefs.OpCode.create, bb.array());\n<line30>        txnList.add(txact);\n<line31>        txn = new MultiTxn(txnList);\n<line32>        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.multi);\n<line33>    }\n<line34>    logFile.processTransaction(txnHeader, dt, null, txn);\n<line35>    int newCversion = parent.stat.getCversion();\n<line36>    long newPzxid = parent.stat.getPzxid();\n<line37>    child = dt.getChildren(parentName, null, null);\n<line38>    childStr = new StringBuilder();\n<line39>    for (String s : child) {\n<line40>        childStr.append(s).append(\" \");\n<line41>    }\n<line42>    LOG.info(\"Children: {} for {}\", childStr, parentName);\n<line43>    LOG.info(\"(cverions, pzxid): {}, {}\", newCversion, newPzxid);\n<line44>    assertTrue((newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1), type + \" <cversion, pzxid> verification failed. Expected: <\" + (prevCversion + 1) + \", \" + (prevPzxid + 1) + \">, found: <\" + newCversion + \", \" + newPzxid + \">\");\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    FileTxnLog txnLog = new FileTxnLog(tmpDir);\n<line4>    TxnHeader txnHeader = new TxnHeader(0xabcd, 0x123, 0x123, Time.currentElapsedTime(), ZooDefs.OpCode.create);\n<line5>    Record txn = new CreateTxn(\"/Test\", new byte[0], null, false, 1);\n<line6>    txnLog.append(new Request(0, 0, 0, txnHeader, txn, 0));\n<line7>    BinaryInputArchive ia = BinaryInputArchive.getArchive(in);\n<line8>    FileHeader header = new FileHeader();\n<line9>    header.deserialize(ia, \"fileheader\");\n<line10>    assertTrue(header.getMagic() == FileTxnLog.TXNLOG_MAGIC, \"Missing magic number \");\n<line11>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    FileTxnLog txnLog = new FileTxnLog(tmpDir);\n<line4>    TxnHeader txnHeader = new TxnHeader(0xabcd, 0x123, 0x123, Time.currentElapsedTime(), ZooDefs.OpCode.create);\n<line5>    Record txn = new CreateTxn(\"/Test\", new byte[0], null, false, 1);\n<line6>    txnLog.append(new Request(0, 0, 0, txnHeader, txn, 0));\n<line7>    FileInputStream in = new FileInputStream(tmpDir.getPath() + \"/log.\" + Long.toHexString(txnHeader.getZxid()));\n<line8>    BinaryInputArchive ia = BinaryInputArchive.getArchive(in);\n<line9>    FileHeader header = new FileHeader();\n<line10>    header.deserialize(ia, \"fileheader\");\n<line11>    LOG.info(\"Received magic : {} Expected : {}\", header.getMagic(), FileTxnLog.TXNLOG_MAGIC);\n<line12>    assertTrue(header.getMagic() == FileTxnLog.TXNLOG_MAGIC, \"Missing magic number \");\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    String resp = sendRequest(cmd, 0);\n<line3>    assertTrue(resp.contains(expected));\n<line4>}","output":"<line1>{\n<line2>    String resp = sendRequest(cmd, 0);\n<line3>    LOG.info(\"cmd {} expected {} got {}\", cmd, expected, resp);\n<line4>    assertTrue(resp.contains(expected));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket sock = new Socket(host, port);\n<line3>    BufferedReader reader = null;\n<line4>    try {\n<line5>        try {\n<line6>            Thread.sleep(delay);\n<line7>        } catch (InterruptedException e) {\n<line8>            // ignore\n<line9>        }\n<line10>        OutputStream outstream = sock.getOutputStream();\n<line11>        outstream.write(cmd.getBytes());\n<line12>        outstream.flush();\n<line13>        // this replicates NC - close the output stream before reading\n<line14>        sock.shutdownOutput();\n<line15>        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line16>        StringBuilder sb = readLine(reader);\n<line17>        return sb.toString();\n<line18>    } finally {\n<line19>        sock.close();\n<line20>        if (reader != null) {\n<line21>            reader.close();\n<line22>        }\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    LOG.info(\"connecting to {} {}\", host, port);\n<line3>    Socket sock = new Socket(host, port);\n<line4>    BufferedReader reader = null;\n<line5>    try {\n<line6>        try {\n<line7>            LOG.info(\"Sleeping for {}ms\", delay);\n<line8>            Thread.sleep(delay);\n<line9>        } catch (InterruptedException e) {\n<line10>            // ignore\n<line11>        }\n<line12>        OutputStream outstream = sock.getOutputStream();\n<line13>        outstream.write(cmd.getBytes());\n<line14>        outstream.flush();\n<line15>        // this replicates NC - close the output stream before reading\n<line16>        sock.shutdownOutput();\n<line17>        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line18>        StringBuilder sb = readLine(reader);\n<line19>        return sb.toString();\n<line20>    } finally {\n<line21>        sock.close();\n<line22>        if (reader != null) {\n<line23>            reader.close();\n<line24>        }\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Thread.sleep(delay);\n<line4>    } catch (InterruptedException e) {\n<line5>        // ignore\n<line6>    }\n<line7>    OutputStream outstream = sock.getOutputStream();\n<line8>    outstream.write(cmd.getBytes());\n<line9>    outstream.flush();\n<line10>    // this replicates NC - close the output stream before reading\n<line11>    sock.shutdownOutput();\n<line12>    reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line13>    StringBuilder sb = readLine(reader);\n<line14>    return sb.toString();\n<line15>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"Sleeping for {}ms\", delay);\n<line4>        Thread.sleep(delay);\n<line5>    } catch (InterruptedException e) {\n<line6>        // ignore\n<line7>    }\n<line8>    OutputStream outstream = sock.getOutputStream();\n<line9>    outstream.write(cmd.getBytes());\n<line10>    outstream.flush();\n<line11>    // this replicates NC - close the output stream before reading\n<line12>    sock.shutdownOutput();\n<line13>    reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line14>    StringBuilder sb = readLine(reader);\n<line15>    return sb.toString();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread.sleep(delay);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Sleeping for {}ms\", delay);\n<line3>    Thread.sleep(delay);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    StringBuilder sb = new StringBuilder();\n<line3>    String line;\n<line4>    try {\n<line5>        while ((line = reader.readLine()) != null) {\n<line6>            sb.append(line + \"\\n\");\n<line7>        }\n<line8>    } catch (IOException ioe) {\n<line9>        // During connection expiry the server will close the connection.\n<line10>        // After the socket is closed, when the client tries to read a\n<line11>        // line of text it will throw java.net.SocketException.\n<line12>        // @see jira issue ZOOKEEPER-1862\n<line13>    }\n<line14>    return sb;\n<line15>}","output":"<line1>{\n<line2>    StringBuilder sb = new StringBuilder();\n<line3>    String line;\n<line4>    try {\n<line5>        while ((line = reader.readLine()) != null) {\n<line6>            sb.append(line + \"\\n\");\n<line7>        }\n<line8>    } catch (IOException ioe) {\n<line9>        // During connection expiry the server will close the connection.\n<line10>        // After the socket is closed, when the client tries to read a\n<line11>        // line of text it will throw java.net.SocketException.\n<line12>        // @see jira issue ZOOKEEPER-1862\n<line13>        LOG.info(\"Connnection is expired\", ioe);\n<line14>    }\n<line15>    return sb;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    // During connection expiry the server will close the connection.\n<line3>    // After the socket is closed, when the client tries to read a\n<line4>    // line of text it will throw java.net.SocketException.\n<line5>    // @see jira issue ZOOKEEPER-1862\n<line6>}","output":"<line1>{\n<line2>    // During connection expiry the server will close the connection.\n<line3>    // After the socket is closed, when the client tries to read a\n<line4>    // line of text it will throw java.net.SocketException.\n<line5>    // @see jira issue ZOOKEEPER-1862\n<line6>    LOG.info(\"Connnection is expired\", ioe);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeper zk = createClient();\n<line3>    try {\n<line4>        zk.create(\"/path1\", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line5>        fail(\"Should have gotten exception.\");\n<line6>    } catch (KeeperException e) {\n<line7>        // ok, exception as expected.\n<line8>    } finally {\n<line9>        zk.close();\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    ZooKeeper zk = createClient();\n<line3>    try {\n<line4>        zk.create(\"/path1\", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line5>        fail(\"Should have gotten exception.\");\n<line6>    } catch (KeeperException e) {\n<line7>        // ok, exception as expected.\n<line8>        LOG.debug(\"Got exception as expected\", e);\n<line9>    } finally {\n<line10>        zk.close();\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // ok, exception as expected.\n<line3>}","output":"<line1>{\n<line2>    // ok, exception as expected.\n<line3>    LOG.debug(\"Got exception as expected\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // giving a grace period of 10seconds\n<line3>    int count = 100;\n<line4>    while (count > 0) {\n<line5>        if (leaderCurrentEpoch == peer.getCurrentEpoch()) {\n<line6>            Thread.sleep(100);\n<line7>        }\n<line8>        count--;\n<line9>    }\n<line10>    assertNotEquals(leaderCurrentEpoch, peer.getCurrentEpoch(), \"New LE cycle must have triggered\");\n<line11>}","output":"<line1>{\n<line2>    LOG.info(\"Waiting for new LE cycle..\");\n<line3>    // giving a grace period of 10seconds\n<line4>    int count = 100;\n<line5>    while (count > 0) {\n<line6>        if (leaderCurrentEpoch == peer.getCurrentEpoch()) {\n<line7>            Thread.sleep(100);\n<line8>        }\n<line9>        count--;\n<line10>    }\n<line11>    assertNotEquals(leaderCurrentEpoch, peer.getCurrentEpoch(), \"New LE cycle must have triggered\");\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.localSessionsEnabled = true;\n<line3>    qb.localSessionsUpgradingEnabled = true;\n<line4>    qb.setUp();\n<line5>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING quorum {}\", getClass().getName());\n<line3>    qb.localSessionsEnabled = true;\n<line4>    qb.localSessionsUpgradingEnabled = true;\n<line5>    qb.setUp();\n<line6>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING quorum {}\", getClass().getName());\n<line3>    qb.tearDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    super.setUp();\n<line3>    events = new LinkedBlockingQueue<>();\n<line4>    persistentWatcher = event -> {\n<line5>        events.add(event);\n<line6>    };\n<line7>}","output":"<line1>{\n<line2>    super.setUp();\n<line3>    events = new LinkedBlockingQueue<>();\n<line4>    persistentWatcher = event -> {\n<line5>        events.add(event);\n<line6>        LOG.info(\"Added event: {}; total: {}\", event, events.size());\n<line7>    };\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    events.add(event);\n<line3>}","output":"<line1>{\n<line2>    events.add(event);\n<line3>    LOG.info(\"Added event: {}; total: {}\", event, events.size());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Cannot use createClient here because server may close session before\n<line3>    // JMXEnv.ensureAll is called which will fail the test case\n<line4>    CountdownWatcher watcher = new CountdownWatcher();\n<line5>    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);\n<line6>    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line7>        fail(\"Unable to connect to server\");\n<line8>    }\n<line9>    try {\n<line10>        zk.create(\"/path1\", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line11>        fail(\"Should have gotten exception.\");\n<line12>    } catch (KeeperException e) {\n<line13>        // ok, exception as expected.\n<line14>    } finally {\n<line15>        zk.close();\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    // Cannot use createClient here because server may close session before\n<line3>    // JMXEnv.ensureAll is called which will fail the test case\n<line4>    CountdownWatcher watcher = new CountdownWatcher();\n<line5>    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);\n<line6>    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line7>        fail(\"Unable to connect to server\");\n<line8>    }\n<line9>    try {\n<line10>        zk.create(\"/path1\", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line11>        fail(\"Should have gotten exception.\");\n<line12>    } catch (KeeperException e) {\n<line13>        // ok, exception as expected.\n<line14>        LOG.debug(\"Got exception as expected\", e);\n<line15>    } finally {\n<line16>        zk.close();\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    // ok, exception as expected.\n<line3>}","output":"<line1>{\n<line2>    // ok, exception as expected.\n<line3>    LOG.debug(\"Got exception as expected\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    int oldSnapCount = SyncRequestProcessor.getSnapCount();\n<line6>    SyncRequestProcessor.setSnapCount(1000);\n<line7>    try {\n<line8>        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line9>        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line10>        f.startup(zks);\n<line11>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line12>        startSignal = new CountDownLatch(1);\n<line13>        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n<line14>        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line15>        assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line16>        String path;\n<line17>        for (int i = 0; i < 10; i++) {\n<line18>            path = \"/\" + i;\n<line19>            zk.create(path, (path + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line20>            for (int j = 0; j < 10; j++) {\n<line21>                String subpath = path + \"/\" + j;\n<line22>                zk.create(subpath, (subpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line23>                for (int k = 0; k < 20; k++) {\n<line24>                    String subsubpath = subpath + \"/\" + k;\n<line25>                    zk.create(subsubpath, (subsubpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line26>                }\n<line27>            }\n<line28>        }\n<line29>        f.shutdown();\n<line30>        zks.shutdown();\n<line31>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line32>        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line33>        f = ServerCnxnFactory.createFactory(PORT, -1);\n<line34>        startSignal = new CountDownLatch(1);\n<line35>        f.startup(zks);\n<line36>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line37>        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line38>        assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line39>        Stat stat = new Stat();\n<line40>        for (int i = 0; i < 10; i++) {\n<line41>            path = \"/\" + i;\n<line42>            assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line43>            for (int j = 0; j < 10; j++) {\n<line44>                String subpath = path + \"/\" + j;\n<line45>                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line46>                for (int k = 0; k < 20; k++) {\n<line47>                    String subsubpath = subpath + \"/\" + k;\n<line48>                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line49>                }\n<line50>            }\n<line51>        }\n<line52>        f.shutdown();\n<line53>        zks.shutdown();\n<line54>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line55>        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line56>        f = ServerCnxnFactory.createFactory(PORT, -1);\n<line57>        startSignal = new CountDownLatch(1);\n<line58>        f.startup(zks);\n<line59>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line60>        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line61>        assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line62>        stat = new Stat();\n<line63>        for (int i = 0; i < 10; i++) {\n<line64>            path = \"/\" + i;\n<line65>            assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line66>            for (int j = 0; j < 10; j++) {\n<line67>                String subpath = path + \"/\" + j;\n<line68>                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line69>                for (int k = 0; k < 20; k++) {\n<line70>                    String subsubpath = subpath + \"/\" + k;\n<line71>                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line72>                }\n<line73>            }\n<line74>        }\n<line75>        zk.close();\n<line76>        f.shutdown();\n<line77>        zks.shutdown();\n<line78>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line79>    } finally {\n<line80>        SyncRequestProcessor.setSnapCount(oldSnapCount);\n<line81>    }\n<line82>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    int oldSnapCount = SyncRequestProcessor.getSnapCount();\n<line6>    SyncRequestProcessor.setSnapCount(1000);\n<line7>    try {\n<line8>        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line9>        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line10>        f.startup(zks);\n<line11>        LOG.info(\"starting up the the server, waiting\");\n<line12>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line13>        startSignal = new CountDownLatch(1);\n<line14>        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n<line15>        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line16>        assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line17>        String path;\n<line18>        LOG.info(\"starting creating nodes\");\n<line19>        for (int i = 0; i < 10; i++) {\n<line20>            path = \"/\" + i;\n<line21>            zk.create(path, (path + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line22>            for (int j = 0; j < 10; j++) {\n<line23>                String subpath = path + \"/\" + j;\n<line24>                zk.create(subpath, (subpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line25>                for (int k = 0; k < 20; k++) {\n<line26>                    String subsubpath = subpath + \"/\" + k;\n<line27>                    zk.create(subsubpath, (subsubpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line28>                }\n<line29>            }\n<line30>        }\n<line31>        f.shutdown();\n<line32>        zks.shutdown();\n<line33>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line34>        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line35>        f = ServerCnxnFactory.createFactory(PORT, -1);\n<line36>        startSignal = new CountDownLatch(1);\n<line37>        f.startup(zks);\n<line38>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line39>        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line40>        assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line41>        Stat stat = new Stat();\n<line42>        for (int i = 0; i < 10; i++) {\n<line43>            path = \"/\" + i;\n<line44>            LOG.info(\"Checking \" + path);\n<line45>            assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line46>            for (int j = 0; j < 10; j++) {\n<line47>                String subpath = path + \"/\" + j;\n<line48>                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line49>                for (int k = 0; k < 20; k++) {\n<line50>                    String subsubpath = subpath + \"/\" + k;\n<line51>                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line52>                }\n<line53>            }\n<line54>        }\n<line55>        f.shutdown();\n<line56>        zks.shutdown();\n<line57>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line58>        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line59>        f = ServerCnxnFactory.createFactory(PORT, -1);\n<line60>        startSignal = new CountDownLatch(1);\n<line61>        f.startup(zks);\n<line62>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line63>        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line64>        assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line65>        stat = new Stat();\n<line66>        LOG.info(\"Check 2\");\n<line67>        for (int i = 0; i < 10; i++) {\n<line68>            path = \"/\" + i;\n<line69>            assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line70>            for (int j = 0; j < 10; j++) {\n<line71>                String subpath = path + \"/\" + j;\n<line72>                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line73>                for (int k = 0; k < 20; k++) {\n<line74>                    String subsubpath = subpath + \"/\" + k;\n<line75>                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line76>                }\n<line77>            }\n<line78>        }\n<line79>        zk.close();\n<line80>        f.shutdown();\n<line81>        zks.shutdown();\n<line82>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line83>    } finally {\n<line84>        SyncRequestProcessor.setSnapCount(oldSnapCount);\n<line85>    }\n<line86>}"},{"input":"","instruction":"<line1>{\n<line2>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line3>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line4>    f.startup(zks);\n<line5>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line6>    startSignal = new CountDownLatch(1);\n<line7>    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n<line8>    startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line9>    assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line10>    String path;\n<line11>    for (int i = 0; i < 10; i++) {\n<line12>        path = \"/\" + i;\n<line13>        zk.create(path, (path + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>        for (int j = 0; j < 10; j++) {\n<line15>            String subpath = path + \"/\" + j;\n<line16>            zk.create(subpath, (subpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line17>            for (int k = 0; k < 20; k++) {\n<line18>                String subsubpath = subpath + \"/\" + k;\n<line19>                zk.create(subsubpath, (subsubpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line20>            }\n<line21>        }\n<line22>    }\n<line23>    f.shutdown();\n<line24>    zks.shutdown();\n<line25>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line26>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line27>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line28>    startSignal = new CountDownLatch(1);\n<line29>    f.startup(zks);\n<line30>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line31>    startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line32>    assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line33>    Stat stat = new Stat();\n<line34>    for (int i = 0; i < 10; i++) {\n<line35>        path = \"/\" + i;\n<line36>        assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line37>        for (int j = 0; j < 10; j++) {\n<line38>            String subpath = path + \"/\" + j;\n<line39>            assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line40>            for (int k = 0; k < 20; k++) {\n<line41>                String subsubpath = subpath + \"/\" + k;\n<line42>                assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line43>            }\n<line44>        }\n<line45>    }\n<line46>    f.shutdown();\n<line47>    zks.shutdown();\n<line48>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line49>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line50>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line51>    startSignal = new CountDownLatch(1);\n<line52>    f.startup(zks);\n<line53>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line54>    startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line55>    assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line56>    stat = new Stat();\n<line57>    for (int i = 0; i < 10; i++) {\n<line58>        path = \"/\" + i;\n<line59>        assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line60>        for (int j = 0; j < 10; j++) {\n<line61>            String subpath = path + \"/\" + j;\n<line62>            assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line63>            for (int k = 0; k < 20; k++) {\n<line64>                String subsubpath = subpath + \"/\" + k;\n<line65>                assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line66>            }\n<line67>        }\n<line68>    }\n<line69>    zk.close();\n<line70>    f.shutdown();\n<line71>    zks.shutdown();\n<line72>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line73>}","output":"<line1>{\n<line2>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line3>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line4>    f.startup(zks);\n<line5>    LOG.info(\"starting up the the server, waiting\");\n<line6>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line7>    startSignal = new CountDownLatch(1);\n<line8>    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n<line9>    startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line10>    assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line11>    String path;\n<line12>    LOG.info(\"starting creating nodes\");\n<line13>    for (int i = 0; i < 10; i++) {\n<line14>        path = \"/\" + i;\n<line15>        zk.create(path, (path + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line16>        for (int j = 0; j < 10; j++) {\n<line17>            String subpath = path + \"/\" + j;\n<line18>            zk.create(subpath, (subpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line19>            for (int k = 0; k < 20; k++) {\n<line20>                String subsubpath = subpath + \"/\" + k;\n<line21>                zk.create(subsubpath, (subsubpath + \"!\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line22>            }\n<line23>        }\n<line24>    }\n<line25>    f.shutdown();\n<line26>    zks.shutdown();\n<line27>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line28>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line29>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line30>    startSignal = new CountDownLatch(1);\n<line31>    f.startup(zks);\n<line32>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line33>    startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line34>    assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line35>    Stat stat = new Stat();\n<line36>    for (int i = 0; i < 10; i++) {\n<line37>        path = \"/\" + i;\n<line38>        LOG.info(\"Checking \" + path);\n<line39>        assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line40>        for (int j = 0; j < 10; j++) {\n<line41>            String subpath = path + \"/\" + j;\n<line42>            assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line43>            for (int k = 0; k < 20; k++) {\n<line44>                String subsubpath = subpath + \"/\" + k;\n<line45>                assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line46>            }\n<line47>        }\n<line48>    }\n<line49>    f.shutdown();\n<line50>    zks.shutdown();\n<line51>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line52>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line53>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line54>    startSignal = new CountDownLatch(1);\n<line55>    f.startup(zks);\n<line56>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line57>    startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n<line58>    assertTrue(startSignal.getCount() == 0, \"count == 0\");\n<line59>    stat = new Stat();\n<line60>    LOG.info(\"Check 2\");\n<line61>    for (int i = 0; i < 10; i++) {\n<line62>        path = \"/\" + i;\n<line63>        assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line64>        for (int j = 0; j < 10; j++) {\n<line65>            String subpath = path + \"/\" + j;\n<line66>            assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line67>            for (int k = 0; k < 20; k++) {\n<line68>                String subsubpath = subpath + \"/\" + k;\n<line69>                assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line70>            }\n<line71>        }\n<line72>    }\n<line73>    zk.close();\n<line74>    f.shutdown();\n<line75>    zks.shutdown();\n<line76>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line77>}"},{"input":"","instruction":"<line1>{\n<line2>    path = \"/\" + i;\n<line3>    assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line4>    for (int j = 0; j < 10; j++) {\n<line5>        String subpath = path + \"/\" + j;\n<line6>        assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line7>        for (int k = 0; k < 20; k++) {\n<line8>            String subsubpath = subpath + \"/\" + k;\n<line9>            assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line10>        }\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    path = \"/\" + i;\n<line3>    LOG.info(\"Checking \" + path);\n<line4>    assertEquals(new String(zk.getData(path, false, stat)), path + \"!\");\n<line5>    for (int j = 0; j < 10; j++) {\n<line6>        String subpath = path + \"/\" + j;\n<line7>        assertEquals(new String(zk.getData(subpath, false, stat)), subpath + \"!\");\n<line8>        for (int k = 0; k < 20; k++) {\n<line9>            String subsubpath = subpath + \"/\" + k;\n<line10>            assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + \"!\");\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {\n<line3>        startSignal.countDown();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Event:{} {} {}\", event.getState(), event.getType(), event.getPath());\n<line3>    if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {\n<line4>        startSignal.countDown();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {\n<line3>        startSignal.countDown();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"{} event:{} {} {}\", name, event.getState(), event.getType(), event.getPath());\n<line3>    if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {\n<line4>        startSignal.countDown();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    DisconnectableZooKeeper zk = createClient();\n<line3>    zk.create(\"/e\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line4>    // disconnect the client by killing the socket, not sending the\n<line5>    // session disconnect to the server as usual. This allows the test\n<line6>    // to verify disconnect handling\n<line7>    zk.disconnect();\n<line8>    Stat stat = new Stat();\n<line9>    startSignal = new CountDownLatch(1);\n<line10>    zk = new DisconnectableZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, new MyWatcher(\"testSession\"), zk.getSessionId(), zk.getSessionPasswd());\n<line11>    startSignal.await();\n<line12>    zk.getData(\"/e\", false, stat);\n<line13>    zk.close();\n<line14>    zk = createClient();\n<line15>    assertEquals(null, zk.exists(\"/e\", false));\n<line16>    zk.close();\n<line17>    try {\n<line18>        zk.getData(\"/e\", false, stat);\n<line19>        fail(\"Should have received a SessionExpiredException\");\n<line20>    } catch (KeeperException.SessionExpiredException e) {\n<line21>    }\n<line22>    AsyncCallback.DataCallback cb = new AsyncCallback.DataCallback() {\n<line23>\n<line24>        String status = \"not done\";\n<line25>\n<line26>        public void processResult(int rc, String p, Object c, byte[] b, Stat s) {\n<line27>            synchronized (this) {\n<line28>                status = KeeperException.Code.get(rc).toString();\n<line29>                this.notify();\n<line30>            }\n<line31>        }\n<line32>\n<line33>        public String toString() {\n<line34>            return status;\n<line35>        }\n<line36>    };\n<line37>    zk.getData(\"/e\", false, cb, null);\n<line38>    synchronized (cb) {\n<line39>        if (cb.toString().equals(\"not done\")) {\n<line40>            cb.wait(1000);\n<line41>        }\n<line42>    }\n<line43>    assertEquals(KeeperException.Code.SESSIONEXPIRED.toString(), cb.toString());\n<line44>}","output":"<line1>{\n<line2>    DisconnectableZooKeeper zk = createClient();\n<line3>    zk.create(\"/e\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line4>    LOG.info(\"zk with session id 0x{} was destroyed!\", Long.toHexString(zk.getSessionId()));\n<line5>    // disconnect the client by killing the socket, not sending the\n<line6>    // session disconnect to the server as usual. This allows the test\n<line7>    // to verify disconnect handling\n<line8>    zk.disconnect();\n<line9>    Stat stat = new Stat();\n<line10>    startSignal = new CountDownLatch(1);\n<line11>    zk = new DisconnectableZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, new MyWatcher(\"testSession\"), zk.getSessionId(), zk.getSessionPasswd());\n<line12>    startSignal.await();\n<line13>    LOG.info(\"zk with session id 0x{} was created!\", Long.toHexString(zk.getSessionId()));\n<line14>    zk.getData(\"/e\", false, stat);\n<line15>    LOG.info(\"After get data /e\");\n<line16>    zk.close();\n<line17>    zk = createClient();\n<line18>    assertEquals(null, zk.exists(\"/e\", false));\n<line19>    LOG.info(\"before close zk with session id 0x{}!\", Long.toHexString(zk.getSessionId()));\n<line20>    zk.close();\n<line21>    try {\n<line22>        zk.getData(\"/e\", false, stat);\n<line23>        fail(\"Should have received a SessionExpiredException\");\n<line24>    } catch (KeeperException.SessionExpiredException e) {\n<line25>    }\n<line26>    AsyncCallback.DataCallback cb = new AsyncCallback.DataCallback() {\n<line27>\n<line28>        String status = \"not done\";\n<line29>\n<line30>        public void processResult(int rc, String p, Object c, byte[] b, Stat s) {\n<line31>            synchronized (this) {\n<line32>                status = KeeperException.Code.get(rc).toString();\n<line33>                this.notify();\n<line34>            }\n<line35>        }\n<line36>\n<line37>        public String toString() {\n<line38>            return status;\n<line39>        }\n<line40>    };\n<line41>    zk.getData(\"/e\", false, cb, null);\n<line42>    synchronized (cb) {\n<line43>        if (cb.toString().equals(\"not done\")) {\n<line44>            cb.wait(1000);\n<line45>        }\n<line46>    }\n<line47>    assertEquals(KeeperException.Code.SESSIONEXPIRED.toString(), cb.toString());\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] hostPorts = HOSTPORT.split(\",\");\n<line3>    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], CONNECTION_TIMEOUT, new MyWatcher(\"0\"));\n<line4>    zk.create(\"/sessionMoveTest\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line5>    // we want to loop through the list twice\n<line6>    for (int i = 0; i < hostPorts.length * 2; i++) {\n<line7>        zk.dontReconnect();\n<line8>        // This should stomp the zk handle\n<line9>        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());\n<line10>        final int[] result = new int[1];\n<line11>        result[0] = Integer.MAX_VALUE;\n<line12>        zknew.sync(\"/\", (rc, path, ctx) -> {\n<line13>            synchronized (result) {\n<line14>                result[0] = rc;\n<line15>                result.notify();\n<line16>            }\n<line17>        }, null);\n<line18>        synchronized (result) {\n<line19>            if (result[0] == Integer.MAX_VALUE) {\n<line20>                result.wait(5000);\n<line21>            }\n<line22>        }\n<line23>        assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line24>        zknew.setData(\"/\", new byte[1], -1);\n<line25>        try {\n<line26>            zk.setData(\"/\", new byte[1], -1);\n<line27>            fail(\"Should have lost the connection\");\n<line28>        } catch (KeeperException.ConnectionLossException e) {\n<line29>        }\n<line30>        //zk.close();\n<line31>        zk = zknew;\n<line32>    }\n<line33>    zk.close();\n<line34>}","output":"<line1>{\n<line2>    String[] hostPorts = HOSTPORT.split(\",\");\n<line3>    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], CONNECTION_TIMEOUT, new MyWatcher(\"0\"));\n<line4>    zk.create(\"/sessionMoveTest\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line5>    // we want to loop through the list twice\n<line6>    for (int i = 0; i < hostPorts.length * 2; i++) {\n<line7>        zk.dontReconnect();\n<line8>        // This should stomp the zk handle\n<line9>        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());\n<line10>        final int[] result = new int[1];\n<line11>        result[0] = Integer.MAX_VALUE;\n<line12>        zknew.sync(\"/\", (rc, path, ctx) -> {\n<line13>            synchronized (result) {\n<line14>                result[0] = rc;\n<line15>                result.notify();\n<line16>            }\n<line17>        }, null);\n<line18>        synchronized (result) {\n<line19>            if (result[0] == Integer.MAX_VALUE) {\n<line20>                result.wait(5000);\n<line21>            }\n<line22>        }\n<line23>        LOG.info(\"{} Sync returned {}\", hostPorts[(i + 1) % hostPorts.length], result[0]);\n<line24>        assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line25>        zknew.setData(\"/\", new byte[1], -1);\n<line26>        try {\n<line27>            zk.setData(\"/\", new byte[1], -1);\n<line28>            fail(\"Should have lost the connection\");\n<line29>        } catch (KeeperException.ConnectionLossException e) {\n<line30>            LOG.info(\"Got connection loss exception as expected\");\n<line31>        }\n<line32>        //zk.close();\n<line33>        zk = zknew;\n<line34>    }\n<line35>    zk.close();\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.dontReconnect();\n<line3>    // This should stomp the zk handle\n<line4>    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());\n<line5>    final int[] result = new int[1];\n<line6>    result[0] = Integer.MAX_VALUE;\n<line7>    zknew.sync(\"/\", (rc, path, ctx) -> {\n<line8>        synchronized (result) {\n<line9>            result[0] = rc;\n<line10>            result.notify();\n<line11>        }\n<line12>    }, null);\n<line13>    synchronized (result) {\n<line14>        if (result[0] == Integer.MAX_VALUE) {\n<line15>            result.wait(5000);\n<line16>        }\n<line17>    }\n<line18>    assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line19>    zknew.setData(\"/\", new byte[1], -1);\n<line20>    try {\n<line21>        zk.setData(\"/\", new byte[1], -1);\n<line22>        fail(\"Should have lost the connection\");\n<line23>    } catch (KeeperException.ConnectionLossException e) {\n<line24>    }\n<line25>    //zk.close();\n<line26>    zk = zknew;\n<line27>}","output":"<line1>{\n<line2>    zk.dontReconnect();\n<line3>    // This should stomp the zk handle\n<line4>    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());\n<line5>    final int[] result = new int[1];\n<line6>    result[0] = Integer.MAX_VALUE;\n<line7>    zknew.sync(\"/\", (rc, path, ctx) -> {\n<line8>        synchronized (result) {\n<line9>            result[0] = rc;\n<line10>            result.notify();\n<line11>        }\n<line12>    }, null);\n<line13>    synchronized (result) {\n<line14>        if (result[0] == Integer.MAX_VALUE) {\n<line15>            result.wait(5000);\n<line16>        }\n<line17>    }\n<line18>    LOG.info(\"{} Sync returned {}\", hostPorts[(i + 1) % hostPorts.length], result[0]);\n<line19>    assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line20>    zknew.setData(\"/\", new byte[1], -1);\n<line21>    try {\n<line22>        zk.setData(\"/\", new byte[1], -1);\n<line23>        fail(\"Should have lost the connection\");\n<line24>    } catch (KeeperException.ConnectionLossException e) {\n<line25>        LOG.info(\"Got connection loss exception as expected\");\n<line26>    }\n<line27>    //zk.close();\n<line28>    zk = zknew;\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Got connection loss exception as expected\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // validate typical case - requested == negotiated\n<line3>    DisconnectableZooKeeper zk = createClient(TICK_TIME * 4);\n<line4>    assertEquals(TICK_TIME * 4, zk.getSessionTimeout());\n<line5>    // make sure tostring works in both cases\n<line6>    zk.close();\n<line7>    // validate lower limit\n<line8>    zk = createClient(TICK_TIME);\n<line9>    assertEquals(TICK_TIME * 2, zk.getSessionTimeout());\n<line10>    zk.close();\n<line11>    // validate upper limit\n<line12>    zk = createClient(TICK_TIME * 30);\n<line13>    assertEquals(TICK_TIME * 20, zk.getSessionTimeout());\n<line14>    zk.close();\n<line15>}","output":"<line1>{\n<line2>    // validate typical case - requested == negotiated\n<line3>    DisconnectableZooKeeper zk = createClient(TICK_TIME * 4);\n<line4>    assertEquals(TICK_TIME * 4, zk.getSessionTimeout());\n<line5>    // make sure tostring works in both cases\n<line6>    LOG.info(zk.toString());\n<line7>    zk.close();\n<line8>    LOG.info(zk.toString());\n<line9>    // validate lower limit\n<line10>    zk = createClient(TICK_TIME);\n<line11>    assertEquals(TICK_TIME * 2, zk.getSessionTimeout());\n<line12>    LOG.info(zk.toString());\n<line13>    zk.close();\n<line14>    LOG.info(zk.toString());\n<line15>    // validate upper limit\n<line16>    zk = createClient(TICK_TIME * 30);\n<line17>    assertEquals(TICK_TIME * 20, zk.getSessionTimeout());\n<line18>    LOG.info(zk.toString());\n<line19>    zk.close();\n<line20>    LOG.info(zk.toString());\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    // override the defaults\n<line3>    final int MINSESS = 20000;\n<line4>    final int MAXSESS = 240000;\n<line5>    {\n<line6>        ZooKeeperServer zs = serverFactory.getZooKeeperServer();\n<line7>        zs.setMinSessionTimeout(MINSESS);\n<line8>        zs.setMaxSessionTimeout(MAXSESS);\n<line9>    }\n<line10>    // validate typical case - requested == negotiated\n<line11>    int timeout = 120000;\n<line12>    DisconnectableZooKeeper zk = createClient(timeout);\n<line13>    assertEquals(timeout, zk.getSessionTimeout());\n<line14>    // make sure tostring works in both cases\n<line15>    zk.close();\n<line16>    // validate lower limit\n<line17>    zk = createClient(MINSESS / 2);\n<line18>    assertEquals(MINSESS, zk.getSessionTimeout());\n<line19>    zk.close();\n<line20>    // validate upper limit\n<line21>    zk = createClient(MAXSESS * 2);\n<line22>    assertEquals(MAXSESS, zk.getSessionTimeout());\n<line23>    zk.close();\n<line24>}","output":"<line1>{\n<line2>    // override the defaults\n<line3>    final int MINSESS = 20000;\n<line4>    final int MAXSESS = 240000;\n<line5>    {\n<line6>        ZooKeeperServer zs = serverFactory.getZooKeeperServer();\n<line7>        zs.setMinSessionTimeout(MINSESS);\n<line8>        zs.setMaxSessionTimeout(MAXSESS);\n<line9>    }\n<line10>    // validate typical case - requested == negotiated\n<line11>    int timeout = 120000;\n<line12>    DisconnectableZooKeeper zk = createClient(timeout);\n<line13>    assertEquals(timeout, zk.getSessionTimeout());\n<line14>    // make sure tostring works in both cases\n<line15>    LOG.info(zk.toString());\n<line16>    zk.close();\n<line17>    LOG.info(zk.toString());\n<line18>    // validate lower limit\n<line19>    zk = createClient(MINSESS / 2);\n<line20>    assertEquals(MINSESS, zk.getSessionTimeout());\n<line21>    LOG.info(zk.toString());\n<line22>    zk.close();\n<line23>    LOG.info(zk.toString());\n<line24>    // validate upper limit\n<line25>    zk = createClient(MAXSESS * 2);\n<line26>    assertEquals(MAXSESS, zk.getSessionTimeout());\n<line27>    LOG.info(zk.toString());\n<line28>    zk.close();\n<line29>    LOG.info(zk.toString());\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int serverToRestart = 1; serverToRestart <= 3; serverToRestart++) {\n<line3>        qu.shutdown(serverToRestart);\n<line4>        assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line5>        qu.restart(serverToRestart);\n<line6>        final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line7>        waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    for (int serverToRestart = 1; serverToRestart <= 3; serverToRestart++) {\n<line3>        LOG.info(\"***** restarting: \" + serverToRestart);\n<line4>        qu.shutdown(serverToRestart);\n<line5>        assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line6>        qu.restart(serverToRestart);\n<line7>        final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line8>        waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line9>        LOG.info(\"***** Restart {} succeeded\", serverToRestart);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.shutdown(serverToRestart);\n<line3>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line4>    qu.restart(serverToRestart);\n<line5>    final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line6>    waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"***** restarting: \" + serverToRestart);\n<line3>    qu.shutdown(serverToRestart);\n<line4>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line5>    qu.restart(serverToRestart);\n<line6>    final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line7>    waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line8>    LOG.info(\"***** Restart {} succeeded\", serverToRestart);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int serverToRestart = 3; serverToRestart >= 1; serverToRestart--) {\n<line3>        qu.shutdown(serverToRestart);\n<line4>        assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line5>        qu.restart(serverToRestart);\n<line6>        final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line7>        waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    for (int serverToRestart = 3; serverToRestart >= 1; serverToRestart--) {\n<line3>        LOG.info(\"***** restarting: \" + serverToRestart);\n<line4>        qu.shutdown(serverToRestart);\n<line5>        assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line6>        qu.restart(serverToRestart);\n<line7>        final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line8>        waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line9>        LOG.info(\"***** Restart {} succeeded\", serverToRestart);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.shutdown(serverToRestart);\n<line3>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line4>    qu.restart(serverToRestart);\n<line5>    final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line6>    waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"***** restarting: \" + serverToRestart);\n<line3>    qu.shutdown(serverToRestart);\n<line4>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(serverToRestart).clientPort, ClientBase.CONNECTION_TIMEOUT), String.format(\"Timeout during waiting for server %d to go down\", serverToRestart));\n<line5>    qu.restart(serverToRestart);\n<line6>    final String errorMessage = \"Not all the quorum members are connected after restarting server \" + serverToRestart;\n<line7>    waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line8>    LOG.info(\"***** Restart {} succeeded\", serverToRestart);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int restartCount = 1; restartCount <= 3; restartCount++) {\n<line3>        int leaderId = qu.getLeaderServer();\n<line4>        qu.shutdown(leaderId);\n<line5>        assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(leaderId).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Timeout during waiting for current leader to go down\");\n<line6>        String errorMessage = \"No new leader was elected\";\n<line7>        waitFor(errorMessage, () -> qu.leaderExists() && qu.getLeaderServer() != leaderId, 30);\n<line8>        qu.restart(leaderId);\n<line9>        errorMessage = \"Not all the quorum members are connected after restarting the old leader\";\n<line10>        waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    for (int restartCount = 1; restartCount <= 3; restartCount++) {\n<line3>        int leaderId = qu.getLeaderServer();\n<line4>        LOG.info(\"***** new leader: \" + leaderId);\n<line5>        qu.shutdown(leaderId);\n<line6>        assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(leaderId).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Timeout during waiting for current leader to go down\");\n<line7>        String errorMessage = \"No new leader was elected\";\n<line8>        waitFor(errorMessage, () -> qu.leaderExists() && qu.getLeaderServer() != leaderId, 30);\n<line9>        qu.restart(leaderId);\n<line10>        errorMessage = \"Not all the quorum members are connected after restarting the old leader\";\n<line11>        waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line12>        LOG.info(\"***** Leader Restart {} succeeded\", restartCount);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    int leaderId = qu.getLeaderServer();\n<line3>    qu.shutdown(leaderId);\n<line4>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(leaderId).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Timeout during waiting for current leader to go down\");\n<line5>    String errorMessage = \"No new leader was elected\";\n<line6>    waitFor(errorMessage, () -> qu.leaderExists() && qu.getLeaderServer() != leaderId, 30);\n<line7>    qu.restart(leaderId);\n<line8>    errorMessage = \"Not all the quorum members are connected after restarting the old leader\";\n<line9>    waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line10>}","output":"<line1>{\n<line2>    int leaderId = qu.getLeaderServer();\n<line3>    LOG.info(\"***** new leader: \" + leaderId);\n<line4>    qu.shutdown(leaderId);\n<line5>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(leaderId).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Timeout during waiting for current leader to go down\");\n<line6>    String errorMessage = \"No new leader was elected\";\n<line7>    waitFor(errorMessage, () -> qu.leaderExists() && qu.getLeaderServer() != leaderId, 30);\n<line8>    qu.restart(leaderId);\n<line9>    errorMessage = \"Not all the quorum members are connected after restarting the old leader\";\n<line10>    waitFor(errorMessage, () -> qu.allPeersAreConnected(), 30);\n<line11>    LOG.info(\"***** Leader Restart {} succeeded\", restartCount);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line4>        List<ACL> acls = zk.getACL(path, null);\n<line5>        for (ACL acl : acls) {\n<line6>        }\n<line7>    } catch (Exception e) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.debug(\"KeyAuthenticationProvider Creating Test Node:{}\\n\", path);\n<line4>        zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line5>        List<ACL> acls = zk.getACL(path, null);\n<line6>        LOG.debug(\"Node:{} Test:{} ACLs:\", path, testName);\n<line7>        for (ACL acl : acls) {\n<line8>            LOG.debug(\"  {}\", acl.toString());\n<line9>        }\n<line10>    } catch (Exception e) {\n<line11>        LOG.debug(\"  EXCEPTION THROWN\", e);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line3>    List<ACL> acls = zk.getACL(path, null);\n<line4>    for (ACL acl : acls) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.debug(\"KeyAuthenticationProvider Creating Test Node:{}\\n\", path);\n<line3>    zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line4>    List<ACL> acls = zk.getACL(path, null);\n<line5>    LOG.debug(\"Node:{} Test:{} ACLs:\", path, testName);\n<line6>    for (ACL acl : acls) {\n<line7>        LOG.debug(\"  {}\", acl.toString());\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"  {}\", acl.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"  EXCEPTION THROWN\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean isUnix = osMbean.getUnix();\n<line3>    if (!isUnix) {\n<line4>    } else {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    boolean isUnix = osMbean.getUnix();\n<line3>    if (!isUnix) {\n<line4>        LOG.info(\"Running in a Windows system! Output won't be printed!\");\n<line5>    } else {\n<line6>        LOG.info(\"Running in a Unix or Linux system!\");\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Running in a Windows system! Output won't be printed!\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Running in a Unix or Linux system!\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (osMbean != null && osMbean.getUnix()) {\n<line3>        ofdc = osMbean.getOpenFileDescriptorCount();\n<line4>    }\n<line5>    assertFalse((ofdc < 0), \"The number of open file descriptor is negative\");\n<line6>}","output":"<line1>{\n<line2>    if (osMbean != null && osMbean.getUnix()) {\n<line3>        ofdc = osMbean.getOpenFileDescriptorCount();\n<line4>        LOG.info(\"open fdcount is: {}\", ofdc);\n<line5>    }\n<line6>    assertFalse((ofdc < 0), \"The number of open file descriptor is negative\");\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ofdc = osMbean.getOpenFileDescriptorCount();\n<line3>}","output":"<line1>{\n<line2>    ofdc = osMbean.getOpenFileDescriptorCount();\n<line3>    LOG.info(\"open fdcount is: {}\", ofdc);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (osMbean != null && osMbean.getUnix()) {\n<line3>        mfdc = osMbean.getMaxFileDescriptorCount();\n<line4>    }\n<line5>    assertFalse((mfdc < 0), \"The max file descriptor number is negative\");\n<line6>}","output":"<line1>{\n<line2>    if (osMbean != null && osMbean.getUnix()) {\n<line3>        mfdc = osMbean.getMaxFileDescriptorCount();\n<line4>        LOG.info(\"max fdcount is: {}\", mfdc);\n<line5>    }\n<line6>    assertFalse((mfdc < 0), \"The max file descriptor number is negative\");\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    mfdc = osMbean.getMaxFileDescriptorCount();\n<line3>}","output":"<line1>{\n<line2>    mfdc = osMbean.getMaxFileDescriptorCount();\n<line3>    LOG.info(\"max fdcount is: {}\", mfdc);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    System.setProperty(\"zookeeper.authProvider.1\", \"org.apache.zookeeper.server.auth.SASLAuthenticationProvider\");\n<line3>    System.setProperty(LOGIN_CONTEXT_NAME_KEY, \"ClientUsingDigest\");\n<line4>    try {\n<line5>        File tmpDir = createTmpDir();\n<line6>        saslConfFile = new File(tmpDir, \"jaas.conf\");\n<line7>        PrintWriter saslConf = new PrintWriter(new FileWriter(saslConfFile));\n<line8>        saslConf.println(\"Server {\");\n<line9>        saslConf.println(\"org.apache.zookeeper.server.auth.DigestLoginModule required\");\n<line10>        saslConf.println(\"user_super=\\\"test\\\";\");\n<line11>        saslConf.println(\"};\");\n<line12>        saslConf.println(\"ClientUsingDigest {\");\n<line13>        saslConf.println(\"org.apache.zookeeper.server.auth.DigestLoginModule required\");\n<line14>        saslConf.println(\"username=\\\"super\\\"\");\n<line15>        saslConf.println(\"password=\\\"test\\\";\");\n<line16>        saslConf.println(\"};\");\n<line17>        saslConf.close();\n<line18>        System.setProperty(Environment.JAAS_CONF_KEY, saslConfFile.getAbsolutePath());\n<line19>    } catch (IOException e) {\n<line20>    }\n<line21>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line22>    // even if other tests already have been executed and initialized the SASL configs before)\n<line23>    Configuration.getConfiguration().refresh();\n<line24>}","output":"<line1>{\n<line2>    System.setProperty(\"zookeeper.authProvider.1\", \"org.apache.zookeeper.server.auth.SASLAuthenticationProvider\");\n<line3>    System.setProperty(LOGIN_CONTEXT_NAME_KEY, \"ClientUsingDigest\");\n<line4>    try {\n<line5>        File tmpDir = createTmpDir();\n<line6>        saslConfFile = new File(tmpDir, \"jaas.conf\");\n<line7>        PrintWriter saslConf = new PrintWriter(new FileWriter(saslConfFile));\n<line8>        saslConf.println(\"Server {\");\n<line9>        saslConf.println(\"org.apache.zookeeper.server.auth.DigestLoginModule required\");\n<line10>        saslConf.println(\"user_super=\\\"test\\\";\");\n<line11>        saslConf.println(\"};\");\n<line12>        saslConf.println(\"ClientUsingDigest {\");\n<line13>        saslConf.println(\"org.apache.zookeeper.server.auth.DigestLoginModule required\");\n<line14>        saslConf.println(\"username=\\\"super\\\"\");\n<line15>        saslConf.println(\"password=\\\"test\\\";\");\n<line16>        saslConf.println(\"};\");\n<line17>        saslConf.close();\n<line18>        System.setProperty(Environment.JAAS_CONF_KEY, saslConfFile.getAbsolutePath());\n<line19>    } catch (IOException e) {\n<line20>        LOG.error(\"could not create tmp directory to hold JAAS conf file, test will fail...\", e);\n<line21>    }\n<line22>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line23>    // even if other tests already have been executed and initialized the SASL configs before)\n<line24>    Configuration.getConfiguration().refresh();\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"could not create tmp directory to hold JAAS conf file, test will fail...\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // registering the server and client users in the KDC mini server\n<line3>    keytabFileForKerberosPrincipals = new File(KerberosTestUtils.getKeytabFile());\n<line4>    String clientPrincipal = KerberosTestUtils.getClientPrincipal();\n<line5>    String serverPrincipal = KerberosTestUtils.getServerPrincipal();\n<line6>    clientPrincipal = clientPrincipal.substring(0, clientPrincipal.lastIndexOf(\"@\"));\n<line7>    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\n<line8>    kdc.createPrincipal(keytabFileForKerberosPrincipals, clientPrincipal, serverPrincipal);\n<line9>    // client-side SASL config\n<line10>    System.setProperty(ZOOKEEPER_SERVER_PRINCIPAL, KerberosTestUtils.getServerPrincipal());\n<line11>    System.setProperty(ENABLE_CLIENT_SASL_KEY, \"true\");\n<line12>    System.setProperty(ZOOKEEPER_SERVER_REALM, KerberosTestUtils.getRealm());\n<line13>    System.setProperty(LOGIN_CONTEXT_NAME_KEY, \"ClientUsingKerberos\");\n<line14>    // server side SASL config\n<line15>    System.setProperty(\"zookeeper.authProvider.1\", \"org.apache.zookeeper.server.auth.SASLAuthenticationProvider\");\n<line16>    System.setProperty(SaslTestUtil.requireSASLAuthProperty, \"true\");\n<line17>    // generating the SASL config to use (contains sections both for the client and the server)\n<line18>    // note: we use \"refreshKrb5Config=true\" to refresh the kerberos config in the JVM,\n<line19>    // making sure that we use the latest config even if other tests already have been executed\n<line20>    // and initialized the kerberos client configs before)\n<line21>    try {\n<line22>        File tmpDir = createTmpDir();\n<line23>        saslConfFile = new File(tmpDir, \"jaas.conf\");\n<line24>        PrintWriter saslConf = new PrintWriter(new FileWriter(saslConfFile));\n<line25>        saslConf.println(\"Server {\");\n<line26>        saslConf.println(\"  com.sun.security.auth.module.Krb5LoginModule required\");\n<line27>        saslConf.println(\"  storeKey=\\\"true\\\"\");\n<line28>        saslConf.println(\"  useTicketCache=\\\"false\\\"\");\n<line29>        saslConf.println(\"  useKeyTab=\\\"true\\\"\");\n<line30>        saslConf.println(\"  doNotPrompt=\\\"true\\\"\");\n<line31>        saslConf.println(\"  debug=\\\"true\\\"\");\n<line32>        saslConf.println(\"  refreshKrb5Config=\\\"true\\\"\");\n<line33>        saslConf.println(\"  keyTab=\\\"\" + keytabFileForKerberosPrincipals.getAbsolutePath() + \"\\\"\");\n<line34>        saslConf.println(\"  principal=\\\"\" + KerberosTestUtils.getServerPrincipal() + \"\\\";\");\n<line35>        saslConf.println(\"};\");\n<line36>        saslConf.println(\"ClientUsingKerberos {\");\n<line37>        saslConf.println(\"  com.sun.security.auth.module.Krb5LoginModule required\");\n<line38>        saslConf.println(\"  storeKey=\\\"false\\\"\");\n<line39>        saslConf.println(\"  useTicketCache=\\\"false\\\"\");\n<line40>        saslConf.println(\"  useKeyTab=\\\"true\\\"\");\n<line41>        saslConf.println(\"  doNotPrompt=\\\"true\\\"\");\n<line42>        saslConf.println(\"  debug=\\\"true\\\"\");\n<line43>        saslConf.println(\"  refreshKrb5Config=\\\"true\\\"\");\n<line44>        saslConf.println(\"  keyTab=\\\"\" + keytabFileForKerberosPrincipals.getAbsolutePath() + \"\\\"\");\n<line45>        saslConf.println(\"  principal=\\\"\" + KerberosTestUtils.getClientPrincipal() + \"\\\";\");\n<line46>        saslConf.println(\"};\");\n<line47>        saslConf.close();\n<line48>        System.setProperty(Environment.JAAS_CONF_KEY, saslConfFile.getAbsolutePath());\n<line49>    } catch (IOException e) {\n<line50>    }\n<line51>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line52>    // even if other tests already have been executed and initialized the SASL configs before)\n<line53>    Configuration.getConfiguration().refresh();\n<line54>}","output":"<line1>{\n<line2>    // registering the server and client users in the KDC mini server\n<line3>    keytabFileForKerberosPrincipals = new File(KerberosTestUtils.getKeytabFile());\n<line4>    String clientPrincipal = KerberosTestUtils.getClientPrincipal();\n<line5>    String serverPrincipal = KerberosTestUtils.getServerPrincipal();\n<line6>    clientPrincipal = clientPrincipal.substring(0, clientPrincipal.lastIndexOf(\"@\"));\n<line7>    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\n<line8>    kdc.createPrincipal(keytabFileForKerberosPrincipals, clientPrincipal, serverPrincipal);\n<line9>    // client-side SASL config\n<line10>    System.setProperty(ZOOKEEPER_SERVER_PRINCIPAL, KerberosTestUtils.getServerPrincipal());\n<line11>    System.setProperty(ENABLE_CLIENT_SASL_KEY, \"true\");\n<line12>    System.setProperty(ZOOKEEPER_SERVER_REALM, KerberosTestUtils.getRealm());\n<line13>    System.setProperty(LOGIN_CONTEXT_NAME_KEY, \"ClientUsingKerberos\");\n<line14>    // server side SASL config\n<line15>    System.setProperty(\"zookeeper.authProvider.1\", \"org.apache.zookeeper.server.auth.SASLAuthenticationProvider\");\n<line16>    System.setProperty(SaslTestUtil.requireSASLAuthProperty, \"true\");\n<line17>    // generating the SASL config to use (contains sections both for the client and the server)\n<line18>    // note: we use \"refreshKrb5Config=true\" to refresh the kerberos config in the JVM,\n<line19>    // making sure that we use the latest config even if other tests already have been executed\n<line20>    // and initialized the kerberos client configs before)\n<line21>    try {\n<line22>        File tmpDir = createTmpDir();\n<line23>        saslConfFile = new File(tmpDir, \"jaas.conf\");\n<line24>        PrintWriter saslConf = new PrintWriter(new FileWriter(saslConfFile));\n<line25>        saslConf.println(\"Server {\");\n<line26>        saslConf.println(\"  com.sun.security.auth.module.Krb5LoginModule required\");\n<line27>        saslConf.println(\"  storeKey=\\\"true\\\"\");\n<line28>        saslConf.println(\"  useTicketCache=\\\"false\\\"\");\n<line29>        saslConf.println(\"  useKeyTab=\\\"true\\\"\");\n<line30>        saslConf.println(\"  doNotPrompt=\\\"true\\\"\");\n<line31>        saslConf.println(\"  debug=\\\"true\\\"\");\n<line32>        saslConf.println(\"  refreshKrb5Config=\\\"true\\\"\");\n<line33>        saslConf.println(\"  keyTab=\\\"\" + keytabFileForKerberosPrincipals.getAbsolutePath() + \"\\\"\");\n<line34>        saslConf.println(\"  principal=\\\"\" + KerberosTestUtils.getServerPrincipal() + \"\\\";\");\n<line35>        saslConf.println(\"};\");\n<line36>        saslConf.println(\"ClientUsingKerberos {\");\n<line37>        saslConf.println(\"  com.sun.security.auth.module.Krb5LoginModule required\");\n<line38>        saslConf.println(\"  storeKey=\\\"false\\\"\");\n<line39>        saslConf.println(\"  useTicketCache=\\\"false\\\"\");\n<line40>        saslConf.println(\"  useKeyTab=\\\"true\\\"\");\n<line41>        saslConf.println(\"  doNotPrompt=\\\"true\\\"\");\n<line42>        saslConf.println(\"  debug=\\\"true\\\"\");\n<line43>        saslConf.println(\"  refreshKrb5Config=\\\"true\\\"\");\n<line44>        saslConf.println(\"  keyTab=\\\"\" + keytabFileForKerberosPrincipals.getAbsolutePath() + \"\\\"\");\n<line45>        saslConf.println(\"  principal=\\\"\" + KerberosTestUtils.getClientPrincipal() + \"\\\";\");\n<line46>        saslConf.println(\"};\");\n<line47>        saslConf.close();\n<line48>        System.setProperty(Environment.JAAS_CONF_KEY, saslConfFile.getAbsolutePath());\n<line49>    } catch (IOException e) {\n<line50>        LOG.error(\"could not create tmp directory to hold JAAS conf file, test will fail...\", e);\n<line51>    }\n<line52>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line53>    // even if other tests already have been executed and initialized the SASL configs before)\n<line54>    Configuration.getConfiguration().refresh();\n<line55>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"could not create tmp directory to hold JAAS conf file, test will fail...\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] hostPorts = qb.hostPort.split(\",\");\n<line3>    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);\n<line4>    zk.create(\"/sessionMoveTest\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line5>    // we want to loop through the list twice\n<line6>    for (int i = 0; i < hostPorts.length * 2; i++) {\n<line7>        zk.dontReconnect();\n<line8>        // This should stomp the zk handle\n<line9>        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());\n<line10>        zknew.setData(\"/\", new byte[1], -1);\n<line11>        final int[] result = new int[1];\n<line12>        result[0] = Integer.MAX_VALUE;\n<line13>        zknew.sync(\"/\", (rc, path, ctx) -> {\n<line14>            synchronized (result) {\n<line15>                result[0] = rc;\n<line16>                result.notify();\n<line17>            }\n<line18>        }, null);\n<line19>        synchronized (result) {\n<line20>            if (result[0] == Integer.MAX_VALUE) {\n<line21>                result.wait(5000);\n<line22>            }\n<line23>        }\n<line24>        assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line25>        try {\n<line26>            zk.setData(\"/\", new byte[1], -1);\n<line27>            fail(\"Should have lost the connection\");\n<line28>        } catch (KeeperException.ConnectionLossException e) {\n<line29>        }\n<line30>        zk = zknew;\n<line31>    }\n<line32>    zk.close();\n<line33>}","output":"<line1>{\n<line2>    String[] hostPorts = qb.hostPort.split(\",\");\n<line3>    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);\n<line4>    zk.create(\"/sessionMoveTest\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line5>    // we want to loop through the list twice\n<line6>    for (int i = 0; i < hostPorts.length * 2; i++) {\n<line7>        zk.dontReconnect();\n<line8>        // This should stomp the zk handle\n<line9>        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());\n<line10>        zknew.setData(\"/\", new byte[1], -1);\n<line11>        final int[] result = new int[1];\n<line12>        result[0] = Integer.MAX_VALUE;\n<line13>        zknew.sync(\"/\", (rc, path, ctx) -> {\n<line14>            synchronized (result) {\n<line15>                result[0] = rc;\n<line16>                result.notify();\n<line17>            }\n<line18>        }, null);\n<line19>        synchronized (result) {\n<line20>            if (result[0] == Integer.MAX_VALUE) {\n<line21>                result.wait(5000);\n<line22>            }\n<line23>        }\n<line24>        LOG.info(\"{} Sync returned {}\", hostPorts[(i + 1) % hostPorts.length], result[0]);\n<line25>        assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line26>        try {\n<line27>            zk.setData(\"/\", new byte[1], -1);\n<line28>            fail(\"Should have lost the connection\");\n<line29>        } catch (KeeperException.ConnectionLossException e) {\n<line30>        }\n<line31>        zk = zknew;\n<line32>    }\n<line33>    zk.close();\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.dontReconnect();\n<line3>    // This should stomp the zk handle\n<line4>    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());\n<line5>    zknew.setData(\"/\", new byte[1], -1);\n<line6>    final int[] result = new int[1];\n<line7>    result[0] = Integer.MAX_VALUE;\n<line8>    zknew.sync(\"/\", (rc, path, ctx) -> {\n<line9>        synchronized (result) {\n<line10>            result[0] = rc;\n<line11>            result.notify();\n<line12>        }\n<line13>    }, null);\n<line14>    synchronized (result) {\n<line15>        if (result[0] == Integer.MAX_VALUE) {\n<line16>            result.wait(5000);\n<line17>        }\n<line18>    }\n<line19>    assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line20>    try {\n<line21>        zk.setData(\"/\", new byte[1], -1);\n<line22>        fail(\"Should have lost the connection\");\n<line23>    } catch (KeeperException.ConnectionLossException e) {\n<line24>    }\n<line25>    zk = zknew;\n<line26>}","output":"<line1>{\n<line2>    zk.dontReconnect();\n<line3>    // This should stomp the zk handle\n<line4>    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());\n<line5>    zknew.setData(\"/\", new byte[1], -1);\n<line6>    final int[] result = new int[1];\n<line7>    result[0] = Integer.MAX_VALUE;\n<line8>    zknew.sync(\"/\", (rc, path, ctx) -> {\n<line9>        synchronized (result) {\n<line10>            result[0] = rc;\n<line11>            result.notify();\n<line12>        }\n<line13>    }, null);\n<line14>    synchronized (result) {\n<line15>        if (result[0] == Integer.MAX_VALUE) {\n<line16>            result.wait(5000);\n<line17>        }\n<line18>    }\n<line19>    LOG.info(\"{} Sync returned {}\", hostPorts[(i + 1) % hostPorts.length], result[0]);\n<line20>    assertTrue(result[0] == KeeperException.Code.OK.intValue());\n<line21>    try {\n<line22>        zk.setData(\"/\", new byte[1], -1);\n<line23>        fail(\"Should have lost the connection\");\n<line24>    } catch (KeeperException.ConnectionLossException e) {\n<line25>    }\n<line26>    zk = zknew;\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    setupTestEnv();\n<line3>    JMXEnv.setUp();\n<line4>    setUpAll();\n<line5>    port1 = PortAssignment.unique();\n<line6>    port2 = PortAssignment.unique();\n<line7>    port3 = PortAssignment.unique();\n<line8>    port4 = PortAssignment.unique();\n<line9>    port5 = PortAssignment.unique();\n<line10>    leport1 = PortAssignment.unique();\n<line11>    leport2 = PortAssignment.unique();\n<line12>    leport3 = PortAssignment.unique();\n<line13>    leport4 = PortAssignment.unique();\n<line14>    leport5 = PortAssignment.unique();\n<line15>    clientport1 = PortAssignment.unique();\n<line16>    clientport2 = PortAssignment.unique();\n<line17>    clientport3 = PortAssignment.unique();\n<line18>    clientport4 = PortAssignment.unique();\n<line19>    clientport5 = PortAssignment.unique();\n<line20>    hostPort = \"127.0.0.1:\" + clientport1 + \",127.0.0.1:\" + clientport2 + \",127.0.0.1:\" + clientport3 + \",127.0.0.1:\" + clientport4 + \",127.0.0.1:\" + clientport5;\n<line21>    s1dir = ClientBase.createTmpDir();\n<line22>    s2dir = ClientBase.createTmpDir();\n<line23>    s3dir = ClientBase.createTmpDir();\n<line24>    s4dir = ClientBase.createTmpDir();\n<line25>    s5dir = ClientBase.createTmpDir();\n<line26>    String config = \"group.1=1:2:3\\n\" + \"group.2=4:5\\n\" + \"weight.1=1\\n\" + \"weight.2=1\\n\" + \"weight.3=1\\n\" + \"weight.4=0\\n\" + \"weight.5=0\\n\" + \"server.1=127.0.0.1:\" + port1 + \":\" + leport1 + \";\" + clientport1 + \"\\n\" + \"server.2=127.0.0.1:\" + port2 + \":\" + leport2 + \";\" + clientport2 + \"\\n\" + \"server.3=127.0.0.1:\" + port3 + \":\" + leport3 + \";\" + clientport3 + \"\\n\" + \"server.4=127.0.0.1:\" + port4 + \":\" + leport4 + \";\" + clientport4 + \"\\n\" + \"server.5=127.0.0.1:\" + port5 + \":\" + leport5 + \";\" + clientport5 + \"\\n\";\n<line27>    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());\n<line28>    this.qp = new Properties();\n<line29>    qp.load(is);\n<line30>    startServers();\n<line31>    cht.hostPort = hostPort;\n<line32>    cht.setUpAll();\n<line33>}","output":"<line1>{\n<line2>    setupTestEnv();\n<line3>    JMXEnv.setUp();\n<line4>    setUpAll();\n<line5>    port1 = PortAssignment.unique();\n<line6>    port2 = PortAssignment.unique();\n<line7>    port3 = PortAssignment.unique();\n<line8>    port4 = PortAssignment.unique();\n<line9>    port5 = PortAssignment.unique();\n<line10>    leport1 = PortAssignment.unique();\n<line11>    leport2 = PortAssignment.unique();\n<line12>    leport3 = PortAssignment.unique();\n<line13>    leport4 = PortAssignment.unique();\n<line14>    leport5 = PortAssignment.unique();\n<line15>    clientport1 = PortAssignment.unique();\n<line16>    clientport2 = PortAssignment.unique();\n<line17>    clientport3 = PortAssignment.unique();\n<line18>    clientport4 = PortAssignment.unique();\n<line19>    clientport5 = PortAssignment.unique();\n<line20>    hostPort = \"127.0.0.1:\" + clientport1 + \",127.0.0.1:\" + clientport2 + \",127.0.0.1:\" + clientport3 + \",127.0.0.1:\" + clientport4 + \",127.0.0.1:\" + clientport5;\n<line21>    LOG.info(\"Ports are: {}\", hostPort);\n<line22>    s1dir = ClientBase.createTmpDir();\n<line23>    s2dir = ClientBase.createTmpDir();\n<line24>    s3dir = ClientBase.createTmpDir();\n<line25>    s4dir = ClientBase.createTmpDir();\n<line26>    s5dir = ClientBase.createTmpDir();\n<line27>    String config = \"group.1=1:2:3\\n\" + \"group.2=4:5\\n\" + \"weight.1=1\\n\" + \"weight.2=1\\n\" + \"weight.3=1\\n\" + \"weight.4=0\\n\" + \"weight.5=0\\n\" + \"server.1=127.0.0.1:\" + port1 + \":\" + leport1 + \";\" + clientport1 + \"\\n\" + \"server.2=127.0.0.1:\" + port2 + \":\" + leport2 + \";\" + clientport2 + \"\\n\" + \"server.3=127.0.0.1:\" + port3 + \":\" + leport3 + \";\" + clientport3 + \"\\n\" + \"server.4=127.0.0.1:\" + port4 + \":\" + leport4 + \";\" + clientport4 + \"\\n\" + \"server.5=127.0.0.1:\" + port5 + \":\" + leport5 + \";\" + clientport5 + \"\\n\";\n<line28>    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());\n<line29>    this.qp = new Properties();\n<line30>    qp.load(is);\n<line31>    startServers();\n<line32>    cht.hostPort = hostPort;\n<line33>    cht.setUpAll();\n<line34>    LOG.info(\"Setup finished\");\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    HashMap<Long, QuorumServer> peers = new HashMap<>();\n<line7>    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(\"127.0.0.1\", port1), new InetSocketAddress(\"127.0.0.1\", leport1), new InetSocketAddress(\"127.0.0.1\", clientport1)));\n<line8>    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(\"127.0.0.1\", port2), new InetSocketAddress(\"127.0.0.1\", leport2), new InetSocketAddress(\"127.0.0.1\", clientport2)));\n<line9>    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(\"127.0.0.1\", port3), new InetSocketAddress(\"127.0.0.1\", leport3), new InetSocketAddress(\"127.0.0.1\", clientport3)));\n<line10>    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(\"127.0.0.1\", port4), new InetSocketAddress(\"127.0.0.1\", leport4), new InetSocketAddress(\"127.0.0.1\", clientport4), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));\n<line11>    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(\"127.0.0.1\", port5), new InetSocketAddress(\"127.0.0.1\", leport5), new InetSocketAddress(\"127.0.0.1\", clientport5), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));\n<line12>    if (withObservers) {\n<line13>        qp.setProperty(\"server.4\", \"127.0.0.1:\" + port4 + \":\" + leport4 + \":observer\" + \";\" + clientport4);\n<line14>        qp.setProperty(\"server.5\", \"127.0.0.1:\" + port5 + \":\" + leport5 + \":observer\" + \";\" + clientport5);\n<line15>    }\n<line16>    QuorumHierarchical hq1 = new QuorumHierarchical(qp);\n<line17>    s1 = new QuorumPeer(peers, s1dir, s1dir, clientport1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq1);\n<line18>    assertEquals(clientport1, s1.getClientPort());\n<line19>    QuorumHierarchical hq2 = new QuorumHierarchical(qp);\n<line20>    s2 = new QuorumPeer(peers, s2dir, s2dir, clientport2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq2);\n<line21>    assertEquals(clientport2, s2.getClientPort());\n<line22>    QuorumHierarchical hq3 = new QuorumHierarchical(qp);\n<line23>    s3 = new QuorumPeer(peers, s3dir, s3dir, clientport3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq3);\n<line24>    assertEquals(clientport3, s3.getClientPort());\n<line25>    QuorumHierarchical hq4 = new QuorumHierarchical(qp);\n<line26>    s4 = new QuorumPeer(peers, s4dir, s4dir, clientport4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq4);\n<line27>    if (withObservers) {\n<line28>        s4.setLearnerType(QuorumPeer.LearnerType.OBSERVER);\n<line29>    }\n<line30>    assertEquals(clientport4, s4.getClientPort());\n<line31>    QuorumHierarchical hq5 = new QuorumHierarchical(qp);\n<line32>    s5 = new QuorumPeer(peers, s5dir, s5dir, clientport5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq5);\n<line33>    if (withObservers) {\n<line34>        s5.setLearnerType(QuorumPeer.LearnerType.OBSERVER);\n<line35>    }\n<line36>    assertEquals(clientport5, s5.getClientPort());\n<line37>    s1.start();\n<line38>    s2.start();\n<line39>    s3.start();\n<line40>    s4.start();\n<line41>    s5.start();\n<line42>    for (String hp : hostPort.split(\",\")) {\n<line43>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line44>    }\n<line45>    final int numberOfPeers = 5;\n<line46>    // interesting to see what's there...\n<line47>    JMXEnv.dump();\n<line48>    // make sure we have these 5 servers listed\n<line49>    Set<String> ensureNames = new LinkedHashSet<>();\n<line50>    for (int i = 1; i <= numberOfPeers; i++) {\n<line51>        ensureNames.add(\"InMemoryDataTree\");\n<line52>    }\n<line53>    for (int i = 1; i <= numberOfPeers; i++) {\n<line54>        ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line55>    }\n<line56>    for (int i = 1; i <= numberOfPeers; i++) {\n<line57>        for (int j = 1; j <= numberOfPeers; j++) {\n<line58>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line59>        }\n<line60>    }\n<line61>    for (int i = 1; i <= numberOfPeers; i++) {\n<line62>        ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line63>    }\n<line64>    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line65>    for (int i = 1; i <= numberOfPeers; i++) {\n<line66>        // LocalPeerBean\n<line67>        String bean = MBeanRegistry.DOMAIN + \":name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i;\n<line68>        JMXEnv.ensureBeanAttribute(bean, \"ConfigVersion\");\n<line69>        JMXEnv.ensureBeanAttribute(bean, \"LearnerType\");\n<line70>        JMXEnv.ensureBeanAttribute(bean, \"ClientAddress\");\n<line71>        JMXEnv.ensureBeanAttribute(bean, \"ElectionAddress\");\n<line72>        JMXEnv.ensureBeanAttribute(bean, \"QuorumSystemInfo\");\n<line73>        JMXEnv.ensureBeanAttribute(bean, \"Leader\");\n<line74>    }\n<line75>    for (int i = 1; i <= numberOfPeers; i++) {\n<line76>        for (int j = 1; j <= numberOfPeers; j++) {\n<line77>            if (j != i) {\n<line78>                // RemotePeerBean\n<line79>                String bean = MBeanRegistry.DOMAIN + \":name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j;\n<line80>                JMXEnv.ensureBeanAttribute(bean, \"Name\");\n<line81>                JMXEnv.ensureBeanAttribute(bean, \"LearnerType\");\n<line82>                JMXEnv.ensureBeanAttribute(bean, \"ClientAddress\");\n<line83>                JMXEnv.ensureBeanAttribute(bean, \"ElectionAddress\");\n<line84>                JMXEnv.ensureBeanAttribute(bean, \"QuorumAddress\");\n<line85>                JMXEnv.ensureBeanAttribute(bean, \"Leader\");\n<line86>            }\n<line87>        }\n<line88>    }\n<line89>}","output":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    HashMap<Long, QuorumServer> peers = new HashMap<>();\n<line7>    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(\"127.0.0.1\", port1), new InetSocketAddress(\"127.0.0.1\", leport1), new InetSocketAddress(\"127.0.0.1\", clientport1)));\n<line8>    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(\"127.0.0.1\", port2), new InetSocketAddress(\"127.0.0.1\", leport2), new InetSocketAddress(\"127.0.0.1\", clientport2)));\n<line9>    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(\"127.0.0.1\", port3), new InetSocketAddress(\"127.0.0.1\", leport3), new InetSocketAddress(\"127.0.0.1\", clientport3)));\n<line10>    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(\"127.0.0.1\", port4), new InetSocketAddress(\"127.0.0.1\", leport4), new InetSocketAddress(\"127.0.0.1\", clientport4), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));\n<line11>    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(\"127.0.0.1\", port5), new InetSocketAddress(\"127.0.0.1\", leport5), new InetSocketAddress(\"127.0.0.1\", clientport5), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));\n<line12>    LOG.info(\"creating QuorumPeer 1 port {}\", clientport1);\n<line13>    if (withObservers) {\n<line14>        qp.setProperty(\"server.4\", \"127.0.0.1:\" + port4 + \":\" + leport4 + \":observer\" + \";\" + clientport4);\n<line15>        qp.setProperty(\"server.5\", \"127.0.0.1:\" + port5 + \":\" + leport5 + \":observer\" + \";\" + clientport5);\n<line16>    }\n<line17>    QuorumHierarchical hq1 = new QuorumHierarchical(qp);\n<line18>    s1 = new QuorumPeer(peers, s1dir, s1dir, clientport1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq1);\n<line19>    assertEquals(clientport1, s1.getClientPort());\n<line20>    LOG.info(\"creating QuorumPeer 2 port {}\", clientport2);\n<line21>    QuorumHierarchical hq2 = new QuorumHierarchical(qp);\n<line22>    s2 = new QuorumPeer(peers, s2dir, s2dir, clientport2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq2);\n<line23>    assertEquals(clientport2, s2.getClientPort());\n<line24>    LOG.info(\"creating QuorumPeer 3 port {}\", clientport3);\n<line25>    QuorumHierarchical hq3 = new QuorumHierarchical(qp);\n<line26>    s3 = new QuorumPeer(peers, s3dir, s3dir, clientport3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq3);\n<line27>    assertEquals(clientport3, s3.getClientPort());\n<line28>    LOG.info(\"creating QuorumPeer 4 port {}\", clientport4);\n<line29>    QuorumHierarchical hq4 = new QuorumHierarchical(qp);\n<line30>    s4 = new QuorumPeer(peers, s4dir, s4dir, clientport4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq4);\n<line31>    if (withObservers) {\n<line32>        s4.setLearnerType(QuorumPeer.LearnerType.OBSERVER);\n<line33>    }\n<line34>    assertEquals(clientport4, s4.getClientPort());\n<line35>    LOG.info(\"creating QuorumPeer 5 port {}\", clientport5);\n<line36>    QuorumHierarchical hq5 = new QuorumHierarchical(qp);\n<line37>    s5 = new QuorumPeer(peers, s5dir, s5dir, clientport5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq5);\n<line38>    if (withObservers) {\n<line39>        s5.setLearnerType(QuorumPeer.LearnerType.OBSERVER);\n<line40>    }\n<line41>    assertEquals(clientport5, s5.getClientPort());\n<line42>    LOG.info(\"start QuorumPeer 1\");\n<line43>    s1.start();\n<line44>    LOG.info(\"start QuorumPeer 2\");\n<line45>    s2.start();\n<line46>    LOG.info(\"start QuorumPeer 3\");\n<line47>    s3.start();\n<line48>    LOG.info(\"start QuorumPeer 4{}\", (withObservers ? \"(observer)\" : \"\"));\n<line49>    s4.start();\n<line50>    LOG.info(\"start QuorumPeer 5{}\", (withObservers ? \"(observer)\" : \"\"));\n<line51>    s5.start();\n<line52>    LOG.info(\"started QuorumPeer 5\");\n<line53>    LOG.info(\"Closing ports {}\", hostPort);\n<line54>    for (String hp : hostPort.split(\",\")) {\n<line55>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line56>        LOG.info(\"{} is accepting client connections\", hp);\n<line57>    }\n<line58>    final int numberOfPeers = 5;\n<line59>    // interesting to see what's there...\n<line60>    JMXEnv.dump();\n<line61>    // make sure we have these 5 servers listed\n<line62>    Set<String> ensureNames = new LinkedHashSet<>();\n<line63>    for (int i = 1; i <= numberOfPeers; i++) {\n<line64>        ensureNames.add(\"InMemoryDataTree\");\n<line65>    }\n<line66>    for (int i = 1; i <= numberOfPeers; i++) {\n<line67>        ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line68>    }\n<line69>    for (int i = 1; i <= numberOfPeers; i++) {\n<line70>        for (int j = 1; j <= numberOfPeers; j++) {\n<line71>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line72>        }\n<line73>    }\n<line74>    for (int i = 1; i <= numberOfPeers; i++) {\n<line75>        ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line76>    }\n<line77>    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line78>    for (int i = 1; i <= numberOfPeers; i++) {\n<line79>        // LocalPeerBean\n<line80>        String bean = MBeanRegistry.DOMAIN + \":name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i;\n<line81>        JMXEnv.ensureBeanAttribute(bean, \"ConfigVersion\");\n<line82>        JMXEnv.ensureBeanAttribute(bean, \"LearnerType\");\n<line83>        JMXEnv.ensureBeanAttribute(bean, \"ClientAddress\");\n<line84>        JMXEnv.ensureBeanAttribute(bean, \"ElectionAddress\");\n<line85>        JMXEnv.ensureBeanAttribute(bean, \"QuorumSystemInfo\");\n<line86>        JMXEnv.ensureBeanAttribute(bean, \"Leader\");\n<line87>    }\n<line88>    for (int i = 1; i <= numberOfPeers; i++) {\n<line89>        for (int j = 1; j <= numberOfPeers; j++) {\n<line90>            if (j != i) {\n<line91>                // RemotePeerBean\n<line92>                String bean = MBeanRegistry.DOMAIN + \":name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j;\n<line93>                JMXEnv.ensureBeanAttribute(bean, \"Name\");\n<line94>                JMXEnv.ensureBeanAttribute(bean, \"LearnerType\");\n<line95>                JMXEnv.ensureBeanAttribute(bean, \"ClientAddress\");\n<line96>                JMXEnv.ensureBeanAttribute(bean, \"ElectionAddress\");\n<line97>                JMXEnv.ensureBeanAttribute(bean, \"QuorumAddress\");\n<line98>                JMXEnv.ensureBeanAttribute(bean, \"Leader\");\n<line99>            }\n<line100>        }\n<line101>    }\n<line102>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line3>    LOG.info(\"{} is accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    cht.tearDownAll();\n<line3>    shutdown(s1);\n<line4>    shutdown(s2);\n<line5>    shutdown(s3);\n<line6>    shutdown(s4);\n<line7>    shutdown(s5);\n<line8>    for (String hp : hostPort.split(\",\")) {\n<line9>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line10>    }\n<line11>    JMXEnv.tearDown();\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"TearDown started\");\n<line3>    cht.tearDownAll();\n<line4>    LOG.info(\"Shutting down server 1\");\n<line5>    shutdown(s1);\n<line6>    LOG.info(\"Shutting down server 2\");\n<line7>    shutdown(s2);\n<line8>    LOG.info(\"Shutting down server 3\");\n<line9>    shutdown(s3);\n<line10>    LOG.info(\"Shutting down server 4\");\n<line11>    shutdown(s4);\n<line12>    LOG.info(\"Shutting down server 5\");\n<line13>    shutdown(s5);\n<line14>    for (String hp : hostPort.split(\",\")) {\n<line15>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line16>        LOG.info(\"{} is no longer accepting client connections\", hp);\n<line17>    }\n<line18>    JMXEnv.tearDown();\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line3>    LOG.info(\"{} is no longer accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.self = self;\n<line3>    this.i = i;\n<line4>    this.peer = peer;\n<line5>    this.totalRounds = rounds;\n<line6>    this.quora = quora;\n<line7>}","output":"<line1>{\n<line2>    this.self = self;\n<line3>    this.i = i;\n<line4>    this.peer = peer;\n<line5>    this.totalRounds = rounds;\n<line6>    this.quora = quora;\n<line7>    LOG.info(\"Constructor: {}\", getName());\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        while (true) {\n<line5>            /*\n<line6>                     * Set the state of the peer to LOOKING and look for leader\n<line7>                     */\n<line8>            peer.setPeerState(ServerState.LOOKING);\n<line9>            v = peer.getElectionAlg().lookForLeader();\n<line10>            if (v == null) {\n<line11>                break;\n<line12>            }\n<line13>            /*\n<line14>                     * Done with the election round, so now we set the vote in\n<line15>                     * the peer. A real zookeeper would take care of setting the\n<line16>                     * current vote. Here we do it manually.\n<line17>                     */\n<line18>            peer.setCurrentVote(v);\n<line19>            votes[i] = v;\n<line20>            /*\n<line21>                     * Get the current value of the logical clock for this peer\n<line22>                     * so that we know in which round this peer has executed.\n<line23>                     */\n<line24>            int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();\n<line25>            /*\n<line26>                     * The leader executes the following block, which essentially shuts down\n<line27>                     * the peer if it is not the last round.\n<line28>                     */\n<line29>            if (v.getId() == i) {\n<line30>                if (lc < this.totalRounds) {\n<line31>                    FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line32>                    election.shutdown();\n<line33>                    // Make sure the vote is reset to -1 after shutdown.\n<line34>                    assertEquals(-1, election.getVote().getId());\n<line35>                    break;\n<line36>                }\n<line37>            }\n<line38>            /*\n<line39>                     * If the peer has done enough rounds, then consider joining. The thread\n<line40>                     * will only join if it is part of a quorum supporting the current\n<line41>                     * leader. Otherwise it will try again.\n<line42>                     */\n<line43>            if (lc >= this.totalRounds) {\n<line44>                /*\n<line45>                         * quora keeps the supporters of a given leader, so\n<line46>                         * we first update it with the vote of this peer.\n<line47>                         */\n<line48>                if (quora.get(v.getId()) == null) {\n<line49>                    quora.put(v.getId(), new HashSet<>());\n<line50>                }\n<line51>                quora.get(v.getId()).add(i);\n<line52>                /*\n<line53>                         * we now wait until a quorum supports the same leader.\n<line54>                         */\n<line55>                if (waitForQuorum(v.getId())) {\n<line56>                    synchronized (self) {\n<line57>                        /*\n<line58>                                 * Assert that the state of the thread is the one expected.\n<line59>                                 */\n<line60>                        if (v.getId() == i) {\n<line61>                            assertTrue(peer.getPeerState() == ServerState.LEADING, \"Wrong state\" + peer.getPeerState());\n<line62>                            leader = i;\n<line63>                        } else {\n<line64>                            assertTrue(peer.getPeerState() == ServerState.FOLLOWING, \"Wrong state\" + peer.getPeerState());\n<line65>                        }\n<line66>                        /*\n<line67>                                 * Global variable keeping track of\n<line68>                                 * how many peers have successfully\n<line69>                                 * joined.\n<line70>                                 */\n<line71>                        successCount++;\n<line72>                        joinedThreads.add((long) i);\n<line73>                        self.notify();\n<line74>                    }\n<line75>                    /*\n<line76>                             * I'm done so joining.\n<line77>                             */\n<line78>                    break;\n<line79>                } else {\n<line80>                    quora.get(v.getId()).remove(i);\n<line81>                }\n<line82>            }\n<line83>            /*\n<line84>                     * This sleep time represents the time a follower\n<line85>                     * would take to declare the leader dead and start\n<line86>                     * a new leader election.\n<line87>                     */\n<line88>            Thread.sleep(100);\n<line89>        }\n<line90>    } catch (InterruptedException e) {\n<line91>        fail(e.toString());\n<line92>    }\n<line93>}","output":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        while (true) {\n<line5>            /*\n<line6>                     * Set the state of the peer to LOOKING and look for leader\n<line7>                     */\n<line8>            peer.setPeerState(ServerState.LOOKING);\n<line9>            LOG.info(\"Going to call leader election again.\");\n<line10>            v = peer.getElectionAlg().lookForLeader();\n<line11>            if (v == null) {\n<line12>                LOG.info(\"Thread {} got a null vote\", i);\n<line13>                break;\n<line14>            }\n<line15>            /*\n<line16>                     * Done with the election round, so now we set the vote in\n<line17>                     * the peer. A real zookeeper would take care of setting the\n<line18>                     * current vote. Here we do it manually.\n<line19>                     */\n<line20>            peer.setCurrentVote(v);\n<line21>            LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line22>            votes[i] = v;\n<line23>            /*\n<line24>                     * Get the current value of the logical clock for this peer\n<line25>                     * so that we know in which round this peer has executed.\n<line26>                     */\n<line27>            int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();\n<line28>            /*\n<line29>                     * The leader executes the following block, which essentially shuts down\n<line30>                     * the peer if it is not the last round.\n<line31>                     */\n<line32>            if (v.getId() == i) {\n<line33>                LOG.info(\"I'm the leader: {}\", i);\n<line34>                if (lc < this.totalRounds) {\n<line35>                    LOG.info(\"Leader {} dying\", i);\n<line36>                    FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line37>                    election.shutdown();\n<line38>                    // Make sure the vote is reset to -1 after shutdown.\n<line39>                    assertEquals(-1, election.getVote().getId());\n<line40>                    LOG.info(\"Leader {} dead\", i);\n<line41>                    break;\n<line42>                }\n<line43>            }\n<line44>            /*\n<line45>                     * If the peer has done enough rounds, then consider joining. The thread\n<line46>                     * will only join if it is part of a quorum supporting the current\n<line47>                     * leader. Otherwise it will try again.\n<line48>                     */\n<line49>            if (lc >= this.totalRounds) {\n<line50>                /*\n<line51>                         * quora keeps the supporters of a given leader, so\n<line52>                         * we first update it with the vote of this peer.\n<line53>                         */\n<line54>                if (quora.get(v.getId()) == null) {\n<line55>                    quora.put(v.getId(), new HashSet<>());\n<line56>                }\n<line57>                quora.get(v.getId()).add(i);\n<line58>                /*\n<line59>                         * we now wait until a quorum supports the same leader.\n<line60>                         */\n<line61>                if (waitForQuorum(v.getId())) {\n<line62>                    synchronized (self) {\n<line63>                        /*\n<line64>                                 * Assert that the state of the thread is the one expected.\n<line65>                                 */\n<line66>                        if (v.getId() == i) {\n<line67>                            assertTrue(peer.getPeerState() == ServerState.LEADING, \"Wrong state\" + peer.getPeerState());\n<line68>                            leader = i;\n<line69>                        } else {\n<line70>                            assertTrue(peer.getPeerState() == ServerState.FOLLOWING, \"Wrong state\" + peer.getPeerState());\n<line71>                        }\n<line72>                        /*\n<line73>                                 * Global variable keeping track of\n<line74>                                 * how many peers have successfully\n<line75>                                 * joined.\n<line76>                                 */\n<line77>                        successCount++;\n<line78>                        joinedThreads.add((long) i);\n<line79>                        self.notify();\n<line80>                    }\n<line81>                    /*\n<line82>                             * I'm done so joining.\n<line83>                             */\n<line84>                    break;\n<line85>                } else {\n<line86>                    quora.get(v.getId()).remove(i);\n<line87>                }\n<line88>            }\n<line89>            /*\n<line90>                     * This sleep time represents the time a follower\n<line91>                     * would take to declare the leader dead and start\n<line92>                     * a new leader election.\n<line93>                     */\n<line94>            Thread.sleep(100);\n<line95>        }\n<line96>        LOG.debug(\"Thread {} votes {}\", i, v);\n<line97>    } catch (InterruptedException e) {\n<line98>        fail(e.toString());\n<line99>    }\n<line100>}"},{"input":"","instruction":"<line1>{\n<line2>    Vote v = null;\n<line3>    while (true) {\n<line4>        /*\n<line5>                     * Set the state of the peer to LOOKING and look for leader\n<line6>                     */\n<line7>        peer.setPeerState(ServerState.LOOKING);\n<line8>        v = peer.getElectionAlg().lookForLeader();\n<line9>        if (v == null) {\n<line10>            break;\n<line11>        }\n<line12>        /*\n<line13>                     * Done with the election round, so now we set the vote in\n<line14>                     * the peer. A real zookeeper would take care of setting the\n<line15>                     * current vote. Here we do it manually.\n<line16>                     */\n<line17>        peer.setCurrentVote(v);\n<line18>        votes[i] = v;\n<line19>        /*\n<line20>                     * Get the current value of the logical clock for this peer\n<line21>                     * so that we know in which round this peer has executed.\n<line22>                     */\n<line23>        int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();\n<line24>        /*\n<line25>                     * The leader executes the following block, which essentially shuts down\n<line26>                     * the peer if it is not the last round.\n<line27>                     */\n<line28>        if (v.getId() == i) {\n<line29>            if (lc < this.totalRounds) {\n<line30>                FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line31>                election.shutdown();\n<line32>                // Make sure the vote is reset to -1 after shutdown.\n<line33>                assertEquals(-1, election.getVote().getId());\n<line34>                break;\n<line35>            }\n<line36>        }\n<line37>        /*\n<line38>                     * If the peer has done enough rounds, then consider joining. The thread\n<line39>                     * will only join if it is part of a quorum supporting the current\n<line40>                     * leader. Otherwise it will try again.\n<line41>                     */\n<line42>        if (lc >= this.totalRounds) {\n<line43>            /*\n<line44>                         * quora keeps the supporters of a given leader, so\n<line45>                         * we first update it with the vote of this peer.\n<line46>                         */\n<line47>            if (quora.get(v.getId()) == null) {\n<line48>                quora.put(v.getId(), new HashSet<>());\n<line49>            }\n<line50>            quora.get(v.getId()).add(i);\n<line51>            /*\n<line52>                         * we now wait until a quorum supports the same leader.\n<line53>                         */\n<line54>            if (waitForQuorum(v.getId())) {\n<line55>                synchronized (self) {\n<line56>                    /*\n<line57>                                 * Assert that the state of the thread is the one expected.\n<line58>                                 */\n<line59>                    if (v.getId() == i) {\n<line60>                        assertTrue(peer.getPeerState() == ServerState.LEADING, \"Wrong state\" + peer.getPeerState());\n<line61>                        leader = i;\n<line62>                    } else {\n<line63>                        assertTrue(peer.getPeerState() == ServerState.FOLLOWING, \"Wrong state\" + peer.getPeerState());\n<line64>                    }\n<line65>                    /*\n<line66>                                 * Global variable keeping track of\n<line67>                                 * how many peers have successfully\n<line68>                                 * joined.\n<line69>                                 */\n<line70>                    successCount++;\n<line71>                    joinedThreads.add((long) i);\n<line72>                    self.notify();\n<line73>                }\n<line74>                /*\n<line75>                             * I'm done so joining.\n<line76>                             */\n<line77>                break;\n<line78>            } else {\n<line79>                quora.get(v.getId()).remove(i);\n<line80>            }\n<line81>        }\n<line82>        /*\n<line83>                     * This sleep time represents the time a follower\n<line84>                     * would take to declare the leader dead and start\n<line85>                     * a new leader election.\n<line86>                     */\n<line87>        Thread.sleep(100);\n<line88>    }\n<line89>}","output":"<line1>{\n<line2>    Vote v = null;\n<line3>    while (true) {\n<line4>        /*\n<line5>                     * Set the state of the peer to LOOKING and look for leader\n<line6>                     */\n<line7>        peer.setPeerState(ServerState.LOOKING);\n<line8>        LOG.info(\"Going to call leader election again.\");\n<line9>        v = peer.getElectionAlg().lookForLeader();\n<line10>        if (v == null) {\n<line11>            LOG.info(\"Thread {} got a null vote\", i);\n<line12>            break;\n<line13>        }\n<line14>        /*\n<line15>                     * Done with the election round, so now we set the vote in\n<line16>                     * the peer. A real zookeeper would take care of setting the\n<line17>                     * current vote. Here we do it manually.\n<line18>                     */\n<line19>        peer.setCurrentVote(v);\n<line20>        LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line21>        votes[i] = v;\n<line22>        /*\n<line23>                     * Get the current value of the logical clock for this peer\n<line24>                     * so that we know in which round this peer has executed.\n<line25>                     */\n<line26>        int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();\n<line27>        /*\n<line28>                     * The leader executes the following block, which essentially shuts down\n<line29>                     * the peer if it is not the last round.\n<line30>                     */\n<line31>        if (v.getId() == i) {\n<line32>            LOG.info(\"I'm the leader: {}\", i);\n<line33>            if (lc < this.totalRounds) {\n<line34>                LOG.info(\"Leader {} dying\", i);\n<line35>                FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line36>                election.shutdown();\n<line37>                // Make sure the vote is reset to -1 after shutdown.\n<line38>                assertEquals(-1, election.getVote().getId());\n<line39>                LOG.info(\"Leader {} dead\", i);\n<line40>                break;\n<line41>            }\n<line42>        }\n<line43>        /*\n<line44>                     * If the peer has done enough rounds, then consider joining. The thread\n<line45>                     * will only join if it is part of a quorum supporting the current\n<line46>                     * leader. Otherwise it will try again.\n<line47>                     */\n<line48>        if (lc >= this.totalRounds) {\n<line49>            /*\n<line50>                         * quora keeps the supporters of a given leader, so\n<line51>                         * we first update it with the vote of this peer.\n<line52>                         */\n<line53>            if (quora.get(v.getId()) == null) {\n<line54>                quora.put(v.getId(), new HashSet<>());\n<line55>            }\n<line56>            quora.get(v.getId()).add(i);\n<line57>            /*\n<line58>                         * we now wait until a quorum supports the same leader.\n<line59>                         */\n<line60>            if (waitForQuorum(v.getId())) {\n<line61>                synchronized (self) {\n<line62>                    /*\n<line63>                                 * Assert that the state of the thread is the one expected.\n<line64>                                 */\n<line65>                    if (v.getId() == i) {\n<line66>                        assertTrue(peer.getPeerState() == ServerState.LEADING, \"Wrong state\" + peer.getPeerState());\n<line67>                        leader = i;\n<line68>                    } else {\n<line69>                        assertTrue(peer.getPeerState() == ServerState.FOLLOWING, \"Wrong state\" + peer.getPeerState());\n<line70>                    }\n<line71>                    /*\n<line72>                                 * Global variable keeping track of\n<line73>                                 * how many peers have successfully\n<line74>                                 * joined.\n<line75>                                 */\n<line76>                    successCount++;\n<line77>                    joinedThreads.add((long) i);\n<line78>                    self.notify();\n<line79>                }\n<line80>                /*\n<line81>                             * I'm done so joining.\n<line82>                             */\n<line83>                break;\n<line84>            } else {\n<line85>                quora.get(v.getId()).remove(i);\n<line86>            }\n<line87>        }\n<line88>        /*\n<line89>                     * This sleep time represents the time a follower\n<line90>                     * would take to declare the leader dead and start\n<line91>                     * a new leader election.\n<line92>                     */\n<line93>        Thread.sleep(100);\n<line94>    }\n<line95>    LOG.debug(\"Thread {} votes {}\", i, v);\n<line96>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                     * Set the state of the peer to LOOKING and look for leader\n<line4>                     */\n<line5>    peer.setPeerState(ServerState.LOOKING);\n<line6>    v = peer.getElectionAlg().lookForLeader();\n<line7>    if (v == null) {\n<line8>        break;\n<line9>    }\n<line10>    /*\n<line11>                     * Done with the election round, so now we set the vote in\n<line12>                     * the peer. A real zookeeper would take care of setting the\n<line13>                     * current vote. Here we do it manually.\n<line14>                     */\n<line15>    peer.setCurrentVote(v);\n<line16>    votes[i] = v;\n<line17>    /*\n<line18>                     * Get the current value of the logical clock for this peer\n<line19>                     * so that we know in which round this peer has executed.\n<line20>                     */\n<line21>    int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();\n<line22>    /*\n<line23>                     * The leader executes the following block, which essentially shuts down\n<line24>                     * the peer if it is not the last round.\n<line25>                     */\n<line26>    if (v.getId() == i) {\n<line27>        if (lc < this.totalRounds) {\n<line28>            FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line29>            election.shutdown();\n<line30>            // Make sure the vote is reset to -1 after shutdown.\n<line31>            assertEquals(-1, election.getVote().getId());\n<line32>            break;\n<line33>        }\n<line34>    }\n<line35>    /*\n<line36>                     * If the peer has done enough rounds, then consider joining. The thread\n<line37>                     * will only join if it is part of a quorum supporting the current\n<line38>                     * leader. Otherwise it will try again.\n<line39>                     */\n<line40>    if (lc >= this.totalRounds) {\n<line41>        /*\n<line42>                         * quora keeps the supporters of a given leader, so\n<line43>                         * we first update it with the vote of this peer.\n<line44>                         */\n<line45>        if (quora.get(v.getId()) == null) {\n<line46>            quora.put(v.getId(), new HashSet<>());\n<line47>        }\n<line48>        quora.get(v.getId()).add(i);\n<line49>        /*\n<line50>                         * we now wait until a quorum supports the same leader.\n<line51>                         */\n<line52>        if (waitForQuorum(v.getId())) {\n<line53>            synchronized (self) {\n<line54>                /*\n<line55>                                 * Assert that the state of the thread is the one expected.\n<line56>                                 */\n<line57>                if (v.getId() == i) {\n<line58>                    assertTrue(peer.getPeerState() == ServerState.LEADING, \"Wrong state\" + peer.getPeerState());\n<line59>                    leader = i;\n<line60>                } else {\n<line61>                    assertTrue(peer.getPeerState() == ServerState.FOLLOWING, \"Wrong state\" + peer.getPeerState());\n<line62>                }\n<line63>                /*\n<line64>                                 * Global variable keeping track of\n<line65>                                 * how many peers have successfully\n<line66>                                 * joined.\n<line67>                                 */\n<line68>                successCount++;\n<line69>                joinedThreads.add((long) i);\n<line70>                self.notify();\n<line71>            }\n<line72>            /*\n<line73>                             * I'm done so joining.\n<line74>                             */\n<line75>            break;\n<line76>        } else {\n<line77>            quora.get(v.getId()).remove(i);\n<line78>        }\n<line79>    }\n<line80>    /*\n<line81>                     * This sleep time represents the time a follower\n<line82>                     * would take to declare the leader dead and start\n<line83>                     * a new leader election.\n<line84>                     */\n<line85>    Thread.sleep(100);\n<line86>}","output":"<line1>{\n<line2>    /*\n<line3>                     * Set the state of the peer to LOOKING and look for leader\n<line4>                     */\n<line5>    peer.setPeerState(ServerState.LOOKING);\n<line6>    LOG.info(\"Going to call leader election again.\");\n<line7>    v = peer.getElectionAlg().lookForLeader();\n<line8>    if (v == null) {\n<line9>        LOG.info(\"Thread {} got a null vote\", i);\n<line10>        break;\n<line11>    }\n<line12>    /*\n<line13>                     * Done with the election round, so now we set the vote in\n<line14>                     * the peer. A real zookeeper would take care of setting the\n<line15>                     * current vote. Here we do it manually.\n<line16>                     */\n<line17>    peer.setCurrentVote(v);\n<line18>    LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line19>    votes[i] = v;\n<line20>    /*\n<line21>                     * Get the current value of the logical clock for this peer\n<line22>                     * so that we know in which round this peer has executed.\n<line23>                     */\n<line24>    int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();\n<line25>    /*\n<line26>                     * The leader executes the following block, which essentially shuts down\n<line27>                     * the peer if it is not the last round.\n<line28>                     */\n<line29>    if (v.getId() == i) {\n<line30>        LOG.info(\"I'm the leader: {}\", i);\n<line31>        if (lc < this.totalRounds) {\n<line32>            LOG.info(\"Leader {} dying\", i);\n<line33>            FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line34>            election.shutdown();\n<line35>            // Make sure the vote is reset to -1 after shutdown.\n<line36>            assertEquals(-1, election.getVote().getId());\n<line37>            LOG.info(\"Leader {} dead\", i);\n<line38>            break;\n<line39>        }\n<line40>    }\n<line41>    /*\n<line42>                     * If the peer has done enough rounds, then consider joining. The thread\n<line43>                     * will only join if it is part of a quorum supporting the current\n<line44>                     * leader. Otherwise it will try again.\n<line45>                     */\n<line46>    if (lc >= this.totalRounds) {\n<line47>        /*\n<line48>                         * quora keeps the supporters of a given leader, so\n<line49>                         * we first update it with the vote of this peer.\n<line50>                         */\n<line51>        if (quora.get(v.getId()) == null) {\n<line52>            quora.put(v.getId(), new HashSet<>());\n<line53>        }\n<line54>        quora.get(v.getId()).add(i);\n<line55>        /*\n<line56>                         * we now wait until a quorum supports the same leader.\n<line57>                         */\n<line58>        if (waitForQuorum(v.getId())) {\n<line59>            synchronized (self) {\n<line60>                /*\n<line61>                                 * Assert that the state of the thread is the one expected.\n<line62>                                 */\n<line63>                if (v.getId() == i) {\n<line64>                    assertTrue(peer.getPeerState() == ServerState.LEADING, \"Wrong state\" + peer.getPeerState());\n<line65>                    leader = i;\n<line66>                } else {\n<line67>                    assertTrue(peer.getPeerState() == ServerState.FOLLOWING, \"Wrong state\" + peer.getPeerState());\n<line68>                }\n<line69>                /*\n<line70>                                 * Global variable keeping track of\n<line71>                                 * how many peers have successfully\n<line72>                                 * joined.\n<line73>                                 */\n<line74>                successCount++;\n<line75>                joinedThreads.add((long) i);\n<line76>                self.notify();\n<line77>            }\n<line78>            /*\n<line79>                             * I'm done so joining.\n<line80>                             */\n<line81>            break;\n<line82>        } else {\n<line83>            quora.get(v.getId()).remove(i);\n<line84>        }\n<line85>    }\n<line86>    /*\n<line87>                     * This sleep time represents the time a follower\n<line88>                     * would take to declare the leader dead and start\n<line89>                     * a new leader election.\n<line90>                     */\n<line91>    Thread.sleep(100);\n<line92>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Thread {} got a null vote\", i);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (lc < this.totalRounds) {\n<line3>        FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line4>        election.shutdown();\n<line5>        // Make sure the vote is reset to -1 after shutdown.\n<line6>        assertEquals(-1, election.getVote().getId());\n<line7>        break;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"I'm the leader: {}\", i);\n<line3>    if (lc < this.totalRounds) {\n<line4>        LOG.info(\"Leader {} dying\", i);\n<line5>        FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line6>        election.shutdown();\n<line7>        // Make sure the vote is reset to -1 after shutdown.\n<line8>        assertEquals(-1, election.getVote().getId());\n<line9>        LOG.info(\"Leader {} dead\", i);\n<line10>        break;\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line3>    election.shutdown();\n<line4>    // Make sure the vote is reset to -1 after shutdown.\n<line5>    assertEquals(-1, election.getVote().getId());\n<line6>    break;\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"Leader {} dying\", i);\n<line3>    FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();\n<line4>    election.shutdown();\n<line5>    // Make sure the vote is reset to -1 after shutdown.\n<line6>    assertEquals(-1, election.getVote().getId());\n<line7>    LOG.info(\"Leader {} dead\", i);\n<line8>    break;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    ConcurrentHashMap<Long, HashSet<Integer>> quora = new ConcurrentHashMap<>();\n<line3>    /*\n<line4>         * Creates list of peers.\n<line5>         */\n<line6>    for (int i = 0; i < count; i++) {\n<line7>        port[i] = PortAssignment.unique();\n<line8>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", port[i])));\n<line9>        tmpdir[i] = ClientBase.createTmpDir();\n<line10>    }\n<line11>    /*\n<line12>         * Start one LEThread for each peer we want to run.\n<line13>         */\n<line14>    for (int i = 0; i < count; i++) {\n<line15>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line16>        peer.startLeaderElection();\n<line17>        LEThread thread = new LEThread(this, peer, i, rounds, quora);\n<line18>        thread.start();\n<line19>        threads.add(thread);\n<line20>    }\n<line21>    int waitCounter = 0;\n<line22>    synchronized (this) {\n<line23>        while (((successCount <= count / 2) || (leader == -1)) && (waitCounter < MAX_LOOP_COUNTER)) {\n<line24>            this.wait(200);\n<line25>            waitCounter++;\n<line26>        }\n<line27>    }\n<line28>    /*\n<line29>         * Lists what threads haven't joined. A thread doesn't join if\n<line30>         * it hasn't decided upon a leader yet. It can happen that a\n<line31>         * peer is slow or disconnected, and it can take longer to\n<line32>         * nominate and connect to the current leader.\n<line33>         */\n<line34>    for (int i = 0; i < threads.size(); i++) {\n<line35>        if (threads.get(i).isAlive()) {\n<line36>        }\n<line37>    }\n<line38>    /*\n<line39>         * If we have a majority, then we are good to go.\n<line40>         */\n<line41>    if (successCount <= count / 2) {\n<line42>        fail(\"Fewer than a a majority has joined\");\n<line43>    }\n<line44>    /*\n<line45>         * I'm done so joining.\n<line46>         */\n<line47>    if (!joinedThreads.contains(leader)) {\n<line48>        fail(\"Leader hasn't joined: \" + leader);\n<line49>    }\n<line50>}","output":"<line1>{\n<line2>    ConcurrentHashMap<Long, HashSet<Integer>> quora = new ConcurrentHashMap<>();\n<line3>    LOG.info(\"TestLE: {}, {}\", getTestName(), count);\n<line4>    /*\n<line5>         * Creates list of peers.\n<line6>         */\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        port[i] = PortAssignment.unique();\n<line9>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", port[i])));\n<line10>        tmpdir[i] = ClientBase.createTmpDir();\n<line11>    }\n<line12>    /*\n<line13>         * Start one LEThread for each peer we want to run.\n<line14>         */\n<line15>    for (int i = 0; i < count; i++) {\n<line16>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line17>        peer.startLeaderElection();\n<line18>        LEThread thread = new LEThread(this, peer, i, rounds, quora);\n<line19>        thread.start();\n<line20>        threads.add(thread);\n<line21>    }\n<line22>    LOG.info(\"Started threads {}\", getTestName());\n<line23>    int waitCounter = 0;\n<line24>    synchronized (this) {\n<line25>        while (((successCount <= count / 2) || (leader == -1)) && (waitCounter < MAX_LOOP_COUNTER)) {\n<line26>            this.wait(200);\n<line27>            waitCounter++;\n<line28>        }\n<line29>    }\n<line30>    LOG.info(\"Success count: {}\", successCount);\n<line31>    /*\n<line32>         * Lists what threads haven't joined. A thread doesn't join if\n<line33>         * it hasn't decided upon a leader yet. It can happen that a\n<line34>         * peer is slow or disconnected, and it can take longer to\n<line35>         * nominate and connect to the current leader.\n<line36>         */\n<line37>    for (int i = 0; i < threads.size(); i++) {\n<line38>        if (threads.get(i).isAlive()) {\n<line39>            LOG.info(\"Threads didn't join: {}\", i);\n<line40>        }\n<line41>    }\n<line42>    /*\n<line43>         * If we have a majority, then we are good to go.\n<line44>         */\n<line45>    if (successCount <= count / 2) {\n<line46>        fail(\"Fewer than a a majority has joined\");\n<line47>    }\n<line48>    /*\n<line49>         * I'm done so joining.\n<line50>         */\n<line51>    if (!joinedThreads.contains(leader)) {\n<line52>        fail(\"Leader hasn't joined: \" + leader);\n<line53>    }\n<line54>}"},{"input":"","instruction":"<line1>{\n<line2>    if (threads.get(i).isAlive()) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (threads.get(i).isAlive()) {\n<line3>        LOG.info(\"Threads didn't join: {}\", i);\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Threads didn't join: {}\", i);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    setName(\"VerifyState-\" + peer.getMyId());\n<line3>    while (true) {\n<line4>        if (peer.getPeerState() == ServerState.FOLLOWING) {\n<line5>            success = true;\n<line6>            break;\n<line7>        } else if (peer.getPeerState() == ServerState.LEADING) {\n<line8>            success = false;\n<line9>            break;\n<line10>        }\n<line11>        try {\n<line12>            Thread.sleep(250);\n<line13>        } catch (Exception e) {\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    setName(\"VerifyState-\" + peer.getMyId());\n<line3>    while (true) {\n<line4>        if (peer.getPeerState() == ServerState.FOLLOWING) {\n<line5>            LOG.info(\"I am following\");\n<line6>            success = true;\n<line7>            break;\n<line8>        } else if (peer.getPeerState() == ServerState.LEADING) {\n<line9>            LOG.info(\"I am leading\");\n<line10>            success = false;\n<line11>            break;\n<line12>        }\n<line13>        try {\n<line14>            Thread.sleep(250);\n<line15>        } catch (Exception e) {\n<line16>            LOG.warn(\"Sleep failed \", e);\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (peer.getPeerState() == ServerState.FOLLOWING) {\n<line3>        success = true;\n<line4>        break;\n<line5>    } else if (peer.getPeerState() == ServerState.LEADING) {\n<line6>        success = false;\n<line7>        break;\n<line8>    }\n<line9>    try {\n<line10>        Thread.sleep(250);\n<line11>    } catch (Exception e) {\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    if (peer.getPeerState() == ServerState.FOLLOWING) {\n<line3>        LOG.info(\"I am following\");\n<line4>        success = true;\n<line5>        break;\n<line6>    } else if (peer.getPeerState() == ServerState.LEADING) {\n<line7>        LOG.info(\"I am leading\");\n<line8>        success = false;\n<line9>        break;\n<line10>    }\n<line11>    try {\n<line12>        Thread.sleep(250);\n<line13>    } catch (Exception e) {\n<line14>        LOG.warn(\"Sleep failed \", e);\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    success = true;\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"I am following\");\n<line3>    success = true;\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    success = false;\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"I am leading\");\n<line3>    success = false;\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    int sid;\n<line3>    QuorumPeer peer;\n<line4>    int waitTime = 10 * 1000;\n<line5>    ArrayList<QuorumPeer> peerList = new ArrayList<>();\n<line6>    for (sid = 0; sid < 3; sid++) {\n<line7>        port[sid] = PortAssignment.unique();\n<line8>        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", port[sid])));\n<line9>        tmpdir[sid] = ClientBase.createTmpDir();\n<line10>    }\n<line11>    // start 2 peers and verify if they form the cluster\n<line12>    for (sid = 0; sid < 2; sid++) {\n<line13>        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line14>        peer.start();\n<line15>        peerList.add(sid, peer);\n<line16>    }\n<line17>    peer = peerList.get(0);\n<line18>    VerifyState v1 = new VerifyState(peerList.get(0));\n<line19>    v1.start();\n<line20>    v1.join(waitTime);\n<line21>    assertFalse(!v1.isSuccess(), \"Unable to form cluster in \" + waitTime + \" ms\");\n<line22>    // Start 3rd peer and check if it goes in LEADING state\n<line23>    peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line24>    peer.start();\n<line25>    peerList.add(sid, peer);\n<line26>    v1 = new VerifyState(peer);\n<line27>    v1.start();\n<line28>    v1.join(waitTime);\n<line29>    if (v1.isAlive()) {\n<line30>        fail(\"Peer \" + peer.getMyId() + \" failed to join the cluster \" + \"within \" + waitTime + \" ms\");\n<line31>    } else if (!v1.isSuccess()) {\n<line32>        fail(\"Incorrect LEADING state for peer \" + peer.getMyId());\n<line33>    }\n<line34>    // cleanup\n<line35>    for (int id = 0; id < 3; id++) {\n<line36>        peer = peerList.get(id);\n<line37>        if (peer != null) {\n<line38>            peer.shutdown();\n<line39>        }\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    int sid;\n<line3>    QuorumPeer peer;\n<line4>    int waitTime = 10 * 1000;\n<line5>    ArrayList<QuorumPeer> peerList = new ArrayList<>();\n<line6>    for (sid = 0; sid < 3; sid++) {\n<line7>        port[sid] = PortAssignment.unique();\n<line8>        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", port[sid])));\n<line9>        tmpdir[sid] = ClientBase.createTmpDir();\n<line10>    }\n<line11>    // start 2 peers and verify if they form the cluster\n<line12>    for (sid = 0; sid < 2; sid++) {\n<line13>        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line14>        LOG.info(\"Starting peer {}\", peer.getMyId());\n<line15>        peer.start();\n<line16>        peerList.add(sid, peer);\n<line17>    }\n<line18>    peer = peerList.get(0);\n<line19>    VerifyState v1 = new VerifyState(peerList.get(0));\n<line20>    v1.start();\n<line21>    v1.join(waitTime);\n<line22>    assertFalse(!v1.isSuccess(), \"Unable to form cluster in \" + waitTime + \" ms\");\n<line23>    // Start 3rd peer and check if it goes in LEADING state\n<line24>    peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line25>    LOG.info(\"Starting peer {}\", peer.getMyId());\n<line26>    peer.start();\n<line27>    peerList.add(sid, peer);\n<line28>    v1 = new VerifyState(peer);\n<line29>    v1.start();\n<line30>    v1.join(waitTime);\n<line31>    if (v1.isAlive()) {\n<line32>        fail(\"Peer \" + peer.getMyId() + \" failed to join the cluster \" + \"within \" + waitTime + \" ms\");\n<line33>    } else if (!v1.isSuccess()) {\n<line34>        fail(\"Incorrect LEADING state for peer \" + peer.getMyId());\n<line35>    }\n<line36>    // cleanup\n<line37>    for (int id = 0; id < 3; id++) {\n<line38>        peer = peerList.get(id);\n<line39>        if (peer != null) {\n<line40>            peer.shutdown();\n<line41>        }\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line3>    peer.start();\n<line4>    peerList.add(sid, peer);\n<line5>}","output":"<line1>{\n<line2>    peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line3>    LOG.info(\"Starting peer {}\", peer.getMyId());\n<line4>    peer.start();\n<line5>    peerList.add(sid, peer);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    int sid;\n<line3>    QuorumPeer peer;\n<line4>    int waitTime = 10 * 1000;\n<line5>    ArrayList<QuorumPeer> peerList = new ArrayList<>();\n<line6>    for (sid = 0; sid < 3; sid++) {\n<line7>        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line8>        tmpdir[sid] = ClientBase.createTmpDir();\n<line9>        port[sid] = PortAssignment.unique();\n<line10>    }\n<line11>    // start 2 peers and verify if they form the cluster\n<line12>    for (sid = 0; sid < 2; sid++) {\n<line13>        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line14>        peer.start();\n<line15>        peerList.add(sid, peer);\n<line16>    }\n<line17>    peer = peerList.get(0);\n<line18>    VerifyState v1 = new VerifyState(peerList.get(0));\n<line19>    v1.start();\n<line20>    v1.join(waitTime);\n<line21>    assertFalse(!v1.isSuccess(), \"Unable to form cluster in \" + waitTime + \" ms\");\n<line22>    // Change the election round for one of the members of the ensemble\n<line23>    long leaderSid = peer.getCurrentVote().getId();\n<line24>    long zxid = peer.getCurrentVote().getZxid();\n<line25>    long electionEpoch = peer.getCurrentVote().getElectionEpoch();\n<line26>    ServerState state = peer.getCurrentVote().getState();\n<line27>    long peerEpoch = peer.getCurrentVote().getPeerEpoch();\n<line28>    Vote newVote = new Vote(leaderSid, zxid + 100, electionEpoch + 100, peerEpoch, state);\n<line29>    peer.setCurrentVote(newVote);\n<line30>    // Start 3rd peer and check if it joins the quorum\n<line31>    peer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 2000, 2, 2, 2);\n<line32>    peer.start();\n<line33>    peerList.add(sid, peer);\n<line34>    v1 = new VerifyState(peer);\n<line35>    v1.start();\n<line36>    v1.join(waitTime);\n<line37>    if (v1.isAlive()) {\n<line38>        fail(\"Peer \" + peer.getMyId() + \" failed to join the cluster \" + \"within \" + waitTime + \" ms\");\n<line39>    }\n<line40>    // cleanup\n<line41>    for (int id = 0; id < 3; id++) {\n<line42>        peer = peerList.get(id);\n<line43>        if (peer != null) {\n<line44>            peer.shutdown();\n<line45>        }\n<line46>    }\n<line47>}","output":"<line1>{\n<line2>    int sid;\n<line3>    QuorumPeer peer;\n<line4>    int waitTime = 10 * 1000;\n<line5>    ArrayList<QuorumPeer> peerList = new ArrayList<>();\n<line6>    for (sid = 0; sid < 3; sid++) {\n<line7>        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line8>        tmpdir[sid] = ClientBase.createTmpDir();\n<line9>        port[sid] = PortAssignment.unique();\n<line10>    }\n<line11>    // start 2 peers and verify if they form the cluster\n<line12>    for (sid = 0; sid < 2; sid++) {\n<line13>        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line14>        LOG.info(\"Starting peer {}\", peer.getMyId());\n<line15>        peer.start();\n<line16>        peerList.add(sid, peer);\n<line17>    }\n<line18>    peer = peerList.get(0);\n<line19>    VerifyState v1 = new VerifyState(peerList.get(0));\n<line20>    v1.start();\n<line21>    v1.join(waitTime);\n<line22>    assertFalse(!v1.isSuccess(), \"Unable to form cluster in \" + waitTime + \" ms\");\n<line23>    // Change the election round for one of the members of the ensemble\n<line24>    long leaderSid = peer.getCurrentVote().getId();\n<line25>    long zxid = peer.getCurrentVote().getZxid();\n<line26>    long electionEpoch = peer.getCurrentVote().getElectionEpoch();\n<line27>    ServerState state = peer.getCurrentVote().getState();\n<line28>    long peerEpoch = peer.getCurrentVote().getPeerEpoch();\n<line29>    Vote newVote = new Vote(leaderSid, zxid + 100, electionEpoch + 100, peerEpoch, state);\n<line30>    peer.setCurrentVote(newVote);\n<line31>    // Start 3rd peer and check if it joins the quorum\n<line32>    peer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 2000, 2, 2, 2);\n<line33>    LOG.info(\"Starting peer {}\", peer.getMyId());\n<line34>    peer.start();\n<line35>    peerList.add(sid, peer);\n<line36>    v1 = new VerifyState(peer);\n<line37>    v1.start();\n<line38>    v1.join(waitTime);\n<line39>    if (v1.isAlive()) {\n<line40>        fail(\"Peer \" + peer.getMyId() + \" failed to join the cluster \" + \"within \" + waitTime + \" ms\");\n<line41>    }\n<line42>    // cleanup\n<line43>    for (int id = 0; id < 3; id++) {\n<line44>        peer = peerList.get(id);\n<line45>        if (peer != null) {\n<line46>            peer.shutdown();\n<line47>        }\n<line48>    }\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>    peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line3>    peer.start();\n<line4>    peerList.add(sid, peer);\n<line5>}","output":"<line1>{\n<line2>    peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);\n<line3>    LOG.info(\"Starting peer {}\", peer.getMyId());\n<line4>    peer.start();\n<line5>    peerList.add(sid, peer);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.close();\n<line3>    q1.shutdown();\n<line4>    q2.shutdown();\n<line5>    q3.shutdown();\n<line6>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 1 to shut down\");\n<line7>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 2 to shut down\");\n<line8>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 3 to shut down\");\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down all servers\");\n<line3>    zk.close();\n<line4>    q1.shutdown();\n<line5>    q2.shutdown();\n<line6>    q3.shutdown();\n<line7>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 1 to shut down\");\n<line8>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 2 to shut down\");\n<line9>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 3 to shut down\");\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    lastEvent = event;\n<line3>    if (latch != null) {\n<line4>        latch.countDown();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    lastEvent = event;\n<line3>    if (latch != null) {\n<line4>        latch.countDown();\n<line5>    }\n<line6>    LOG.info(\"Latch got event :: {}\", event);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    assertNull(zk.exists(\"/multi\", null));\n<line3>    try {\n<line4>        multi(zk, Arrays.asList(Op.create(\"/multi\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(\"/multi\", \"X\".getBytes(), 0), Op.setData(\"/multi\", \"Y\".getBytes(), 0)), useAsync);\n<line5>        fail(\"Should have thrown a KeeperException for invalid version\");\n<line6>    } catch (KeeperException e) {\n<line7>        //PASS\n<line8>    }\n<line9>    assertNull(zk.exists(\"/multi\", null));\n<line10>    //Updating version solves conflict -- order matters\n<line11>    multi(zk, Arrays.asList(Op.create(\"/multi\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(\"/multi\", \"X\".getBytes(), 0), Op.setData(\"/multi\", \"Y\".getBytes(), 1)), useAsync);\n<line12>    assertArrayEquals(zk.getData(\"/multi\", false, null), \"Y\".getBytes());\n<line13>}","output":"<line1>{\n<line2>    assertNull(zk.exists(\"/multi\", null));\n<line3>    try {\n<line4>        multi(zk, Arrays.asList(Op.create(\"/multi\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(\"/multi\", \"X\".getBytes(), 0), Op.setData(\"/multi\", \"Y\".getBytes(), 0)), useAsync);\n<line5>        fail(\"Should have thrown a KeeperException for invalid version\");\n<line6>    } catch (KeeperException e) {\n<line7>        //PASS\n<line8>        LOG.error(\"STACKTRACE: \", e);\n<line9>    }\n<line10>    assertNull(zk.exists(\"/multi\", null));\n<line11>    //Updating version solves conflict -- order matters\n<line12>    multi(zk, Arrays.asList(Op.create(\"/multi\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(\"/multi\", \"X\".getBytes(), 0), Op.setData(\"/multi\", \"Y\".getBytes(), 1)), useAsync);\n<line13>    assertArrayEquals(zk.getData(\"/multi\", false, null), \"Y\".getBytes());\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    //PASS\n<line3>}","output":"<line1>{\n<line2>    //PASS\n<line3>    LOG.error(\"STACKTRACE: \", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    /* Delete of a node folowed by an update of the (now) deleted node */\n<line3>    Iterable<Op> ops = Arrays.asList(Op.create(\"/multi\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete(\"/multi\", 0), Op.setData(\"/multi\", \"Y\".getBytes(), 0), Op.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));\n<line4>    List<OpResult> results = null;\n<line5>    if (useAsync) {\n<line6>        final MultiResult res = new MultiResult();\n<line7>        zk.multi(ops, new MultiCallback() {\n<line8>\n<line9>            @Override\n<line10>            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {\n<line11>                synchronized (res) {\n<line12>                    res.rc = rc;\n<line13>                    res.results = opResults;\n<line14>                    res.finished = true;\n<line15>                    res.notifyAll();\n<line16>                }\n<line17>            }\n<line18>        }, null);\n<line19>        synchronized (res) {\n<line20>            while (!res.finished) {\n<line21>                res.wait();\n<line22>            }\n<line23>        }\n<line24>        assertFalse(KeeperException.Code.OK.intValue() == res.rc, \"/multi should have been deleted so setData should have failed\");\n<line25>        assertNull(zk.exists(\"/multi\", null));\n<line26>        results = res.results;\n<line27>    } else {\n<line28>        try {\n<line29>            zk.multi(ops);\n<line30>            fail(\"/multi should have been deleted so setData should have failed\");\n<line31>        } catch (KeeperException e) {\n<line32>            // '/multi' should never have been created as entire op should fail\n<line33>            assertNull(zk.exists(\"/multi\", null));\n<line34>            results = e.getResults();\n<line35>        }\n<line36>    }\n<line37>    assertNotNull(results);\n<line38>    for (OpResult r : results) {\n<line39>        if (r instanceof ErrorResult) {\n<line40>            ErrorResult er = (ErrorResult) r;\n<line41>        }\n<line42>    }\n<line43>}","output":"<line1>{\n<line2>    /* Delete of a node folowed by an update of the (now) deleted node */\n<line3>    Iterable<Op> ops = Arrays.asList(Op.create(\"/multi\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete(\"/multi\", 0), Op.setData(\"/multi\", \"Y\".getBytes(), 0), Op.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));\n<line4>    List<OpResult> results = null;\n<line5>    if (useAsync) {\n<line6>        final MultiResult res = new MultiResult();\n<line7>        zk.multi(ops, new MultiCallback() {\n<line8>\n<line9>            @Override\n<line10>            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {\n<line11>                synchronized (res) {\n<line12>                    res.rc = rc;\n<line13>                    res.results = opResults;\n<line14>                    res.finished = true;\n<line15>                    res.notifyAll();\n<line16>                }\n<line17>            }\n<line18>        }, null);\n<line19>        synchronized (res) {\n<line20>            while (!res.finished) {\n<line21>                res.wait();\n<line22>            }\n<line23>        }\n<line24>        assertFalse(KeeperException.Code.OK.intValue() == res.rc, \"/multi should have been deleted so setData should have failed\");\n<line25>        assertNull(zk.exists(\"/multi\", null));\n<line26>        results = res.results;\n<line27>    } else {\n<line28>        try {\n<line29>            zk.multi(ops);\n<line30>            fail(\"/multi should have been deleted so setData should have failed\");\n<line31>        } catch (KeeperException e) {\n<line32>            // '/multi' should never have been created as entire op should fail\n<line33>            assertNull(zk.exists(\"/multi\", null));\n<line34>            results = e.getResults();\n<line35>        }\n<line36>    }\n<line37>    assertNotNull(results);\n<line38>    for (OpResult r : results) {\n<line39>        LOG.info(\"RESULT==> {}\", r);\n<line40>        if (r instanceof ErrorResult) {\n<line41>            ErrorResult er = (ErrorResult) r;\n<line42>            LOG.info(\"ERROR RESULT: {} ERR=>{}\", er, KeeperException.Code.get(er.getErr()));\n<line43>        }\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    if (r instanceof ErrorResult) {\n<line3>        ErrorResult er = (ErrorResult) r;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"RESULT==> {}\", r);\n<line3>    if (r instanceof ErrorResult) {\n<line4>        ErrorResult er = (ErrorResult) r;\n<line5>        LOG.info(\"ERROR RESULT: {} ERR=>{}\", er, KeeperException.Code.get(er.getErr()));\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ErrorResult er = (ErrorResult) r;\n<line3>}","output":"<line1>{\n<line2>    ErrorResult er = (ErrorResult) r;\n<line3>    LOG.info(\"ERROR RESULT: {} ERR=>{}\", er, KeeperException.Code.get(er.getErr()));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // We expect two notifications before we want to continue\n<line3>    latch = new CountDownLatch(2);\n<line4>    setUp(-1, testObserverMaster);\n<line5>    q3.start();\n<line6>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT), \"waiting for server 3 being up\");\n<line7>    validateObserverSyncTimeMetrics();\n<line8>    if (testObserverMaster) {\n<line9>        int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();\n<line10>        assertEquals(masterPort, OM_PORT, \"observer failed to connect to observer master\");\n<line11>    }\n<line12>    zk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);\n<line13>    zk.create(\"/obstest\", \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>    // Assert that commands are getting forwarded correctly\n<line15>    assertEquals(new String(zk.getData(\"/obstest\", null, null)), \"test\");\n<line16>    // Now check that other commands don't blow everything up\n<line17>    zk.sync(\"/\", null, null);\n<line18>    zk.setData(\"/obstest\", \"test2\".getBytes(), -1);\n<line19>    zk.getChildren(\"/\", false);\n<line20>    assertEquals(zk.getState(), States.CONNECTED);\n<line21>    // Now kill one of the other real servers\n<line22>    q2.shutdown();\n<line23>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 2 to shut down\");\n<line24>    // Now the resulting ensemble shouldn't be quorate\n<line25>    latch.await();\n<line26>    assertNotSame(KeeperState.SyncConnected, lastEvent.getState(), \"Client is still connected to non-quorate cluster\");\n<line27>    try {\n<line28>        assertNotEquals(\"Shouldn't get a response when cluster not quorate!\", \"test\", new String(zk.getData(\"/obstest\", null, null)));\n<line29>    } catch (ConnectionLossException c) {\n<line30>    }\n<line31>    latch = new CountDownLatch(1);\n<line32>    // Bring it back\n<line33>    //q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, extraCfgs);\n<line34>    q2.start();\n<line35>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT), \"waiting for server 2 being up\");\n<line36>    latch.await();\n<line37>    // It's possible our session expired - but this is ok, shows we\n<line38>    // were able to talk to the ensemble\n<line39>    assertTrue((KeeperState.SyncConnected == lastEvent.getState() || KeeperState.Expired == lastEvent.getState()), \"Client didn't reconnect to quorate ensemble (state was\" + lastEvent.getState() + \")\");\n<line40>    int leaderProxyPort = PortAssignment.unique();\n<line41>    int obsProxyPort = PortAssignment.unique();\n<line42>    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;\n<line43>    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);\n<line44>    latch = new CountDownLatch(1);\n<line45>    ZooKeeper client = new ZooKeeper(String.format(\"127.0.0.1:%d,127.0.0.1:%d\", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);\n<line46>    latch.await();\n<line47>    client.create(\"/revalidtest\", \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line48>    assertNotNull(client.exists(\"/revalidtest\", null), \"Read-after write failed\");\n<line49>    latch = new CountDownLatch(2);\n<line50>    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);\n<line51>    try {\n<line52>        leaderPF.shutdown();\n<line53>    } catch (Exception e) {\n<line54>        // ignore?\n<line55>    }\n<line56>    latch.await();\n<line57>    assertEquals(new String(client.getData(\"/revalidtest\", null, null)), \"test\");\n<line58>    client.close();\n<line59>    obsPF.shutdown();\n<line60>    shutdown();\n<line61>}","output":"<line1>{\n<line2>    // We expect two notifications before we want to continue\n<line3>    latch = new CountDownLatch(2);\n<line4>    setUp(-1, testObserverMaster);\n<line5>    q3.start();\n<line6>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT), \"waiting for server 3 being up\");\n<line7>    validateObserverSyncTimeMetrics();\n<line8>    if (testObserverMaster) {\n<line9>        int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();\n<line10>        LOG.info(\"port {} {}\", masterPort, OM_PORT);\n<line11>        assertEquals(masterPort, OM_PORT, \"observer failed to connect to observer master\");\n<line12>    }\n<line13>    zk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);\n<line14>    zk.create(\"/obstest\", \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>    // Assert that commands are getting forwarded correctly\n<line16>    assertEquals(new String(zk.getData(\"/obstest\", null, null)), \"test\");\n<line17>    // Now check that other commands don't blow everything up\n<line18>    zk.sync(\"/\", null, null);\n<line19>    zk.setData(\"/obstest\", \"test2\".getBytes(), -1);\n<line20>    zk.getChildren(\"/\", false);\n<line21>    assertEquals(zk.getState(), States.CONNECTED);\n<line22>    LOG.info(\"Shutting down server 2\");\n<line23>    // Now kill one of the other real servers\n<line24>    q2.shutdown();\n<line25>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server 2 to shut down\");\n<line26>    LOG.info(\"Server 2 down\");\n<line27>    // Now the resulting ensemble shouldn't be quorate\n<line28>    latch.await();\n<line29>    assertNotSame(KeeperState.SyncConnected, lastEvent.getState(), \"Client is still connected to non-quorate cluster\");\n<line30>    LOG.info(\"Latch returned\");\n<line31>    try {\n<line32>        assertNotEquals(\"Shouldn't get a response when cluster not quorate!\", \"test\", new String(zk.getData(\"/obstest\", null, null)));\n<line33>    } catch (ConnectionLossException c) {\n<line34>        LOG.info(\"Connection loss exception caught - ensemble not quorate (this is expected)\");\n<line35>    }\n<line36>    latch = new CountDownLatch(1);\n<line37>    LOG.info(\"Restarting server 2\");\n<line38>    // Bring it back\n<line39>    //q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, extraCfgs);\n<line40>    q2.start();\n<line41>    LOG.info(\"Waiting for server 2 to come up\");\n<line42>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT), \"waiting for server 2 being up\");\n<line43>    LOG.info(\"Server 2 started, waiting for latch\");\n<line44>    latch.await();\n<line45>    // It's possible our session expired - but this is ok, shows we\n<line46>    // were able to talk to the ensemble\n<line47>    assertTrue((KeeperState.SyncConnected == lastEvent.getState() || KeeperState.Expired == lastEvent.getState()), \"Client didn't reconnect to quorate ensemble (state was\" + lastEvent.getState() + \")\");\n<line48>    LOG.info(\"perform a revalidation test\");\n<line49>    int leaderProxyPort = PortAssignment.unique();\n<line50>    int obsProxyPort = PortAssignment.unique();\n<line51>    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;\n<line52>    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);\n<line53>    latch = new CountDownLatch(1);\n<line54>    ZooKeeper client = new ZooKeeper(String.format(\"127.0.0.1:%d,127.0.0.1:%d\", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);\n<line55>    latch.await();\n<line56>    client.create(\"/revalidtest\", \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line57>    assertNotNull(client.exists(\"/revalidtest\", null), \"Read-after write failed\");\n<line58>    latch = new CountDownLatch(2);\n<line59>    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);\n<line60>    try {\n<line61>        leaderPF.shutdown();\n<line62>    } catch (Exception e) {\n<line63>        // ignore?\n<line64>    }\n<line65>    latch.await();\n<line66>    assertEquals(new String(client.getData(\"/revalidtest\", null, null)), \"test\");\n<line67>    client.close();\n<line68>    obsPF.shutdown();\n<line69>    shutdown();\n<line70>}"},{"input":"","instruction":"<line1>{\n<line2>    int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();\n<line3>    assertEquals(masterPort, OM_PORT, \"observer failed to connect to observer master\");\n<line4>}","output":"<line1>{\n<line2>    int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();\n<line3>    LOG.info(\"port {} {}\", masterPort, OM_PORT);\n<line4>    assertEquals(masterPort, OM_PORT, \"observer failed to connect to observer master\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Connection loss exception caught - ensemble not quorate (this is expected)\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    setUp(-1, testObserverMaster);\n<line3>    zk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, null);\n<line4>    for (int i = 0; i < 10; i++) {\n<line5>        zk.create(\"/bulk\" + i, (\"Initial data of some size\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    }\n<line7>    zk.close();\n<line8>    q3.start();\n<line9>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT), \"waiting for observer to be up\");\n<line10>    latch = new CountDownLatch(1);\n<line11>    zk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);\n<line12>    latch.await();\n<line13>    assertEquals(zk.getState(), States.CONNECTED);\n<line14>    zk.create(\"/init\", \"first\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>    final long zxid = q1.getQuorumPeer().getLastLoggedZxid();\n<line16>    // wait for change to propagate\n<line17>    waitFor(\"Timeout waiting for observer sync\", new WaitForCondition() {\n<line18>\n<line19>        public boolean evaluate() {\n<line20>            return zxid == q3.getQuorumPeer().getLastLoggedZxid();\n<line21>        }\n<line22>    }, 30);\n<line23>    ZooKeeper obsZk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);\n<line24>    int followerPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP1 : CLIENT_PORT_QP2;\n<line25>    ZooKeeper fZk = new ZooKeeper(\"127.0.0.1:\" + followerPort, ClientBase.CONNECTION_TIMEOUT, this);\n<line26>    final int numTransactions = 10001;\n<line27>    CountDownLatch gate = new CountDownLatch(1);\n<line28>    CountDownLatch oAsyncLatch = new CountDownLatch(numTransactions);\n<line29>    Thread oAsyncWriteThread = new Thread(new AsyncWriter(obsZk, numTransactions, true, oAsyncLatch, \"/obs\", gate));\n<line30>    CountDownLatch fAsyncLatch = new CountDownLatch(numTransactions);\n<line31>    Thread fAsyncWriteThread = new Thread(new AsyncWriter(fZk, numTransactions, true, fAsyncLatch, \"/follower\", gate));\n<line32>    oAsyncWriteThread.start();\n<line33>    fAsyncWriteThread.start();\n<line34>    gate.countDown();\n<line35>    oAsyncLatch.await();\n<line36>    fAsyncLatch.await();\n<line37>    oAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line38>    if (oAsyncWriteThread.isAlive()) {\n<line39>    }\n<line40>    fAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line41>    if (fAsyncWriteThread.isAlive()) {\n<line42>    }\n<line43>    obsZk.close();\n<line44>    fZk.close();\n<line45>    shutdown();\n<line46>}","output":"<line1>{\n<line2>    setUp(-1, testObserverMaster);\n<line3>    zk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, null);\n<line4>    for (int i = 0; i < 10; i++) {\n<line5>        zk.create(\"/bulk\" + i, (\"Initial data of some size\").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    }\n<line7>    zk.close();\n<line8>    q3.start();\n<line9>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT), \"waiting for observer to be up\");\n<line10>    latch = new CountDownLatch(1);\n<line11>    zk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);\n<line12>    latch.await();\n<line13>    assertEquals(zk.getState(), States.CONNECTED);\n<line14>    zk.create(\"/init\", \"first\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>    final long zxid = q1.getQuorumPeer().getLastLoggedZxid();\n<line16>    // wait for change to propagate\n<line17>    waitFor(\"Timeout waiting for observer sync\", new WaitForCondition() {\n<line18>\n<line19>        public boolean evaluate() {\n<line20>            return zxid == q3.getQuorumPeer().getLastLoggedZxid();\n<line21>        }\n<line22>    }, 30);\n<line23>    ZooKeeper obsZk = new ZooKeeper(\"127.0.0.1:\" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);\n<line24>    int followerPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP1 : CLIENT_PORT_QP2;\n<line25>    ZooKeeper fZk = new ZooKeeper(\"127.0.0.1:\" + followerPort, ClientBase.CONNECTION_TIMEOUT, this);\n<line26>    final int numTransactions = 10001;\n<line27>    CountDownLatch gate = new CountDownLatch(1);\n<line28>    CountDownLatch oAsyncLatch = new CountDownLatch(numTransactions);\n<line29>    Thread oAsyncWriteThread = new Thread(new AsyncWriter(obsZk, numTransactions, true, oAsyncLatch, \"/obs\", gate));\n<line30>    CountDownLatch fAsyncLatch = new CountDownLatch(numTransactions);\n<line31>    Thread fAsyncWriteThread = new Thread(new AsyncWriter(fZk, numTransactions, true, fAsyncLatch, \"/follower\", gate));\n<line32>    LOG.info(\"ASYNC WRITES\");\n<line33>    oAsyncWriteThread.start();\n<line34>    fAsyncWriteThread.start();\n<line35>    gate.countDown();\n<line36>    oAsyncLatch.await();\n<line37>    fAsyncLatch.await();\n<line38>    oAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line39>    if (oAsyncWriteThread.isAlive()) {\n<line40>        LOG.error(\"asyncWriteThread is still alive\");\n<line41>    }\n<line42>    fAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line43>    if (fAsyncWriteThread.isAlive()) {\n<line44>        LOG.error(\"asyncWriteThread is still alive\");\n<line45>    }\n<line46>    obsZk.close();\n<line47>    fZk.close();\n<line48>    shutdown();\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"asyncWriteThread is still alive\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"asyncWriteThread is still alive\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!testObserverMaster) {\n<line3>        return;\n<line4>    }\n<line5>    ClientBase.setupTestEnv();\n<line6>    // create a quorum running with different observer master port\n<line7>    // to make it easier to choose which server the observer is\n<line8>    // following with\n<line9>    //\n<line10>    // we have setObserverMaster function but it's broken, use this\n<line11>    // solution before we fixed that\n<line12>    int clientPort1 = PortAssignment.unique();\n<line13>    int clientPort2 = PortAssignment.unique();\n<line14>    int omPort1 = PortAssignment.unique();\n<line15>    int omPort2 = PortAssignment.unique();\n<line16>    String quorumCfgSection = createServerString(\"participant\", 1, clientPort1) + \"\\n\" + createServerString(\"participant\", 2, clientPort2);\n<line17>    MainThread s1 = new MainThread(1, clientPort1, quorumCfgSection, String.format(\"observerMasterPort=%d%n\", omPort1));\n<line18>    MainThread s2 = new MainThread(2, clientPort2, quorumCfgSection, String.format(\"observerMasterPort=%d%n\", omPort2));\n<line19>    s1.start();\n<line20>    s2.start();\n<line21>    waitServerUp(clientPort1);\n<line22>    waitServerUp(clientPort2);\n<line23>    // create observer to follow non-leader observer master\n<line24>    long nonLeaderOMPort = s1.getQuorumPeer().leader == null ? omPort1 : omPort2;\n<line25>    int observerClientPort = PortAssignment.unique();\n<line26>    int observerId = 10;\n<line27>    MainThread observer = new MainThread(observerId, observerClientPort, quorumCfgSection + \"\\n\" + createServerString(\"observer\", observerId, observerClientPort), String.format(\"observerMasterPort=%d%n\", nonLeaderOMPort));\n<line28>    observer.start();\n<line29>    waitServerUp(observerClientPort);\n<line30>    // create a client to the observer\n<line31>    final LinkedBlockingQueue<KeeperState> states = new LinkedBlockingQueue<>();\n<line32>    ZooKeeper observerClient = new ZooKeeper(\"127.0.0.1:\" + observerClientPort, ClientBase.CONNECTION_TIMEOUT, event -> {\n<line33>        try {\n<line34>            states.put(event.getState());\n<line35>        } catch (InterruptedException ignore) {\n<line36>        }\n<line37>    });\n<line38>    // wait for connected\n<line39>    KeeperState state = states.poll(1000, TimeUnit.MILLISECONDS);\n<line40>    assertEquals(KeeperState.SyncConnected, state);\n<line41>    // issue reconfig command\n<line42>    ArrayList<String> newServers = new ArrayList<>();\n<line43>    String server = \"server.3=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;localhost:\" + PortAssignment.unique();\n<line44>    newServers.add(server);\n<line45>    ZooKeeperAdmin admin = createAdmin(clientPort1);\n<line46>    ReconfigTest.reconfig(admin, newServers, null, null, -1);\n<line47>    // make sure the observer has the new config\n<line48>    ReconfigTest.testServerHasConfig(observerClient, newServers, null);\n<line49>    // shouldn't be disconnected during reconfig, so expect to not\n<line50>    // receive any new event\n<line51>    state = states.poll(1000, TimeUnit.MILLISECONDS);\n<line52>    assertNull(state);\n<line53>    admin.close();\n<line54>    observerClient.close();\n<line55>    observer.shutdown();\n<line56>    s2.shutdown();\n<line57>    s1.shutdown();\n<line58>}","output":"<line1>{\n<line2>    if (!testObserverMaster) {\n<line3>        return;\n<line4>    }\n<line5>    ClientBase.setupTestEnv();\n<line6>    // create a quorum running with different observer master port\n<line7>    // to make it easier to choose which server the observer is\n<line8>    // following with\n<line9>    //\n<line10>    // we have setObserverMaster function but it's broken, use this\n<line11>    // solution before we fixed that\n<line12>    int clientPort1 = PortAssignment.unique();\n<line13>    int clientPort2 = PortAssignment.unique();\n<line14>    int omPort1 = PortAssignment.unique();\n<line15>    int omPort2 = PortAssignment.unique();\n<line16>    String quorumCfgSection = createServerString(\"participant\", 1, clientPort1) + \"\\n\" + createServerString(\"participant\", 2, clientPort2);\n<line17>    MainThread s1 = new MainThread(1, clientPort1, quorumCfgSection, String.format(\"observerMasterPort=%d%n\", omPort1));\n<line18>    MainThread s2 = new MainThread(2, clientPort2, quorumCfgSection, String.format(\"observerMasterPort=%d%n\", omPort2));\n<line19>    s1.start();\n<line20>    s2.start();\n<line21>    waitServerUp(clientPort1);\n<line22>    waitServerUp(clientPort2);\n<line23>    // create observer to follow non-leader observer master\n<line24>    long nonLeaderOMPort = s1.getQuorumPeer().leader == null ? omPort1 : omPort2;\n<line25>    int observerClientPort = PortAssignment.unique();\n<line26>    int observerId = 10;\n<line27>    MainThread observer = new MainThread(observerId, observerClientPort, quorumCfgSection + \"\\n\" + createServerString(\"observer\", observerId, observerClientPort), String.format(\"observerMasterPort=%d%n\", nonLeaderOMPort));\n<line28>    LOG.info(\"starting observer\");\n<line29>    observer.start();\n<line30>    waitServerUp(observerClientPort);\n<line31>    // create a client to the observer\n<line32>    final LinkedBlockingQueue<KeeperState> states = new LinkedBlockingQueue<>();\n<line33>    ZooKeeper observerClient = new ZooKeeper(\"127.0.0.1:\" + observerClientPort, ClientBase.CONNECTION_TIMEOUT, event -> {\n<line34>        try {\n<line35>            states.put(event.getState());\n<line36>        } catch (InterruptedException ignore) {\n<line37>        }\n<line38>    });\n<line39>    // wait for connected\n<line40>    KeeperState state = states.poll(1000, TimeUnit.MILLISECONDS);\n<line41>    assertEquals(KeeperState.SyncConnected, state);\n<line42>    // issue reconfig command\n<line43>    ArrayList<String> newServers = new ArrayList<>();\n<line44>    String server = \"server.3=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;localhost:\" + PortAssignment.unique();\n<line45>    newServers.add(server);\n<line46>    ZooKeeperAdmin admin = createAdmin(clientPort1);\n<line47>    ReconfigTest.reconfig(admin, newServers, null, null, -1);\n<line48>    // make sure the observer has the new config\n<line49>    ReconfigTest.testServerHasConfig(observerClient, newServers, null);\n<line50>    // shouldn't be disconnected during reconfig, so expect to not\n<line51>    // receive any new event\n<line52>    state = states.poll(1000, TimeUnit.MILLISECONDS);\n<line53>    assertNull(state);\n<line54>    admin.close();\n<line55>    observerClient.close();\n<line56>    observer.shutdown();\n<line57>    s2.shutdown();\n<line58>    s1.shutdown();\n<line59>}"},{"input":"","instruction":"<line1>{\n<line2>    if (gate != null) {\n<line3>        try {\n<line4>            gate.await();\n<line5>        } catch (InterruptedException e) {\n<line6>            return;\n<line7>        }\n<line8>    }\n<line9>    for (int i = 0; i < numTransactions; i++) {\n<line10>        final boolean pleaseLog = i % 100 == 0;\n<line11>        client.create(root + i, \"inner thread\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {\n<line12>            writerLatch.countDown();\n<line13>            if (pleaseLog) {\n<line14>            }\n<line15>        }, null);\n<line16>        if (pleaseLog) {\n<line17>            if (issueSync) {\n<line18>                client.sync(root + \"0\", null, null);\n<line19>            }\n<line20>        }\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    if (gate != null) {\n<line3>        try {\n<line4>            gate.await();\n<line5>        } catch (InterruptedException e) {\n<line6>            LOG.error(\"Gate interrupted\");\n<line7>            return;\n<line8>        }\n<line9>    }\n<line10>    for (int i = 0; i < numTransactions; i++) {\n<line11>        final boolean pleaseLog = i % 100 == 0;\n<line12>        client.create(root + i, \"inner thread\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {\n<line13>            writerLatch.countDown();\n<line14>            if (pleaseLog) {\n<line15>                LOG.info(\"wrote {}\", path);\n<line16>            }\n<line17>        }, null);\n<line18>        if (pleaseLog) {\n<line19>            LOG.info(\"async wrote {}{}\", root, i);\n<line20>            if (issueSync) {\n<line21>                client.sync(root + \"0\", null, null);\n<line22>            }\n<line23>        }\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        gate.await();\n<line4>    } catch (InterruptedException e) {\n<line5>        return;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        gate.await();\n<line4>    } catch (InterruptedException e) {\n<line5>        LOG.error(\"Gate interrupted\");\n<line6>        return;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Gate interrupted\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final boolean pleaseLog = i % 100 == 0;\n<line3>    client.create(root + i, \"inner thread\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {\n<line4>        writerLatch.countDown();\n<line5>        if (pleaseLog) {\n<line6>        }\n<line7>    }, null);\n<line8>    if (pleaseLog) {\n<line9>        if (issueSync) {\n<line10>            client.sync(root + \"0\", null, null);\n<line11>        }\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    final boolean pleaseLog = i % 100 == 0;\n<line3>    client.create(root + i, \"inner thread\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {\n<line4>        writerLatch.countDown();\n<line5>        if (pleaseLog) {\n<line6>            LOG.info(\"wrote {}\", path);\n<line7>        }\n<line8>    }, null);\n<line9>    if (pleaseLog) {\n<line10>        LOG.info(\"async wrote {}{}\", root, i);\n<line11>        if (issueSync) {\n<line12>            client.sync(root + \"0\", null, null);\n<line13>        }\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    writerLatch.countDown();\n<line3>    if (pleaseLog) {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    writerLatch.countDown();\n<line3>    if (pleaseLog) {\n<line4>        LOG.info(\"wrote {}\", path);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"wrote {}\", path);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (issueSync) {\n<line3>        client.sync(root + \"0\", null, null);\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"async wrote {}{}\", root, i);\n<line3>    if (issueSync) {\n<line4>        client.sync(root + \"0\", null, null);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    for (HostPort hpobj : parseHostPortList(hp)) {\n<line3>        String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);\n<line4>        if (cmd.equals(\"dump\")) {\n<line5>            assertTrue(resp.contains(expected) || resp.contains(\"Sessions with Ephemerals\"));\n<line6>        } else {\n<line7>            assertTrue(resp.contains(expected));\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    for (HostPort hpobj : parseHostPortList(hp)) {\n<line3>        String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);\n<line4>        LOG.info(\"cmd {} expected {} got {}\", cmd, expected, resp);\n<line5>        if (cmd.equals(\"dump\")) {\n<line6>            assertTrue(resp.contains(expected) || resp.contains(\"Sessions with Ephemerals\"));\n<line7>        } else {\n<line8>            assertTrue(resp.contains(expected));\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);\n<line3>    if (cmd.equals(\"dump\")) {\n<line4>        assertTrue(resp.contains(expected) || resp.contains(\"Sessions with Ephemerals\"));\n<line5>    } else {\n<line6>        assertTrue(resp.contains(expected));\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);\n<line3>    LOG.info(\"cmd {} expected {} got {}\", cmd, expected, resp);\n<line4>    if (cmd.equals(\"dump\")) {\n<line5>        assertTrue(resp.contains(expected) || resp.contains(\"Sessions with Ephemerals\"));\n<line6>    } else {\n<line7>        assertTrue(resp.contains(expected));\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    OSMXBean osMbean = new OSMXBean();\n<line3>    if (!osMbean.getUnix()) {\n<line4>        return;\n<line5>    }\n<line6>    long startFdCount = osMbean.getOpenFileDescriptorCount();\n<line7>    for (int i = 0; i < 50; ++i) {\n<line8>        NIOServerCnxnFactory factory = new NIOServerCnxnFactory();\n<line9>        factory.configure(new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), 10);\n<line10>        factory.start();\n<line11>        Thread.sleep(100);\n<line12>        factory.shutdown();\n<line13>    }\n<line14>    long endFdCount = osMbean.getOpenFileDescriptorCount();\n<line15>    // On my box, if selector.close() is not called fd diff is > 700.\n<line16>    assertTrue(((endFdCount - startFdCount) < 50), \"Possible fd leakage\");\n<line17>}","output":"<line1>{\n<line2>    OSMXBean osMbean = new OSMXBean();\n<line3>    if (!osMbean.getUnix()) {\n<line4>        LOG.info(\"Unable to run test on non-unix system\");\n<line5>        return;\n<line6>    }\n<line7>    long startFdCount = osMbean.getOpenFileDescriptorCount();\n<line8>    LOG.info(\"Start fdcount is: {}\", startFdCount);\n<line9>    for (int i = 0; i < 50; ++i) {\n<line10>        NIOServerCnxnFactory factory = new NIOServerCnxnFactory();\n<line11>        factory.configure(new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), 10);\n<line12>        factory.start();\n<line13>        Thread.sleep(100);\n<line14>        factory.shutdown();\n<line15>    }\n<line16>    long endFdCount = osMbean.getOpenFileDescriptorCount();\n<line17>    LOG.info(\"End fdcount is: {}\", endFdCount);\n<line18>    // On my box, if selector.close() is not called fd diff is > 700.\n<line19>    assertTrue(((endFdCount - startFdCount) < 50), \"Possible fd leakage\");\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Unable to run test on non-unix system\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (rc == KeeperException.Code.OK.intValue()) {\n<line3>        String string = new String(data);\n<line4>        String lastString = null;\n<line5>        byte[] v = lastValue.get(path);\n<line6>        if (v != null) {\n<line7>            lastString = new String(v);\n<line8>        }\n<line9>        if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {\n<line10>            errorCount++;\n<line11>        }\n<line12>        lastValue.put(path, (byte[]) ctx);\n<line13>    }\n<line14>    decOutstanding();\n<line15>}","output":"<line1>{\n<line2>    if (rc == KeeperException.Code.OK.intValue()) {\n<line3>        String string = new String(data);\n<line4>        String lastString = null;\n<line5>        byte[] v = lastValue.get(path);\n<line6>        if (v != null) {\n<line7>            lastString = new String(v);\n<line8>        }\n<line9>        if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {\n<line10>            LOG.error(\"ERROR: Got {} expected >= {}\", string, lastString);\n<line11>            errorCount++;\n<line12>        }\n<line13>        lastValue.put(path, (byte[]) ctx);\n<line14>    }\n<line15>    decOutstanding();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    String string = new String(data);\n<line3>    String lastString = null;\n<line4>    byte[] v = lastValue.get(path);\n<line5>    if (v != null) {\n<line6>        lastString = new String(v);\n<line7>    }\n<line8>    if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {\n<line9>        errorCount++;\n<line10>    }\n<line11>    lastValue.put(path, (byte[]) ctx);\n<line12>}","output":"<line1>{\n<line2>    String string = new String(data);\n<line3>    String lastString = null;\n<line4>    byte[] v = lastValue.get(path);\n<line5>    if (v != null) {\n<line6>        lastString = new String(v);\n<line7>    }\n<line8>    if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {\n<line9>        LOG.error(\"ERROR: Got {} expected >= {}\", string, lastString);\n<line10>        errorCount++;\n<line11>    }\n<line12>    lastValue.put(path, (byte[]) ctx);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    errorCount++;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"ERROR: Got {} expected >= {}\", string, lastString);\n<line3>    errorCount++;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    File origSnapDir = new File(testData, \"invalidsnap\");\n<line3>    // This test otherwise updates the resources directory.\n<line4>    File snapDir = ClientBase.createTmpDir();\n<line5>    FileUtils.copyDirectory(origSnapDir, snapDir);\n<line6>    ZooKeeperServer zks = new ZooKeeperServer(snapDir, snapDir, 3000);\n<line7>    SyncRequestProcessor.setSnapCount(1000);\n<line8>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line9>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line10>    f.startup(zks);\n<line11>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line12>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line13>    try {\n<line14>        // we know this from the data files\n<line15>        // this node is the last node in the snapshot\n<line16>        assertTrue(zk.exists(\"/9/9/8\", false) != null);\n<line17>    } finally {\n<line18>        zk.close();\n<line19>    }\n<line20>    f.shutdown();\n<line21>    zks.shutdown();\n<line22>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line23>}","output":"<line1>{\n<line2>    File origSnapDir = new File(testData, \"invalidsnap\");\n<line3>    // This test otherwise updates the resources directory.\n<line4>    File snapDir = ClientBase.createTmpDir();\n<line5>    FileUtils.copyDirectory(origSnapDir, snapDir);\n<line6>    ZooKeeperServer zks = new ZooKeeperServer(snapDir, snapDir, 3000);\n<line7>    SyncRequestProcessor.setSnapCount(1000);\n<line8>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line9>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line10>    f.startup(zks);\n<line11>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line12>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line13>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line14>    try {\n<line15>        // we know this from the data files\n<line16>        // this node is the last node in the snapshot\n<line17>        assertTrue(zk.exists(\"/9/9/8\", false) != null);\n<line18>    } finally {\n<line19>        zk.close();\n<line20>    }\n<line21>    f.shutdown();\n<line22>    zks.shutdown();\n<line23>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>    // don't call setup - we don't want to reassign ports/dirs, etc...\n<line4>    JMXEnv.setUp();\n<line5>    qb.startServers();\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"RESTARTING {}\", getTestName());\n<line3>    qb.tearDown();\n<line4>    // don't call setup - we don't want to reassign ports/dirs, etc...\n<line5>    JMXEnv.setUp();\n<line6>    qb.startServers();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Test clients shutting down\");\n<line3>    qb.tearDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        CountdownWatcher watcher = new CountdownWatcher();\n<line4>        zk = new TestableZooKeeper(qb.hostPort, CONNECTION_TIMEOUT, watcher);\n<line5>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line6>        while (bang) {\n<line7>            // before create otw race\n<line8>            incOutstanding();\n<line9>            zk.create(\"/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, this, null);\n<line10>        }\n<line11>    } catch (InterruptedException e) {\n<line12>        if (bang) {\n<line13>            // sanity check\n<line14>            return;\n<line15>        }\n<line16>    } catch (Exception e) {\n<line17>        return;\n<line18>    } finally {\n<line19>        if (zk != null) {\n<line20>            try {\n<line21>                if (!zk.close(CONNECTION_TIMEOUT)) {\n<line22>                    failed = true;\n<line23>                }\n<line24>            } catch (InterruptedException e) {\n<line25>            }\n<line26>        }\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    try {\n<line3>        CountdownWatcher watcher = new CountdownWatcher();\n<line4>        zk = new TestableZooKeeper(qb.hostPort, CONNECTION_TIMEOUT, watcher);\n<line5>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line6>        while (bang) {\n<line7>            // before create otw race\n<line8>            incOutstanding();\n<line9>            zk.create(\"/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, this, null);\n<line10>        }\n<line11>    } catch (InterruptedException e) {\n<line12>        if (bang) {\n<line13>            // sanity check\n<line14>            LOG.error(\"sanity check failed!!!\");\n<line15>            return;\n<line16>        }\n<line17>    } catch (Exception e) {\n<line18>        LOG.error(\"Client create operation failed\", e);\n<line19>        return;\n<line20>    } finally {\n<line21>        if (zk != null) {\n<line22>            try {\n<line23>                if (!zk.close(CONNECTION_TIMEOUT)) {\n<line24>                    failed = true;\n<line25>                    LOG.error(\"Client did not shutdown\");\n<line26>                }\n<line27>            } catch (InterruptedException e) {\n<line28>                LOG.info(\"Interrupted\", e);\n<line29>            }\n<line30>        }\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bang) {\n<line3>        // sanity check\n<line4>        return;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (bang) {\n<line3>        // sanity check\n<line4>        LOG.error(\"sanity check failed!!!\");\n<line5>        return;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    // sanity check\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    // sanity check\n<line3>    LOG.error(\"sanity check failed!!!\");\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Client create operation failed\", e);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (zk != null) {\n<line3>        try {\n<line4>            if (!zk.close(CONNECTION_TIMEOUT)) {\n<line5>                failed = true;\n<line6>            }\n<line7>        } catch (InterruptedException e) {\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (zk != null) {\n<line3>        try {\n<line4>            if (!zk.close(CONNECTION_TIMEOUT)) {\n<line5>                failed = true;\n<line6>                LOG.error(\"Client did not shutdown\");\n<line7>            }\n<line8>        } catch (InterruptedException e) {\n<line9>            LOG.info(\"Interrupted\", e);\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!zk.close(CONNECTION_TIMEOUT)) {\n<line4>            failed = true;\n<line5>        }\n<line6>    } catch (InterruptedException e) {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        if (!zk.close(CONNECTION_TIMEOUT)) {\n<line4>            failed = true;\n<line5>            LOG.error(\"Client did not shutdown\");\n<line6>        }\n<line7>    } catch (InterruptedException e) {\n<line8>        LOG.info(\"Interrupted\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!zk.close(CONNECTION_TIMEOUT)) {\n<line3>        failed = true;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (!zk.close(CONNECTION_TIMEOUT)) {\n<line3>        failed = true;\n<line4>        LOG.error(\"Client did not shutdown\");\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    failed = true;\n<line3>}","output":"<line1>{\n<line2>    failed = true;\n<line3>    LOG.error(\"Client did not shutdown\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Interrupted\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (rc != KeeperException.Code.OK.intValue()) {\n<line3>        if (bang) {\n<line4>            failed = true;\n<line5>        }\n<line6>        decOutstanding();\n<line7>        return;\n<line8>    }\n<line9>    try {\n<line10>        decOutstanding();\n<line11>        zk.delete(name, -1, this, null);\n<line12>    } catch (Exception e) {\n<line13>        if (bang) {\n<line14>            failed = true;\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    if (rc != KeeperException.Code.OK.intValue()) {\n<line3>        if (bang) {\n<line4>            failed = true;\n<line5>            LOG.error(\"Create failed for 0x{} with rc:{} path:{}\", Long.toHexString(zk.getSessionId()), rc, path);\n<line6>        }\n<line7>        decOutstanding();\n<line8>        return;\n<line9>    }\n<line10>    try {\n<line11>        decOutstanding();\n<line12>        zk.delete(name, -1, this, null);\n<line13>    } catch (Exception e) {\n<line14>        if (bang) {\n<line15>            failed = true;\n<line16>            LOG.error(\"Client delete failed\", e);\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bang) {\n<line3>        failed = true;\n<line4>    }\n<line5>    decOutstanding();\n<line6>    return;\n<line7>}","output":"<line1>{\n<line2>    if (bang) {\n<line3>        failed = true;\n<line4>        LOG.error(\"Create failed for 0x{} with rc:{} path:{}\", Long.toHexString(zk.getSessionId()), rc, path);\n<line5>    }\n<line6>    decOutstanding();\n<line7>    return;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    failed = true;\n<line3>}","output":"<line1>{\n<line2>    failed = true;\n<line3>    LOG.error(\"Create failed for 0x{} with rc:{} path:{}\", Long.toHexString(zk.getSessionId()), rc, path);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bang) {\n<line3>        failed = true;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (bang) {\n<line3>        failed = true;\n<line4>        LOG.error(\"Client delete failed\", e);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    failed = true;\n<line3>}","output":"<line1>{\n<line2>    failed = true;\n<line3>    LOG.error(\"Client delete failed\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (rc != KeeperException.Code.OK.intValue()) {\n<line3>        if (bang) {\n<line4>            failed = true;\n<line5>        }\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (rc != KeeperException.Code.OK.intValue()) {\n<line3>        if (bang) {\n<line4>            failed = true;\n<line5>            LOG.error(\"Delete failed for 0x{} with rc:{} path:{}\", Long.toHexString(zk.getSessionId()), rc, path);\n<line6>        }\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bang) {\n<line3>        failed = true;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (bang) {\n<line3>        failed = true;\n<line4>        LOG.error(\"Delete failed for 0x{} with rc:{} path:{}\", Long.toHexString(zk.getSessionId()), rc, path);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    failed = true;\n<line3>}","output":"<line1>{\n<line2>    failed = true;\n<line3>    LOG.error(\"Delete failed for 0x{} with rc:{} path:{}\", Long.toHexString(zk.getSessionId()), rc, path);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    setUp(false);\n<line3>    bang = true;\n<line4>    HammerThread[] hammers = new HammerThread[100];\n<line5>    for (int i = 0; i < hammers.length; i++) {\n<line6>        hammers[i] = new HammerThread(\"HammerThread-\" + i);\n<line7>        hammers[i].start();\n<line8>    }\n<line9>    // allow the clients to run for max 5sec\n<line10>    Thread.sleep(5000);\n<line11>    bang = false;\n<line12>    for (int i = 0; i < hammers.length; i++) {\n<line13>        hammers[i].interrupt();\n<line14>        verifyThreadTerminated(hammers[i], 60000);\n<line15>        assertFalse(hammers[i].failed);\n<line16>    }\n<line17>    // before restart\n<line18>    qb.verifyRootOfAllServersMatch(qb.hostPort);\n<line19>    restart();\n<line20>    // after restart\n<line21>    qb.verifyRootOfAllServersMatch(qb.hostPort);\n<line22>    tearDown();\n<line23>}","output":"<line1>{\n<line2>    setUp(false);\n<line3>    bang = true;\n<line4>    LOG.info(\"Starting hammers\");\n<line5>    HammerThread[] hammers = new HammerThread[100];\n<line6>    for (int i = 0; i < hammers.length; i++) {\n<line7>        hammers[i] = new HammerThread(\"HammerThread-\" + i);\n<line8>        hammers[i].start();\n<line9>    }\n<line10>    LOG.info(\"Started hammers\");\n<line11>    // allow the clients to run for max 5sec\n<line12>    Thread.sleep(5000);\n<line13>    bang = false;\n<line14>    LOG.info(\"Stopping hammers\");\n<line15>    for (int i = 0; i < hammers.length; i++) {\n<line16>        hammers[i].interrupt();\n<line17>        verifyThreadTerminated(hammers[i], 60000);\n<line18>        assertFalse(hammers[i].failed);\n<line19>    }\n<line20>    // before restart\n<line21>    LOG.info(\"Hammers stopped, verifying consistency\");\n<line22>    qb.verifyRootOfAllServersMatch(qb.hostPort);\n<line23>    restart();\n<line24>    // after restart\n<line25>    LOG.info(\"Verifying hammers 2\");\n<line26>    qb.verifyRootOfAllServersMatch(qb.hostPort);\n<line27>    tearDown();\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Test clients shutting down\");\n<line3>    qb.tearDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // must be greater than 3\n<line3>    final int N = 5;\n<line4>    final int COUNT = 100;\n<line5>    RequestThrottleMock.throttleEveryNthOp(N);\n<line6>    int opCount = 0;\n<line7>    for (int i = 0; i < COUNT; i++) {\n<line8>        String nodeName = \"/ivailo\" + i;\n<line9>        if (opCount % N == N - 1) {\n<line10>            try {\n<line11>                zk.create(nodeName, \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);\n<line12>                fail(\"Should have gotten ThrottledOp exception\");\n<line13>            } catch (KeeperException.ThrottledOpException e) {\n<line14>                // anticipated outcome\n<line15>                Stat stat = zk.exists(nodeName, null);\n<line16>                assertNull(stat);\n<line17>                zk.create(nodeName, \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);\n<line18>            } catch (KeeperException e) {\n<line19>                fail(\"Should have gotten ThrottledOp exception\");\n<line20>            }\n<line21>            // three ops issued\n<line22>            opCount += 3;\n<line23>        } else {\n<line24>            zk.create(nodeName, \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);\n<line25>            // one op issued\n<line26>            opCount++;\n<line27>        }\n<line28>        if (opCount % N == N - 1) {\n<line29>            try {\n<line30>                zk.setData(nodeName, nodeName.getBytes(), -1);\n<line31>                fail(\"Should have gotten ThrottledOp exception\");\n<line32>            } catch (KeeperException.ThrottledOpException e) {\n<line33>                // anticipated outcome & retry\n<line34>                zk.setData(nodeName, nodeName.getBytes(), -1);\n<line35>            } catch (KeeperException e) {\n<line36>                fail(\"Should have gotten ThrottledOp exception\");\n<line37>            }\n<line38>            // two ops issued, one for retry\n<line39>            opCount += 2;\n<line40>        } else {\n<line41>            zk.setData(nodeName, nodeName.getBytes(), -1);\n<line42>            // one op issued\n<line43>            opCount++;\n<line44>        }\n<line45>    }\n<line46>    for (int i = 0; i < COUNT; i++) {\n<line47>        String nodeName = \"/ivailo\" + i;\n<line48>        if (opCount % N == N - 1) {\n<line49>            try {\n<line50>                zk.exists(nodeName, null);\n<line51>                fail(\"Should have gotten ThrottledOp exception\");\n<line52>            } catch (KeeperException.ThrottledOpException e) {\n<line53>                // anticipated outcome & retry\n<line54>                Stat stat = zk.exists(nodeName, null);\n<line55>                assertNotNull(stat);\n<line56>                // two ops issued, one is retry\n<line57>                opCount += 2;\n<line58>            } catch (KeeperException e) {\n<line59>                fail(\"Should have gotten ThrottledOp exception\");\n<line60>            }\n<line61>        } else {\n<line62>            Stat stat = zk.exists(nodeName, null);\n<line63>            assertNotNull(stat);\n<line64>            opCount++;\n<line65>        }\n<line66>        if (opCount % N == N - 1) {\n<line67>            try {\n<line68>                zk.getData(nodeName, null, null);\n<line69>                fail(\"Should have gotten ThrottledOp exception\");\n<line70>            } catch (KeeperException.ThrottledOpException e) {\n<line71>                // anticipated outcome & retry\n<line72>                byte[] data = zk.getData(nodeName, null, null);\n<line73>                assertEquals(nodeName, new String(data));\n<line74>                // two ops issued, one is retry\n<line75>                opCount += 2;\n<line76>            } catch (KeeperException e) {\n<line77>                fail(\"Should have gotten ThrottledOp exception\");\n<line78>            }\n<line79>        } else {\n<line80>            byte[] data = zk.getData(nodeName, null, null);\n<line81>            assertEquals(nodeName, new String(data));\n<line82>            opCount++;\n<line83>        }\n<line84>        if (opCount % N == N - 1) {\n<line85>            try {\n<line86>                // version 0 should not trigger BadVersion exception\n<line87>                zk.delete(nodeName, 0);\n<line88>                fail(\"Should have gotten ThrottledOp exception\");\n<line89>            } catch (KeeperException.ThrottledOpException e) {\n<line90>                // anticipated outcome & retry\n<line91>                zk.delete(nodeName, -1);\n<line92>            } catch (KeeperException e) {\n<line93>                fail(\"Should have gotten ThrottledOp exception\");\n<line94>            }\n<line95>            // two ops issues, one for retry\n<line96>            opCount += 2;\n<line97>        } else {\n<line98>            zk.delete(nodeName, -1);\n<line99>            // one op only issued\n<line100>            opCount++;\n<line101>        }\n<line102>        if (opCount % N == N - 1) {\n<line103>            try {\n<line104>                zk.exists(nodeName, null);\n<line105>                fail(\"Should have gotten ThrottledOp exception\");\n<line106>            } catch (KeeperException.ThrottledOpException e) {\n<line107>                // anticipated outcome & retry\n<line108>                Stat stat = zk.exists(nodeName, null);\n<line109>                assertNull(stat);\n<line110>                // two ops issued, one is retry\n<line111>                opCount += 2;\n<line112>            } catch (KeeperException e) {\n<line113>                fail(\"Should have gotten ThrottledOp exception\");\n<line114>            }\n<line115>        } else {\n<line116>            Stat stat = zk.exists(nodeName, null);\n<line117>            assertNull(stat);\n<line118>            opCount++;\n<line119>        }\n<line120>    }\n<line121>    zk.close();\n<line122>}","output":"<line1>{\n<line2>    // must be greater than 3\n<line3>    final int N = 5;\n<line4>    final int COUNT = 100;\n<line5>    RequestThrottleMock.throttleEveryNthOp(N);\n<line6>    LOG.info(\"Before create /ivailo nodes\");\n<line7>    int opCount = 0;\n<line8>    for (int i = 0; i < COUNT; i++) {\n<line9>        String nodeName = \"/ivailo\" + i;\n<line10>        if (opCount % N == N - 1) {\n<line11>            try {\n<line12>                zk.create(nodeName, \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);\n<line13>                fail(\"Should have gotten ThrottledOp exception\");\n<line14>            } catch (KeeperException.ThrottledOpException e) {\n<line15>                // anticipated outcome\n<line16>                Stat stat = zk.exists(nodeName, null);\n<line17>                assertNull(stat);\n<line18>                zk.create(nodeName, \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);\n<line19>            } catch (KeeperException e) {\n<line20>                fail(\"Should have gotten ThrottledOp exception\");\n<line21>            }\n<line22>            // three ops issued\n<line23>            opCount += 3;\n<line24>        } else {\n<line25>            zk.create(nodeName, \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);\n<line26>            // one op issued\n<line27>            opCount++;\n<line28>        }\n<line29>        if (opCount % N == N - 1) {\n<line30>            try {\n<line31>                zk.setData(nodeName, nodeName.getBytes(), -1);\n<line32>                fail(\"Should have gotten ThrottledOp exception\");\n<line33>            } catch (KeeperException.ThrottledOpException e) {\n<line34>                // anticipated outcome & retry\n<line35>                zk.setData(nodeName, nodeName.getBytes(), -1);\n<line36>            } catch (KeeperException e) {\n<line37>                fail(\"Should have gotten ThrottledOp exception\");\n<line38>            }\n<line39>            // two ops issued, one for retry\n<line40>            opCount += 2;\n<line41>        } else {\n<line42>            zk.setData(nodeName, nodeName.getBytes(), -1);\n<line43>            // one op issued\n<line44>            opCount++;\n<line45>        }\n<line46>    }\n<line47>    LOG.info(\"Before delete /ivailo nodes\");\n<line48>    for (int i = 0; i < COUNT; i++) {\n<line49>        String nodeName = \"/ivailo\" + i;\n<line50>        if (opCount % N == N - 1) {\n<line51>            try {\n<line52>                zk.exists(nodeName, null);\n<line53>                fail(\"Should have gotten ThrottledOp exception\");\n<line54>            } catch (KeeperException.ThrottledOpException e) {\n<line55>                // anticipated outcome & retry\n<line56>                Stat stat = zk.exists(nodeName, null);\n<line57>                assertNotNull(stat);\n<line58>                // two ops issued, one is retry\n<line59>                opCount += 2;\n<line60>            } catch (KeeperException e) {\n<line61>                fail(\"Should have gotten ThrottledOp exception\");\n<line62>            }\n<line63>        } else {\n<line64>            Stat stat = zk.exists(nodeName, null);\n<line65>            assertNotNull(stat);\n<line66>            opCount++;\n<line67>        }\n<line68>        if (opCount % N == N - 1) {\n<line69>            try {\n<line70>                zk.getData(nodeName, null, null);\n<line71>                fail(\"Should have gotten ThrottledOp exception\");\n<line72>            } catch (KeeperException.ThrottledOpException e) {\n<line73>                // anticipated outcome & retry\n<line74>                byte[] data = zk.getData(nodeName, null, null);\n<line75>                assertEquals(nodeName, new String(data));\n<line76>                // two ops issued, one is retry\n<line77>                opCount += 2;\n<line78>            } catch (KeeperException e) {\n<line79>                fail(\"Should have gotten ThrottledOp exception\");\n<line80>            }\n<line81>        } else {\n<line82>            byte[] data = zk.getData(nodeName, null, null);\n<line83>            assertEquals(nodeName, new String(data));\n<line84>            opCount++;\n<line85>        }\n<line86>        if (opCount % N == N - 1) {\n<line87>            try {\n<line88>                // version 0 should not trigger BadVersion exception\n<line89>                zk.delete(nodeName, 0);\n<line90>                fail(\"Should have gotten ThrottledOp exception\");\n<line91>            } catch (KeeperException.ThrottledOpException e) {\n<line92>                // anticipated outcome & retry\n<line93>                zk.delete(nodeName, -1);\n<line94>            } catch (KeeperException e) {\n<line95>                fail(\"Should have gotten ThrottledOp exception\");\n<line96>            }\n<line97>            // two ops issues, one for retry\n<line98>            opCount += 2;\n<line99>        } else {\n<line100>            zk.delete(nodeName, -1);\n<line101>            // one op only issued\n<line102>            opCount++;\n<line103>        }\n<line104>        if (opCount % N == N - 1) {\n<line105>            try {\n<line106>                zk.exists(nodeName, null);\n<line107>                fail(\"Should have gotten ThrottledOp exception\");\n<line108>            } catch (KeeperException.ThrottledOpException e) {\n<line109>                // anticipated outcome & retry\n<line110>                Stat stat = zk.exists(nodeName, null);\n<line111>                assertNull(stat);\n<line112>                // two ops issued, one is retry\n<line113>                opCount += 2;\n<line114>            } catch (KeeperException e) {\n<line115>                fail(\"Should have gotten ThrottledOp exception\");\n<line116>            }\n<line117>        } else {\n<line118>            Stat stat = zk.exists(nodeName, null);\n<line119>            assertNull(stat);\n<line120>            opCount++;\n<line121>        }\n<line122>    }\n<line123>    LOG.info(\"After delete /ivailo\");\n<line124>    zk.close();\n<line125>}"},{"input":"","instruction":"<line1>{\n<line2>    return KeeperException.Code.AUTHFAILED;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Authentication failed\");\n<line3>    return KeeperException.Code.AUTHFAILED;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    zk2 = createClient(watcher2);\n<line3>    // 110 character base path\n<line4>    String pathBase = \"/long-path-000000000-111111111-222222222-333333333-444444444-\" + \"555555555-666666666-777777777-888888888-999999999\";\n<line5>    zk1.create(pathBase, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    // Create 10,000 nodes. This should ensure the length of our\n<line7>    // watches set below exceeds 1MB.\n<line8>    List<String> paths = new ArrayList<>();\n<line9>    for (int i = 0; i < 10000; i++) {\n<line10>        String path = zk1.create(pathBase + \"/ch-\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line11>        paths.add(path);\n<line12>    }\n<line13>    MyWatcher childWatcher = new MyWatcher();\n<line14>    // Set a combination of child/exists/data watches\n<line15>    int i = 0;\n<line16>    for (String path : paths) {\n<line17>        if (i % 3 == 0) {\n<line18>            zk2.getChildren(path, childWatcher);\n<line19>        } else if (i % 3 == 1) {\n<line20>            zk2.exists(path + \"/foo\", childWatcher);\n<line21>        } else if (i % 3 == 2) {\n<line22>            zk2.getData(path, childWatcher, null);\n<line23>        }\n<line24>        i++;\n<line25>    }\n<line26>    stopServer();\n<line27>    watcher2.waitForDisconnected(30000);\n<line28>    startServer();\n<line29>    watcher2.waitForConnected(30000);\n<line30>    watcher1.waitForConnected(30000);\n<line31>    // Trigger the watches and ensure they properly propagate to the client\n<line32>    i = 0;\n<line33>    for (String path : paths) {\n<line34>        if (i % 3 == 0) {\n<line35>            zk1.create(path + \"/ch\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line36>            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line37>            assertNotNull(e);\n<line38>            assertEquals(EventType.NodeChildrenChanged, e.getType());\n<line39>            assertEquals(path, e.getPath());\n<line40>        } else if (i % 3 == 1) {\n<line41>            zk1.create(path + \"/foo\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line42>            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line43>            assertNotNull(e);\n<line44>            assertEquals(EventType.NodeCreated, e.getType());\n<line45>            assertEquals(path + \"/foo\", e.getPath());\n<line46>        } else if (i % 3 == 2) {\n<line47>            zk1.setData(path, new byte[] { 1, 2, 3 }, -1);\n<line48>            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line49>            assertNotNull(e);\n<line50>            assertEquals(EventType.NodeDataChanged, e.getType());\n<line51>            assertEquals(path, e.getPath());\n<line52>        }\n<line53>        i++;\n<line54>    }\n<line55>}","output":"<line1>{\n<line2>    zk2 = createClient(watcher2);\n<line3>    // 110 character base path\n<line4>    String pathBase = \"/long-path-000000000-111111111-222222222-333333333-444444444-\" + \"555555555-666666666-777777777-888888888-999999999\";\n<line5>    zk1.create(pathBase, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    // Create 10,000 nodes. This should ensure the length of our\n<line7>    // watches set below exceeds 1MB.\n<line8>    List<String> paths = new ArrayList<>();\n<line9>    for (int i = 0; i < 10000; i++) {\n<line10>        String path = zk1.create(pathBase + \"/ch-\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line11>        paths.add(path);\n<line12>    }\n<line13>    LOG.info(\"Created 10,000 nodes.\");\n<line14>    MyWatcher childWatcher = new MyWatcher();\n<line15>    // Set a combination of child/exists/data watches\n<line16>    int i = 0;\n<line17>    for (String path : paths) {\n<line18>        if (i % 3 == 0) {\n<line19>            zk2.getChildren(path, childWatcher);\n<line20>        } else if (i % 3 == 1) {\n<line21>            zk2.exists(path + \"/foo\", childWatcher);\n<line22>        } else if (i % 3 == 2) {\n<line23>            zk2.getData(path, childWatcher, null);\n<line24>        }\n<line25>        i++;\n<line26>    }\n<line27>    stopServer();\n<line28>    watcher2.waitForDisconnected(30000);\n<line29>    startServer();\n<line30>    watcher2.waitForConnected(30000);\n<line31>    watcher1.waitForConnected(30000);\n<line32>    // Trigger the watches and ensure they properly propagate to the client\n<line33>    i = 0;\n<line34>    for (String path : paths) {\n<line35>        if (i % 3 == 0) {\n<line36>            zk1.create(path + \"/ch\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line37>            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line38>            assertNotNull(e);\n<line39>            assertEquals(EventType.NodeChildrenChanged, e.getType());\n<line40>            assertEquals(path, e.getPath());\n<line41>        } else if (i % 3 == 1) {\n<line42>            zk1.create(path + \"/foo\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line43>            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line44>            assertNotNull(e);\n<line45>            assertEquals(EventType.NodeCreated, e.getType());\n<line46>            assertEquals(path + \"/foo\", e.getPath());\n<line47>        } else if (i % 3 == 2) {\n<line48>            zk1.setData(path, new byte[] { 1, 2, 3 }, -1);\n<line49>            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line50>            assertNotNull(e);\n<line51>            assertEquals(EventType.NodeDataChanged, e.getType());\n<line52>            assertEquals(path, e.getPath());\n<line53>        }\n<line54>        i++;\n<line55>    }\n<line56>}"},{"input":"","instruction":"<line1>{\n<line2>    String hp = hostPort;\n<line3>    hostPort = hostPort + \"/chrootclienttest\";\n<line4>    System.out.println(hostPort);\n<line5>    super.setUp();\n<line6>    ZooKeeper zk = createClient(hp);\n<line7>    try {\n<line8>        zk.create(\"/chrootclienttest\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>    } finally {\n<line10>        zk.close();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    String hp = hostPort;\n<line3>    hostPort = hostPort + \"/chrootclienttest\";\n<line4>    System.out.println(hostPort);\n<line5>    super.setUp();\n<line6>    LOG.info(\"STARTING {}\", getTestName());\n<line7>    ZooKeeper zk = createClient(hp);\n<line8>    try {\n<line9>        zk.create(\"/chrootclienttest\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>    } finally {\n<line11>        zk.close();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    String HOSTPORT = \"127.0.0.1:\" + PortAssignment.unique();\n<line3>    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, \"org.apache.zookeeper.server.NettyServerCnxnFactory\");\n<line4>    ClientBase.setupTestEnv();\n<line5>    File tmpDir = ClientBase.createTmpDir();\n<line6>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line7>    SyncRequestProcessor.setSnapCount(1000);\n<line8>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line9>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line10>    f.startup(zks);\n<line11>    try {\n<line12>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line13>        ClientBase.createZKClient(HOSTPORT);\n<line14>        for (ServerCnxn cnxn : f.getConnections()) {\n<line15>            boolean foundID = false;\n<line16>            for (Id id : cnxn.getAuthInfo()) {\n<line17>                if (id.getScheme().equals(\"ip\")) {\n<line18>                    foundID = true;\n<line19>                    break;\n<line20>                }\n<line21>            }\n<line22>            assertTrue(foundID);\n<line23>        }\n<line24>    } finally {\n<line25>        f.shutdown();\n<line26>        zks.shutdown();\n<line27>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line28>        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    String HOSTPORT = \"127.0.0.1:\" + PortAssignment.unique();\n<line3>    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, \"org.apache.zookeeper.server.NettyServerCnxnFactory\");\n<line4>    ClientBase.setupTestEnv();\n<line5>    File tmpDir = ClientBase.createTmpDir();\n<line6>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line7>    SyncRequestProcessor.setSnapCount(1000);\n<line8>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line9>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line10>    f.startup(zks);\n<line11>    try {\n<line12>        LOG.info(\"starting up the zookeeper server .. waiting\");\n<line13>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line14>        ClientBase.createZKClient(HOSTPORT);\n<line15>        for (ServerCnxn cnxn : f.getConnections()) {\n<line16>            boolean foundID = false;\n<line17>            for (Id id : cnxn.getAuthInfo()) {\n<line18>                if (id.getScheme().equals(\"ip\")) {\n<line19>                    foundID = true;\n<line20>                    break;\n<line21>                }\n<line22>            }\n<line23>            assertTrue(foundID);\n<line24>        }\n<line25>    } finally {\n<line26>        f.shutdown();\n<line27>        zks.shutdown();\n<line28>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line29>        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line3>    ClientBase.createZKClient(HOSTPORT);\n<line4>    for (ServerCnxn cnxn : f.getConnections()) {\n<line5>        boolean foundID = false;\n<line6>        for (Id id : cnxn.getAuthInfo()) {\n<line7>            if (id.getScheme().equals(\"ip\")) {\n<line8>                foundID = true;\n<line9>                break;\n<line10>            }\n<line11>        }\n<line12>        assertTrue(foundID);\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line3>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line4>    ClientBase.createZKClient(HOSTPORT);\n<line5>    for (ServerCnxn cnxn : f.getConnections()) {\n<line6>        boolean foundID = false;\n<line7>        for (Id id : cnxn.getAuthInfo()) {\n<line8>            if (id.getScheme().equals(\"ip\")) {\n<line9>                foundID = true;\n<line10>                break;\n<line11>            }\n<line12>        }\n<line13>        assertTrue(foundID);\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(1000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    try {\n<line10>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line11>        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line12>        try {\n<line13>            zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line14>            zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line15>        } finally {\n<line16>            zk.close();\n<line17>        }\n<line18>    } finally {\n<line19>        f.shutdown();\n<line20>        zks.shutdown();\n<line21>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(1000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    try {\n<line10>        LOG.info(\"starting up the zookeeper server .. waiting\");\n<line11>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line12>        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line13>        try {\n<line14>            zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line15>            zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line16>        } finally {\n<line17>            zk.close();\n<line18>        }\n<line19>    } finally {\n<line20>        f.shutdown();\n<line21>        zks.shutdown();\n<line22>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line3>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line4>    try {\n<line5>        zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line6>        zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line7>    } finally {\n<line8>        zk.close();\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line3>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line4>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line5>    try {\n<line6>        zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line7>        zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line8>    } finally {\n<line9>        zk.close();\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(1000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    ZooKeeper zk;\n<line10>    String path;\n<line11>    try {\n<line12>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line13>        zk = ClientBase.createZKClient(HOSTPORT);\n<line14>        for (int i = 0; i < 100; i++) {\n<line15>            path = \"/\" + i;\n<line16>            zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line17>        }\n<line18>        int size = zks.getZKDatabase().getAclSize();\n<line19>        assertTrue((2 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line20>        for (int j = 100; j < 200; j++) {\n<line21>            path = \"/\" + j;\n<line22>            ACL acl = new ACL();\n<line23>            acl.setPerms(0);\n<line24>            Id id = new Id();\n<line25>            id.setId(\"1.1.1.\" + j);\n<line26>            id.setScheme(\"ip\");\n<line27>            acl.setId(id);\n<line28>            List<ACL> list = new ArrayList<>();\n<line29>            list.add(acl);\n<line30>            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);\n<line31>        }\n<line32>        assertTrue((102 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line33>    } finally {\n<line34>        // now shutdown the server and restart it\n<line35>        f.shutdown();\n<line36>        zks.shutdown();\n<line37>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line38>    }\n<line39>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line40>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line41>    f.startup(zks);\n<line42>    try {\n<line43>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line44>        zk = ClientBase.createZKClient(HOSTPORT);\n<line45>        assertTrue((102 == zks.getZKDatabase().getAclSize()), \"acl map \");\n<line46>        for (int j = 200; j < 205; j++) {\n<line47>            path = \"/\" + j;\n<line48>            ACL acl = new ACL();\n<line49>            acl.setPerms(0);\n<line50>            Id id = new Id();\n<line51>            id.setId(\"1.1.1.\" + j);\n<line52>            id.setScheme(\"ip\");\n<line53>            acl.setId(id);\n<line54>            ArrayList<ACL> list = new ArrayList<>();\n<line55>            list.add(acl);\n<line56>            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);\n<line57>        }\n<line58>        assertTrue((107 == zks.getZKDatabase().getAclSize()), \"acl map \");\n<line59>        zk.close();\n<line60>    } finally {\n<line61>        f.shutdown();\n<line62>        zks.shutdown();\n<line63>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line64>    }\n<line65>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(1000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    ZooKeeper zk;\n<line10>    String path;\n<line11>    try {\n<line12>        LOG.info(\"starting up the zookeeper server .. waiting\");\n<line13>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line14>        zk = ClientBase.createZKClient(HOSTPORT);\n<line15>        LOG.info(\"starting creating acls\");\n<line16>        for (int i = 0; i < 100; i++) {\n<line17>            path = \"/\" + i;\n<line18>            zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line19>        }\n<line20>        int size = zks.getZKDatabase().getAclSize();\n<line21>        assertTrue((2 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line22>        for (int j = 100; j < 200; j++) {\n<line23>            path = \"/\" + j;\n<line24>            ACL acl = new ACL();\n<line25>            acl.setPerms(0);\n<line26>            Id id = new Id();\n<line27>            id.setId(\"1.1.1.\" + j);\n<line28>            id.setScheme(\"ip\");\n<line29>            acl.setId(id);\n<line30>            List<ACL> list = new ArrayList<>();\n<line31>            list.add(acl);\n<line32>            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);\n<line33>        }\n<line34>        assertTrue((102 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line35>    } finally {\n<line36>        // now shutdown the server and restart it\n<line37>        f.shutdown();\n<line38>        zks.shutdown();\n<line39>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line40>    }\n<line41>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line42>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line43>    f.startup(zks);\n<line44>    try {\n<line45>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line46>        zk = ClientBase.createZKClient(HOSTPORT);\n<line47>        assertTrue((102 == zks.getZKDatabase().getAclSize()), \"acl map \");\n<line48>        for (int j = 200; j < 205; j++) {\n<line49>            path = \"/\" + j;\n<line50>            ACL acl = new ACL();\n<line51>            acl.setPerms(0);\n<line52>            Id id = new Id();\n<line53>            id.setId(\"1.1.1.\" + j);\n<line54>            id.setScheme(\"ip\");\n<line55>            acl.setId(id);\n<line56>            ArrayList<ACL> list = new ArrayList<>();\n<line57>            list.add(acl);\n<line58>            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);\n<line59>        }\n<line60>        assertTrue((107 == zks.getZKDatabase().getAclSize()), \"acl map \");\n<line61>        zk.close();\n<line62>    } finally {\n<line63>        f.shutdown();\n<line64>        zks.shutdown();\n<line65>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line66>    }\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line3>    zk = ClientBase.createZKClient(HOSTPORT);\n<line4>    for (int i = 0; i < 100; i++) {\n<line5>        path = \"/\" + i;\n<line6>        zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>    }\n<line8>    int size = zks.getZKDatabase().getAclSize();\n<line9>    assertTrue((2 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line10>    for (int j = 100; j < 200; j++) {\n<line11>        path = \"/\" + j;\n<line12>        ACL acl = new ACL();\n<line13>        acl.setPerms(0);\n<line14>        Id id = new Id();\n<line15>        id.setId(\"1.1.1.\" + j);\n<line16>        id.setScheme(\"ip\");\n<line17>        acl.setId(id);\n<line18>        List<ACL> list = new ArrayList<>();\n<line19>        list.add(acl);\n<line20>        zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);\n<line21>    }\n<line22>    assertTrue((102 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line23>}","output":"<line1>{\n<line2>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line3>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line4>    zk = ClientBase.createZKClient(HOSTPORT);\n<line5>    LOG.info(\"starting creating acls\");\n<line6>    for (int i = 0; i < 100; i++) {\n<line7>        path = \"/\" + i;\n<line8>        zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>    }\n<line10>    int size = zks.getZKDatabase().getAclSize();\n<line11>    assertTrue((2 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line12>    for (int j = 100; j < 200; j++) {\n<line13>        path = \"/\" + j;\n<line14>        ACL acl = new ACL();\n<line15>        acl.setPerms(0);\n<line16>        Id id = new Id();\n<line17>        id.setId(\"1.1.1.\" + j);\n<line18>        id.setScheme(\"ip\");\n<line19>        acl.setId(id);\n<line20>        List<ACL> list = new ArrayList<>();\n<line21>        list.add(acl);\n<line22>        zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);\n<line23>    }\n<line24>    assertTrue((102 == zks.getZKDatabase().getAclSize()), \"size of the acl map \");\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event.getState() == KeeperState.SyncConnected) {\n<line3>        if (startSignal != null && startSignal.getCount() > 0) {\n<line4>            startSignal.countDown();\n<line5>        } else {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.info(\"Event:{} {} {}\", event.getState(), event.getType(), event.getPath());\n<line3>    if (event.getState() == KeeperState.SyncConnected) {\n<line4>        if (startSignal != null && startSignal.getCount() > 0) {\n<line5>            LOG.info(\"startsignal.countDown()\");\n<line6>            startSignal.countDown();\n<line7>        } else {\n<line8>            LOG.warn(\"startsignal {}\", startSignal);\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (startSignal != null && startSignal.getCount() > 0) {\n<line3>        startSignal.countDown();\n<line4>    } else {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (startSignal != null && startSignal.getCount() > 0) {\n<line3>        LOG.info(\"startsignal.countDown()\");\n<line4>        startSignal.countDown();\n<line5>    } else {\n<line6>        LOG.warn(\"startsignal {}\", startSignal);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    startSignal.countDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"startsignal.countDown()\");\n<line3>    startSignal.countDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    String path = \"/testExistACLCheck\";\n<line9>    String data = \"/testExistACLCheck-data\";\n<line10>    try {\n<line11>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line12>        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line13>        try {\n<line14>            Stat stat = zk.exists(path, false);\n<line15>            assertNull(stat);\n<line16>            zk.create(path, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line17>            stat = zk.exists(path, false);\n<line18>            assertNotNull(stat);\n<line19>            assertEquals(data.length(), stat.getDataLength());\n<line20>            zk.delete(path, -1);\n<line21>            ArrayList<ACL> acls = new ArrayList<>();\n<line22>            acls.add(new ACL(ZooDefs.Perms.WRITE, Ids.ANYONE_ID_UNSAFE));\n<line23>            zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line24>            try {\n<line25>                stat = zk.exists(path, false);\n<line26>                fail(\"exists should throw NoAuthException when don't have read permission\");\n<line27>            } catch (KeeperException.NoAuthException e) {\n<line28>                //expected\n<line29>            }\n<line30>            zk.delete(path, -1);\n<line31>            acls = new ArrayList<>();\n<line32>            acls.add(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE));\n<line33>            zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line34>            stat = zk.exists(path, false);\n<line35>            assertNotNull(stat);\n<line36>            assertEquals(data.length(), stat.getDataLength());\n<line37>        } finally {\n<line38>            zk.close();\n<line39>        }\n<line40>    } finally {\n<line41>        f.shutdown();\n<line42>        zks.shutdown();\n<line43>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line44>    }\n<line45>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    String path = \"/testExistACLCheck\";\n<line9>    String data = \"/testExistACLCheck-data\";\n<line10>    try {\n<line11>        LOG.info(\"starting up the zookeeper server .. waiting\");\n<line12>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line13>        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line14>        try {\n<line15>            Stat stat = zk.exists(path, false);\n<line16>            assertNull(stat);\n<line17>            zk.create(path, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line18>            stat = zk.exists(path, false);\n<line19>            assertNotNull(stat);\n<line20>            assertEquals(data.length(), stat.getDataLength());\n<line21>            zk.delete(path, -1);\n<line22>            ArrayList<ACL> acls = new ArrayList<>();\n<line23>            acls.add(new ACL(ZooDefs.Perms.WRITE, Ids.ANYONE_ID_UNSAFE));\n<line24>            zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line25>            try {\n<line26>                stat = zk.exists(path, false);\n<line27>                fail(\"exists should throw NoAuthException when don't have read permission\");\n<line28>            } catch (KeeperException.NoAuthException e) {\n<line29>                //expected\n<line30>            }\n<line31>            zk.delete(path, -1);\n<line32>            acls = new ArrayList<>();\n<line33>            acls.add(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE));\n<line34>            zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line35>            stat = zk.exists(path, false);\n<line36>            assertNotNull(stat);\n<line37>            assertEquals(data.length(), stat.getDataLength());\n<line38>        } finally {\n<line39>            zk.close();\n<line40>        }\n<line41>    } finally {\n<line42>        f.shutdown();\n<line43>        zks.shutdown();\n<line44>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line3>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line4>    try {\n<line5>        Stat stat = zk.exists(path, false);\n<line6>        assertNull(stat);\n<line7>        zk.create(path, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>        stat = zk.exists(path, false);\n<line9>        assertNotNull(stat);\n<line10>        assertEquals(data.length(), stat.getDataLength());\n<line11>        zk.delete(path, -1);\n<line12>        ArrayList<ACL> acls = new ArrayList<>();\n<line13>        acls.add(new ACL(ZooDefs.Perms.WRITE, Ids.ANYONE_ID_UNSAFE));\n<line14>        zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line15>        try {\n<line16>            stat = zk.exists(path, false);\n<line17>            fail(\"exists should throw NoAuthException when don't have read permission\");\n<line18>        } catch (KeeperException.NoAuthException e) {\n<line19>            //expected\n<line20>        }\n<line21>        zk.delete(path, -1);\n<line22>        acls = new ArrayList<>();\n<line23>        acls.add(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE));\n<line24>        zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line25>        stat = zk.exists(path, false);\n<line26>        assertNotNull(stat);\n<line27>        assertEquals(data.length(), stat.getDataLength());\n<line28>    } finally {\n<line29>        zk.close();\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line3>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line4>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line5>    try {\n<line6>        Stat stat = zk.exists(path, false);\n<line7>        assertNull(stat);\n<line8>        zk.create(path, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>        stat = zk.exists(path, false);\n<line10>        assertNotNull(stat);\n<line11>        assertEquals(data.length(), stat.getDataLength());\n<line12>        zk.delete(path, -1);\n<line13>        ArrayList<ACL> acls = new ArrayList<>();\n<line14>        acls.add(new ACL(ZooDefs.Perms.WRITE, Ids.ANYONE_ID_UNSAFE));\n<line15>        zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line16>        try {\n<line17>            stat = zk.exists(path, false);\n<line18>            fail(\"exists should throw NoAuthException when don't have read permission\");\n<line19>        } catch (KeeperException.NoAuthException e) {\n<line20>            //expected\n<line21>        }\n<line22>        zk.delete(path, -1);\n<line23>        acls = new ArrayList<>();\n<line24>        acls.add(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE));\n<line25>        zk.create(path, data.getBytes(), acls, CreateMode.PERSISTENT);\n<line26>        stat = zk.exists(path, false);\n<line27>        assertNotNull(stat);\n<line28>        assertEquals(data.length(), stat.getDataLength());\n<line29>    } finally {\n<line30>        zk.close();\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    try {\n<line9>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line10>        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line11>        try {\n<line12>            String data = \"/testExistACLCheckAtRootPath-data\";\n<line13>            zk.create(\"/a\", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>            ArrayList<ACL> acls = new ArrayList<>();\n<line15>            acls.add(new ACL(0, Ids.ANYONE_ID_UNSAFE));\n<line16>            zk.setACL(\"/\", acls, -1);\n<line17>            Stat stat = zk.exists(\"/a\", false);\n<line18>            assertNotNull(stat);\n<line19>            assertEquals(data.length(), stat.getDataLength());\n<line20>            try {\n<line21>                stat = zk.exists(\"/\", false);\n<line22>                fail(\"exists should throw NoAuthException when removing root path's ACL permission\");\n<line23>            } catch (KeeperException.NoAuthException e) {\n<line24>                //expected\n<line25>            }\n<line26>        } finally {\n<line27>            zk.close();\n<line28>        }\n<line29>    } finally {\n<line30>        f.shutdown();\n<line31>        zks.shutdown();\n<line32>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    try {\n<line9>        LOG.info(\"starting up the zookeeper server .. waiting\");\n<line10>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line11>        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line12>        try {\n<line13>            String data = \"/testExistACLCheckAtRootPath-data\";\n<line14>            zk.create(\"/a\", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>            ArrayList<ACL> acls = new ArrayList<>();\n<line16>            acls.add(new ACL(0, Ids.ANYONE_ID_UNSAFE));\n<line17>            zk.setACL(\"/\", acls, -1);\n<line18>            Stat stat = zk.exists(\"/a\", false);\n<line19>            assertNotNull(stat);\n<line20>            assertEquals(data.length(), stat.getDataLength());\n<line21>            try {\n<line22>                stat = zk.exists(\"/\", false);\n<line23>                fail(\"exists should throw NoAuthException when removing root path's ACL permission\");\n<line24>            } catch (KeeperException.NoAuthException e) {\n<line25>                //expected\n<line26>            }\n<line27>        } finally {\n<line28>            zk.close();\n<line29>        }\n<line30>    } finally {\n<line31>        f.shutdown();\n<line32>        zks.shutdown();\n<line33>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line34>    }\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line3>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line4>    try {\n<line5>        String data = \"/testExistACLCheckAtRootPath-data\";\n<line6>        zk.create(\"/a\", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        ArrayList<ACL> acls = new ArrayList<>();\n<line8>        acls.add(new ACL(0, Ids.ANYONE_ID_UNSAFE));\n<line9>        zk.setACL(\"/\", acls, -1);\n<line10>        Stat stat = zk.exists(\"/a\", false);\n<line11>        assertNotNull(stat);\n<line12>        assertEquals(data.length(), stat.getDataLength());\n<line13>        try {\n<line14>            stat = zk.exists(\"/\", false);\n<line15>            fail(\"exists should throw NoAuthException when removing root path's ACL permission\");\n<line16>        } catch (KeeperException.NoAuthException e) {\n<line17>            //expected\n<line18>        }\n<line19>    } finally {\n<line20>        zk.close();\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line3>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line4>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line5>    try {\n<line6>        String data = \"/testExistACLCheckAtRootPath-data\";\n<line7>        zk.create(\"/a\", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>        ArrayList<ACL> acls = new ArrayList<>();\n<line9>        acls.add(new ACL(0, Ids.ANYONE_ID_UNSAFE));\n<line10>        zk.setACL(\"/\", acls, -1);\n<line11>        Stat stat = zk.exists(\"/a\", false);\n<line12>        assertNotNull(stat);\n<line13>        assertEquals(data.length(), stat.getDataLength());\n<line14>        try {\n<line15>            stat = zk.exists(\"/\", false);\n<line16>            fail(\"exists should throw NoAuthException when removing root path's ACL permission\");\n<line17>        } catch (KeeperException.NoAuthException e) {\n<line18>            //expected\n<line19>        }\n<line20>    } finally {\n<line21>        zk.close();\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumUtil qU = new QuorumUtil(1);\n<line3>    qU.startAll();\n<line4>    int leaderIndex = qU.getLeaderServer();\n<line5>    int firstFollowerIndex = 0;\n<line6>    int secondFollowerIndex = 0;\n<line7>    switch(leaderIndex) {\n<line8>        case 1:\n<line9>            firstFollowerIndex = 2;\n<line10>            secondFollowerIndex = 3;\n<line11>            break;\n<line12>        case 2:\n<line13>            firstFollowerIndex = 1;\n<line14>            secondFollowerIndex = 3;\n<line15>            break;\n<line16>        case 3:\n<line17>            firstFollowerIndex = 1;\n<line18>            secondFollowerIndex = 2;\n<line19>            break;\n<line20>        default:\n<line21>            fail(\"Unexpected leaderIndex value: \" + leaderIndex);\n<line22>            break;\n<line23>    }\n<line24>    qU.shutdown(firstFollowerIndex);\n<line25>    qU.shutdown(secondFollowerIndex);\n<line26>    qU.restart(firstFollowerIndex);\n<line27>    qU.restart(secondFollowerIndex);\n<line28>    qU.shutdownAll();\n<line29>    Set<ZKMBeanInfo> pending = MBeanRegistry.getInstance().getRegisteredBeans();\n<line30>    assertTrue(pending.isEmpty(), \"The following beans should have been unregistered: \" + pending);\n<line31>}","output":"<line1>{\n<line2>    QuorumUtil qU = new QuorumUtil(1);\n<line3>    LOG.info(\">-->> Starting up all servers...\");\n<line4>    qU.startAll();\n<line5>    LOG.info(\">-->> Servers up and running...\");\n<line6>    int leaderIndex = qU.getLeaderServer();\n<line7>    int firstFollowerIndex = 0;\n<line8>    int secondFollowerIndex = 0;\n<line9>    switch(leaderIndex) {\n<line10>        case 1:\n<line11>            firstFollowerIndex = 2;\n<line12>            secondFollowerIndex = 3;\n<line13>            break;\n<line14>        case 2:\n<line15>            firstFollowerIndex = 1;\n<line16>            secondFollowerIndex = 3;\n<line17>            break;\n<line18>        case 3:\n<line19>            firstFollowerIndex = 1;\n<line20>            secondFollowerIndex = 2;\n<line21>            break;\n<line22>        default:\n<line23>            fail(\"Unexpected leaderIndex value: \" + leaderIndex);\n<line24>            break;\n<line25>    }\n<line26>    LOG.info(\">-->> Shuting down server [{}]\", firstFollowerIndex);\n<line27>    qU.shutdown(firstFollowerIndex);\n<line28>    LOG.info(\">-->> Shuting down server [{}]\", secondFollowerIndex);\n<line29>    qU.shutdown(secondFollowerIndex);\n<line30>    LOG.info(\">-->> Restarting server [{}]\", firstFollowerIndex);\n<line31>    qU.restart(firstFollowerIndex);\n<line32>    LOG.info(\">-->> Restarting server [{}]\", secondFollowerIndex);\n<line33>    qU.restart(secondFollowerIndex);\n<line34>    qU.shutdownAll();\n<line35>    Set<ZKMBeanInfo> pending = MBeanRegistry.getInstance().getRegisteredBeans();\n<line36>    assertTrue(pending.isEmpty(), \"The following beans should have been unregistered: \" + pending);\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean isGlobal = (localWatcher == globalWatcher);\n<line3>    // First test to see if the watch survives across reconnects\n<line4>    zk.create(\"/watchtest\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    zk.create(\"/watchtest/child\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line6>    if (isGlobal) {\n<line7>        zk.getChildren(\"/watchtest\", true);\n<line8>        zk.getData(\"/watchtest/child\", true, new Stat());\n<line9>        zk.exists(\"/watchtest/child2\", true);\n<line10>    } else {\n<line11>        zk.getChildren(\"/watchtest\", localWatcher);\n<line12>        zk.getData(\"/watchtest/child\", localWatcher, new Stat());\n<line13>        zk.exists(\"/watchtest/child2\", localWatcher);\n<line14>    }\n<line15>    assertTrue(localWatcher.events.isEmpty());\n<line16>    stopServer();\n<line17>    globalWatcher.waitForDisconnected(3000);\n<line18>    localWatcher.waitForDisconnected(500);\n<line19>    startServer();\n<line20>    globalWatcher.waitForConnected(3000);\n<line21>    boolean disableAutoWatchReset = zk.getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET);\n<line22>    if (!isGlobal && !disableAutoWatchReset) {\n<line23>        localWatcher.waitForConnected(500);\n<line24>    }\n<line25>    assertTrue(localWatcher.events.isEmpty());\n<line26>    zk.setData(\"/watchtest/child\", new byte[1], -1);\n<line27>    zk.create(\"/watchtest/child2\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line28>    WatchedEvent e;\n<line29>    if (!disableAutoWatchReset) {\n<line30>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line31>        assertEquals(EventType.NodeDataChanged, e.getType(), e.getPath());\n<line32>        assertEquals(\"/watchtest/child\", e.getPath());\n<line33>    } else {\n<line34>        // we'll catch this later if it does happen after timeout, so\n<line35>        // why waste the time on poll\n<line36>    }\n<line37>    if (!disableAutoWatchReset) {\n<line38>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line39>        // The create will trigger the get children and the exist\n<line40>        // watches\n<line41>        assertEquals(EventType.NodeCreated, e.getType());\n<line42>        assertEquals(\"/watchtest/child2\", e.getPath());\n<line43>    } else {\n<line44>        // we'll catch this later if it does happen after timeout, so\n<line45>        // why waste the time on poll\n<line46>    }\n<line47>    if (!disableAutoWatchReset) {\n<line48>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line49>        assertEquals(EventType.NodeChildrenChanged, e.getType());\n<line50>        assertEquals(\"/watchtest\", e.getPath());\n<line51>    } else {\n<line52>        // we'll catch this later if it does happen after timeout, so\n<line53>        // why waste the time on poll\n<line54>    }\n<line55>    // ensure no late arrivals\n<line56>    assertTrue(localWatcher.events.isEmpty());\n<line57>    stopServer();\n<line58>    globalWatcher.waitForDisconnected(TIMEOUT);\n<line59>    try {\n<line60>        try {\n<line61>            localWatcher.waitForDisconnected(500);\n<line62>            if (!isGlobal && !disableAutoWatchReset) {\n<line63>                fail(\"Got an event when I shouldn't have\");\n<line64>            }\n<line65>        } catch (TimeoutException toe) {\n<line66>            if (disableAutoWatchReset) {\n<line67>                fail(\"Didn't get an event when I should have\");\n<line68>            }\n<line69>            // Else what we are expecting since there are no outstanding watches\n<line70>        }\n<line71>    } catch (Exception e1) {\n<line72>        throw new RuntimeException(e1);\n<line73>    }\n<line74>    startServer();\n<line75>    globalWatcher.waitForConnected(TIMEOUT);\n<line76>    if (isGlobal) {\n<line77>        zk.getChildren(\"/watchtest\", true);\n<line78>        zk.getData(\"/watchtest/child\", true, new Stat());\n<line79>        zk.exists(\"/watchtest/child2\", true);\n<line80>    } else {\n<line81>        zk.getChildren(\"/watchtest\", localWatcher);\n<line82>        zk.getData(\"/watchtest/child\", localWatcher, new Stat());\n<line83>        zk.exists(\"/watchtest/child2\", localWatcher);\n<line84>    }\n<line85>    // Do trigger an event to make sure that we do not get\n<line86>    // it later\n<line87>    zk.delete(\"/watchtest/child2\", -1);\n<line88>    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line89>    assertEquals(EventType.NodeDeleted, e.getType());\n<line90>    assertEquals(\"/watchtest/child2\", e.getPath());\n<line91>    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line92>    assertEquals(EventType.NodeChildrenChanged, e.getType());\n<line93>    assertEquals(\"/watchtest\", e.getPath());\n<line94>    assertTrue(localWatcher.events.isEmpty());\n<line95>    stopServer();\n<line96>    globalWatcher.waitForDisconnected(TIMEOUT);\n<line97>    localWatcher.waitForDisconnected(500);\n<line98>    startServer();\n<line99>    globalWatcher.waitForConnected(TIMEOUT);\n<line100>    if (!isGlobal && !disableAutoWatchReset) {\n<line101>        localWatcher.waitForConnected(500);\n<line102>    }\n<line103>    zk.delete(\"/watchtest/child\", -1);\n<line104>    zk.delete(\"/watchtest\", -1);\n<line105>    if (!disableAutoWatchReset) {\n<line106>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line107>        assertEquals(EventType.NodeDeleted, e.getType());\n<line108>        assertEquals(\"/watchtest/child\", e.getPath());\n<line109>    } else {\n<line110>        // we'll catch this later if it does happen after timeout, so\n<line111>        // why waste the time on poll\n<line112>    }\n<line113>    // Make sure nothing is straggling!\n<line114>    Thread.sleep(1000);\n<line115>    assertTrue(localWatcher.events.isEmpty());\n<line116>}","output":"<line1>{\n<line2>    boolean isGlobal = (localWatcher == globalWatcher);\n<line3>    // First test to see if the watch survives across reconnects\n<line4>    zk.create(\"/watchtest\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    zk.create(\"/watchtest/child\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line6>    if (isGlobal) {\n<line7>        zk.getChildren(\"/watchtest\", true);\n<line8>        zk.getData(\"/watchtest/child\", true, new Stat());\n<line9>        zk.exists(\"/watchtest/child2\", true);\n<line10>    } else {\n<line11>        zk.getChildren(\"/watchtest\", localWatcher);\n<line12>        zk.getData(\"/watchtest/child\", localWatcher, new Stat());\n<line13>        zk.exists(\"/watchtest/child2\", localWatcher);\n<line14>    }\n<line15>    assertTrue(localWatcher.events.isEmpty());\n<line16>    stopServer();\n<line17>    globalWatcher.waitForDisconnected(3000);\n<line18>    localWatcher.waitForDisconnected(500);\n<line19>    startServer();\n<line20>    globalWatcher.waitForConnected(3000);\n<line21>    boolean disableAutoWatchReset = zk.getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET);\n<line22>    if (!isGlobal && !disableAutoWatchReset) {\n<line23>        localWatcher.waitForConnected(500);\n<line24>    }\n<line25>    assertTrue(localWatcher.events.isEmpty());\n<line26>    zk.setData(\"/watchtest/child\", new byte[1], -1);\n<line27>    zk.create(\"/watchtest/child2\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line28>    WatchedEvent e;\n<line29>    if (!disableAutoWatchReset) {\n<line30>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line31>        assertEquals(EventType.NodeDataChanged, e.getType(), e.getPath());\n<line32>        assertEquals(\"/watchtest/child\", e.getPath());\n<line33>    } else {\n<line34>        // we'll catch this later if it does happen after timeout, so\n<line35>        // why waste the time on poll\n<line36>    }\n<line37>    if (!disableAutoWatchReset) {\n<line38>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line39>        // The create will trigger the get children and the exist\n<line40>        // watches\n<line41>        assertEquals(EventType.NodeCreated, e.getType());\n<line42>        assertEquals(\"/watchtest/child2\", e.getPath());\n<line43>    } else {\n<line44>        // we'll catch this later if it does happen after timeout, so\n<line45>        // why waste the time on poll\n<line46>    }\n<line47>    if (!disableAutoWatchReset) {\n<line48>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line49>        assertEquals(EventType.NodeChildrenChanged, e.getType());\n<line50>        assertEquals(\"/watchtest\", e.getPath());\n<line51>    } else {\n<line52>        // we'll catch this later if it does happen after timeout, so\n<line53>        // why waste the time on poll\n<line54>    }\n<line55>    // ensure no late arrivals\n<line56>    assertTrue(localWatcher.events.isEmpty());\n<line57>    stopServer();\n<line58>    globalWatcher.waitForDisconnected(TIMEOUT);\n<line59>    try {\n<line60>        try {\n<line61>            localWatcher.waitForDisconnected(500);\n<line62>            if (!isGlobal && !disableAutoWatchReset) {\n<line63>                fail(\"Got an event when I shouldn't have\");\n<line64>            }\n<line65>        } catch (TimeoutException toe) {\n<line66>            if (disableAutoWatchReset) {\n<line67>                fail(\"Didn't get an event when I should have\");\n<line68>            }\n<line69>            // Else what we are expecting since there are no outstanding watches\n<line70>        }\n<line71>    } catch (Exception e1) {\n<line72>        LOG.error(\"bad\", e1);\n<line73>        throw new RuntimeException(e1);\n<line74>    }\n<line75>    startServer();\n<line76>    globalWatcher.waitForConnected(TIMEOUT);\n<line77>    if (isGlobal) {\n<line78>        zk.getChildren(\"/watchtest\", true);\n<line79>        zk.getData(\"/watchtest/child\", true, new Stat());\n<line80>        zk.exists(\"/watchtest/child2\", true);\n<line81>    } else {\n<line82>        zk.getChildren(\"/watchtest\", localWatcher);\n<line83>        zk.getData(\"/watchtest/child\", localWatcher, new Stat());\n<line84>        zk.exists(\"/watchtest/child2\", localWatcher);\n<line85>    }\n<line86>    // Do trigger an event to make sure that we do not get\n<line87>    // it later\n<line88>    zk.delete(\"/watchtest/child2\", -1);\n<line89>    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line90>    assertEquals(EventType.NodeDeleted, e.getType());\n<line91>    assertEquals(\"/watchtest/child2\", e.getPath());\n<line92>    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line93>    assertEquals(EventType.NodeChildrenChanged, e.getType());\n<line94>    assertEquals(\"/watchtest\", e.getPath());\n<line95>    assertTrue(localWatcher.events.isEmpty());\n<line96>    stopServer();\n<line97>    globalWatcher.waitForDisconnected(TIMEOUT);\n<line98>    localWatcher.waitForDisconnected(500);\n<line99>    startServer();\n<line100>    globalWatcher.waitForConnected(TIMEOUT);\n<line101>    if (!isGlobal && !disableAutoWatchReset) {\n<line102>        localWatcher.waitForConnected(500);\n<line103>    }\n<line104>    zk.delete(\"/watchtest/child\", -1);\n<line105>    zk.delete(\"/watchtest\", -1);\n<line106>    if (!disableAutoWatchReset) {\n<line107>        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n<line108>        assertEquals(EventType.NodeDeleted, e.getType());\n<line109>        assertEquals(\"/watchtest/child\", e.getPath());\n<line110>    } else {\n<line111>        // we'll catch this later if it does happen after timeout, so\n<line112>        // why waste the time on poll\n<line113>    }\n<line114>    // Make sure nothing is straggling!\n<line115>    Thread.sleep(1000);\n<line116>    assertTrue(localWatcher.events.isEmpty());\n<line117>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new RuntimeException(e1);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"bad\", e1);\n<line3>    throw new RuntimeException(e1);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        opsCount = new CountDownLatch(limit);\n<line4>        ZooKeeper zk = createClient();\n<line5>        for (int i = 0; i < 50; i++) {\n<line6>            zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);\n<line7>        }\n<line8>        for (int i = 50; i < 100; i++) {\n<line9>            zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);\n<line10>        }\n<line11>        zk.sync(\"/test\", this, results);\n<line12>        for (int i = 0; i < 100; i++) {\n<line13>            zk.delete(\"/test\" + i, 0, this, results);\n<line14>        }\n<line15>        for (int i = 0; i < 100; i++) {\n<line16>            zk.getChildren(\"/\", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);\n<line17>        }\n<line18>        for (int i = 0; i < 100; i++) {\n<line19>            zk.getChildren(\"/\", DummyWatcher.INSTANCE, (Children2Callback) this, results);\n<line20>        }\n<line21>        if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {\n<line22>            fail(\"Haven't received all confirmations\" + opsCount.getCount());\n<line23>        }\n<line24>        for (int i = 0; i < limit; i++) {\n<line25>            assertEquals(0, (int) results.get(i));\n<line26>        }\n<line27>    } catch (IOException e) {\n<line28>        System.out.println(e.toString());\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"Starting ZK:{}\", (new Date()).toString());\n<line4>        opsCount = new CountDownLatch(limit);\n<line5>        ZooKeeper zk = createClient();\n<line6>        LOG.info(\"Beginning test:{}\", (new Date()).toString());\n<line7>        for (int i = 0; i < 50; i++) {\n<line8>            zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);\n<line9>        }\n<line10>        for (int i = 50; i < 100; i++) {\n<line11>            zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);\n<line12>        }\n<line13>        zk.sync(\"/test\", this, results);\n<line14>        for (int i = 0; i < 100; i++) {\n<line15>            zk.delete(\"/test\" + i, 0, this, results);\n<line16>        }\n<line17>        for (int i = 0; i < 100; i++) {\n<line18>            zk.getChildren(\"/\", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);\n<line19>        }\n<line20>        for (int i = 0; i < 100; i++) {\n<line21>            zk.getChildren(\"/\", DummyWatcher.INSTANCE, (Children2Callback) this, results);\n<line22>        }\n<line23>        LOG.info(\"Submitted all operations:{}\", (new Date()).toString());\n<line24>        if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {\n<line25>            fail(\"Haven't received all confirmations\" + opsCount.getCount());\n<line26>        }\n<line27>        for (int i = 0; i < limit; i++) {\n<line28>            assertEquals(0, (int) results.get(i));\n<line29>        }\n<line30>    } catch (IOException e) {\n<line31>        System.out.println(e.toString());\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    opsCount = new CountDownLatch(limit);\n<line3>    ZooKeeper zk = createClient();\n<line4>    for (int i = 0; i < 50; i++) {\n<line5>        zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);\n<line6>    }\n<line7>    for (int i = 50; i < 100; i++) {\n<line8>        zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);\n<line9>    }\n<line10>    zk.sync(\"/test\", this, results);\n<line11>    for (int i = 0; i < 100; i++) {\n<line12>        zk.delete(\"/test\" + i, 0, this, results);\n<line13>    }\n<line14>    for (int i = 0; i < 100; i++) {\n<line15>        zk.getChildren(\"/\", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);\n<line16>    }\n<line17>    for (int i = 0; i < 100; i++) {\n<line18>        zk.getChildren(\"/\", DummyWatcher.INSTANCE, (Children2Callback) this, results);\n<line19>    }\n<line20>    if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {\n<line21>        fail(\"Haven't received all confirmations\" + opsCount.getCount());\n<line22>    }\n<line23>    for (int i = 0; i < limit; i++) {\n<line24>        assertEquals(0, (int) results.get(i));\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    LOG.info(\"Starting ZK:{}\", (new Date()).toString());\n<line3>    opsCount = new CountDownLatch(limit);\n<line4>    ZooKeeper zk = createClient();\n<line5>    LOG.info(\"Beginning test:{}\", (new Date()).toString());\n<line6>    for (int i = 0; i < 50; i++) {\n<line7>        zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);\n<line8>    }\n<line9>    for (int i = 50; i < 100; i++) {\n<line10>        zk.create(\"/test\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);\n<line11>    }\n<line12>    zk.sync(\"/test\", this, results);\n<line13>    for (int i = 0; i < 100; i++) {\n<line14>        zk.delete(\"/test\" + i, 0, this, results);\n<line15>    }\n<line16>    for (int i = 0; i < 100; i++) {\n<line17>        zk.getChildren(\"/\", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);\n<line18>    }\n<line19>    for (int i = 0; i < 100; i++) {\n<line20>        zk.getChildren(\"/\", DummyWatcher.INSTANCE, (Children2Callback) this, results);\n<line21>    }\n<line22>    LOG.info(\"Submitted all operations:{}\", (new Date()).toString());\n<line23>    if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {\n<line24>        fail(\"Haven't received all confirmations\" + opsCount.getCount());\n<line25>    }\n<line26>    for (int i = 0; i < limit; i++) {\n<line27>        assertEquals(0, (int) results.get(i));\n<line28>    }\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    TestableZooKeeper zk = createClient();\n<line3>    try {\n<line4>    } finally {\n<line5>        zk.close(CONNECTION_TIMEOUT);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    TestableZooKeeper zk = createClient();\n<line3>    try {\n<line4>        LOG.info(\"{}\", zk.testableLocalSocketAddress());\n<line5>        LOG.info(\"{}\", zk.testableRemoteSocketAddress());\n<line6>        LOG.info(\"{}\", zk.toString());\n<line7>    } finally {\n<line8>        zk.close(CONNECTION_TIMEOUT);\n<line9>        LOG.info(\"{}\", zk.testableLocalSocketAddress());\n<line10>        LOG.info(\"{}\", zk.testableRemoteSocketAddress());\n<line11>        LOG.info(\"{}\", zk.toString());\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"{}\", zk.testableLocalSocketAddress());\n<line3>    LOG.info(\"{}\", zk.testableRemoteSocketAddress());\n<line4>    LOG.info(\"{}\", zk.toString());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.close(CONNECTION_TIMEOUT);\n<line3>}","output":"<line1>{\n<line2>    zk.close(CONNECTION_TIMEOUT);\n<line3>    LOG.info(\"{}\", zk.testableLocalSocketAddress());\n<line4>    LOG.info(\"{}\", zk.testableRemoteSocketAddress());\n<line5>    LOG.info(\"{}\", zk.toString());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeper zk = null;\n<line3>    try {\n<line4>        zk = createClient();\n<line5>        try {\n<line6>            zk.create(\"/acltest\", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line7>            fail(\"Should have received an invalid acl error\");\n<line8>        } catch (InvalidACLException e) {\n<line9>        }\n<line10>        try {\n<line11>            ArrayList<ACL> testACL = new ArrayList<>();\n<line12>            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));\n<line13>            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id(\"ip\", \"127.0.0.1/8\")));\n<line14>            zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line15>            fail(\"Should have received an invalid acl error\");\n<line16>        } catch (InvalidACLException e) {\n<line17>        }\n<line18>        try {\n<line19>            ArrayList<ACL> testACL = new ArrayList<>();\n<line20>            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));\n<line21>            zk.create(\"/nullidtest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line22>            fail(\"Should have received an invalid acl error\");\n<line23>        } catch (InvalidACLException e) {\n<line24>        }\n<line25>        zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line26>        ArrayList<ACL> testACL = new ArrayList<>();\n<line27>        testACL.add(new ACL(Perms.ALL, new Id(\"auth\", \"\")));\n<line28>        testACL.add(new ACL(Perms.WRITE, new Id(\"ip\", \"127.0.0.1\")));\n<line29>        zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line30>        zk.close();\n<line31>        zk = createClient();\n<line32>        zk.addAuthInfo(\"digest\", \"ben:passwd2\".getBytes());\n<line33>        if (skipACL) {\n<line34>            try {\n<line35>                zk.getData(\"/acltest\", false, null);\n<line36>            } catch (KeeperException e) {\n<line37>                fail(\"Badauth reads should succeed with skipACL.\");\n<line38>            }\n<line39>        } else {\n<line40>            try {\n<line41>                zk.getData(\"/acltest\", false, null);\n<line42>                fail(\"Should have received a permission error\");\n<line43>            } catch (KeeperException e) {\n<line44>                assertEquals(Code.NOAUTH, e.code());\n<line45>            }\n<line46>        }\n<line47>        zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line48>        zk.getData(\"/acltest\", false, null);\n<line49>        zk.setACL(\"/acltest\", Ids.OPEN_ACL_UNSAFE, -1);\n<line50>        zk.close();\n<line51>        zk = createClient();\n<line52>        zk.getData(\"/acltest\", false, null);\n<line53>        List<ACL> acls = zk.getACL(\"/acltest\", new Stat());\n<line54>        assertEquals(1, acls.size());\n<line55>        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line56>        // The stat parameter should be optional.\n<line57>        acls = zk.getACL(\"/acltest\", null);\n<line58>        assertEquals(1, acls.size());\n<line59>        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line60>        zk.close();\n<line61>    } finally {\n<line62>        if (zk != null) {\n<line63>            zk.close();\n<line64>        }\n<line65>    }\n<line66>}","output":"<line1>{\n<line2>    ZooKeeper zk = null;\n<line3>    try {\n<line4>        zk = createClient();\n<line5>        try {\n<line6>            zk.create(\"/acltest\", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line7>            fail(\"Should have received an invalid acl error\");\n<line8>        } catch (InvalidACLException e) {\n<line9>            LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line10>        }\n<line11>        try {\n<line12>            ArrayList<ACL> testACL = new ArrayList<>();\n<line13>            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));\n<line14>            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id(\"ip\", \"127.0.0.1/8\")));\n<line15>            zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line16>            fail(\"Should have received an invalid acl error\");\n<line17>        } catch (InvalidACLException e) {\n<line18>            LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line19>        }\n<line20>        try {\n<line21>            ArrayList<ACL> testACL = new ArrayList<>();\n<line22>            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));\n<line23>            zk.create(\"/nullidtest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line24>            fail(\"Should have received an invalid acl error\");\n<line25>        } catch (InvalidACLException e) {\n<line26>            LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line27>        }\n<line28>        zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line29>        ArrayList<ACL> testACL = new ArrayList<>();\n<line30>        testACL.add(new ACL(Perms.ALL, new Id(\"auth\", \"\")));\n<line31>        testACL.add(new ACL(Perms.WRITE, new Id(\"ip\", \"127.0.0.1\")));\n<line32>        zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line33>        zk.close();\n<line34>        zk = createClient();\n<line35>        zk.addAuthInfo(\"digest\", \"ben:passwd2\".getBytes());\n<line36>        if (skipACL) {\n<line37>            try {\n<line38>                zk.getData(\"/acltest\", false, null);\n<line39>            } catch (KeeperException e) {\n<line40>                fail(\"Badauth reads should succeed with skipACL.\");\n<line41>            }\n<line42>        } else {\n<line43>            try {\n<line44>                zk.getData(\"/acltest\", false, null);\n<line45>                fail(\"Should have received a permission error\");\n<line46>            } catch (KeeperException e) {\n<line47>                assertEquals(Code.NOAUTH, e.code());\n<line48>            }\n<line49>        }\n<line50>        zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line51>        zk.getData(\"/acltest\", false, null);\n<line52>        zk.setACL(\"/acltest\", Ids.OPEN_ACL_UNSAFE, -1);\n<line53>        zk.close();\n<line54>        zk = createClient();\n<line55>        zk.getData(\"/acltest\", false, null);\n<line56>        List<ACL> acls = zk.getACL(\"/acltest\", new Stat());\n<line57>        assertEquals(1, acls.size());\n<line58>        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line59>        // The stat parameter should be optional.\n<line60>        acls = zk.getACL(\"/acltest\", null);\n<line61>        assertEquals(1, acls.size());\n<line62>        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line63>        zk.close();\n<line64>    } finally {\n<line65>        if (zk != null) {\n<line66>            zk.close();\n<line67>        }\n<line68>    }\n<line69>}"},{"input":"","instruction":"<line1>{\n<line2>    zk = createClient();\n<line3>    try {\n<line4>        zk.create(\"/acltest\", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line5>        fail(\"Should have received an invalid acl error\");\n<line6>    } catch (InvalidACLException e) {\n<line7>    }\n<line8>    try {\n<line9>        ArrayList<ACL> testACL = new ArrayList<>();\n<line10>        testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));\n<line11>        testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id(\"ip\", \"127.0.0.1/8\")));\n<line12>        zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line13>        fail(\"Should have received an invalid acl error\");\n<line14>    } catch (InvalidACLException e) {\n<line15>    }\n<line16>    try {\n<line17>        ArrayList<ACL> testACL = new ArrayList<>();\n<line18>        testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));\n<line19>        zk.create(\"/nullidtest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line20>        fail(\"Should have received an invalid acl error\");\n<line21>    } catch (InvalidACLException e) {\n<line22>    }\n<line23>    zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line24>    ArrayList<ACL> testACL = new ArrayList<>();\n<line25>    testACL.add(new ACL(Perms.ALL, new Id(\"auth\", \"\")));\n<line26>    testACL.add(new ACL(Perms.WRITE, new Id(\"ip\", \"127.0.0.1\")));\n<line27>    zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line28>    zk.close();\n<line29>    zk = createClient();\n<line30>    zk.addAuthInfo(\"digest\", \"ben:passwd2\".getBytes());\n<line31>    if (skipACL) {\n<line32>        try {\n<line33>            zk.getData(\"/acltest\", false, null);\n<line34>        } catch (KeeperException e) {\n<line35>            fail(\"Badauth reads should succeed with skipACL.\");\n<line36>        }\n<line37>    } else {\n<line38>        try {\n<line39>            zk.getData(\"/acltest\", false, null);\n<line40>            fail(\"Should have received a permission error\");\n<line41>        } catch (KeeperException e) {\n<line42>            assertEquals(Code.NOAUTH, e.code());\n<line43>        }\n<line44>    }\n<line45>    zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line46>    zk.getData(\"/acltest\", false, null);\n<line47>    zk.setACL(\"/acltest\", Ids.OPEN_ACL_UNSAFE, -1);\n<line48>    zk.close();\n<line49>    zk = createClient();\n<line50>    zk.getData(\"/acltest\", false, null);\n<line51>    List<ACL> acls = zk.getACL(\"/acltest\", new Stat());\n<line52>    assertEquals(1, acls.size());\n<line53>    assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line54>    // The stat parameter should be optional.\n<line55>    acls = zk.getACL(\"/acltest\", null);\n<line56>    assertEquals(1, acls.size());\n<line57>    assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line58>    zk.close();\n<line59>}","output":"<line1>{\n<line2>    zk = createClient();\n<line3>    try {\n<line4>        zk.create(\"/acltest\", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line5>        fail(\"Should have received an invalid acl error\");\n<line6>    } catch (InvalidACLException e) {\n<line7>        LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line8>    }\n<line9>    try {\n<line10>        ArrayList<ACL> testACL = new ArrayList<>();\n<line11>        testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));\n<line12>        testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id(\"ip\", \"127.0.0.1/8\")));\n<line13>        zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line14>        fail(\"Should have received an invalid acl error\");\n<line15>    } catch (InvalidACLException e) {\n<line16>        LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line17>    }\n<line18>    try {\n<line19>        ArrayList<ACL> testACL = new ArrayList<>();\n<line20>        testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));\n<line21>        zk.create(\"/nullidtest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line22>        fail(\"Should have received an invalid acl error\");\n<line23>    } catch (InvalidACLException e) {\n<line24>        LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line25>    }\n<line26>    zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line27>    ArrayList<ACL> testACL = new ArrayList<>();\n<line28>    testACL.add(new ACL(Perms.ALL, new Id(\"auth\", \"\")));\n<line29>    testACL.add(new ACL(Perms.WRITE, new Id(\"ip\", \"127.0.0.1\")));\n<line30>    zk.create(\"/acltest\", new byte[0], testACL, CreateMode.PERSISTENT);\n<line31>    zk.close();\n<line32>    zk = createClient();\n<line33>    zk.addAuthInfo(\"digest\", \"ben:passwd2\".getBytes());\n<line34>    if (skipACL) {\n<line35>        try {\n<line36>            zk.getData(\"/acltest\", false, null);\n<line37>        } catch (KeeperException e) {\n<line38>            fail(\"Badauth reads should succeed with skipACL.\");\n<line39>        }\n<line40>    } else {\n<line41>        try {\n<line42>            zk.getData(\"/acltest\", false, null);\n<line43>            fail(\"Should have received a permission error\");\n<line44>        } catch (KeeperException e) {\n<line45>            assertEquals(Code.NOAUTH, e.code());\n<line46>        }\n<line47>    }\n<line48>    zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line49>    zk.getData(\"/acltest\", false, null);\n<line50>    zk.setACL(\"/acltest\", Ids.OPEN_ACL_UNSAFE, -1);\n<line51>    zk.close();\n<line52>    zk = createClient();\n<line53>    zk.getData(\"/acltest\", false, null);\n<line54>    List<ACL> acls = zk.getACL(\"/acltest\", new Stat());\n<line55>    assertEquals(1, acls.size());\n<line56>    assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line57>    // The stat parameter should be optional.\n<line58>    acls = zk.getACL(\"/acltest\", null);\n<line59>    assertEquals(1, acls.size());\n<line60>    assertEquals(Ids.OPEN_ACL_UNSAFE, acls);\n<line61>    zk.close();\n<line62>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Test successful, invalid acl received : {}\", e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeper zk = null;\n<line3>    try {\n<line4>        MyWatcher watcher = new MyWatcher();\n<line5>        zk = createClient(watcher, hostPort);\n<line6>        zk.create(\"/benwashere\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        try {\n<line8>            zk.setData(\"/benwashere\", \"hi\".getBytes(), 57);\n<line9>            fail(\"Should have gotten BadVersion exception\");\n<line10>        } catch (KeeperException.BadVersionException e) {\n<line11>            // expected that\n<line12>        } catch (KeeperException e) {\n<line13>            fail(\"Should have gotten BadVersion exception\");\n<line14>        }\n<line15>        zk.delete(\"/benwashere\", 0);\n<line16>        zk.close();\n<line17>        Thread.sleep(2000);\n<line18>        zk = createClient(watcher, hostPort);\n<line19>        try {\n<line20>            zk.delete(\"/\", -1);\n<line21>            fail(\"deleted root!\");\n<line22>        } catch (KeeperException.BadArgumentsException e) {\n<line23>            // good, expected that\n<line24>        }\n<line25>        Stat stat = new Stat();\n<line26>        // Test basic create, ls, and getData\n<line27>        zk.create(\"/pat\", \"Pat was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line28>        zk.create(\"/pat/ben\", \"Ben was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line29>        List<String> children = zk.getChildren(\"/pat\", false);\n<line30>        assertEquals(1, children.size());\n<line31>        assertEquals(\"ben\", children.get(0));\n<line32>        List<String> children2 = zk.getChildren(\"/pat\", false, null);\n<line33>        assertEquals(children, children2);\n<line34>        String value = new String(zk.getData(\"/pat/ben\", false, stat));\n<line35>        assertEquals(\"Ben was here\", value);\n<line36>        // Test stat and watch of non existent node\n<line37>        try {\n<line38>            if (withWatcherObj) {\n<line39>                assertEquals(null, zk.exists(\"/frog\", watcher));\n<line40>            } else {\n<line41>                assertEquals(null, zk.exists(\"/frog\", true));\n<line42>            }\n<line43>        } catch (KeeperException.NoNodeException e) {\n<line44>            // OK, expected that\n<line45>        }\n<line46>        zk.create(\"/frog\", \"hi\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line47>        // the first poll is just a session delivery\n<line48>        WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line49>        assertEquals(\"/frog\", event.getPath());\n<line50>        assertEquals(EventType.NodeCreated, event.getType());\n<line51>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line52>        // Test child watch and create with sequence\n<line53>        zk.getChildren(\"/pat/ben\", true);\n<line54>        for (int i = 0; i < 10; i++) {\n<line55>            zk.create(\"/pat/ben/\" + i + \"-\", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line56>        }\n<line57>        children = zk.getChildren(\"/pat/ben\", false);\n<line58>        Collections.sort(children);\n<line59>        assertEquals(10, children.size());\n<line60>        for (int i = 0; i < 10; i++) {\n<line61>            final String name = children.get(i);\n<line62>            assertTrue(name.startsWith(i + \"-\"), \"starts with -\");\n<line63>            byte[] b;\n<line64>            if (withWatcherObj) {\n<line65>                b = zk.getData(\"/pat/ben/\" + name, watcher, stat);\n<line66>            } else {\n<line67>                b = zk.getData(\"/pat/ben/\" + name, true, stat);\n<line68>            }\n<line69>            assertEquals(Integer.toString(i), new String(b));\n<line70>            zk.setData(\"/pat/ben/\" + name, \"new\".getBytes(), stat.getVersion());\n<line71>            if (withWatcherObj) {\n<line72>                stat = zk.exists(\"/pat/ben/\" + name, watcher);\n<line73>            } else {\n<line74>                stat = zk.exists(\"/pat/ben/\" + name, true);\n<line75>            }\n<line76>            zk.delete(\"/pat/ben/\" + name, stat.getVersion());\n<line77>        }\n<line78>        event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line79>        assertEquals(\"/pat/ben\", event.getPath());\n<line80>        assertEquals(EventType.NodeChildrenChanged, event.getType());\n<line81>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line82>        for (int i = 0; i < 10; i++) {\n<line83>            event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line84>            final String name = children.get(i);\n<line85>            assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line86>            assertEquals(EventType.NodeDataChanged, event.getType());\n<line87>            assertEquals(KeeperState.SyncConnected, event.getState());\n<line88>            event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line89>            assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line90>            assertEquals(EventType.NodeDeleted, event.getType());\n<line91>            assertEquals(KeeperState.SyncConnected, event.getState());\n<line92>        }\n<line93>        zk.create(\"/good\\u0040path\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line94>        zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line95>        try {\n<line96>            zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line97>            fail(\"duplicate create allowed\");\n<line98>        } catch (KeeperException.NodeExistsException e) {\n<line99>            // OK, expected that\n<line100>        }\n<line101>    } finally {\n<line102>        if (zk != null) {\n<line103>            zk.close();\n<line104>        }\n<line105>    }\n<line106>}","output":"<line1>{\n<line2>    ZooKeeper zk = null;\n<line3>    try {\n<line4>        MyWatcher watcher = new MyWatcher();\n<line5>        zk = createClient(watcher, hostPort);\n<line6>        LOG.info(\"Before create /benwashere\");\n<line7>        zk.create(\"/benwashere\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>        LOG.info(\"After create /benwashere\");\n<line9>        try {\n<line10>            zk.setData(\"/benwashere\", \"hi\".getBytes(), 57);\n<line11>            fail(\"Should have gotten BadVersion exception\");\n<line12>        } catch (KeeperException.BadVersionException e) {\n<line13>            // expected that\n<line14>        } catch (KeeperException e) {\n<line15>            fail(\"Should have gotten BadVersion exception\");\n<line16>        }\n<line17>        LOG.info(\"Before delete /benwashere\");\n<line18>        zk.delete(\"/benwashere\", 0);\n<line19>        LOG.info(\"After delete /benwashere\");\n<line20>        zk.close();\n<line21>        Thread.sleep(2000);\n<line22>        zk = createClient(watcher, hostPort);\n<line23>        LOG.info(\"Before delete /\");\n<line24>        try {\n<line25>            zk.delete(\"/\", -1);\n<line26>            fail(\"deleted root!\");\n<line27>        } catch (KeeperException.BadArgumentsException e) {\n<line28>            // good, expected that\n<line29>        }\n<line30>        Stat stat = new Stat();\n<line31>        // Test basic create, ls, and getData\n<line32>        zk.create(\"/pat\", \"Pat was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line33>        LOG.info(\"Before create /ben\");\n<line34>        zk.create(\"/pat/ben\", \"Ben was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line35>        LOG.info(\"Before getChildren /pat\");\n<line36>        List<String> children = zk.getChildren(\"/pat\", false);\n<line37>        assertEquals(1, children.size());\n<line38>        assertEquals(\"ben\", children.get(0));\n<line39>        List<String> children2 = zk.getChildren(\"/pat\", false, null);\n<line40>        assertEquals(children, children2);\n<line41>        String value = new String(zk.getData(\"/pat/ben\", false, stat));\n<line42>        assertEquals(\"Ben was here\", value);\n<line43>        // Test stat and watch of non existent node\n<line44>        try {\n<line45>            if (withWatcherObj) {\n<line46>                assertEquals(null, zk.exists(\"/frog\", watcher));\n<line47>            } else {\n<line48>                assertEquals(null, zk.exists(\"/frog\", true));\n<line49>            }\n<line50>            LOG.info(\"Comment: asseting passed for frog setting /\");\n<line51>        } catch (KeeperException.NoNodeException e) {\n<line52>            // OK, expected that\n<line53>        }\n<line54>        zk.create(\"/frog\", \"hi\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line55>        // the first poll is just a session delivery\n<line56>        LOG.info(\"Comment: checking for events length {}\", watcher.events.size());\n<line57>        WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line58>        assertEquals(\"/frog\", event.getPath());\n<line59>        assertEquals(EventType.NodeCreated, event.getType());\n<line60>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line61>        // Test child watch and create with sequence\n<line62>        zk.getChildren(\"/pat/ben\", true);\n<line63>        for (int i = 0; i < 10; i++) {\n<line64>            zk.create(\"/pat/ben/\" + i + \"-\", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line65>        }\n<line66>        children = zk.getChildren(\"/pat/ben\", false);\n<line67>        Collections.sort(children);\n<line68>        assertEquals(10, children.size());\n<line69>        for (int i = 0; i < 10; i++) {\n<line70>            final String name = children.get(i);\n<line71>            assertTrue(name.startsWith(i + \"-\"), \"starts with -\");\n<line72>            byte[] b;\n<line73>            if (withWatcherObj) {\n<line74>                b = zk.getData(\"/pat/ben/\" + name, watcher, stat);\n<line75>            } else {\n<line76>                b = zk.getData(\"/pat/ben/\" + name, true, stat);\n<line77>            }\n<line78>            assertEquals(Integer.toString(i), new String(b));\n<line79>            zk.setData(\"/pat/ben/\" + name, \"new\".getBytes(), stat.getVersion());\n<line80>            if (withWatcherObj) {\n<line81>                stat = zk.exists(\"/pat/ben/\" + name, watcher);\n<line82>            } else {\n<line83>                stat = zk.exists(\"/pat/ben/\" + name, true);\n<line84>            }\n<line85>            zk.delete(\"/pat/ben/\" + name, stat.getVersion());\n<line86>        }\n<line87>        event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line88>        assertEquals(\"/pat/ben\", event.getPath());\n<line89>        assertEquals(EventType.NodeChildrenChanged, event.getType());\n<line90>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line91>        for (int i = 0; i < 10; i++) {\n<line92>            event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line93>            final String name = children.get(i);\n<line94>            assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line95>            assertEquals(EventType.NodeDataChanged, event.getType());\n<line96>            assertEquals(KeeperState.SyncConnected, event.getState());\n<line97>            event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line98>            assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line99>            assertEquals(EventType.NodeDeleted, event.getType());\n<line100>            assertEquals(KeeperState.SyncConnected, event.getState());\n<line101>        }\n<line102>        zk.create(\"/good\\u0040path\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line103>        zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line104>        try {\n<line105>            zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line106>            fail(\"duplicate create allowed\");\n<line107>        } catch (KeeperException.NodeExistsException e) {\n<line108>            // OK, expected that\n<line109>        }\n<line110>    } finally {\n<line111>        if (zk != null) {\n<line112>            zk.close();\n<line113>        }\n<line114>    }\n<line115>}"},{"input":"","instruction":"<line1>{\n<line2>    MyWatcher watcher = new MyWatcher();\n<line3>    zk = createClient(watcher, hostPort);\n<line4>    zk.create(\"/benwashere\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    try {\n<line6>        zk.setData(\"/benwashere\", \"hi\".getBytes(), 57);\n<line7>        fail(\"Should have gotten BadVersion exception\");\n<line8>    } catch (KeeperException.BadVersionException e) {\n<line9>        // expected that\n<line10>    } catch (KeeperException e) {\n<line11>        fail(\"Should have gotten BadVersion exception\");\n<line12>    }\n<line13>    zk.delete(\"/benwashere\", 0);\n<line14>    zk.close();\n<line15>    Thread.sleep(2000);\n<line16>    zk = createClient(watcher, hostPort);\n<line17>    try {\n<line18>        zk.delete(\"/\", -1);\n<line19>        fail(\"deleted root!\");\n<line20>    } catch (KeeperException.BadArgumentsException e) {\n<line21>        // good, expected that\n<line22>    }\n<line23>    Stat stat = new Stat();\n<line24>    // Test basic create, ls, and getData\n<line25>    zk.create(\"/pat\", \"Pat was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line26>    zk.create(\"/pat/ben\", \"Ben was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line27>    List<String> children = zk.getChildren(\"/pat\", false);\n<line28>    assertEquals(1, children.size());\n<line29>    assertEquals(\"ben\", children.get(0));\n<line30>    List<String> children2 = zk.getChildren(\"/pat\", false, null);\n<line31>    assertEquals(children, children2);\n<line32>    String value = new String(zk.getData(\"/pat/ben\", false, stat));\n<line33>    assertEquals(\"Ben was here\", value);\n<line34>    // Test stat and watch of non existent node\n<line35>    try {\n<line36>        if (withWatcherObj) {\n<line37>            assertEquals(null, zk.exists(\"/frog\", watcher));\n<line38>        } else {\n<line39>            assertEquals(null, zk.exists(\"/frog\", true));\n<line40>        }\n<line41>    } catch (KeeperException.NoNodeException e) {\n<line42>        // OK, expected that\n<line43>    }\n<line44>    zk.create(\"/frog\", \"hi\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line45>    // the first poll is just a session delivery\n<line46>    WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line47>    assertEquals(\"/frog\", event.getPath());\n<line48>    assertEquals(EventType.NodeCreated, event.getType());\n<line49>    assertEquals(KeeperState.SyncConnected, event.getState());\n<line50>    // Test child watch and create with sequence\n<line51>    zk.getChildren(\"/pat/ben\", true);\n<line52>    for (int i = 0; i < 10; i++) {\n<line53>        zk.create(\"/pat/ben/\" + i + \"-\", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line54>    }\n<line55>    children = zk.getChildren(\"/pat/ben\", false);\n<line56>    Collections.sort(children);\n<line57>    assertEquals(10, children.size());\n<line58>    for (int i = 0; i < 10; i++) {\n<line59>        final String name = children.get(i);\n<line60>        assertTrue(name.startsWith(i + \"-\"), \"starts with -\");\n<line61>        byte[] b;\n<line62>        if (withWatcherObj) {\n<line63>            b = zk.getData(\"/pat/ben/\" + name, watcher, stat);\n<line64>        } else {\n<line65>            b = zk.getData(\"/pat/ben/\" + name, true, stat);\n<line66>        }\n<line67>        assertEquals(Integer.toString(i), new String(b));\n<line68>        zk.setData(\"/pat/ben/\" + name, \"new\".getBytes(), stat.getVersion());\n<line69>        if (withWatcherObj) {\n<line70>            stat = zk.exists(\"/pat/ben/\" + name, watcher);\n<line71>        } else {\n<line72>            stat = zk.exists(\"/pat/ben/\" + name, true);\n<line73>        }\n<line74>        zk.delete(\"/pat/ben/\" + name, stat.getVersion());\n<line75>    }\n<line76>    event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line77>    assertEquals(\"/pat/ben\", event.getPath());\n<line78>    assertEquals(EventType.NodeChildrenChanged, event.getType());\n<line79>    assertEquals(KeeperState.SyncConnected, event.getState());\n<line80>    for (int i = 0; i < 10; i++) {\n<line81>        event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line82>        final String name = children.get(i);\n<line83>        assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line84>        assertEquals(EventType.NodeDataChanged, event.getType());\n<line85>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line86>        event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line87>        assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line88>        assertEquals(EventType.NodeDeleted, event.getType());\n<line89>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line90>    }\n<line91>    zk.create(\"/good\\u0040path\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line92>    zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line93>    try {\n<line94>        zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line95>        fail(\"duplicate create allowed\");\n<line96>    } catch (KeeperException.NodeExistsException e) {\n<line97>        // OK, expected that\n<line98>    }\n<line99>}","output":"<line1>{\n<line2>    MyWatcher watcher = new MyWatcher();\n<line3>    zk = createClient(watcher, hostPort);\n<line4>    LOG.info(\"Before create /benwashere\");\n<line5>    zk.create(\"/benwashere\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    LOG.info(\"After create /benwashere\");\n<line7>    try {\n<line8>        zk.setData(\"/benwashere\", \"hi\".getBytes(), 57);\n<line9>        fail(\"Should have gotten BadVersion exception\");\n<line10>    } catch (KeeperException.BadVersionException e) {\n<line11>        // expected that\n<line12>    } catch (KeeperException e) {\n<line13>        fail(\"Should have gotten BadVersion exception\");\n<line14>    }\n<line15>    LOG.info(\"Before delete /benwashere\");\n<line16>    zk.delete(\"/benwashere\", 0);\n<line17>    LOG.info(\"After delete /benwashere\");\n<line18>    zk.close();\n<line19>    Thread.sleep(2000);\n<line20>    zk = createClient(watcher, hostPort);\n<line21>    LOG.info(\"Before delete /\");\n<line22>    try {\n<line23>        zk.delete(\"/\", -1);\n<line24>        fail(\"deleted root!\");\n<line25>    } catch (KeeperException.BadArgumentsException e) {\n<line26>        // good, expected that\n<line27>    }\n<line28>    Stat stat = new Stat();\n<line29>    // Test basic create, ls, and getData\n<line30>    zk.create(\"/pat\", \"Pat was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line31>    LOG.info(\"Before create /ben\");\n<line32>    zk.create(\"/pat/ben\", \"Ben was here\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line33>    LOG.info(\"Before getChildren /pat\");\n<line34>    List<String> children = zk.getChildren(\"/pat\", false);\n<line35>    assertEquals(1, children.size());\n<line36>    assertEquals(\"ben\", children.get(0));\n<line37>    List<String> children2 = zk.getChildren(\"/pat\", false, null);\n<line38>    assertEquals(children, children2);\n<line39>    String value = new String(zk.getData(\"/pat/ben\", false, stat));\n<line40>    assertEquals(\"Ben was here\", value);\n<line41>    // Test stat and watch of non existent node\n<line42>    try {\n<line43>        if (withWatcherObj) {\n<line44>            assertEquals(null, zk.exists(\"/frog\", watcher));\n<line45>        } else {\n<line46>            assertEquals(null, zk.exists(\"/frog\", true));\n<line47>        }\n<line48>        LOG.info(\"Comment: asseting passed for frog setting /\");\n<line49>    } catch (KeeperException.NoNodeException e) {\n<line50>        // OK, expected that\n<line51>    }\n<line52>    zk.create(\"/frog\", \"hi\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line53>    // the first poll is just a session delivery\n<line54>    LOG.info(\"Comment: checking for events length {}\", watcher.events.size());\n<line55>    WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line56>    assertEquals(\"/frog\", event.getPath());\n<line57>    assertEquals(EventType.NodeCreated, event.getType());\n<line58>    assertEquals(KeeperState.SyncConnected, event.getState());\n<line59>    // Test child watch and create with sequence\n<line60>    zk.getChildren(\"/pat/ben\", true);\n<line61>    for (int i = 0; i < 10; i++) {\n<line62>        zk.create(\"/pat/ben/\" + i + \"-\", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line63>    }\n<line64>    children = zk.getChildren(\"/pat/ben\", false);\n<line65>    Collections.sort(children);\n<line66>    assertEquals(10, children.size());\n<line67>    for (int i = 0; i < 10; i++) {\n<line68>        final String name = children.get(i);\n<line69>        assertTrue(name.startsWith(i + \"-\"), \"starts with -\");\n<line70>        byte[] b;\n<line71>        if (withWatcherObj) {\n<line72>            b = zk.getData(\"/pat/ben/\" + name, watcher, stat);\n<line73>        } else {\n<line74>            b = zk.getData(\"/pat/ben/\" + name, true, stat);\n<line75>        }\n<line76>        assertEquals(Integer.toString(i), new String(b));\n<line77>        zk.setData(\"/pat/ben/\" + name, \"new\".getBytes(), stat.getVersion());\n<line78>        if (withWatcherObj) {\n<line79>            stat = zk.exists(\"/pat/ben/\" + name, watcher);\n<line80>        } else {\n<line81>            stat = zk.exists(\"/pat/ben/\" + name, true);\n<line82>        }\n<line83>        zk.delete(\"/pat/ben/\" + name, stat.getVersion());\n<line84>    }\n<line85>    event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line86>    assertEquals(\"/pat/ben\", event.getPath());\n<line87>    assertEquals(EventType.NodeChildrenChanged, event.getType());\n<line88>    assertEquals(KeeperState.SyncConnected, event.getState());\n<line89>    for (int i = 0; i < 10; i++) {\n<line90>        event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line91>        final String name = children.get(i);\n<line92>        assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line93>        assertEquals(EventType.NodeDataChanged, event.getType());\n<line94>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line95>        event = watcher.events.poll(10, TimeUnit.SECONDS);\n<line96>        assertEquals(\"/pat/ben/\" + name, event.getPath());\n<line97>        assertEquals(EventType.NodeDeleted, event.getType());\n<line98>        assertEquals(KeeperState.SyncConnected, event.getState());\n<line99>    }\n<line100>    zk.create(\"/good\\u0040path\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line101>    zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line102>    try {\n<line103>        zk.create(\"/duplicate\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line104>        fail(\"duplicate create allowed\");\n<line105>    } catch (KeeperException.NodeExistsException e) {\n<line106>        // OK, expected that\n<line107>    }\n<line108>}"},{"input":"","instruction":"<line1>{\n<line2>    if (withWatcherObj) {\n<line3>        assertEquals(null, zk.exists(\"/frog\", watcher));\n<line4>    } else {\n<line5>        assertEquals(null, zk.exists(\"/frog\", true));\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (withWatcherObj) {\n<line3>        assertEquals(null, zk.exists(\"/frog\", watcher));\n<line4>    } else {\n<line5>        assertEquals(null, zk.exists(\"/frog\", true));\n<line6>    }\n<line7>    LOG.info(\"Comment: asseting passed for frog setting /\");\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        for (; current < count; current++) {\n<line4>            TestableZooKeeper zk = createClient();\n<line5>            // we've asked to close, wait for it to finish closing\n<line6>            // all the sub-threads otw the selector may not be\n<line7>            // closed when we check (false positive on test failure\n<line8>            zk.close(CONNECTION_TIMEOUT);\n<line9>        }\n<line10>    } catch (Throwable t) {\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        for (; current < count; current++) {\n<line4>            TestableZooKeeper zk = createClient();\n<line5>            // we've asked to close, wait for it to finish closing\n<line6>            // all the sub-threads otw the selector may not be\n<line7>            // closed when we check (false positive on test failure\n<line8>            zk.close(CONNECTION_TIMEOUT);\n<line9>        }\n<line10>    } catch (Throwable t) {\n<line11>        LOG.error(\"test failed\", t);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"test failed\", t);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    OSMXBean osMbean = new OSMXBean();\n<line3>    if (!osMbean.getUnix()) {\n<line4>        return;\n<line5>    }\n<line6>    final int threadCount = 3;\n<line7>    final int clientCount = 10;\n<line8>    /* Log the number of fds used before and after a test is run. Verifies\n<line9>         * we are freeing resources correctly. Unfortunately this only works\n<line10>         * on unix systems (the only place sun has implemented as part of the\n<line11>         * mgmt bean api).\n<line12>         */\n<line13>    long initialFdCount = osMbean.getOpenFileDescriptorCount();\n<line14>    VerifyClientCleanup[] threads = new VerifyClientCleanup[threadCount];\n<line15>    for (int i = 0; i < threads.length; i++) {\n<line16>        threads[i] = new VerifyClientCleanup(\"VCC\" + i, clientCount);\n<line17>        threads[i].start();\n<line18>    }\n<line19>    for (int i = 0; i < threads.length; i++) {\n<line20>        threads[i].join(CONNECTION_TIMEOUT);\n<line21>        assertTrue(threads[i].current == threads[i].count);\n<line22>    }\n<line23>    // if this fails it means we are not cleaning up after the closed\n<line24>    // sessions.\n<line25>    long currentCount = osMbean.getOpenFileDescriptorCount();\n<line26>    final String logmsg = \"open fds after test ({}) are not significantly higher than before ({})\";\n<line27>    if (currentCount > initialFdCount + 10) {\n<line28>        // consider as error\n<line29>    } else {\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    OSMXBean osMbean = new OSMXBean();\n<line3>    if (!osMbean.getUnix()) {\n<line4>        LOG.warn(\"skipping testClientCleanup, only available on Unix\");\n<line5>        return;\n<line6>    }\n<line7>    final int threadCount = 3;\n<line8>    final int clientCount = 10;\n<line9>    /* Log the number of fds used before and after a test is run. Verifies\n<line10>         * we are freeing resources correctly. Unfortunately this only works\n<line11>         * on unix systems (the only place sun has implemented as part of the\n<line12>         * mgmt bean api).\n<line13>         */\n<line14>    long initialFdCount = osMbean.getOpenFileDescriptorCount();\n<line15>    VerifyClientCleanup[] threads = new VerifyClientCleanup[threadCount];\n<line16>    for (int i = 0; i < threads.length; i++) {\n<line17>        threads[i] = new VerifyClientCleanup(\"VCC\" + i, clientCount);\n<line18>        threads[i].start();\n<line19>    }\n<line20>    for (int i = 0; i < threads.length; i++) {\n<line21>        threads[i].join(CONNECTION_TIMEOUT);\n<line22>        assertTrue(threads[i].current == threads[i].count);\n<line23>    }\n<line24>    // if this fails it means we are not cleaning up after the closed\n<line25>    // sessions.\n<line26>    long currentCount = osMbean.getOpenFileDescriptorCount();\n<line27>    final String logmsg = \"open fds after test ({}) are not significantly higher than before ({})\";\n<line28>    if (currentCount > initialFdCount + 10) {\n<line29>        // consider as error\n<line30>        LOG.error(logmsg, currentCount, initialFdCount);\n<line31>    } else {\n<line32>        LOG.info(logmsg, currentCount, initialFdCount);\n<line33>    }\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    // consider as error\n<line3>}","output":"<line1>{\n<line2>    // consider as error\n<line3>    LOG.error(logmsg, currentCount, initialFdCount);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(logmsg, currentCount, initialFdCount);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    setupTestEnv();\n<line3>    JMXEnv.setUp();\n<line4>    setUpAll();\n<line5>    port1 = PortAssignment.unique();\n<line6>    port2 = PortAssignment.unique();\n<line7>    port3 = PortAssignment.unique();\n<line8>    port4 = PortAssignment.unique();\n<line9>    port5 = PortAssignment.unique();\n<line10>    portLE1 = PortAssignment.unique();\n<line11>    portLE2 = PortAssignment.unique();\n<line12>    portLE3 = PortAssignment.unique();\n<line13>    portLE4 = PortAssignment.unique();\n<line14>    portLE5 = PortAssignment.unique();\n<line15>    portClient1 = PortAssignment.unique();\n<line16>    portClient2 = PortAssignment.unique();\n<line17>    portClient3 = PortAssignment.unique();\n<line18>    portClient4 = PortAssignment.unique();\n<line19>    portClient5 = PortAssignment.unique();\n<line20>    hostPort = \"127.0.0.1:\" + portClient1 + \",127.0.0.1:\" + portClient2 + \",127.0.0.1:\" + portClient3 + \",127.0.0.1:\" + portClient4 + \",127.0.0.1:\" + portClient5;\n<line21>    s1dir = ClientBase.createTmpDir();\n<line22>    s2dir = ClientBase.createTmpDir();\n<line23>    s3dir = ClientBase.createTmpDir();\n<line24>    s4dir = ClientBase.createTmpDir();\n<line25>    s5dir = ClientBase.createTmpDir();\n<line26>    startServers(withObservers, withOracle);\n<line27>    OSMXBean osMbean = new OSMXBean();\n<line28>    if (osMbean.getUnix()) {\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    LOG.info(\"QuorumBase.setup {}\", getTestName());\n<line3>    setupTestEnv();\n<line4>    JMXEnv.setUp();\n<line5>    setUpAll();\n<line6>    port1 = PortAssignment.unique();\n<line7>    port2 = PortAssignment.unique();\n<line8>    port3 = PortAssignment.unique();\n<line9>    port4 = PortAssignment.unique();\n<line10>    port5 = PortAssignment.unique();\n<line11>    portLE1 = PortAssignment.unique();\n<line12>    portLE2 = PortAssignment.unique();\n<line13>    portLE3 = PortAssignment.unique();\n<line14>    portLE4 = PortAssignment.unique();\n<line15>    portLE5 = PortAssignment.unique();\n<line16>    portClient1 = PortAssignment.unique();\n<line17>    portClient2 = PortAssignment.unique();\n<line18>    portClient3 = PortAssignment.unique();\n<line19>    portClient4 = PortAssignment.unique();\n<line20>    portClient5 = PortAssignment.unique();\n<line21>    hostPort = \"127.0.0.1:\" + portClient1 + \",127.0.0.1:\" + portClient2 + \",127.0.0.1:\" + portClient3 + \",127.0.0.1:\" + portClient4 + \",127.0.0.1:\" + portClient5;\n<line22>    LOG.info(\"Ports are: {}\", hostPort);\n<line23>    s1dir = ClientBase.createTmpDir();\n<line24>    s2dir = ClientBase.createTmpDir();\n<line25>    s3dir = ClientBase.createTmpDir();\n<line26>    s4dir = ClientBase.createTmpDir();\n<line27>    s5dir = ClientBase.createTmpDir();\n<line28>    startServers(withObservers, withOracle);\n<line29>    OSMXBean osMbean = new OSMXBean();\n<line30>    if (osMbean.getUnix()) {\n<line31>        LOG.info(\"Initial fdcount is: {}\", osMbean.getOpenFileDescriptorCount());\n<line32>    }\n<line33>    LOG.info(\"Setup finished\");\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Initial fdcount is: {}\", osMbean.getOpenFileDescriptorCount());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    Map<Long, QuorumServer> peers = new HashMap<>();\n<line7>    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));\n<line8>    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));\n<line9>    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));\n<line10>    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));\n<line11>    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));\n<line12>    if (withObservers) {\n<line13>        peers.get(Long.valueOf(4)).type = LearnerType.OBSERVER;\n<line14>        peers.get(Long.valueOf(5)).type = LearnerType.OBSERVER;\n<line15>    }\n<line16>    if (!withOracle) {\n<line17>        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line18>        assertEquals(portClient1, s1.getClientPort());\n<line19>        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line20>        assertEquals(portClient2, s2.getClientPort());\n<line21>        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line22>        assertEquals(portClient3, s3.getClientPort());\n<line23>        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line24>        assertEquals(portClient4, s4.getClientPort());\n<line25>        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line26>        assertEquals(portClient5, s5.getClientPort());\n<line27>    } else {\n<line28>        createOraclePath();\n<line29>        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_0 + mastership);\n<line30>        assertEquals(portClient1, s1.getClientPort());\n<line31>        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_1 + mastership);\n<line32>        assertEquals(portClient2, s2.getClientPort());\n<line33>        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_2 + mastership);\n<line34>        assertEquals(portClient3, s3.getClientPort());\n<line35>        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_3 + mastership);\n<line36>        assertEquals(portClient4, s4.getClientPort());\n<line37>        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_4 + mastership);\n<line38>        assertEquals(portClient5, s5.getClientPort());\n<line39>    }\n<line40>    if (withObservers) {\n<line41>        s4.setLearnerType(LearnerType.OBSERVER);\n<line42>        s5.setLearnerType(LearnerType.OBSERVER);\n<line43>    }\n<line44>    s1.enableLocalSessions(localSessionsEnabled);\n<line45>    s2.enableLocalSessions(localSessionsEnabled);\n<line46>    s3.enableLocalSessions(localSessionsEnabled);\n<line47>    s4.enableLocalSessions(localSessionsEnabled);\n<line48>    s5.enableLocalSessions(localSessionsEnabled);\n<line49>    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line50>    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line51>    s3.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line52>    s4.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line53>    s5.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line54>    s1.start();\n<line55>    s2.start();\n<line56>    s3.start();\n<line57>    s4.start();\n<line58>    s5.start();\n<line59>    for (String hp : hostPort.split(\",\")) {\n<line60>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line61>    }\n<line62>    // interesting to see what's there...\n<line63>    JMXEnv.dump();\n<line64>    // make sure we have these 5 servers listed\n<line65>    Set<String> ensureNames = new LinkedHashSet<>();\n<line66>    for (int i = 1; i <= 5; i++) {\n<line67>        ensureNames.add(\"InMemoryDataTree\");\n<line68>    }\n<line69>    for (int i = 1; i <= 5; i++) {\n<line70>        ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line71>    }\n<line72>    for (int i = 1; i <= 5; i++) {\n<line73>        for (int j = 1; j <= 5; j++) {\n<line74>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line75>        }\n<line76>    }\n<line77>    for (int i = 1; i <= 5; i++) {\n<line78>        ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line79>    }\n<line80>    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line81>}","output":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    Map<Long, QuorumServer> peers = new HashMap<>();\n<line7>    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));\n<line8>    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));\n<line9>    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));\n<line10>    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));\n<line11>    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));\n<line12>    if (withObservers) {\n<line13>        peers.get(Long.valueOf(4)).type = LearnerType.OBSERVER;\n<line14>        peers.get(Long.valueOf(5)).type = LearnerType.OBSERVER;\n<line15>    }\n<line16>    if (!withOracle) {\n<line17>        LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line18>        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line19>        assertEquals(portClient1, s1.getClientPort());\n<line20>        LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line21>        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line22>        assertEquals(portClient2, s2.getClientPort());\n<line23>        LOG.info(\"creating QuorumPeer 3 port {}\", portClient3);\n<line24>        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line25>        assertEquals(portClient3, s3.getClientPort());\n<line26>        LOG.info(\"creating QuorumPeer 4 port {}\", portClient4);\n<line27>        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line28>        assertEquals(portClient4, s4.getClientPort());\n<line29>        LOG.info(\"creating QuorumPeer 5 port {}\", portClient5);\n<line30>        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line31>        assertEquals(portClient5, s5.getClientPort());\n<line32>    } else {\n<line33>        createOraclePath();\n<line34>        LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line35>        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_0 + mastership);\n<line36>        assertEquals(portClient1, s1.getClientPort());\n<line37>        LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line38>        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_1 + mastership);\n<line39>        assertEquals(portClient2, s2.getClientPort());\n<line40>        LOG.info(\"creating QuorumPeer 3 port {}\", portClient3);\n<line41>        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_2 + mastership);\n<line42>        assertEquals(portClient3, s3.getClientPort());\n<line43>        LOG.info(\"creating QuorumPeer 4 port {}\", portClient4);\n<line44>        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_3 + mastership);\n<line45>        assertEquals(portClient4, s4.getClientPort());\n<line46>        LOG.info(\"creating QuorumPeer 5 port {}\", portClient5);\n<line47>        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_4 + mastership);\n<line48>        assertEquals(portClient5, s5.getClientPort());\n<line49>    }\n<line50>    if (withObservers) {\n<line51>        s4.setLearnerType(LearnerType.OBSERVER);\n<line52>        s5.setLearnerType(LearnerType.OBSERVER);\n<line53>    }\n<line54>    LOG.info(\"QuorumPeer 1 voting view: {}\", s1.getVotingView());\n<line55>    LOG.info(\"QuorumPeer 2 voting view: {}\", s2.getVotingView());\n<line56>    LOG.info(\"QuorumPeer 3 voting view: {}\", s3.getVotingView());\n<line57>    LOG.info(\"QuorumPeer 4 voting view: {}\", s4.getVotingView());\n<line58>    LOG.info(\"QuorumPeer 5 voting view: {}\", s5.getVotingView());\n<line59>    s1.enableLocalSessions(localSessionsEnabled);\n<line60>    s2.enableLocalSessions(localSessionsEnabled);\n<line61>    s3.enableLocalSessions(localSessionsEnabled);\n<line62>    s4.enableLocalSessions(localSessionsEnabled);\n<line63>    s5.enableLocalSessions(localSessionsEnabled);\n<line64>    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line65>    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line66>    s3.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line67>    s4.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line68>    s5.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);\n<line69>    LOG.info(\"start QuorumPeer 1\");\n<line70>    s1.start();\n<line71>    LOG.info(\"start QuorumPeer 2\");\n<line72>    s2.start();\n<line73>    LOG.info(\"start QuorumPeer 3\");\n<line74>    s3.start();\n<line75>    LOG.info(\"start QuorumPeer 4\");\n<line76>    s4.start();\n<line77>    LOG.info(\"start QuorumPeer 5\");\n<line78>    s5.start();\n<line79>    LOG.info(\"started QuorumPeer 5\");\n<line80>    LOG.info(\"Checking ports {}\", hostPort);\n<line81>    for (String hp : hostPort.split(\",\")) {\n<line82>        assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line83>        LOG.info(\"{} is accepting client connections\", hp);\n<line84>    }\n<line85>    // interesting to see what's there...\n<line86>    JMXEnv.dump();\n<line87>    // make sure we have these 5 servers listed\n<line88>    Set<String> ensureNames = new LinkedHashSet<>();\n<line89>    for (int i = 1; i <= 5; i++) {\n<line90>        ensureNames.add(\"InMemoryDataTree\");\n<line91>    }\n<line92>    for (int i = 1; i <= 5; i++) {\n<line93>        ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line94>    }\n<line95>    for (int i = 1; i <= 5; i++) {\n<line96>        for (int j = 1; j <= 5; j++) {\n<line97>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line98>        }\n<line99>    }\n<line100>    for (int i = 1; i <= 5; i++) {\n<line101>        ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line102>    }\n<line103>    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line104>}"},{"input":"","instruction":"<line1>{\n<line2>    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line3>    assertEquals(portClient1, s1.getClientPort());\n<line4>    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line5>    assertEquals(portClient2, s2.getClientPort());\n<line6>    s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line7>    assertEquals(portClient3, s3.getClientPort());\n<line8>    s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line9>    assertEquals(portClient4, s4.getClientPort());\n<line10>    s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line11>    assertEquals(portClient5, s5.getClientPort());\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line3>    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line4>    assertEquals(portClient1, s1.getClientPort());\n<line5>    LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line6>    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line7>    assertEquals(portClient2, s2.getClientPort());\n<line8>    LOG.info(\"creating QuorumPeer 3 port {}\", portClient3);\n<line9>    s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line10>    assertEquals(portClient3, s3.getClientPort());\n<line11>    LOG.info(\"creating QuorumPeer 4 port {}\", portClient4);\n<line12>    s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line13>    assertEquals(portClient4, s4.getClientPort());\n<line14>    LOG.info(\"creating QuorumPeer 5 port {}\", portClient5);\n<line15>    s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line16>    assertEquals(portClient5, s5.getClientPort());\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    createOraclePath();\n<line3>    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_0 + mastership);\n<line4>    assertEquals(portClient1, s1.getClientPort());\n<line5>    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_1 + mastership);\n<line6>    assertEquals(portClient2, s2.getClientPort());\n<line7>    s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_2 + mastership);\n<line8>    assertEquals(portClient3, s3.getClientPort());\n<line9>    s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_3 + mastership);\n<line10>    assertEquals(portClient4, s4.getClientPort());\n<line11>    s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_4 + mastership);\n<line12>    assertEquals(portClient5, s5.getClientPort());\n<line13>}","output":"<line1>{\n<line2>    createOraclePath();\n<line3>    LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line4>    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_0 + mastership);\n<line5>    assertEquals(portClient1, s1.getClientPort());\n<line6>    LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line7>    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_1 + mastership);\n<line8>    assertEquals(portClient2, s2.getClientPort());\n<line9>    LOG.info(\"creating QuorumPeer 3 port {}\", portClient3);\n<line10>    s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_2 + mastership);\n<line11>    assertEquals(portClient3, s3.getClientPort());\n<line12>    LOG.info(\"creating QuorumPeer 4 port {}\", portClient4);\n<line13>    s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_3 + mastership);\n<line14>    assertEquals(portClient4, s4.getClientPort());\n<line15>    LOG.info(\"creating QuorumPeer 5 port {}\", portClient5);\n<line16>    s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, oracleDir.getAbsolutePath() + oraclePath_4 + mastership);\n<line17>    assertEquals(portClient5, s5.getClientPort());\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line3>    LOG.info(\"{} is accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    StringBuilder hosts = new StringBuilder();\n<line3>    for (QuorumPeer p : getPeerList()) {\n<line4>        if (p.getPeerState() == state) {\n<line5>            hosts.append(String.format(\"%s:%d,\", LOCALADDR, p.getClientAddress().getPort()));\n<line6>        }\n<line7>    }\n<line8>    return hosts.toString();\n<line9>}","output":"<line1>{\n<line2>    StringBuilder hosts = new StringBuilder();\n<line3>    for (QuorumPeer p : getPeerList()) {\n<line4>        if (p.getPeerState() == state) {\n<line5>            hosts.append(String.format(\"%s:%d,\", LOCALADDR, p.getClientAddress().getPort()));\n<line6>        }\n<line7>    }\n<line8>    LOG.info(\"getPeersMatching ports are {}\", hosts);\n<line9>    return hosts.toString();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    if (peers == null) {\n<line7>        peers = new HashMap<>();\n<line8>        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));\n<line9>        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));\n<line10>        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));\n<line11>        peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));\n<line12>        peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));\n<line13>    }\n<line14>    switch(i) {\n<line15>        case 1:\n<line16>            s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line17>            assertEquals(portClient1, s1.getClientPort());\n<line18>            break;\n<line19>        case 2:\n<line20>            s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line21>            assertEquals(portClient2, s2.getClientPort());\n<line22>            break;\n<line23>        case 3:\n<line24>            s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line25>            assertEquals(portClient3, s3.getClientPort());\n<line26>            break;\n<line27>        case 4:\n<line28>            s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line29>            assertEquals(portClient4, s4.getClientPort());\n<line30>            break;\n<line31>        case 5:\n<line32>            s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line33>            assertEquals(portClient5, s5.getClientPort());\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    int tickTime = 2000;\n<line3>    int initLimit = 3;\n<line4>    int syncLimit = 3;\n<line5>    int connectToLearnerMasterLimit = 3;\n<line6>    if (peers == null) {\n<line7>        peers = new HashMap<>();\n<line8>        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));\n<line9>        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));\n<line10>        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));\n<line11>        peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));\n<line12>        peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));\n<line13>    }\n<line14>    switch(i) {\n<line15>        case 1:\n<line16>            LOG.info(\"creating QuorumPeer 1 port {}\", portClient1);\n<line17>            s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line18>            assertEquals(portClient1, s1.getClientPort());\n<line19>            break;\n<line20>        case 2:\n<line21>            LOG.info(\"creating QuorumPeer 2 port {}\", portClient2);\n<line22>            s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line23>            assertEquals(portClient2, s2.getClientPort());\n<line24>            break;\n<line25>        case 3:\n<line26>            LOG.info(\"creating QuorumPeer 3 port {}\", portClient3);\n<line27>            s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line28>            assertEquals(portClient3, s3.getClientPort());\n<line29>            break;\n<line30>        case 4:\n<line31>            LOG.info(\"creating QuorumPeer 4 port {}\", portClient4);\n<line32>            s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line33>            assertEquals(portClient4, s4.getClientPort());\n<line34>            break;\n<line35>        case 5:\n<line36>            LOG.info(\"creating QuorumPeer 5 port {}\", portClient5);\n<line37>            s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line38>            assertEquals(portClient5, s5.getClientPort());\n<line39>    }\n<line40>}"},{"input":"","instruction":"<line1>{\n<line2>    if (oracleDir != null) {\n<line3>        ClientBase.recursiveDelete(oracleDir);\n<line4>    }\n<line5>    OSMXBean osMbean = new OSMXBean();\n<line6>    if (osMbean.getUnix()) {\n<line7>    }\n<line8>    shutdownServers();\n<line9>    for (String hp : hostPort.split(\",\")) {\n<line10>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line11>    }\n<line12>    JMXEnv.tearDown();\n<line13>}","output":"<line1>{\n<line2>    LOG.info(\"TearDown started\");\n<line3>    if (oracleDir != null) {\n<line4>        ClientBase.recursiveDelete(oracleDir);\n<line5>    }\n<line6>    OSMXBean osMbean = new OSMXBean();\n<line7>    if (osMbean.getUnix()) {\n<line8>        LOG.info(\"fdcount after test is: {}\", osMbean.getOpenFileDescriptorCount());\n<line9>    }\n<line10>    shutdownServers();\n<line11>    for (String hp : hostPort.split(\",\")) {\n<line12>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line13>        LOG.info(\"{} is no longer accepting client connections\", hp);\n<line14>    }\n<line15>    JMXEnv.tearDown();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"fdcount after test is: {}\", osMbean.getOpenFileDescriptorCount());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line3>    LOG.info(\"{} is no longer accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (qp == null) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        qp.shutdown();\n<line7>        Election e = qp.getElectionAlg();\n<line8>        if (e != null) {\n<line9>            e.shutdown();\n<line10>        } else {\n<line11>        }\n<line12>        long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line13>        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line14>        long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line15>        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line16>        qp.join(maxTimeout * 2);\n<line17>        if (qp.isAlive()) {\n<line18>            fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line19>        }\n<line20>    } catch (InterruptedException e) {\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    if (qp == null) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        LOG.info(\"Shutting down quorum peer {}\", qp.getName());\n<line7>        qp.shutdown();\n<line8>        Election e = qp.getElectionAlg();\n<line9>        if (e != null) {\n<line10>            LOG.info(\"Shutting down leader election {}\", qp.getName());\n<line11>            e.shutdown();\n<line12>        } else {\n<line13>            LOG.info(\"No election available to shutdown {}\", qp.getName());\n<line14>        }\n<line15>        LOG.info(\"Waiting for {} to exit thread\", qp.getName());\n<line16>        long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line17>        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line18>        long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line19>        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line20>        qp.join(maxTimeout * 2);\n<line21>        if (qp.isAlive()) {\n<line22>            fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line23>        }\n<line24>    } catch (InterruptedException e) {\n<line25>        LOG.debug(\"QP interrupted: {}\", qp.getName(), e);\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    qp.shutdown();\n<line3>    Election e = qp.getElectionAlg();\n<line4>    if (e != null) {\n<line5>        e.shutdown();\n<line6>    } else {\n<line7>    }\n<line8>    long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line9>    long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line10>    long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line11>    maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line12>    qp.join(maxTimeout * 2);\n<line13>    if (qp.isAlive()) {\n<line14>        fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down quorum peer {}\", qp.getName());\n<line3>    qp.shutdown();\n<line4>    Election e = qp.getElectionAlg();\n<line5>    if (e != null) {\n<line6>        LOG.info(\"Shutting down leader election {}\", qp.getName());\n<line7>        e.shutdown();\n<line8>    } else {\n<line9>        LOG.info(\"No election available to shutdown {}\", qp.getName());\n<line10>    }\n<line11>    LOG.info(\"Waiting for {} to exit thread\", qp.getName());\n<line12>    long readTimeout = qp.getTickTime() * qp.getInitLimit();\n<line13>    long connectTimeout = qp.getTickTime() * qp.getSyncLimit();\n<line14>    long maxTimeout = Math.max(readTimeout, connectTimeout);\n<line15>    maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);\n<line16>    qp.join(maxTimeout * 2);\n<line17>    if (qp.isAlive()) {\n<line18>        fail(\"QP failed to shutdown in \" + (maxTimeout * 2) + \" seconds: \" + qp.getName());\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    e.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down leader election {}\", qp.getName());\n<line3>    e.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"No election available to shutdown {}\", qp.getName());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"QP interrupted: {}\", qp.getName(), e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try (ZooKeeper zk = createClient()) {\n<line3>        zk.create(\"/path1\", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line4>        fail(\"Should have gotten exception.\");\n<line5>    } catch (Exception e) {\n<line6>        // ok, exception as expected.\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try (ZooKeeper zk = createClient()) {\n<line3>        zk.create(\"/path1\", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);\n<line4>        fail(\"Should have gotten exception.\");\n<line5>    } catch (Exception e) {\n<line6>        // ok, exception as expected.\n<line7>        LOG.debug(\"Got exception as expected\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    // ok, exception as expected.\n<line3>}","output":"<line1>{\n<line2>    // ok, exception as expected.\n<line3>    LOG.debug(\"Got exception as expected\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    assertTrue(resp.contains(expected));\n<line4>}","output":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    LOG.info(\"cmd {} expected {} got {}\", cmd, expected, resp);\n<line4>    assertTrue(resp.contains(expected));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    assertTrue(resp.trim().equals(expected));\n<line4>}","output":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    LOG.info(\"cmd {} expected an exact match of {}; got {}\", cmd, expected, resp);\n<line4>    assertTrue(resp.trim().equals(expected));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        ClientBase.setupTestEnv();\n<line4>        JMXEnv.setUp();\n<line5>        N = n;\n<line6>        ALL = 2 * N + 1;\n<line7>        tickTime = 2000;\n<line8>        initLimit = 3;\n<line9>        this.syncLimit = syncLimit;\n<line10>        connectToLearnerMasterLimit = 3;\n<line11>        electionAlg = 3;\n<line12>        hostPort = \"\";\n<line13>        for (int i = 1; i <= ALL; ++i) {\n<line14>            PeerStruct ps = new PeerStruct();\n<line15>            ps.id = i;\n<line16>            ps.dataDir = ClientBase.createTmpDir();\n<line17>            ps.clientPort = PortAssignment.unique();\n<line18>            peers.put(i, ps);\n<line19>            peersView.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", ps.clientPort), LearnerType.PARTICIPANT));\n<line20>            hostPort += \"127.0.0.1:\" + ps.clientPort + ((i == ALL) ? \"\" : \",\");\n<line21>        }\n<line22>        for (int i = 1; i <= ALL; ++i) {\n<line23>            PeerStruct ps = peers.get(i);\n<line24>            ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line25>            assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line26>        }\n<line27>    } catch (Exception e) {\n<line28>        throw new RuntimeException(e);\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    try {\n<line3>        ClientBase.setupTestEnv();\n<line4>        JMXEnv.setUp();\n<line5>        N = n;\n<line6>        ALL = 2 * N + 1;\n<line7>        tickTime = 2000;\n<line8>        initLimit = 3;\n<line9>        this.syncLimit = syncLimit;\n<line10>        connectToLearnerMasterLimit = 3;\n<line11>        electionAlg = 3;\n<line12>        hostPort = \"\";\n<line13>        for (int i = 1; i <= ALL; ++i) {\n<line14>            PeerStruct ps = new PeerStruct();\n<line15>            ps.id = i;\n<line16>            ps.dataDir = ClientBase.createTmpDir();\n<line17>            ps.clientPort = PortAssignment.unique();\n<line18>            peers.put(i, ps);\n<line19>            peersView.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", ps.clientPort), LearnerType.PARTICIPANT));\n<line20>            hostPort += \"127.0.0.1:\" + ps.clientPort + ((i == ALL) ? \"\" : \",\");\n<line21>        }\n<line22>        for (int i = 1; i <= ALL; ++i) {\n<line23>            PeerStruct ps = peers.get(i);\n<line24>            LOG.info(\"Creating QuorumPeer {}; public port {}\", i, ps.clientPort);\n<line25>            ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line26>            assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line27>        }\n<line28>    } catch (Exception e) {\n<line29>        throw new RuntimeException(e);\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    ClientBase.setupTestEnv();\n<line3>    JMXEnv.setUp();\n<line4>    N = n;\n<line5>    ALL = 2 * N + 1;\n<line6>    tickTime = 2000;\n<line7>    initLimit = 3;\n<line8>    this.syncLimit = syncLimit;\n<line9>    connectToLearnerMasterLimit = 3;\n<line10>    electionAlg = 3;\n<line11>    hostPort = \"\";\n<line12>    for (int i = 1; i <= ALL; ++i) {\n<line13>        PeerStruct ps = new PeerStruct();\n<line14>        ps.id = i;\n<line15>        ps.dataDir = ClientBase.createTmpDir();\n<line16>        ps.clientPort = PortAssignment.unique();\n<line17>        peers.put(i, ps);\n<line18>        peersView.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", ps.clientPort), LearnerType.PARTICIPANT));\n<line19>        hostPort += \"127.0.0.1:\" + ps.clientPort + ((i == ALL) ? \"\" : \",\");\n<line20>    }\n<line21>    for (int i = 1; i <= ALL; ++i) {\n<line22>        PeerStruct ps = peers.get(i);\n<line23>        ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line24>        assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    ClientBase.setupTestEnv();\n<line3>    JMXEnv.setUp();\n<line4>    N = n;\n<line5>    ALL = 2 * N + 1;\n<line6>    tickTime = 2000;\n<line7>    initLimit = 3;\n<line8>    this.syncLimit = syncLimit;\n<line9>    connectToLearnerMasterLimit = 3;\n<line10>    electionAlg = 3;\n<line11>    hostPort = \"\";\n<line12>    for (int i = 1; i <= ALL; ++i) {\n<line13>        PeerStruct ps = new PeerStruct();\n<line14>        ps.id = i;\n<line15>        ps.dataDir = ClientBase.createTmpDir();\n<line16>        ps.clientPort = PortAssignment.unique();\n<line17>        peers.put(i, ps);\n<line18>        peersView.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", ps.clientPort), LearnerType.PARTICIPANT));\n<line19>        hostPort += \"127.0.0.1:\" + ps.clientPort + ((i == ALL) ? \"\" : \",\");\n<line20>    }\n<line21>    for (int i = 1; i <= ALL; ++i) {\n<line22>        PeerStruct ps = peers.get(i);\n<line23>        LOG.info(\"Creating QuorumPeer {}; public port {}\", i, ps.clientPort);\n<line24>        ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line25>        assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    PeerStruct ps = peers.get(i);\n<line3>    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line4>    assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line5>}","output":"<line1>{\n<line2>    PeerStruct ps = peers.get(i);\n<line3>    LOG.info(\"Creating QuorumPeer {}; public port {}\", i, ps.clientPort);\n<line4>    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line5>    assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    shutdownAll();\n<line3>    for (int i = 1; i <= ALL; ++i) {\n<line4>        start(i);\n<line5>    }\n<line6>    for (String hp : hostPort.split(\",\")) {\n<line7>        assertTrue(ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server \" + hp + \" up\");\n<line8>    }\n<line9>    // This was added to avoid running into the problem of ZOOKEEPER-1539\n<line10>    if (disableJMXTest) {\n<line11>        return;\n<line12>    }\n<line13>    // interesting to see what's there...\n<line14>    try {\n<line15>        JMXEnv.dump();\n<line16>        // make sure we have all servers listed\n<line17>        Set<String> ensureNames = new LinkedHashSet<>();\n<line18>        for (int i = 1; i <= ALL; ++i) {\n<line19>            ensureNames.add(\"InMemoryDataTree\");\n<line20>        }\n<line21>        for (int i = 1; i <= ALL; ++i) {\n<line22>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line23>        }\n<line24>        for (int i = 1; i <= ALL; ++i) {\n<line25>            for (int j = 1; j <= ALL; ++j) {\n<line26>                ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line27>            }\n<line28>        }\n<line29>        for (int i = 1; i <= ALL; ++i) {\n<line30>            ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line31>        }\n<line32>        JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line33>    } catch (IOException e) {\n<line34>    } catch (InterruptedException e) {\n<line35>    }\n<line36>}","output":"<line1>{\n<line2>    shutdownAll();\n<line3>    for (int i = 1; i <= ALL; ++i) {\n<line4>        start(i);\n<line5>        LOG.info(\"Started QuorumPeer {}\", i);\n<line6>    }\n<line7>    LOG.info(\"Checking ports {}\", hostPort);\n<line8>    for (String hp : hostPort.split(\",\")) {\n<line9>        assertTrue(ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server \" + hp + \" up\");\n<line10>        LOG.info(\"{} is accepting client connections\", hp);\n<line11>    }\n<line12>    // This was added to avoid running into the problem of ZOOKEEPER-1539\n<line13>    if (disableJMXTest) {\n<line14>        return;\n<line15>    }\n<line16>    // interesting to see what's there...\n<line17>    try {\n<line18>        JMXEnv.dump();\n<line19>        // make sure we have all servers listed\n<line20>        Set<String> ensureNames = new LinkedHashSet<>();\n<line21>        for (int i = 1; i <= ALL; ++i) {\n<line22>            ensureNames.add(\"InMemoryDataTree\");\n<line23>        }\n<line24>        for (int i = 1; i <= ALL; ++i) {\n<line25>            ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + i + \",name2=\");\n<line26>        }\n<line27>        for (int i = 1; i <= ALL; ++i) {\n<line28>            for (int j = 1; j <= ALL; ++j) {\n<line29>                ensureNames.add(\"name0=ReplicatedServer_id\" + i + \",name1=replica.\" + j);\n<line30>            }\n<line31>        }\n<line32>        for (int i = 1; i <= ALL; ++i) {\n<line33>            ensureNames.add(\"name0=ReplicatedServer_id\" + i);\n<line34>        }\n<line35>        JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));\n<line36>    } catch (IOException e) {\n<line37>        LOG.warn(\"IOException during JMXEnv operation\", e);\n<line38>    } catch (InterruptedException e) {\n<line39>        LOG.warn(\"InterruptedException during JMXEnv operation\", e);\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    start(i);\n<line3>}","output":"<line1>{\n<line2>    start(i);\n<line3>    LOG.info(\"Started QuorumPeer {}\", i);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server \" + hp + \" up\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT), \"waiting for server \" + hp + \" up\");\n<line3>    LOG.info(\"{} is accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    PeerStruct ps = getPeer(id);\n<line3>    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line4>    if (localSessionEnabled) {\n<line5>        ps.peer.enableLocalSessions(true);\n<line6>    }\n<line7>    assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line8>    ps.peer.start();\n<line9>}","output":"<line1>{\n<line2>    PeerStruct ps = getPeer(id);\n<line3>    LOG.info(\"Creating QuorumPeer {}; public port {}\", ps.id, ps.clientPort);\n<line4>    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line5>    if (localSessionEnabled) {\n<line6>        ps.peer.enableLocalSessions(true);\n<line7>    }\n<line8>    assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line9>    ps.peer.start();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    PeerStruct ps = getPeer(id);\n<line3>    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line4>    if (localSessionEnabled) {\n<line5>        ps.peer.enableLocalSessions(true);\n<line6>    }\n<line7>    assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line8>    ps.peer.start();\n<line9>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + getPeer(id).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line10>    shutdown(id);\n<line11>}","output":"<line1>{\n<line2>    PeerStruct ps = getPeer(id);\n<line3>    LOG.info(\"Creating QuorumPeer {}; public port {}\", ps.id, ps.clientPort);\n<line4>    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line5>    if (localSessionEnabled) {\n<line6>        ps.peer.enableLocalSessions(true);\n<line7>    }\n<line8>    assertEquals(ps.clientPort, ps.peer.getClientPort());\n<line9>    ps.peer.start();\n<line10>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + getPeer(id).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line11>    shutdown(id);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 1; i <= ALL; ++i) {\n<line3>        shutdown(i);\n<line4>    }\n<line5>    for (String hp : hostPort.split(\",\")) {\n<line6>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    for (int i = 1; i <= ALL; ++i) {\n<line3>        shutdown(i);\n<line4>    }\n<line5>    for (String hp : hostPort.split(\",\")) {\n<line6>        assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line7>        LOG.info(\"{} is no longer accepting client connections\", hp);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line3>}","output":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line3>    LOG.info(\"{} is no longer accepting client connections\", hp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer qp = getPeer(id).peer;\n<line3>    try {\n<line4>        qp.shutdown();\n<line5>        Election e = qp.getElectionAlg();\n<line6>        if (e != null) {\n<line7>            e.shutdown();\n<line8>        } else {\n<line9>        }\n<line10>        qp.join(30000);\n<line11>        if (qp.isAlive()) {\n<line12>            fail(\"QP failed to shutdown in 30 seconds: \" + qp.getName() + \" \" + id);\n<line13>        }\n<line14>    } catch (InterruptedException e) {\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    QuorumPeer qp = getPeer(id).peer;\n<line3>    try {\n<line4>        LOG.info(\"Shutting down quorum peer {} with id {}\", qp.getName(), id);\n<line5>        qp.shutdown();\n<line6>        Election e = qp.getElectionAlg();\n<line7>        if (e != null) {\n<line8>            LOG.info(\"Shutting down leader election {} with id {}\", qp.getName(), id);\n<line9>            e.shutdown();\n<line10>        } else {\n<line11>            LOG.info(\"No election available to shutdown {} with id {}\", qp.getName(), id);\n<line12>        }\n<line13>        LOG.info(\"Waiting for {} with id {} to exit thread\", qp.getName(), id);\n<line14>        qp.join(30000);\n<line15>        if (qp.isAlive()) {\n<line16>            fail(\"QP failed to shutdown in 30 seconds: \" + qp.getName() + \" \" + id);\n<line17>        }\n<line18>    } catch (InterruptedException e) {\n<line19>        LOG.debug(\"QP interrupted: {} {}\", qp.getName(), id, e);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    qp.shutdown();\n<line3>    Election e = qp.getElectionAlg();\n<line4>    if (e != null) {\n<line5>        e.shutdown();\n<line6>    } else {\n<line7>    }\n<line8>    qp.join(30000);\n<line9>    if (qp.isAlive()) {\n<line10>        fail(\"QP failed to shutdown in 30 seconds: \" + qp.getName() + \" \" + id);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down quorum peer {} with id {}\", qp.getName(), id);\n<line3>    qp.shutdown();\n<line4>    Election e = qp.getElectionAlg();\n<line5>    if (e != null) {\n<line6>        LOG.info(\"Shutting down leader election {} with id {}\", qp.getName(), id);\n<line7>        e.shutdown();\n<line8>    } else {\n<line9>        LOG.info(\"No election available to shutdown {} with id {}\", qp.getName(), id);\n<line10>    }\n<line11>    LOG.info(\"Waiting for {} with id {} to exit thread\", qp.getName(), id);\n<line12>    qp.join(30000);\n<line13>    if (qp.isAlive()) {\n<line14>        fail(\"QP failed to shutdown in 30 seconds: \" + qp.getName() + \" \" + id);\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    e.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down leader election {} with id {}\", qp.getName(), id);\n<line3>    e.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"No election available to shutdown {} with id {}\", qp.getName(), id);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"QP interrupted: {} {}\", qp.getName(), id, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    OSMXBean osMbean = new OSMXBean();\n<line3>    if (osMbean.getUnix()) {\n<line4>    }\n<line5>    shutdownAll();\n<line6>    JMXEnv.tearDown();\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"TearDown started\");\n<line3>    OSMXBean osMbean = new OSMXBean();\n<line4>    if (osMbean.getUnix()) {\n<line5>        LOG.info(\"fdcount after test is: {}\", osMbean.getOpenFileDescriptorCount());\n<line6>    }\n<line7>    shutdownAll();\n<line8>    JMXEnv.tearDown();\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"fdcount after test is: {}\", osMbean.getOpenFileDescriptorCount());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpSnapDir = ClientBase.createTmpDir();\n<line3>    File tmpLogDir = ClientBase.createTmpDir();\n<line4>    ClientBase.setupTestEnv();\n<line5>    ZooKeeperServer zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);\n<line6>    SyncRequestProcessor.setSnapCount(SNAP_COUNT);\n<line7>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line8>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line9>    f.startup(zks);\n<line10>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line11>    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n<line12>    try {\n<line13>        for (int i = 0; i < N_TRANSACTIONS; i++) {\n<line14>            zk.create(\"/node-\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>        }\n<line16>    } finally {\n<line17>        zk.close();\n<line18>    }\n<line19>    f.shutdown();\n<line20>    zks.shutdown();\n<line21>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server to shutdown\");\n<line22>    // start server again with intact database\n<line23>    zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);\n<line24>    zks.startdata();\n<line25>    long zxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line26>    assertTrue(zxid > 0, \"zxid > 0\");\n<line27>    zks.shutdown();\n<line28>    // Make all snapshots empty\n<line29>    FileTxnSnapLog txnLogFactory = zks.getTxnLogFactory();\n<line30>    List<File> snapshots = txnLogFactory.findNRecentSnapshots(10);\n<line31>    assertTrue(snapshots.size() > 0, \"We have a snapshot to corrupt\");\n<line32>    for (File file : snapshots) {\n<line33>        if (leaveEmptyFile) {\n<line34>            new PrintWriter(file).close();\n<line35>        } else {\n<line36>            file.delete();\n<line37>        }\n<line38>    }\n<line39>    if (trustEmptySnap) {\n<line40>        System.setProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, \"true\");\n<line41>    }\n<line42>    // start server again with corrupted database\n<line43>    zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);\n<line44>    try {\n<line45>        zks.startdata();\n<line46>        long currentZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line47>        if (!trustEmptySnap) {\n<line48>            fail(\"Should have gotten exception for corrupted database\");\n<line49>        }\n<line50>        assertEquals(currentZxid, zxid, \"zxid mismatch after restoring database\");\n<line51>    } catch (IOException e) {\n<line52>        // expected behavior\n<line53>        if (trustEmptySnap) {\n<line54>            fail(\"Should not get exception for empty database\");\n<line55>        }\n<line56>    } finally {\n<line57>        if (trustEmptySnap) {\n<line58>            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n<line59>        }\n<line60>    }\n<line61>    zks.shutdown();\n<line62>}","output":"<line1>{\n<line2>    File tmpSnapDir = ClientBase.createTmpDir();\n<line3>    File tmpLogDir = ClientBase.createTmpDir();\n<line4>    ClientBase.setupTestEnv();\n<line5>    ZooKeeperServer zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);\n<line6>    SyncRequestProcessor.setSnapCount(SNAP_COUNT);\n<line7>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line8>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line9>    f.startup(zks);\n<line10>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line11>    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n<line12>    try {\n<line13>        for (int i = 0; i < N_TRANSACTIONS; i++) {\n<line14>            zk.create(\"/node-\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>        }\n<line16>    } finally {\n<line17>        zk.close();\n<line18>    }\n<line19>    f.shutdown();\n<line20>    zks.shutdown();\n<line21>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server to shutdown\");\n<line22>    // start server again with intact database\n<line23>    zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);\n<line24>    zks.startdata();\n<line25>    long zxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line26>    LOG.info(\"After clean restart, zxid = {}\", zxid);\n<line27>    assertTrue(zxid > 0, \"zxid > 0\");\n<line28>    zks.shutdown();\n<line29>    // Make all snapshots empty\n<line30>    FileTxnSnapLog txnLogFactory = zks.getTxnLogFactory();\n<line31>    List<File> snapshots = txnLogFactory.findNRecentSnapshots(10);\n<line32>    assertTrue(snapshots.size() > 0, \"We have a snapshot to corrupt\");\n<line33>    for (File file : snapshots) {\n<line34>        if (leaveEmptyFile) {\n<line35>            new PrintWriter(file).close();\n<line36>        } else {\n<line37>            file.delete();\n<line38>        }\n<line39>    }\n<line40>    if (trustEmptySnap) {\n<line41>        System.setProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, \"true\");\n<line42>    }\n<line43>    // start server again with corrupted database\n<line44>    zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);\n<line45>    try {\n<line46>        zks.startdata();\n<line47>        long currentZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line48>        if (!trustEmptySnap) {\n<line49>            fail(\"Should have gotten exception for corrupted database\");\n<line50>        }\n<line51>        assertEquals(currentZxid, zxid, \"zxid mismatch after restoring database\");\n<line52>    } catch (IOException e) {\n<line53>        // expected behavior\n<line54>        if (trustEmptySnap) {\n<line55>            fail(\"Should not get exception for empty database\");\n<line56>        }\n<line57>    } finally {\n<line58>        if (trustEmptySnap) {\n<line59>            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n<line60>        }\n<line61>    }\n<line62>    zks.shutdown();\n<line63>}"},{"input":"","instruction":"<line1>{\n<line2>    ArrayList<QuorumPeer> peers = getPeerList();\n<line3>    for (int i = 1; i <= peers.size(); i++) {\n<line4>        QuorumPeer qp = peers.get(i - 1);\n<line5>        Long electionTimeTaken = -1L;\n<line6>        String bean = \"\";\n<line7>        if (qp.getPeerState() == QuorumPeer.ServerState.FOLLOWING) {\n<line8>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower\", MBeanRegistry.DOMAIN, i, i);\n<line9>        } else if (qp.getPeerState() == QuorumPeer.ServerState.LEADING) {\n<line10>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader\", MBeanRegistry.DOMAIN, i, i);\n<line11>        }\n<line12>        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, \"ElectionTimeTaken\");\n<line13>        assertTrue(electionTimeTaken >= 0, \"Wrong electionTimeTaken value!\");\n<line14>    }\n<line15>    tearDown();\n<line16>    //setup servers 1-2 to be followers\n<line17>    // id=1, oracle is false; id=2, oracle is true\n<line18>    setUp();\n<line19>    QuorumPeer s;\n<line20>    int leader;\n<line21>    if ((leader = getLeaderIndex()) == 1) {\n<line22>        s = s1;\n<line23>    } else {\n<line24>        s = s2;\n<line25>    }\n<line26>    noDropConectionTest(s);\n<line27>    dropConnectionTest(s, leader);\n<line28>}","output":"<line1>{\n<line2>    LOG.info(\"Verify QuorumPeer#electionTimeTaken jmx bean attribute\");\n<line3>    ArrayList<QuorumPeer> peers = getPeerList();\n<line4>    for (int i = 1; i <= peers.size(); i++) {\n<line5>        QuorumPeer qp = peers.get(i - 1);\n<line6>        Long electionTimeTaken = -1L;\n<line7>        String bean = \"\";\n<line8>        if (qp.getPeerState() == QuorumPeer.ServerState.FOLLOWING) {\n<line9>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower\", MBeanRegistry.DOMAIN, i, i);\n<line10>        } else if (qp.getPeerState() == QuorumPeer.ServerState.LEADING) {\n<line11>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader\", MBeanRegistry.DOMAIN, i, i);\n<line12>        }\n<line13>        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, \"ElectionTimeTaken\");\n<line14>        assertTrue(electionTimeTaken >= 0, \"Wrong electionTimeTaken value!\");\n<line15>    }\n<line16>    tearDown();\n<line17>    //setup servers 1-2 to be followers\n<line18>    // id=1, oracle is false; id=2, oracle is true\n<line19>    setUp();\n<line20>    QuorumPeer s;\n<line21>    int leader;\n<line22>    if ((leader = getLeaderIndex()) == 1) {\n<line23>        s = s1;\n<line24>    } else {\n<line25>        s = s2;\n<line26>    }\n<line27>    noDropConectionTest(s);\n<line28>    dropConnectionTest(s, leader);\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    // generate some transactions that will get logged\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    try {\n<line5>        for (int i = 0; i < NUM_MESSAGES; i++) {\n<line6>            zk.create(\"/invalidsnap-\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        }\n<line8>    } finally {\n<line9>        zk.close();\n<line10>    }\n<line11>    stopServer();\n<line12>    // now verify that the FileTxnLog reads every transaction only once\n<line13>    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);\n<line14>    FileTxnLog txnLog = new FileTxnLog(logDir);\n<line15>    TxnIterator itr = txnLog.read(0);\n<line16>    // Check that storage space return some value\n<line17>    FileTxnIterator fileItr = (FileTxnIterator) itr;\n<line18>    long storageSize = fileItr.getStorageSize();\n<line19>    assertTrue((storageSize > 0), \"Storage size is greater than zero \");\n<line20>    long expectedZxid = 0;\n<line21>    long lastZxid = 0;\n<line22>    TxnHeader hdr;\n<line23>    do {\n<line24>        hdr = itr.getHeader();\n<line25>        expectedZxid++;\n<line26>        assertTrue(lastZxid != hdr.getZxid(), \"not the same transaction. lastZxid=\" + lastZxid + \", zxid=\" + hdr.getZxid());\n<line27>        assertTrue((hdr.getZxid() == expectedZxid), \"excepting next transaction. expected=\" + expectedZxid + \", retrieved=\" + hdr.getZxid());\n<line28>        lastZxid = hdr.getZxid();\n<line29>    } while (itr.next());\n<line30>    assertTrue((expectedZxid == TOTAL_TRANSACTIONS), \"processed all transactions. \" + expectedZxid + \" == \" + TOTAL_TRANSACTIONS);\n<line31>}","output":"<line1>{\n<line2>    // generate some transactions that will get logged\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    try {\n<line5>        for (int i = 0; i < NUM_MESSAGES; i++) {\n<line6>            zk.create(\"/invalidsnap-\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        }\n<line8>    } finally {\n<line9>        zk.close();\n<line10>    }\n<line11>    stopServer();\n<line12>    // now verify that the FileTxnLog reads every transaction only once\n<line13>    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);\n<line14>    FileTxnLog txnLog = new FileTxnLog(logDir);\n<line15>    TxnIterator itr = txnLog.read(0);\n<line16>    // Check that storage space return some value\n<line17>    FileTxnIterator fileItr = (FileTxnIterator) itr;\n<line18>    long storageSize = fileItr.getStorageSize();\n<line19>    LOG.info(\"Txnlog size: {} bytes\", storageSize);\n<line20>    assertTrue((storageSize > 0), \"Storage size is greater than zero \");\n<line21>    long expectedZxid = 0;\n<line22>    long lastZxid = 0;\n<line23>    TxnHeader hdr;\n<line24>    do {\n<line25>        hdr = itr.getHeader();\n<line26>        expectedZxid++;\n<line27>        assertTrue(lastZxid != hdr.getZxid(), \"not the same transaction. lastZxid=\" + lastZxid + \", zxid=\" + hdr.getZxid());\n<line28>        assertTrue((hdr.getZxid() == expectedZxid), \"excepting next transaction. expected=\" + expectedZxid + \", retrieved=\" + hdr.getZxid());\n<line29>        lastZxid = hdr.getZxid();\n<line30>    } while (itr.next());\n<line31>    assertTrue((expectedZxid == TOTAL_TRANSACTIONS), \"processed all transactions. \" + expectedZxid + \" == \" + TOTAL_TRANSACTIONS);\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    // generate some transactions\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    String lastPath = null;\n<line5>    try {\n<line6>        zk.create(\"/invalidsnap\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        for (int i = 0; i < NUM_MESSAGES; i++) {\n<line8>            lastPath = zk.create(\"/invalidsnap/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line9>        }\n<line10>    } finally {\n<line11>        zk.close();\n<line12>    }\n<line13>    String[] tokens = lastPath.split(\"-\");\n<line14>    String expectedPath = \"/invalidsnap/test-\" + String.format(\"%010d\", (Integer.parseInt(tokens[1])) + 1);\n<line15>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line16>    long eZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line17>    // force the zxid to be behind the content\n<line18>    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);\n<line19>    // Force snapshot and restore\n<line20>    zks.takeSnapshot();\n<line21>    zks.shutdown();\n<line22>    stopServer();\n<line23>    startServer();\n<line24>    zks = serverFactory.getZooKeeperServer();\n<line25>    long fZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line26>    // Verify lastProcessedZxid is set correctly\n<line27>    assertTrue(fZxid == eZxid, \"Restore failed expected zxid=\" + eZxid + \" found=\" + fZxid);\n<line28>    zk = createZKClient(hostPort);\n<line29>    // Verify correctness of data and whether sequential znode creation\n<line30>    // proceeds correctly after this point\n<line31>    String[] children;\n<line32>    String path;\n<line33>    try {\n<line34>        children = zk.getChildren(\"/invalidsnap\", false).toArray(new String[0]);\n<line35>        path = zk.create(\"/invalidsnap/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line36>    } finally {\n<line37>        zk.close();\n<line38>    }\n<line39>    assertTrue(path.equals(expectedPath), \"Error in sequential znode creation expected \" + expectedPath + \" found \" + path);\n<line40>    assertTrue((children.length == NUM_MESSAGES), \"Unexpected number of children \" + children.length + \" expected \" + NUM_MESSAGES);\n<line41>}","output":"<line1>{\n<line2>    // generate some transactions\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    String lastPath = null;\n<line5>    try {\n<line6>        zk.create(\"/invalidsnap\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        for (int i = 0; i < NUM_MESSAGES; i++) {\n<line8>            lastPath = zk.create(\"/invalidsnap/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line9>        }\n<line10>    } finally {\n<line11>        zk.close();\n<line12>    }\n<line13>    String[] tokens = lastPath.split(\"-\");\n<line14>    String expectedPath = \"/invalidsnap/test-\" + String.format(\"%010d\", (Integer.parseInt(tokens[1])) + 1);\n<line15>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line16>    long eZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line17>    // force the zxid to be behind the content\n<line18>    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);\n<line19>    LOG.info(\"Set lastProcessedZxid to {}\", zks.getZKDatabase().getDataTreeLastProcessedZxid());\n<line20>    // Force snapshot and restore\n<line21>    zks.takeSnapshot();\n<line22>    zks.shutdown();\n<line23>    stopServer();\n<line24>    startServer();\n<line25>    zks = serverFactory.getZooKeeperServer();\n<line26>    long fZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line27>    // Verify lastProcessedZxid is set correctly\n<line28>    assertTrue(fZxid == eZxid, \"Restore failed expected zxid=\" + eZxid + \" found=\" + fZxid);\n<line29>    zk = createZKClient(hostPort);\n<line30>    // Verify correctness of data and whether sequential znode creation\n<line31>    // proceeds correctly after this point\n<line32>    String[] children;\n<line33>    String path;\n<line34>    try {\n<line35>        children = zk.getChildren(\"/invalidsnap\", false).toArray(new String[0]);\n<line36>        path = zk.create(\"/invalidsnap/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line37>    } finally {\n<line38>        zk.close();\n<line39>    }\n<line40>    LOG.info(\"Expected {} found {}\", expectedPath, path);\n<line41>    assertTrue(path.equals(expectedPath), \"Error in sequential znode creation expected \" + expectedPath + \" found \" + path);\n<line42>    assertTrue((children.length == NUM_MESSAGES), \"Unexpected number of children \" + children.length + \" expected \" + NUM_MESSAGES);\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    // generate some transactions\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    try {\n<line5>        for (int i = 0; i < NUM_MESSAGES; i++) {\n<line6>            try {\n<line7>                zk.create(\"/invaliddir/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line8>            } catch (NoNodeException e) {\n<line9>                //Expected\n<line10>            }\n<line11>        }\n<line12>    } finally {\n<line13>        zk.close();\n<line14>    }\n<line15>    // force the zxid to be behind the content\n<line16>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line17>    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);\n<line18>    // Force snapshot and restore\n<line19>    zks.takeSnapshot();\n<line20>    zks.shutdown();\n<line21>    stopServer();\n<line22>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line23>    startServer();\n<line24>}","output":"<line1>{\n<line2>    // generate some transactions\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    try {\n<line5>        for (int i = 0; i < NUM_MESSAGES; i++) {\n<line6>            try {\n<line7>                zk.create(\"/invaliddir/test-\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line8>            } catch (NoNodeException e) {\n<line9>                //Expected\n<line10>            }\n<line11>        }\n<line12>    } finally {\n<line13>        zk.close();\n<line14>    }\n<line15>    // force the zxid to be behind the content\n<line16>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line17>    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);\n<line18>    LOG.info(\"Set lastProcessedZxid to {}\", zks.getZKDatabase().getDataTreeLastProcessedZxid());\n<line19>    // Force snapshot and restore\n<line20>    zks.takeSnapshot();\n<line21>    zks.shutdown();\n<line22>    stopServer();\n<line23>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line24>    startServer();\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    stopServer();\n<line3>    try {\n<line4>        // now verify autocreate off works\n<line5>        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, \"false\");\n<line6>        tmpDir = createTmpDir();\n<line7>        startServer();\n<line8>        fail(\"Server should not have started without datadir\");\n<line9>    } catch (IOException e) {\n<line10>    } finally {\n<line11>        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT);\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    stopServer();\n<line3>    try {\n<line4>        // now verify autocreate off works\n<line5>        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, \"false\");\n<line6>        tmpDir = createTmpDir();\n<line7>        startServer();\n<line8>        fail(\"Server should not have started without datadir\");\n<line9>    } catch (IOException e) {\n<line10>        LOG.debug(\"Server failed to start - correct behavior\", e);\n<line11>    } finally {\n<line12>        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Server failed to start - correct behavior\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // create transactions to create the snapshot with create/delete pattern\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    zk.create(\"/a\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    Stat stat = zk.exists(\"/a\", false);\n<line6>    long createZxId = stat.getMzxid();\n<line7>    zk.create(\"/a/b\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    zk.delete(\"/a/b\", -1);\n<line9>    zk.delete(\"/a\", -1);\n<line10>    // force the zxid to be behind the content\n<line11>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line12>    zks.getZKDatabase().setlastProcessedZxid(createZxId);\n<line13>    // Force snapshot and restore\n<line14>    zks.takeSnapshot();\n<line15>    zks.shutdown();\n<line16>    stopServer();\n<line17>    startServer();\n<line18>}","output":"<line1>{\n<line2>    // create transactions to create the snapshot with create/delete pattern\n<line3>    ZooKeeper zk = createZKClient(hostPort);\n<line4>    zk.create(\"/a\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    Stat stat = zk.exists(\"/a\", false);\n<line6>    long createZxId = stat.getMzxid();\n<line7>    zk.create(\"/a/b\", \"\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    zk.delete(\"/a/b\", -1);\n<line9>    zk.delete(\"/a\", -1);\n<line10>    // force the zxid to be behind the content\n<line11>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line12>    zks.getZKDatabase().setlastProcessedZxid(createZxId);\n<line13>    LOG.info(\"Set lastProcessedZxid to {}\", zks.getZKDatabase().getDataTreeLastProcessedZxid());\n<line14>    // Force snapshot and restore\n<line15>    zks.takeSnapshot();\n<line16>    zks.shutdown();\n<line17>    stopServer();\n<line18>    startServer();\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line9>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line10>    try {\n<line11>        for (int i = 0; i < totalTransactions; i++) {\n<line12>            zk.create(\"/invalidsnap-\" + i, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line13>        }\n<line14>    } finally {\n<line15>        zk.close();\n<line16>    }\n<line17>    final int numSnaps = zks.getTxnLogFactory().findNRecentSnapshots(10 * minExpectedSnapshots).size();\n<line18>    f.shutdown();\n<line19>    zks.shutdown();\n<line20>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server to shutdown\");\n<line21>    assertTrue(numSnaps > minExpectedSnapshots, \"too few snapshot files\");\n<line22>    assertTrue(numSnaps <= minExpectedSnapshots * 2, \"too many snapshot files\");\n<line23>    // start server again\n<line24>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line25>    zks.startdata();\n<line26>    Collection<Proposal> committedLog = zks.getZKDatabase().getCommittedLog();\n<line27>    int logsize = committedLog.size();\n<line28>    assertTrue((logsize != 0), \"log size != 0\");\n<line29>    zks.shutdown();\n<line30>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line9>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line10>    try {\n<line11>        for (int i = 0; i < totalTransactions; i++) {\n<line12>            zk.create(\"/invalidsnap-\" + i, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line13>        }\n<line14>    } finally {\n<line15>        zk.close();\n<line16>    }\n<line17>    final int numSnaps = zks.getTxnLogFactory().findNRecentSnapshots(10 * minExpectedSnapshots).size();\n<line18>    LOG.info(\"number of snapshots taken {}\", numSnaps);\n<line19>    f.shutdown();\n<line20>    zks.shutdown();\n<line21>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server to shutdown\");\n<line22>    assertTrue(numSnaps > minExpectedSnapshots, \"too few snapshot files\");\n<line23>    assertTrue(numSnaps <= minExpectedSnapshots * 2, \"too many snapshot files\");\n<line24>    // start server again\n<line25>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line26>    zks.startdata();\n<line27>    Collection<Proposal> committedLog = zks.getZKDatabase().getCommittedLog();\n<line28>    int logsize = committedLog.size();\n<line29>    LOG.info(\"committedLog size = {}\", logsize);\n<line30>    assertTrue((logsize != 0), \"log size != 0\");\n<line31>    zks.shutdown();\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    assertTrue(resp.contains(expected));\n<line4>}","output":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    LOG.info(\"cmd {} expected {} got {}\", cmd, expected, resp);\n<line4>    assertTrue(resp.contains(expected));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n<line3>    JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi://127.0.0.1\");\n<line4>    cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);\n<line5>    cs.start();\n<line6>    JMXServiceURL addr = cs.getAddress();\n<line7>    cc = JMXConnectorFactory.connect(addr);\n<line8>}","output":"<line1>{\n<line2>    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n<line3>    JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi://127.0.0.1\");\n<line4>    cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);\n<line5>    cs.start();\n<line6>    JMXServiceURL addr = cs.getAddress();\n<line7>    LOG.info(\"connecting to addr {}\", addr);\n<line8>    cc = JMXConnectorFactory.connect(addr);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<ObjectName> beans;\n<line3>    Set<ObjectName> found;\n<line4>    int nTry = 0;\n<line5>    do {\n<line6>        if (nTry++ > 0) {\n<line7>            Thread.sleep(100);\n<line8>        }\n<line9>        try {\n<line10>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line11>        } catch (MalformedObjectNameException e) {\n<line12>            throw new RuntimeException(e);\n<line13>        }\n<line14>        found = new HashSet<>();\n<line15>        for (String name : expectedNames) {\n<line16>            for (ObjectName bean : beans) {\n<line17>                if (bean.toString().contains(name)) {\n<line18>                    found.add(bean);\n<line19>                    break;\n<line20>                }\n<line21>            }\n<line22>            beans.removeAll(found);\n<line23>        }\n<line24>    } while ((expectedNames.length != found.size()) && (nTry < 600));\n<line25>    assertEquals(expectedNames.length, found.size(), \"expected \" + Arrays.toString(expectedNames));\n<line26>    return beans;\n<line27>}","output":"<line1>{\n<line2>    Set<ObjectName> beans;\n<line3>    Set<ObjectName> found;\n<line4>    int nTry = 0;\n<line5>    do {\n<line6>        if (nTry++ > 0) {\n<line7>            Thread.sleep(100);\n<line8>        }\n<line9>        try {\n<line10>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line11>        } catch (MalformedObjectNameException e) {\n<line12>            throw new RuntimeException(e);\n<line13>        }\n<line14>        found = new HashSet<>();\n<line15>        for (String name : expectedNames) {\n<line16>            LOG.info(\"expect:{}\", name);\n<line17>            for (ObjectName bean : beans) {\n<line18>                if (bean.toString().contains(name)) {\n<line19>                    LOG.info(\"found:{} {}\", name, bean);\n<line20>                    found.add(bean);\n<line21>                    break;\n<line22>                }\n<line23>            }\n<line24>            beans.removeAll(found);\n<line25>        }\n<line26>    } while ((expectedNames.length != found.size()) && (nTry < 600));\n<line27>    assertEquals(expectedNames.length, found.size(), \"expected \" + Arrays.toString(expectedNames));\n<line28>    return beans;\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(100);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    found = new HashSet<>();\n<line11>    for (String name : expectedNames) {\n<line12>        for (ObjectName bean : beans) {\n<line13>            if (bean.toString().contains(name)) {\n<line14>                found.add(bean);\n<line15>                break;\n<line16>            }\n<line17>        }\n<line18>        beans.removeAll(found);\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(100);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    found = new HashSet<>();\n<line11>    for (String name : expectedNames) {\n<line12>        LOG.info(\"expect:{}\", name);\n<line13>        for (ObjectName bean : beans) {\n<line14>            if (bean.toString().contains(name)) {\n<line15>                LOG.info(\"found:{} {}\", name, bean);\n<line16>                found.add(bean);\n<line17>                break;\n<line18>            }\n<line19>        }\n<line20>        beans.removeAll(found);\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    for (ObjectName bean : beans) {\n<line3>        if (bean.toString().contains(name)) {\n<line4>            found.add(bean);\n<line5>            break;\n<line6>        }\n<line7>    }\n<line8>    beans.removeAll(found);\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"expect:{}\", name);\n<line3>    for (ObjectName bean : beans) {\n<line4>        if (bean.toString().contains(name)) {\n<line5>            LOG.info(\"found:{} {}\", name, bean);\n<line6>            found.add(bean);\n<line7>            break;\n<line8>        }\n<line9>    }\n<line10>    beans.removeAll(found);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bean.toString().contains(name)) {\n<line3>        found.add(bean);\n<line4>        break;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (bean.toString().contains(name)) {\n<line3>        LOG.info(\"found:{} {}\", name, bean);\n<line4>        found.add(bean);\n<line5>        break;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    found.add(bean);\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"found:{} {}\", name, bean);\n<line3>    found.add(bean);\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<ObjectName> beans = ensureAll(expectedNames);\n<line3>    for (ObjectName bean : beans) {\n<line4>    }\n<line5>    assertEquals(0, beans.size());\n<line6>    return beans;\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"ensureOnly:{}\", Arrays.toString(expectedNames));\n<line3>    Set<ObjectName> beans = ensureAll(expectedNames);\n<line4>    for (ObjectName bean : beans) {\n<line5>        LOG.info(\"unexpected:{}\", bean.toString());\n<line6>    }\n<line7>    assertEquals(0, beans.size());\n<line8>    return beans;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"unexpected:{}\", bean.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<ObjectName> beans;\n<line3>    int nTry = 0;\n<line4>    boolean foundUnexpected = false;\n<line5>    String unexpectedName = \"\";\n<line6>    do {\n<line7>        if (nTry++ > 0) {\n<line8>            Thread.sleep(100);\n<line9>        }\n<line10>        try {\n<line11>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line12>        } catch (MalformedObjectNameException e) {\n<line13>            throw new RuntimeException(e);\n<line14>        }\n<line15>        foundUnexpected = false;\n<line16>        for (String name : expectedNames) {\n<line17>            for (ObjectName bean : beans) {\n<line18>                if (bean.toString().contains(name)) {\n<line19>                    foundUnexpected = true;\n<line20>                    unexpectedName = name + \" \" + bean.toString();\n<line21>                    break;\n<line22>                }\n<line23>            }\n<line24>            if (foundUnexpected) {\n<line25>                break;\n<line26>            }\n<line27>        }\n<line28>    } while ((foundUnexpected) && (nTry < 600));\n<line29>    if (foundUnexpected) {\n<line30>        for (ObjectName bean : beans) {\n<line31>        }\n<line32>        fail(unexpectedName);\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    Set<ObjectName> beans;\n<line3>    int nTry = 0;\n<line4>    boolean foundUnexpected = false;\n<line5>    String unexpectedName = \"\";\n<line6>    do {\n<line7>        if (nTry++ > 0) {\n<line8>            Thread.sleep(100);\n<line9>        }\n<line10>        try {\n<line11>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line12>        } catch (MalformedObjectNameException e) {\n<line13>            throw new RuntimeException(e);\n<line14>        }\n<line15>        foundUnexpected = false;\n<line16>        for (String name : expectedNames) {\n<line17>            for (ObjectName bean : beans) {\n<line18>                if (bean.toString().contains(name)) {\n<line19>                    LOG.info(\"didntexpect:{}\", name);\n<line20>                    foundUnexpected = true;\n<line21>                    unexpectedName = name + \" \" + bean.toString();\n<line22>                    break;\n<line23>                }\n<line24>            }\n<line25>            if (foundUnexpected) {\n<line26>                break;\n<line27>            }\n<line28>        }\n<line29>    } while ((foundUnexpected) && (nTry < 600));\n<line30>    if (foundUnexpected) {\n<line31>        LOG.info(\"List of all beans follows:\");\n<line32>        for (ObjectName bean : beans) {\n<line33>            LOG.info(\"bean:{}\", bean.toString());\n<line34>        }\n<line35>        fail(unexpectedName);\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(100);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    foundUnexpected = false;\n<line11>    for (String name : expectedNames) {\n<line12>        for (ObjectName bean : beans) {\n<line13>            if (bean.toString().contains(name)) {\n<line14>                foundUnexpected = true;\n<line15>                unexpectedName = name + \" \" + bean.toString();\n<line16>                break;\n<line17>            }\n<line18>        }\n<line19>        if (foundUnexpected) {\n<line20>            break;\n<line21>        }\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(100);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    foundUnexpected = false;\n<line11>    for (String name : expectedNames) {\n<line12>        for (ObjectName bean : beans) {\n<line13>            if (bean.toString().contains(name)) {\n<line14>                LOG.info(\"didntexpect:{}\", name);\n<line15>                foundUnexpected = true;\n<line16>                unexpectedName = name + \" \" + bean.toString();\n<line17>                break;\n<line18>            }\n<line19>        }\n<line20>        if (foundUnexpected) {\n<line21>            break;\n<line22>        }\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    for (ObjectName bean : beans) {\n<line3>        if (bean.toString().contains(name)) {\n<line4>            foundUnexpected = true;\n<line5>            unexpectedName = name + \" \" + bean.toString();\n<line6>            break;\n<line7>        }\n<line8>    }\n<line9>    if (foundUnexpected) {\n<line10>        break;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    for (ObjectName bean : beans) {\n<line3>        if (bean.toString().contains(name)) {\n<line4>            LOG.info(\"didntexpect:{}\", name);\n<line5>            foundUnexpected = true;\n<line6>            unexpectedName = name + \" \" + bean.toString();\n<line7>            break;\n<line8>        }\n<line9>    }\n<line10>    if (foundUnexpected) {\n<line11>        break;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bean.toString().contains(name)) {\n<line3>        foundUnexpected = true;\n<line4>        unexpectedName = name + \" \" + bean.toString();\n<line5>        break;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (bean.toString().contains(name)) {\n<line3>        LOG.info(\"didntexpect:{}\", name);\n<line4>        foundUnexpected = true;\n<line5>        unexpectedName = name + \" \" + bean.toString();\n<line6>        break;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    foundUnexpected = true;\n<line3>    unexpectedName = name + \" \" + bean.toString();\n<line4>    break;\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"didntexpect:{}\", name);\n<line3>    foundUnexpected = true;\n<line4>    unexpectedName = name + \" \" + bean.toString();\n<line5>    break;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    for (ObjectName bean : beans) {\n<line3>    }\n<line4>    fail(unexpectedName);\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"List of all beans follows:\");\n<line3>    for (ObjectName bean : beans) {\n<line4>        LOG.info(\"bean:{}\", bean.toString());\n<line5>    }\n<line6>    fail(unexpectedName);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"bean:{}\", bean.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<ObjectName> beans;\n<line3>    try {\n<line4>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line5>    } catch (MalformedObjectNameException e) {\n<line6>        throw new RuntimeException(e);\n<line7>    }\n<line8>    for (ObjectName bean : beans) {\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.info(\"JMXEnv.dump() follows\");\n<line3>    Set<ObjectName> beans;\n<line4>    try {\n<line5>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line6>    } catch (MalformedObjectNameException e) {\n<line7>        throw new RuntimeException(e);\n<line8>    }\n<line9>    for (ObjectName bean : beans) {\n<line10>        LOG.info(\"bean:{}\", bean.toString());\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"bean:{}\", bean.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<ObjectName> beans;\n<line3>    int nTry = 0;\n<line4>    Set<ObjectName> found = new HashSet<>();\n<line5>    do {\n<line6>        if (nTry++ > 0) {\n<line7>            Thread.sleep(500);\n<line8>        }\n<line9>        try {\n<line10>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line11>        } catch (MalformedObjectNameException e) {\n<line12>            throw new RuntimeException(e);\n<line13>        }\n<line14>        found.clear();\n<line15>        for (String name : expectedNames) {\n<line16>            for (ObjectName bean : beans) {\n<line17>                // check the existence of name in bean\n<line18>                if (compare(bean.toString(), name)) {\n<line19>                    found.add(bean);\n<line20>                    break;\n<line21>                }\n<line22>            }\n<line23>            beans.removeAll(found);\n<line24>        }\n<line25>    } while (expectedNames.length != found.size() && nTry < 120);\n<line26>    assertEquals(expectedNames.length, found.size(), \"expected \" + Arrays.toString(expectedNames));\n<line27>    return beans;\n<line28>}","output":"<line1>{\n<line2>    LOG.info(\"ensureParent:{}\", Arrays.toString(expectedNames));\n<line3>    Set<ObjectName> beans;\n<line4>    int nTry = 0;\n<line5>    Set<ObjectName> found = new HashSet<>();\n<line6>    do {\n<line7>        if (nTry++ > 0) {\n<line8>            Thread.sleep(500);\n<line9>        }\n<line10>        try {\n<line11>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line12>        } catch (MalformedObjectNameException e) {\n<line13>            throw new RuntimeException(e);\n<line14>        }\n<line15>        found.clear();\n<line16>        for (String name : expectedNames) {\n<line17>            LOG.info(\"expect:{}\", name);\n<line18>            for (ObjectName bean : beans) {\n<line19>                // check the existence of name in bean\n<line20>                if (compare(bean.toString(), name)) {\n<line21>                    LOG.info(\"found:{} {}\", name, bean);\n<line22>                    found.add(bean);\n<line23>                    break;\n<line24>                }\n<line25>            }\n<line26>            beans.removeAll(found);\n<line27>        }\n<line28>    } while (expectedNames.length != found.size() && nTry < 120);\n<line29>    assertEquals(expectedNames.length, found.size(), \"expected \" + Arrays.toString(expectedNames));\n<line30>    return beans;\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(500);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    found.clear();\n<line11>    for (String name : expectedNames) {\n<line12>        for (ObjectName bean : beans) {\n<line13>            // check the existence of name in bean\n<line14>            if (compare(bean.toString(), name)) {\n<line15>                found.add(bean);\n<line16>                break;\n<line17>            }\n<line18>        }\n<line19>        beans.removeAll(found);\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(500);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    found.clear();\n<line11>    for (String name : expectedNames) {\n<line12>        LOG.info(\"expect:{}\", name);\n<line13>        for (ObjectName bean : beans) {\n<line14>            // check the existence of name in bean\n<line15>            if (compare(bean.toString(), name)) {\n<line16>                LOG.info(\"found:{} {}\", name, bean);\n<line17>                found.add(bean);\n<line18>                break;\n<line19>            }\n<line20>        }\n<line21>        beans.removeAll(found);\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    for (ObjectName bean : beans) {\n<line3>        // check the existence of name in bean\n<line4>        if (compare(bean.toString(), name)) {\n<line5>            found.add(bean);\n<line6>            break;\n<line7>        }\n<line8>    }\n<line9>    beans.removeAll(found);\n<line10>}","output":"<line1>{\n<line2>    LOG.info(\"expect:{}\", name);\n<line3>    for (ObjectName bean : beans) {\n<line4>        // check the existence of name in bean\n<line5>        if (compare(bean.toString(), name)) {\n<line6>            LOG.info(\"found:{} {}\", name, bean);\n<line7>            found.add(bean);\n<line8>            break;\n<line9>        }\n<line10>    }\n<line11>    beans.removeAll(found);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // check the existence of name in bean\n<line3>    if (compare(bean.toString(), name)) {\n<line4>        found.add(bean);\n<line5>        break;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    // check the existence of name in bean\n<line3>    if (compare(bean.toString(), name)) {\n<line4>        LOG.info(\"found:{} {}\", name, bean);\n<line5>        found.add(bean);\n<line6>        break;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    found.add(bean);\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"found:{} {}\", name, bean);\n<line3>    found.add(bean);\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String value = \"\";\n<line3>    Set<ObjectName> beans;\n<line4>    int nTry = 0;\n<line5>    do {\n<line6>        if (nTry++ > 0) {\n<line7>            Thread.sleep(500);\n<line8>        }\n<line9>        try {\n<line10>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line11>        } catch (MalformedObjectNameException e) {\n<line12>            throw new RuntimeException(e);\n<line13>        }\n<line14>        for (ObjectName bean : beans) {\n<line15>            // check the existence of name in bean\n<line16>            if (bean.toString().equals(expectedName)) {\n<line17>                return conn().getAttribute(bean, expectedAttribute);\n<line18>            }\n<line19>        }\n<line20>    } while (nTry < 120);\n<line21>    fail(\"Failed to find bean:\" + expectedName + \", attribute:\" + expectedAttribute);\n<line22>    return value;\n<line23>}","output":"<line1>{\n<line2>    String value = \"\";\n<line3>    LOG.info(\"ensure bean:{}, attribute:{}\", expectedName, expectedAttribute);\n<line4>    Set<ObjectName> beans;\n<line5>    int nTry = 0;\n<line6>    do {\n<line7>        if (nTry++ > 0) {\n<line8>            Thread.sleep(500);\n<line9>        }\n<line10>        try {\n<line11>            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line12>        } catch (MalformedObjectNameException e) {\n<line13>            throw new RuntimeException(e);\n<line14>        }\n<line15>        LOG.info(\"expect:{}\", expectedName);\n<line16>        for (ObjectName bean : beans) {\n<line17>            // check the existence of name in bean\n<line18>            if (bean.toString().equals(expectedName)) {\n<line19>                LOG.info(\"found:{} {}\", expectedName, bean);\n<line20>                return conn().getAttribute(bean, expectedAttribute);\n<line21>            }\n<line22>        }\n<line23>    } while (nTry < 120);\n<line24>    fail(\"Failed to find bean:\" + expectedName + \", attribute:\" + expectedAttribute);\n<line25>    return value;\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(500);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    for (ObjectName bean : beans) {\n<line11>        // check the existence of name in bean\n<line12>        if (bean.toString().equals(expectedName)) {\n<line13>            return conn().getAttribute(bean, expectedAttribute);\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    if (nTry++ > 0) {\n<line3>        Thread.sleep(500);\n<line4>    }\n<line5>    try {\n<line6>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line7>    } catch (MalformedObjectNameException e) {\n<line8>        throw new RuntimeException(e);\n<line9>    }\n<line10>    LOG.info(\"expect:{}\", expectedName);\n<line11>    for (ObjectName bean : beans) {\n<line12>        // check the existence of name in bean\n<line13>        if (bean.toString().equals(expectedName)) {\n<line14>            LOG.info(\"found:{} {}\", expectedName, bean);\n<line15>            return conn().getAttribute(bean, expectedAttribute);\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    // check the existence of name in bean\n<line3>    if (bean.toString().equals(expectedName)) {\n<line4>        return conn().getAttribute(bean, expectedAttribute);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    // check the existence of name in bean\n<line3>    if (bean.toString().equals(expectedName)) {\n<line4>        LOG.info(\"found:{} {}\", expectedName, bean);\n<line5>        return conn().getAttribute(bean, expectedAttribute);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    return conn().getAttribute(bean, expectedAttribute);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"found:{} {}\", expectedName, bean);\n<line3>    return conn().getAttribute(bean, expectedAttribute);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ArrayList<ObjectName> serverBeans = new ArrayList<>();\n<line3>    Set<ObjectName> beans;\n<line4>    try {\n<line5>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line6>    } catch (MalformedObjectNameException e) {\n<line7>        throw new RuntimeException(e);\n<line8>    }\n<line9>    for (ObjectName bean : beans) {\n<line10>        String name = bean.toString();\n<line11>        for (Pattern pattern : beanPatterns) {\n<line12>            if (pattern.matcher(name).find()) {\n<line13>                serverBeans.add(bean);\n<line14>            }\n<line15>        }\n<line16>    }\n<line17>    return serverBeans;\n<line18>}","output":"<line1>{\n<line2>    ArrayList<ObjectName> serverBeans = new ArrayList<>();\n<line3>    Set<ObjectName> beans;\n<line4>    try {\n<line5>        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + \":*\"), null);\n<line6>    } catch (MalformedObjectNameException e) {\n<line7>        throw new RuntimeException(e);\n<line8>    }\n<line9>    for (ObjectName bean : beans) {\n<line10>        String name = bean.toString();\n<line11>        LOG.info(\"bean:{}\", name);\n<line12>        for (Pattern pattern : beanPatterns) {\n<line13>            if (pattern.matcher(name).find()) {\n<line14>                serverBeans.add(bean);\n<line15>            }\n<line16>        }\n<line17>    }\n<line18>    return serverBeans;\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    String name = bean.toString();\n<line3>    for (Pattern pattern : beanPatterns) {\n<line4>        if (pattern.matcher(name).find()) {\n<line5>            serverBeans.add(bean);\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    String name = bean.toString();\n<line3>    LOG.info(\"bean:{}\", name);\n<line4>    for (Pattern pattern : beanPatterns) {\n<line5>        if (pattern.matcher(name).find()) {\n<line6>            serverBeans.add(bean);\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpdir = ClientBase.createTmpDir();\n<line3>    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);\n<line4>    ZKDatabase zkdb = new ZKDatabase(snaplog);\n<line5>    for (int i = 1; i <= 100; i++) {\n<line6>        append(zkdb, i);\n<line7>    }\n<line8>    zkdb.close();\n<line9>    for (int i = 0; i < logs.length; i++) {\n<line10>        assertTrue(logs[i].delete(), \"Failed to delete log file: \" + logs[i].getName());\n<line11>    }\n<line12>    try {\n<line13>        assertThat(\"truncateLog() should return false if truncation fails instead of throwing exception\", zkdb.truncateLog(1), is(false));\n<line14>    } catch (NullPointerException npe) {\n<line15>        fail(\"This should not throw NPE!\");\n<line16>    }\n<line17>    ClientBase.recursiveDelete(tmpdir);\n<line18>}","output":"<line1>{\n<line2>    File tmpdir = ClientBase.createTmpDir();\n<line3>    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);\n<line4>    ZKDatabase zkdb = new ZKDatabase(snaplog);\n<line5>    for (int i = 1; i <= 100; i++) {\n<line6>        append(zkdb, i);\n<line7>    }\n<line8>    zkdb.close();\n<line9>    File[] logs = snaplog.getDataLogDir().listFiles();\n<line10>    for (int i = 0; i < logs.length; i++) {\n<line11>        LOG.debug(\"Deleting: {}\", logs[i].getName());\n<line12>        assertTrue(logs[i].delete(), \"Failed to delete log file: \" + logs[i].getName());\n<line13>    }\n<line14>    try {\n<line15>        assertThat(\"truncateLog() should return false if truncation fails instead of throwing exception\", zkdb.truncateLog(1), is(false));\n<line16>    } catch (NullPointerException npe) {\n<line17>        fail(\"This should not throw NPE!\");\n<line18>    }\n<line19>    ClientBase.recursiveDelete(tmpdir);\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(logs[i].delete(), \"Failed to delete log file: \" + logs[i].getName());\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Deleting: {}\", logs[i].getName());\n<line3>    assertTrue(logs[i].delete(), \"Failed to delete log file: \" + logs[i].getName());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Error count {}\", errors.get());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    CountdownWatcher watcher1 = new CountdownWatcher();\n<line3>    CountdownWatcher watcher2 = new CountdownWatcher();\n<line4>    CountdownWatcher watcher3 = new CountdownWatcher();\n<line5>    QuorumUtil qu = new QuorumUtil(1);\n<line6>    qu.shutdownAll();\n<line7>    qu.start(1);\n<line8>    qu.start(2);\n<line9>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line10>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line11>    ZooKeeper zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);\n<line12>    final String resyncPath = \"/resyncundernewepoch\";\n<line13>    zk1.create(resyncPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>    zk1.close();\n<line15>    qu.shutdown(1);\n<line16>    qu.shutdown(2);\n<line17>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line18>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line19>    qu.start(1);\n<line20>    qu.start(2);\n<line21>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line22>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line23>    qu.start(3);\n<line24>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(3).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line25>    zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);\n<line26>    assertNotNull(zk1.exists(resyncPath, false), \"zk1 has data\");\n<line27>    final ZooKeeper zk2 = createClient(qu.getPeer(2).peer.getClientPort(), watcher2);\n<line28>    assertNotNull(zk2.exists(resyncPath, false), \"zk2 has data\");\n<line29>    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);\n<line30>    assertNotNull(zk3.exists(resyncPath, false), \"zk3 has data\");\n<line31>    zk1.close();\n<line32>    zk2.close();\n<line33>    zk3.close();\n<line34>    qu.shutdownAll();\n<line35>}","output":"<line1>{\n<line2>    CountdownWatcher watcher1 = new CountdownWatcher();\n<line3>    CountdownWatcher watcher2 = new CountdownWatcher();\n<line4>    CountdownWatcher watcher3 = new CountdownWatcher();\n<line5>    QuorumUtil qu = new QuorumUtil(1);\n<line6>    qu.shutdownAll();\n<line7>    qu.start(1);\n<line8>    qu.start(2);\n<line9>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line10>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line11>    ZooKeeper zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);\n<line12>    LOG.info(\"zk1 has session id 0x{}\", Long.toHexString(zk1.getSessionId()));\n<line13>    final String resyncPath = \"/resyncundernewepoch\";\n<line14>    zk1.create(resyncPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>    zk1.close();\n<line16>    qu.shutdown(1);\n<line17>    qu.shutdown(2);\n<line18>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line19>    assertTrue(ClientBase.waitForServerDown(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server down\");\n<line20>    qu.start(1);\n<line21>    qu.start(2);\n<line22>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line23>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line24>    qu.start(3);\n<line25>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(3).clientPort, ClientBase.CONNECTION_TIMEOUT), \"Waiting for server up\");\n<line26>    zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);\n<line27>    LOG.info(\"zk1 has session id 0x{}\", Long.toHexString(zk1.getSessionId()));\n<line28>    assertNotNull(zk1.exists(resyncPath, false), \"zk1 has data\");\n<line29>    final ZooKeeper zk2 = createClient(qu.getPeer(2).peer.getClientPort(), watcher2);\n<line30>    LOG.info(\"zk2 has session id 0x{}\", Long.toHexString(zk2.getSessionId()));\n<line31>    assertNotNull(zk2.exists(resyncPath, false), \"zk2 has data\");\n<line32>    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);\n<line33>    LOG.info(\"zk3 has session id 0x{}\", Long.toHexString(zk3.getSessionId()));\n<line34>    assertNotNull(zk3.exists(resyncPath, false), \"zk3 has data\");\n<line35>    zk1.close();\n<line36>    zk2.close();\n<line37>    zk3.close();\n<line38>    qu.shutdownAll();\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    final Semaphore sem = new Semaphore(0);\n<line3>    QuorumUtil qu = new QuorumUtil(1);\n<line4>    qu.startAll();\n<line5>    CountdownWatcher watcher1 = new CountdownWatcher();\n<line6>    CountdownWatcher watcher2 = new CountdownWatcher();\n<line7>    CountdownWatcher watcher3 = new CountdownWatcher();\n<line8>    int index = 1;\n<line9>    while (qu.getPeer(index).peer.leader == null) {\n<line10>        index++;\n<line11>    }\n<line12>    Leader leader = qu.getPeer(index).peer.leader;\n<line13>    assertNotNull(leader);\n<line14>    if (useTxnLogResync) {\n<line15>        // Set the factor to high value so that this test case always\n<line16>        // resync using txnlog\n<line17>        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(1000);\n<line18>    } else {\n<line19>        // Disable sending DIFF using txnlog, so that this test still\n<line20>        // testing the ZOOKEEPER-962 bug\n<line21>        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(-1);\n<line22>    }\n<line23>    /* Reusing the index variable to select a follower to connect to */\n<line24>    index = (index == 1) ? 2 : 1;\n<line25>    qu.shutdown(index);\n<line26>    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);\n<line27>    zk3.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line28>    qu.restart(index);\n<line29>    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);\n<line30>    final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);\n<line31>    zk1.create(\"/first\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line32>    // Prepare a thread that will create znodes.\n<line33>    Thread mytestfooThread = new Thread(new Runnable() {\n<line34>\n<line35>        @Override\n<line36>        public void run() {\n<line37>            for (int i = 0; i < 3000; i++) {\n<line38>                // Here we create 3000 znodes\n<line39>                zk3.create(\"/mytestfoo\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line40>                    pending.decrementAndGet();\n<line41>                    counter.incrementAndGet();\n<line42>                    if (rc != 0) {\n<line43>                        errors.incrementAndGet();\n<line44>                    }\n<line45>                    if (counter.get() == 16200) {\n<line46>                        sem.release();\n<line47>                    }\n<line48>                }, null);\n<line49>                pending.incrementAndGet();\n<line50>                if (i % 10 == 0) {\n<line51>                    try {\n<line52>                        Thread.sleep(100);\n<line53>                    } catch (Exception e) {\n<line54>                    }\n<line55>                }\n<line56>            }\n<line57>        }\n<line58>    });\n<line59>    // Here we start populating the server and shutdown the follower after\n<line60>    // initial data is written.\n<line61>    for (int i = 0; i < 13000; i++) {\n<line62>        // Here we create 13000 znodes\n<line63>        zk3.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line64>            pending.decrementAndGet();\n<line65>            counter.incrementAndGet();\n<line66>            if (rc != 0) {\n<line67>                errors.incrementAndGet();\n<line68>            }\n<line69>            if (counter.get() == 16200) {\n<line70>                sem.release();\n<line71>            }\n<line72>        }, null);\n<line73>        pending.incrementAndGet();\n<line74>        if (i == 5000) {\n<line75>            qu.shutdown(index);\n<line76>        }\n<line77>        if (i == 12000) {\n<line78>            // Start the prepared thread so that it is writing znodes while\n<line79>            // the follower is restarting. On the first restart, the follow\n<line80>            // should use txnlog to catchup. For subsequent restart, the\n<line81>            // follower should use a diff to catchup.\n<line82>            mytestfooThread.start();\n<line83>            qu.restart(index);\n<line84>            Thread.sleep(300);\n<line85>            qu.shutdown(index);\n<line86>            Thread.sleep(300);\n<line87>            qu.restart(index);\n<line88>        }\n<line89>        if ((i % 1000) == 0) {\n<line90>            Thread.sleep(1000);\n<line91>        }\n<line92>        if (i % 50 == 0) {\n<line93>            zk2.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line94>                pending.decrementAndGet();\n<line95>                counter.incrementAndGet();\n<line96>                if (rc != 0) {\n<line97>                    errors.incrementAndGet();\n<line98>                }\n<line99>                if (counter.get() == 16200) {\n<line100>                    sem.release();\n<line101>                }\n<line102>            }, null);\n<line103>            pending.incrementAndGet();\n<line104>        }\n<line105>    }\n<line106>    // Wait until all updates return\n<line107>    if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line108>    }\n<line109>    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line110>    if (mytestfooThread.isAlive()) {\n<line111>    }\n<line112>    assertTrue(waitForPendingRequests(60));\n<line113>    assertTrue(waitForSync(qu, index, 10));\n<line114>    verifyState(qu, index, leader);\n<line115>    zk1.close();\n<line116>    zk2.close();\n<line117>    zk3.close();\n<line118>    qu.shutdownAll();\n<line119>}","output":"<line1>{\n<line2>    final Semaphore sem = new Semaphore(0);\n<line3>    QuorumUtil qu = new QuorumUtil(1);\n<line4>    qu.startAll();\n<line5>    CountdownWatcher watcher1 = new CountdownWatcher();\n<line6>    CountdownWatcher watcher2 = new CountdownWatcher();\n<line7>    CountdownWatcher watcher3 = new CountdownWatcher();\n<line8>    int index = 1;\n<line9>    while (qu.getPeer(index).peer.leader == null) {\n<line10>        index++;\n<line11>    }\n<line12>    Leader leader = qu.getPeer(index).peer.leader;\n<line13>    assertNotNull(leader);\n<line14>    if (useTxnLogResync) {\n<line15>        // Set the factor to high value so that this test case always\n<line16>        // resync using txnlog\n<line17>        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(1000);\n<line18>    } else {\n<line19>        // Disable sending DIFF using txnlog, so that this test still\n<line20>        // testing the ZOOKEEPER-962 bug\n<line21>        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(-1);\n<line22>    }\n<line23>    /* Reusing the index variable to select a follower to connect to */\n<line24>    index = (index == 1) ? 2 : 1;\n<line25>    LOG.info(\"Connecting to follower: {}\", index);\n<line26>    qu.shutdown(index);\n<line27>    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);\n<line28>    LOG.info(\"zk3 has session id 0x{}\", Long.toHexString(zk3.getSessionId()));\n<line29>    zk3.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line30>    qu.restart(index);\n<line31>    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);\n<line32>    LOG.info(\"zk1 has session id 0x{}\", Long.toHexString(zk1.getSessionId()));\n<line33>    final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);\n<line34>    LOG.info(\"zk2 has session id 0x{}\", Long.toHexString(zk2.getSessionId()));\n<line35>    zk1.create(\"/first\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line36>    // Prepare a thread that will create znodes.\n<line37>    Thread mytestfooThread = new Thread(new Runnable() {\n<line38>\n<line39>        @Override\n<line40>        public void run() {\n<line41>            for (int i = 0; i < 3000; i++) {\n<line42>                // Here we create 3000 znodes\n<line43>                zk3.create(\"/mytestfoo\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line44>                    pending.decrementAndGet();\n<line45>                    counter.incrementAndGet();\n<line46>                    if (rc != 0) {\n<line47>                        errors.incrementAndGet();\n<line48>                    }\n<line49>                    if (counter.get() == 16200) {\n<line50>                        sem.release();\n<line51>                    }\n<line52>                }, null);\n<line53>                pending.incrementAndGet();\n<line54>                if (i % 10 == 0) {\n<line55>                    try {\n<line56>                        Thread.sleep(100);\n<line57>                    } catch (Exception e) {\n<line58>                    }\n<line59>                }\n<line60>            }\n<line61>        }\n<line62>    });\n<line63>    // Here we start populating the server and shutdown the follower after\n<line64>    // initial data is written.\n<line65>    for (int i = 0; i < 13000; i++) {\n<line66>        // Here we create 13000 znodes\n<line67>        zk3.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line68>            pending.decrementAndGet();\n<line69>            counter.incrementAndGet();\n<line70>            if (rc != 0) {\n<line71>                errors.incrementAndGet();\n<line72>            }\n<line73>            if (counter.get() == 16200) {\n<line74>                sem.release();\n<line75>            }\n<line76>        }, null);\n<line77>        pending.incrementAndGet();\n<line78>        if (i == 5000) {\n<line79>            qu.shutdown(index);\n<line80>            LOG.info(\"Shutting down s1\");\n<line81>        }\n<line82>        if (i == 12000) {\n<line83>            // Start the prepared thread so that it is writing znodes while\n<line84>            // the follower is restarting. On the first restart, the follow\n<line85>            // should use txnlog to catchup. For subsequent restart, the\n<line86>            // follower should use a diff to catchup.\n<line87>            mytestfooThread.start();\n<line88>            LOG.info(\"Restarting follower: {}\", index);\n<line89>            qu.restart(index);\n<line90>            Thread.sleep(300);\n<line91>            LOG.info(\"Shutdown follower: {}\", index);\n<line92>            qu.shutdown(index);\n<line93>            Thread.sleep(300);\n<line94>            LOG.info(\"Restarting follower: {}\", index);\n<line95>            qu.restart(index);\n<line96>            LOG.info(\"Setting up server: {}\", index);\n<line97>        }\n<line98>        if ((i % 1000) == 0) {\n<line99>            Thread.sleep(1000);\n<line100>        }\n<line101>        if (i % 50 == 0) {\n<line102>            zk2.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line103>                pending.decrementAndGet();\n<line104>                counter.incrementAndGet();\n<line105>                if (rc != 0) {\n<line106>                    errors.incrementAndGet();\n<line107>                }\n<line108>                if (counter.get() == 16200) {\n<line109>                    sem.release();\n<line110>                }\n<line111>            }, null);\n<line112>            pending.incrementAndGet();\n<line113>        }\n<line114>    }\n<line115>    // Wait until all updates return\n<line116>    if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line117>        LOG.warn(\"Did not aquire semaphore fast enough\");\n<line118>    }\n<line119>    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line120>    if (mytestfooThread.isAlive()) {\n<line121>        LOG.error(\"mytestfooThread is still alive\");\n<line122>    }\n<line123>    assertTrue(waitForPendingRequests(60));\n<line124>    assertTrue(waitForSync(qu, index, 10));\n<line125>    verifyState(qu, index, leader);\n<line126>    zk1.close();\n<line127>    zk2.close();\n<line128>    zk3.close();\n<line129>    qu.shutdownAll();\n<line130>}"},{"input":"","instruction":"<line1>{\n<line2>    // Here we create 13000 znodes\n<line3>    zk3.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line4>        pending.decrementAndGet();\n<line5>        counter.incrementAndGet();\n<line6>        if (rc != 0) {\n<line7>            errors.incrementAndGet();\n<line8>        }\n<line9>        if (counter.get() == 16200) {\n<line10>            sem.release();\n<line11>        }\n<line12>    }, null);\n<line13>    pending.incrementAndGet();\n<line14>    if (i == 5000) {\n<line15>        qu.shutdown(index);\n<line16>    }\n<line17>    if (i == 12000) {\n<line18>        // Start the prepared thread so that it is writing znodes while\n<line19>        // the follower is restarting. On the first restart, the follow\n<line20>        // should use txnlog to catchup. For subsequent restart, the\n<line21>        // follower should use a diff to catchup.\n<line22>        mytestfooThread.start();\n<line23>        qu.restart(index);\n<line24>        Thread.sleep(300);\n<line25>        qu.shutdown(index);\n<line26>        Thread.sleep(300);\n<line27>        qu.restart(index);\n<line28>    }\n<line29>    if ((i % 1000) == 0) {\n<line30>        Thread.sleep(1000);\n<line31>    }\n<line32>    if (i % 50 == 0) {\n<line33>        zk2.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line34>            pending.decrementAndGet();\n<line35>            counter.incrementAndGet();\n<line36>            if (rc != 0) {\n<line37>                errors.incrementAndGet();\n<line38>            }\n<line39>            if (counter.get() == 16200) {\n<line40>                sem.release();\n<line41>            }\n<line42>        }, null);\n<line43>        pending.incrementAndGet();\n<line44>    }\n<line45>}","output":"<line1>{\n<line2>    // Here we create 13000 znodes\n<line3>    zk3.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line4>        pending.decrementAndGet();\n<line5>        counter.incrementAndGet();\n<line6>        if (rc != 0) {\n<line7>            errors.incrementAndGet();\n<line8>        }\n<line9>        if (counter.get() == 16200) {\n<line10>            sem.release();\n<line11>        }\n<line12>    }, null);\n<line13>    pending.incrementAndGet();\n<line14>    if (i == 5000) {\n<line15>        qu.shutdown(index);\n<line16>        LOG.info(\"Shutting down s1\");\n<line17>    }\n<line18>    if (i == 12000) {\n<line19>        // Start the prepared thread so that it is writing znodes while\n<line20>        // the follower is restarting. On the first restart, the follow\n<line21>        // should use txnlog to catchup. For subsequent restart, the\n<line22>        // follower should use a diff to catchup.\n<line23>        mytestfooThread.start();\n<line24>        LOG.info(\"Restarting follower: {}\", index);\n<line25>        qu.restart(index);\n<line26>        Thread.sleep(300);\n<line27>        LOG.info(\"Shutdown follower: {}\", index);\n<line28>        qu.shutdown(index);\n<line29>        Thread.sleep(300);\n<line30>        LOG.info(\"Restarting follower: {}\", index);\n<line31>        qu.restart(index);\n<line32>        LOG.info(\"Setting up server: {}\", index);\n<line33>    }\n<line34>    if ((i % 1000) == 0) {\n<line35>        Thread.sleep(1000);\n<line36>    }\n<line37>    if (i % 50 == 0) {\n<line38>        zk2.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line39>            pending.decrementAndGet();\n<line40>            counter.incrementAndGet();\n<line41>            if (rc != 0) {\n<line42>                errors.incrementAndGet();\n<line43>            }\n<line44>            if (counter.get() == 16200) {\n<line45>                sem.release();\n<line46>            }\n<line47>        }, null);\n<line48>        pending.incrementAndGet();\n<line49>    }\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.shutdown(index);\n<line3>}","output":"<line1>{\n<line2>    qu.shutdown(index);\n<line3>    LOG.info(\"Shutting down s1\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Start the prepared thread so that it is writing znodes while\n<line3>    // the follower is restarting. On the first restart, the follow\n<line4>    // should use txnlog to catchup. For subsequent restart, the\n<line5>    // follower should use a diff to catchup.\n<line6>    mytestfooThread.start();\n<line7>    qu.restart(index);\n<line8>    Thread.sleep(300);\n<line9>    qu.shutdown(index);\n<line10>    Thread.sleep(300);\n<line11>    qu.restart(index);\n<line12>}","output":"<line1>{\n<line2>    // Start the prepared thread so that it is writing znodes while\n<line3>    // the follower is restarting. On the first restart, the follow\n<line4>    // should use txnlog to catchup. For subsequent restart, the\n<line5>    // follower should use a diff to catchup.\n<line6>    mytestfooThread.start();\n<line7>    LOG.info(\"Restarting follower: {}\", index);\n<line8>    qu.restart(index);\n<line9>    Thread.sleep(300);\n<line10>    LOG.info(\"Shutdown follower: {}\", index);\n<line11>    qu.shutdown(index);\n<line12>    Thread.sleep(300);\n<line13>    LOG.info(\"Restarting follower: {}\", index);\n<line14>    qu.restart(index);\n<line15>    LOG.info(\"Setting up server: {}\", index);\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"mytestfooThread is still alive\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final Semaphore sem = new Semaphore(0);\n<line3>    QuorumUtil qu = new QuorumUtil(1);\n<line4>    qu.startAll();\n<line5>    CountdownWatcher watcher1 = new CountdownWatcher();\n<line6>    CountdownWatcher watcher2 = new CountdownWatcher();\n<line7>    CountdownWatcher watcher3 = new CountdownWatcher();\n<line8>    int index = 1;\n<line9>    while (qu.getPeer(index).peer.leader == null) {\n<line10>        index++;\n<line11>    }\n<line12>    Leader leader = qu.getPeer(index).peer.leader;\n<line13>    assertNotNull(leader);\n<line14>    /* Reusing the index variable to select a follower to connect to */\n<line15>    index = (index == 1) ? 2 : 1;\n<line16>    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);\n<line17>    final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);\n<line18>    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);\n<line19>    zk1.create(\"/first\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line20>    zk2.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line21>    final AtomicBoolean runNow = new AtomicBoolean(false);\n<line22>    Thread mytestfooThread = new Thread(new Runnable() {\n<line23>\n<line24>        @Override\n<line25>        public void run() {\n<line26>            int inSyncCounter = 0;\n<line27>            while (inSyncCounter < 400) {\n<line28>                if (runNow.get()) {\n<line29>                    zk3.create(\"/mytestfoo\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line30>                        pending.decrementAndGet();\n<line31>                        counter.incrementAndGet();\n<line32>                        if (rc != 0) {\n<line33>                            errors.incrementAndGet();\n<line34>                        }\n<line35>                        if (counter.get() > 7300) {\n<line36>                            sem.release();\n<line37>                        }\n<line38>                    }, null);\n<line39>                    pending.incrementAndGet();\n<line40>                    try {\n<line41>                        Thread.sleep(10);\n<line42>                    } catch (Exception e) {\n<line43>                    }\n<line44>                    inSyncCounter++;\n<line45>                } else {\n<line46>                    Thread.yield();\n<line47>                }\n<line48>            }\n<line49>        }\n<line50>    });\n<line51>    mytestfooThread.start();\n<line52>    for (int i = 0; i < 5000; i++) {\n<line53>        zk2.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line54>            pending.decrementAndGet();\n<line55>            counter.incrementAndGet();\n<line56>            if (rc != 0) {\n<line57>                errors.incrementAndGet();\n<line58>            }\n<line59>            if (counter.get() > 7300) {\n<line60>                sem.release();\n<line61>            }\n<line62>        }, null);\n<line63>        pending.incrementAndGet();\n<line64>        if (i == 1000) {\n<line65>            qu.shutdown(index);\n<line66>            Thread.sleep(1100);\n<line67>        }\n<line68>        if (i == 1100 || i == 1150 || i == 1200) {\n<line69>            Thread.sleep(1000);\n<line70>        }\n<line71>        if (i == 1200) {\n<line72>            qu.startThenShutdown(index);\n<line73>            runNow.set(true);\n<line74>            qu.restart(index);\n<line75>        }\n<line76>        if (i >= 1000 && i % 2 == 0) {\n<line77>            zk3.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line78>                pending.decrementAndGet();\n<line79>                counter.incrementAndGet();\n<line80>                if (rc != 0) {\n<line81>                    errors.incrementAndGet();\n<line82>                }\n<line83>                if (counter.get() > 7300) {\n<line84>                    sem.release();\n<line85>                }\n<line86>            }, null);\n<line87>            pending.incrementAndGet();\n<line88>        }\n<line89>        if (i == 1050 || i == 1100 || i == 1150) {\n<line90>            Thread.sleep(1000);\n<line91>        }\n<line92>    }\n<line93>    // Wait until all updates return\n<line94>    if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line95>    }\n<line96>    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line97>    if (mytestfooThread.isAlive()) {\n<line98>    }\n<line99>    assertTrue(waitForPendingRequests(60));\n<line100>    assertTrue(waitForSync(qu, index, 10));\n<line101>    // Verify that server is following and has the same epoch as the leader\n<line102>    verifyState(qu, index, leader);\n<line103>    zk1.close();\n<line104>    zk2.close();\n<line105>    zk3.close();\n<line106>    qu.shutdownAll();\n<line107>}","output":"<line1>{\n<line2>    final Semaphore sem = new Semaphore(0);\n<line3>    QuorumUtil qu = new QuorumUtil(1);\n<line4>    qu.startAll();\n<line5>    CountdownWatcher watcher1 = new CountdownWatcher();\n<line6>    CountdownWatcher watcher2 = new CountdownWatcher();\n<line7>    CountdownWatcher watcher3 = new CountdownWatcher();\n<line8>    int index = 1;\n<line9>    while (qu.getPeer(index).peer.leader == null) {\n<line10>        index++;\n<line11>    }\n<line12>    Leader leader = qu.getPeer(index).peer.leader;\n<line13>    assertNotNull(leader);\n<line14>    /* Reusing the index variable to select a follower to connect to */\n<line15>    index = (index == 1) ? 2 : 1;\n<line16>    LOG.info(\"Connecting to follower: {}\", index);\n<line17>    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);\n<line18>    LOG.info(\"zk1 has session id 0x{}\", Long.toHexString(zk1.getSessionId()));\n<line19>    final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);\n<line20>    LOG.info(\"zk2 has session id 0x{}\", Long.toHexString(zk2.getSessionId()));\n<line21>    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);\n<line22>    LOG.info(\"zk3 has session id 0x{}\", Long.toHexString(zk3.getSessionId()));\n<line23>    zk1.create(\"/first\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line24>    zk2.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line25>    final AtomicBoolean runNow = new AtomicBoolean(false);\n<line26>    Thread mytestfooThread = new Thread(new Runnable() {\n<line27>\n<line28>        @Override\n<line29>        public void run() {\n<line30>            int inSyncCounter = 0;\n<line31>            while (inSyncCounter < 400) {\n<line32>                if (runNow.get()) {\n<line33>                    zk3.create(\"/mytestfoo\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line34>                        pending.decrementAndGet();\n<line35>                        counter.incrementAndGet();\n<line36>                        if (rc != 0) {\n<line37>                            errors.incrementAndGet();\n<line38>                        }\n<line39>                        if (counter.get() > 7300) {\n<line40>                            sem.release();\n<line41>                        }\n<line42>                    }, null);\n<line43>                    pending.incrementAndGet();\n<line44>                    try {\n<line45>                        Thread.sleep(10);\n<line46>                    } catch (Exception e) {\n<line47>                    }\n<line48>                    inSyncCounter++;\n<line49>                } else {\n<line50>                    Thread.yield();\n<line51>                }\n<line52>            }\n<line53>        }\n<line54>    });\n<line55>    mytestfooThread.start();\n<line56>    for (int i = 0; i < 5000; i++) {\n<line57>        zk2.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line58>            pending.decrementAndGet();\n<line59>            counter.incrementAndGet();\n<line60>            if (rc != 0) {\n<line61>                errors.incrementAndGet();\n<line62>            }\n<line63>            if (counter.get() > 7300) {\n<line64>                sem.release();\n<line65>            }\n<line66>        }, null);\n<line67>        pending.incrementAndGet();\n<line68>        if (i == 1000) {\n<line69>            qu.shutdown(index);\n<line70>            Thread.sleep(1100);\n<line71>            LOG.info(\"Shutting down s1\");\n<line72>        }\n<line73>        if (i == 1100 || i == 1150 || i == 1200) {\n<line74>            Thread.sleep(1000);\n<line75>        }\n<line76>        if (i == 1200) {\n<line77>            qu.startThenShutdown(index);\n<line78>            runNow.set(true);\n<line79>            qu.restart(index);\n<line80>            LOG.info(\"Setting up server: {}\", index);\n<line81>        }\n<line82>        if (i >= 1000 && i % 2 == 0) {\n<line83>            zk3.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line84>                pending.decrementAndGet();\n<line85>                counter.incrementAndGet();\n<line86>                if (rc != 0) {\n<line87>                    errors.incrementAndGet();\n<line88>                }\n<line89>                if (counter.get() > 7300) {\n<line90>                    sem.release();\n<line91>                }\n<line92>            }, null);\n<line93>            pending.incrementAndGet();\n<line94>        }\n<line95>        if (i == 1050 || i == 1100 || i == 1150) {\n<line96>            Thread.sleep(1000);\n<line97>        }\n<line98>    }\n<line99>    // Wait until all updates return\n<line100>    if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line101>        LOG.warn(\"Did not aquire semaphore fast enough\");\n<line102>    }\n<line103>    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);\n<line104>    if (mytestfooThread.isAlive()) {\n<line105>        LOG.error(\"mytestfooThread is still alive\");\n<line106>    }\n<line107>    assertTrue(waitForPendingRequests(60));\n<line108>    assertTrue(waitForSync(qu, index, 10));\n<line109>    // Verify that server is following and has the same epoch as the leader\n<line110>    verifyState(qu, index, leader);\n<line111>    zk1.close();\n<line112>    zk2.close();\n<line113>    zk3.close();\n<line114>    qu.shutdownAll();\n<line115>}"},{"input":"","instruction":"<line1>{\n<line2>    zk2.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line3>        pending.decrementAndGet();\n<line4>        counter.incrementAndGet();\n<line5>        if (rc != 0) {\n<line6>            errors.incrementAndGet();\n<line7>        }\n<line8>        if (counter.get() > 7300) {\n<line9>            sem.release();\n<line10>        }\n<line11>    }, null);\n<line12>    pending.incrementAndGet();\n<line13>    if (i == 1000) {\n<line14>        qu.shutdown(index);\n<line15>        Thread.sleep(1100);\n<line16>    }\n<line17>    if (i == 1100 || i == 1150 || i == 1200) {\n<line18>        Thread.sleep(1000);\n<line19>    }\n<line20>    if (i == 1200) {\n<line21>        qu.startThenShutdown(index);\n<line22>        runNow.set(true);\n<line23>        qu.restart(index);\n<line24>    }\n<line25>    if (i >= 1000 && i % 2 == 0) {\n<line26>        zk3.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line27>            pending.decrementAndGet();\n<line28>            counter.incrementAndGet();\n<line29>            if (rc != 0) {\n<line30>                errors.incrementAndGet();\n<line31>            }\n<line32>            if (counter.get() > 7300) {\n<line33>                sem.release();\n<line34>            }\n<line35>        }, null);\n<line36>        pending.incrementAndGet();\n<line37>    }\n<line38>    if (i == 1050 || i == 1100 || i == 1150) {\n<line39>        Thread.sleep(1000);\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    zk2.create(\"/mybar\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line3>        pending.decrementAndGet();\n<line4>        counter.incrementAndGet();\n<line5>        if (rc != 0) {\n<line6>            errors.incrementAndGet();\n<line7>        }\n<line8>        if (counter.get() > 7300) {\n<line9>            sem.release();\n<line10>        }\n<line11>    }, null);\n<line12>    pending.incrementAndGet();\n<line13>    if (i == 1000) {\n<line14>        qu.shutdown(index);\n<line15>        Thread.sleep(1100);\n<line16>        LOG.info(\"Shutting down s1\");\n<line17>    }\n<line18>    if (i == 1100 || i == 1150 || i == 1200) {\n<line19>        Thread.sleep(1000);\n<line20>    }\n<line21>    if (i == 1200) {\n<line22>        qu.startThenShutdown(index);\n<line23>        runNow.set(true);\n<line24>        qu.restart(index);\n<line25>        LOG.info(\"Setting up server: {}\", index);\n<line26>    }\n<line27>    if (i >= 1000 && i % 2 == 0) {\n<line28>        zk3.create(\"/newbaz\", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, (rc, path, ctx, name) -> {\n<line29>            pending.decrementAndGet();\n<line30>            counter.incrementAndGet();\n<line31>            if (rc != 0) {\n<line32>                errors.incrementAndGet();\n<line33>            }\n<line34>            if (counter.get() > 7300) {\n<line35>                sem.release();\n<line36>            }\n<line37>        }, null);\n<line38>        pending.incrementAndGet();\n<line39>    }\n<line40>    if (i == 1050 || i == 1100 || i == 1150) {\n<line41>        Thread.sleep(1000);\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.shutdown(index);\n<line3>    Thread.sleep(1100);\n<line4>}","output":"<line1>{\n<line2>    qu.shutdown(index);\n<line3>    Thread.sleep(1100);\n<line4>    LOG.info(\"Shutting down s1\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.startThenShutdown(index);\n<line3>    runNow.set(true);\n<line4>    qu.restart(index);\n<line5>}","output":"<line1>{\n<line2>    qu.startThenShutdown(index);\n<line3>    runNow.set(true);\n<line4>    qu.restart(index);\n<line5>    LOG.info(\"Setting up server: {}\", index);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"mytestfooThread is still alive\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < timeout; ++i) {\n<line3>        Thread.sleep(1000);\n<line4>        if (pending.get() == 0) {\n<line5>            return true;\n<line6>        }\n<line7>    }\n<line8>    return false;\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Wait for pending requests: {}\", pending.get());\n<line3>    for (int i = 0; i < timeout; ++i) {\n<line4>        Thread.sleep(1000);\n<line5>        if (pending.get() == 0) {\n<line6>            return true;\n<line7>        }\n<line8>    }\n<line9>    LOG.info(\"Timeout waiting for pending requests: {}\", pending.get());\n<line10>    return false;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    int leaderIndex = (index == 1) ? 2 : 1;\n<line3>    ZKDatabase restartedDb = qu.getPeer(index).peer.getActiveServer().getZKDatabase();\n<line4>    ZKDatabase cleanDb = qu.getPeer(3).peer.getActiveServer().getZKDatabase();\n<line5>    ZKDatabase leadDb = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();\n<line6>    long leadZxid = 0;\n<line7>    long cleanZxid = 0;\n<line8>    long restartedZxid = 0;\n<line9>    for (int i = 0; i < timeout; ++i) {\n<line10>        leadZxid = leadDb.getDataTreeLastProcessedZxid();\n<line11>        cleanZxid = cleanDb.getDataTreeLastProcessedZxid();\n<line12>        restartedZxid = restartedDb.getDataTreeLastProcessedZxid();\n<line13>        if (leadZxid == cleanZxid && leadZxid == restartedZxid) {\n<line14>            return true;\n<line15>        }\n<line16>        Thread.sleep(1000);\n<line17>    }\n<line18>    return false;\n<line19>}","output":"<line1>{\n<line2>    LOG.info(\"Wait for server to sync\");\n<line3>    int leaderIndex = (index == 1) ? 2 : 1;\n<line4>    ZKDatabase restartedDb = qu.getPeer(index).peer.getActiveServer().getZKDatabase();\n<line5>    ZKDatabase cleanDb = qu.getPeer(3).peer.getActiveServer().getZKDatabase();\n<line6>    ZKDatabase leadDb = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();\n<line7>    long leadZxid = 0;\n<line8>    long cleanZxid = 0;\n<line9>    long restartedZxid = 0;\n<line10>    for (int i = 0; i < timeout; ++i) {\n<line11>        leadZxid = leadDb.getDataTreeLastProcessedZxid();\n<line12>        cleanZxid = cleanDb.getDataTreeLastProcessedZxid();\n<line13>        restartedZxid = restartedDb.getDataTreeLastProcessedZxid();\n<line14>        if (leadZxid == cleanZxid && leadZxid == restartedZxid) {\n<line15>            return true;\n<line16>        }\n<line17>        Thread.sleep(1000);\n<line18>    }\n<line19>    LOG.info(\"Timeout waiting for zxid to sync: leader 0x{} clean 0x{} restarted 0x{}\", Long.toHexString(leadZxid), Long.toHexString(cleanZxid), Long.toHexString(restartedZxid));\n<line20>    return false;\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(qu.getPeer(index).peer.follower != null, \"Not following\");\n<line3>    long epochF = (qu.getPeer(index).peer.getActiveServer().getZxid() >> 32L);\n<line4>    long epochL = (leader.getEpoch() >> 32L);\n<line5>    assertTrue(epochF == epochL, \"Zxid: \" + qu.getPeer(index).peer.getActiveServer().getZKDatabase().getDataTreeLastProcessedZxid() + \"Current epoch: \" + epochF);\n<line6>    int leaderIndex = (index == 1) ? 2 : 1;\n<line7>    Collection<Long> sessionsRestarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase().getSessions();\n<line8>    Collection<Long> sessionsNotRestarted = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase().getSessions();\n<line9>    for (Long l : sessionsRestarted) {\n<line10>        assertTrue(sessionsNotRestarted.contains(l), \"Should have same set of sessions in both servers, did not expect: \" + l);\n<line11>    }\n<line12>    assertEquals(sessionsNotRestarted.size(), sessionsRestarted.size(), \"Should have same number of sessions\");\n<line13>    ZKDatabase restarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase();\n<line14>    ZKDatabase clean = qu.getPeer(3).peer.getActiveServer().getZKDatabase();\n<line15>    ZKDatabase lead = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();\n<line16>    for (Long l : sessionsRestarted) {\n<line17>        assertTrue(sessionsNotRestarted.contains(l), \"Should have same set of sessions in both servers, did not expect: \" + l);\n<line18>        Set<String> ephemerals = restarted.getEphemerals(l);\n<line19>        Set<String> cleanEphemerals = clean.getEphemerals(l);\n<line20>        for (String o : cleanEphemerals) {\n<line21>            if (!ephemerals.contains(o)) {\n<line22>            }\n<line23>        }\n<line24>        for (String o : ephemerals) {\n<line25>            if (!cleanEphemerals.contains(o)) {\n<line26>            }\n<line27>        }\n<line28>        Set<String> leadEphemerals = lead.getEphemerals(l);\n<line29>        for (String o : leadEphemerals) {\n<line30>            if (!cleanEphemerals.contains(o)) {\n<line31>            }\n<line32>        }\n<line33>        for (String o : cleanEphemerals) {\n<line34>            if (!leadEphemerals.contains(o)) {\n<line35>            }\n<line36>        }\n<line37>        assertEquals(ephemerals.size(), cleanEphemerals.size(), \"Should have same number of ephemerals in both followers\");\n<line38>        assertEquals(lead.getEphemerals(l).size(), cleanEphemerals.size(), \"Leader should equal follower\");\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    LOG.info(\"Verifying state\");\n<line3>    assertTrue(qu.getPeer(index).peer.follower != null, \"Not following\");\n<line4>    long epochF = (qu.getPeer(index).peer.getActiveServer().getZxid() >> 32L);\n<line5>    long epochL = (leader.getEpoch() >> 32L);\n<line6>    assertTrue(epochF == epochL, \"Zxid: \" + qu.getPeer(index).peer.getActiveServer().getZKDatabase().getDataTreeLastProcessedZxid() + \"Current epoch: \" + epochF);\n<line7>    int leaderIndex = (index == 1) ? 2 : 1;\n<line8>    Collection<Long> sessionsRestarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase().getSessions();\n<line9>    Collection<Long> sessionsNotRestarted = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase().getSessions();\n<line10>    for (Long l : sessionsRestarted) {\n<line11>        assertTrue(sessionsNotRestarted.contains(l), \"Should have same set of sessions in both servers, did not expect: \" + l);\n<line12>    }\n<line13>    assertEquals(sessionsNotRestarted.size(), sessionsRestarted.size(), \"Should have same number of sessions\");\n<line14>    ZKDatabase restarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase();\n<line15>    ZKDatabase clean = qu.getPeer(3).peer.getActiveServer().getZKDatabase();\n<line16>    ZKDatabase lead = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();\n<line17>    for (Long l : sessionsRestarted) {\n<line18>        LOG.info(\"Validating ephemeral for session id 0x{}\", Long.toHexString(l));\n<line19>        assertTrue(sessionsNotRestarted.contains(l), \"Should have same set of sessions in both servers, did not expect: \" + l);\n<line20>        Set<String> ephemerals = restarted.getEphemerals(l);\n<line21>        Set<String> cleanEphemerals = clean.getEphemerals(l);\n<line22>        for (String o : cleanEphemerals) {\n<line23>            if (!ephemerals.contains(o)) {\n<line24>                LOG.info(\"Restarted follower doesn't contain ephemeral {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line25>            }\n<line26>        }\n<line27>        for (String o : ephemerals) {\n<line28>            if (!cleanEphemerals.contains(o)) {\n<line29>                LOG.info(\"Restarted follower has extra ephemeral {} zxid 0x{}\", o, Long.toHexString(restarted.getDataTree().getNode(o).stat.getMzxid()));\n<line30>            }\n<line31>        }\n<line32>        Set<String> leadEphemerals = lead.getEphemerals(l);\n<line33>        for (String o : leadEphemerals) {\n<line34>            if (!cleanEphemerals.contains(o)) {\n<line35>                LOG.info(\"Follower doesn't contain ephemeral from leader {} zxid 0x{}\", o, Long.toHexString(lead.getDataTree().getNode(o).stat.getMzxid()));\n<line36>            }\n<line37>        }\n<line38>        for (String o : cleanEphemerals) {\n<line39>            if (!leadEphemerals.contains(o)) {\n<line40>                LOG.info(\"Leader doesn't contain ephemeral from follower {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line41>            }\n<line42>        }\n<line43>        assertEquals(ephemerals.size(), cleanEphemerals.size(), \"Should have same number of ephemerals in both followers\");\n<line44>        assertEquals(lead.getEphemerals(l).size(), cleanEphemerals.size(), \"Leader should equal follower\");\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(sessionsNotRestarted.contains(l), \"Should have same set of sessions in both servers, did not expect: \" + l);\n<line3>    Set<String> ephemerals = restarted.getEphemerals(l);\n<line4>    Set<String> cleanEphemerals = clean.getEphemerals(l);\n<line5>    for (String o : cleanEphemerals) {\n<line6>        if (!ephemerals.contains(o)) {\n<line7>        }\n<line8>    }\n<line9>    for (String o : ephemerals) {\n<line10>        if (!cleanEphemerals.contains(o)) {\n<line11>        }\n<line12>    }\n<line13>    Set<String> leadEphemerals = lead.getEphemerals(l);\n<line14>    for (String o : leadEphemerals) {\n<line15>        if (!cleanEphemerals.contains(o)) {\n<line16>        }\n<line17>    }\n<line18>    for (String o : cleanEphemerals) {\n<line19>        if (!leadEphemerals.contains(o)) {\n<line20>        }\n<line21>    }\n<line22>    assertEquals(ephemerals.size(), cleanEphemerals.size(), \"Should have same number of ephemerals in both followers\");\n<line23>    assertEquals(lead.getEphemerals(l).size(), cleanEphemerals.size(), \"Leader should equal follower\");\n<line24>}","output":"<line1>{\n<line2>    LOG.info(\"Validating ephemeral for session id 0x{}\", Long.toHexString(l));\n<line3>    assertTrue(sessionsNotRestarted.contains(l), \"Should have same set of sessions in both servers, did not expect: \" + l);\n<line4>    Set<String> ephemerals = restarted.getEphemerals(l);\n<line5>    Set<String> cleanEphemerals = clean.getEphemerals(l);\n<line6>    for (String o : cleanEphemerals) {\n<line7>        if (!ephemerals.contains(o)) {\n<line8>            LOG.info(\"Restarted follower doesn't contain ephemeral {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line9>        }\n<line10>    }\n<line11>    for (String o : ephemerals) {\n<line12>        if (!cleanEphemerals.contains(o)) {\n<line13>            LOG.info(\"Restarted follower has extra ephemeral {} zxid 0x{}\", o, Long.toHexString(restarted.getDataTree().getNode(o).stat.getMzxid()));\n<line14>        }\n<line15>    }\n<line16>    Set<String> leadEphemerals = lead.getEphemerals(l);\n<line17>    for (String o : leadEphemerals) {\n<line18>        if (!cleanEphemerals.contains(o)) {\n<line19>            LOG.info(\"Follower doesn't contain ephemeral from leader {} zxid 0x{}\", o, Long.toHexString(lead.getDataTree().getNode(o).stat.getMzxid()));\n<line20>        }\n<line21>    }\n<line22>    for (String o : cleanEphemerals) {\n<line23>        if (!leadEphemerals.contains(o)) {\n<line24>            LOG.info(\"Leader doesn't contain ephemeral from follower {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line25>        }\n<line26>    }\n<line27>    assertEquals(ephemerals.size(), cleanEphemerals.size(), \"Should have same number of ephemerals in both followers\");\n<line28>    assertEquals(lead.getEphemerals(l).size(), cleanEphemerals.size(), \"Leader should equal follower\");\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!ephemerals.contains(o)) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!ephemerals.contains(o)) {\n<line3>        LOG.info(\"Restarted follower doesn't contain ephemeral {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Restarted follower doesn't contain ephemeral {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!cleanEphemerals.contains(o)) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!cleanEphemerals.contains(o)) {\n<line3>        LOG.info(\"Restarted follower has extra ephemeral {} zxid 0x{}\", o, Long.toHexString(restarted.getDataTree().getNode(o).stat.getMzxid()));\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Restarted follower has extra ephemeral {} zxid 0x{}\", o, Long.toHexString(restarted.getDataTree().getNode(o).stat.getMzxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!cleanEphemerals.contains(o)) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!cleanEphemerals.contains(o)) {\n<line3>        LOG.info(\"Follower doesn't contain ephemeral from leader {} zxid 0x{}\", o, Long.toHexString(lead.getDataTree().getNode(o).stat.getMzxid()));\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Follower doesn't contain ephemeral from leader {} zxid 0x{}\", o, Long.toHexString(lead.getDataTree().getNode(o).stat.getMzxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!leadEphemerals.contains(o)) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!leadEphemerals.contains(o)) {\n<line3>        LOG.info(\"Leader doesn't contain ephemeral from follower {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Leader doesn't contain ephemeral from follower {} zxid 0x{}\", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumUtil qu = new QuorumUtil(1);\n<line3>    qu.startAll();\n<line4>    int index = 1;\n<line5>    while (qu.getPeer(index).peer.follower == null) {\n<line6>        index++;\n<line7>    }\n<line8>    TestableZooKeeper zk = createTestableClient(\"localhost:\" + qu.getPeer(index).peer.getClientPort());\n<line9>    assertEquals(0L, zk.testableLastZxid());\n<line10>    zk.exists(\"/\", false);\n<line11>    long lzxid = zk.testableLastZxid();\n<line12>    assertTrue(lzxid > 0, \"lzxid:\" + lzxid + \" > 0\");\n<line13>    zk.close();\n<line14>    qu.shutdownAll();\n<line15>}","output":"<line1>{\n<line2>    QuorumUtil qu = new QuorumUtil(1);\n<line3>    qu.startAll();\n<line4>    int index = 1;\n<line5>    while (qu.getPeer(index).peer.follower == null) {\n<line6>        index++;\n<line7>    }\n<line8>    LOG.info(\"Connecting to follower: {}\", index);\n<line9>    TestableZooKeeper zk = createTestableClient(\"localhost:\" + qu.getPeer(index).peer.getClientPort());\n<line10>    assertEquals(0L, zk.testableLastZxid());\n<line11>    zk.exists(\"/\", false);\n<line12>    long lzxid = zk.testableLastZxid();\n<line13>    assertTrue(lzxid > 0, \"lzxid:\" + lzxid + \" > 0\");\n<line14>    zk.close();\n<line15>    qu.shutdownAll();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumUtil qu = new QuorumUtil(1);\n<line3>    qu.startAll();\n<line4>    int index = 1;\n<line5>    while (qu.getPeer(index).peer.follower == null) {\n<line6>        index++;\n<line7>    }\n<line8>    TestableZooKeeper zk1 = createTestableClient(\"localhost:\" + qu.getPeer(index).peer.getClientPort());\n<line9>    zk1.create(\"/foo\", \"foo\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>    MyWatcher watcher = new MyWatcher();\n<line11>    TestableZooKeeper zk2 = createTestableClient(watcher, \"localhost:\" + qu.getPeer(index).peer.getClientPort());\n<line12>    zk2.exists(\"/foo\", true);\n<line13>    watcher.reset();\n<line14>    zk2.testableConnloss();\n<line15>    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line16>        fail(\"Unable to connect to server\");\n<line17>    }\n<line18>    assertArrayEquals(\"foo\".getBytes(), zk2.getData(\"/foo\", false, null));\n<line19>    assertNull(watcher.events.poll(5, TimeUnit.SECONDS));\n<line20>    zk1.close();\n<line21>    zk2.close();\n<line22>    qu.shutdownAll();\n<line23>}","output":"<line1>{\n<line2>    QuorumUtil qu = new QuorumUtil(1);\n<line3>    qu.startAll();\n<line4>    int index = 1;\n<line5>    while (qu.getPeer(index).peer.follower == null) {\n<line6>        index++;\n<line7>    }\n<line8>    LOG.info(\"Connecting to follower: {}\", index);\n<line9>    TestableZooKeeper zk1 = createTestableClient(\"localhost:\" + qu.getPeer(index).peer.getClientPort());\n<line10>    zk1.create(\"/foo\", \"foo\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line11>    MyWatcher watcher = new MyWatcher();\n<line12>    TestableZooKeeper zk2 = createTestableClient(watcher, \"localhost:\" + qu.getPeer(index).peer.getClientPort());\n<line13>    zk2.exists(\"/foo\", true);\n<line14>    watcher.reset();\n<line15>    zk2.testableConnloss();\n<line16>    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {\n<line17>        fail(\"Unable to connect to server\");\n<line18>    }\n<line19>    assertArrayEquals(\"foo\".getBytes(), zk2.getData(\"/foo\", false, null));\n<line20>    assertNull(watcher.events.poll(5, TimeUnit.SECONDS));\n<line21>    zk1.close();\n<line22>    zk2.close();\n<line23>    qu.shutdownAll();\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.localSessionsEnabled = true;\n<line3>    qb.localSessionsUpgradingEnabled = true;\n<line4>    qb.setUp();\n<line5>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING quorum {}\", getClass().getName());\n<line3>    qb.localSessionsEnabled = true;\n<line4>    qb.localSessionsUpgradingEnabled = true;\n<line5>    qb.setUp();\n<line6>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING quorum {}\", getClass().getName());\n<line3>    qb.tearDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String session = Long.toHexString(sessionId);\n<line3>    String peerType = peerId == qb.getLeaderIndex() ? \"leader\" : \"follower\";\n<line4>    QuorumPeer peer = qb.getPeerList().get(peerId);\n<line5>    ZKDatabase db = peer.getActiveServer().getZKDatabase();\n<line6>    for (Proposal p : db.getCommittedLog()) {\n<line7>        assertFalse(p.getRequest().sessionId == sessionId, \"Should not see \" + Request.op2String(p.getRequest().type) + \" request from local session 0x\" + session + \" on the \" + peerType);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    String session = Long.toHexString(sessionId);\n<line3>    LOG.info(\"Searching for txn of session 0x \" + session + \" on peer \" + peerId);\n<line4>    String peerType = peerId == qb.getLeaderIndex() ? \"leader\" : \"follower\";\n<line5>    QuorumPeer peer = qb.getPeerList().get(peerId);\n<line6>    ZKDatabase db = peer.getActiveServer().getZKDatabase();\n<line7>    for (Proposal p : db.getCommittedLog()) {\n<line8>        assertFalse(p.getRequest().sessionId == sessionId, \"Should not see \" + Request.op2String(p.getRequest().type) + \" request from local session 0x\" + session + \" on the \" + peerType);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    String bindAddress = null;\n<line3>    Enumeration<NetworkInterface> intfs = NetworkInterface.getNetworkInterfaces();\n<line4>    // if we have a loopback and it has an address use it\n<line5>    while (intfs.hasMoreElements()) {\n<line6>        NetworkInterface i = intfs.nextElement();\n<line7>        try {\n<line8>            if (i.isLoopback()) {\n<line9>                Enumeration<InetAddress> addrs = i.getInetAddresses();\n<line10>                while (addrs.hasMoreElements()) {\n<line11>                    InetAddress a = addrs.nextElement();\n<line12>                    if (a.isLoopbackAddress()) {\n<line13>                        bindAddress = a.getHostAddress();\n<line14>                        if (a instanceof Inet6Address) {\n<line15>                            bindAddress = \"[\" + bindAddress + \"]\";\n<line16>                        }\n<line17>                        break;\n<line18>                    }\n<line19>                }\n<line20>            }\n<line21>        } catch (SocketException se) {\n<line22>        }\n<line23>    }\n<line24>    if (bindAddress == null) {\n<line25>        return;\n<line26>    }\n<line27>    final int PORT = PortAssignment.unique();\n<line28>    final String HOSTPORT = bindAddress + \":\" + PORT;\n<line29>    File tmpDir = ClientBase.createTmpDir();\n<line30>    ClientBase.setupTestEnv();\n<line31>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line32>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(new InetSocketAddress(bindAddress, PORT), -1);\n<line33>    f.startup(zks);\n<line34>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line35>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line36>    try {\n<line37>        zk.close();\n<line38>    } finally {\n<line39>        f.shutdown();\n<line40>        zks.shutdown();\n<line41>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line42>    }\n<line43>}","output":"<line1>{\n<line2>    String bindAddress = null;\n<line3>    Enumeration<NetworkInterface> intfs = NetworkInterface.getNetworkInterfaces();\n<line4>    // if we have a loopback and it has an address use it\n<line5>    while (intfs.hasMoreElements()) {\n<line6>        NetworkInterface i = intfs.nextElement();\n<line7>        try {\n<line8>            if (i.isLoopback()) {\n<line9>                Enumeration<InetAddress> addrs = i.getInetAddresses();\n<line10>                while (addrs.hasMoreElements()) {\n<line11>                    InetAddress a = addrs.nextElement();\n<line12>                    if (a.isLoopbackAddress()) {\n<line13>                        bindAddress = a.getHostAddress();\n<line14>                        if (a instanceof Inet6Address) {\n<line15>                            bindAddress = \"[\" + bindAddress + \"]\";\n<line16>                        }\n<line17>                        break;\n<line18>                    }\n<line19>                }\n<line20>            }\n<line21>        } catch (SocketException se) {\n<line22>            LOG.warn(\"Couldn't find loopback interface\", se);\n<line23>        }\n<line24>    }\n<line25>    if (bindAddress == null) {\n<line26>        LOG.warn(\"Unable to determine loop back address, skipping test\");\n<line27>        return;\n<line28>    }\n<line29>    final int PORT = PortAssignment.unique();\n<line30>    LOG.info(\"Using {} as the bind address\", bindAddress);\n<line31>    final String HOSTPORT = bindAddress + \":\" + PORT;\n<line32>    LOG.info(\"Using {} as the host/port\", HOSTPORT);\n<line33>    File tmpDir = ClientBase.createTmpDir();\n<line34>    ClientBase.setupTestEnv();\n<line35>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line36>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(new InetSocketAddress(bindAddress, PORT), -1);\n<line37>    f.startup(zks);\n<line38>    LOG.info(\"starting up the the server, waiting\");\n<line39>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line40>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line41>    try {\n<line42>        zk.close();\n<line43>    } finally {\n<line44>        f.shutdown();\n<line45>        zks.shutdown();\n<line46>        assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server down\");\n<line47>    }\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>    ArrayList<QuorumPeer> peers = getPeerList();\n<line3>    for (int i = 1; i <= peers.size(); i++) {\n<line4>        QuorumPeer qp = peers.get(i - 1);\n<line5>        Long electionTimeTaken = -1L;\n<line6>        String bean = \"\";\n<line7>        if (qp.getPeerState() == ServerState.FOLLOWING) {\n<line8>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower\", MBeanRegistry.DOMAIN, i, i);\n<line9>        } else if (qp.getPeerState() == ServerState.LEADING) {\n<line10>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader\", MBeanRegistry.DOMAIN, i, i);\n<line11>        }\n<line12>        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, \"ElectionTimeTaken\");\n<line13>        assertTrue(electionTimeTaken >= 0, \"Wrong electionTimeTaken value!\");\n<line14>    }\n<line15>    //setup servers 1-5 to be followers\n<line16>    setUp(false, true);\n<line17>    Proposal p = new Proposal();\n<line18>    p.addQuorumVerifier(s1.getQuorumVerifier());\n<line19>    // 2 followers out of 5 is not a majority\n<line20>    p.addAck(Long.valueOf(1));\n<line21>    p.addAck(Long.valueOf(2));\n<line22>    assertEquals(false, p.hasAllQuorums());\n<line23>    // 6 is not in the view - its vote shouldn't count\n<line24>    p.addAck(Long.valueOf(6));\n<line25>    assertEquals(false, p.hasAllQuorums());\n<line26>    // 3 followers out of 5 are a majority of the voting view\n<line27>    p.addAck(Long.valueOf(3));\n<line28>    assertEquals(true, p.hasAllQuorums());\n<line29>    //setup servers 1-3 to be followers and 4 and 5 to be observers\n<line30>    setUp(true, true);\n<line31>    p = new Proposal();\n<line32>    p.addQuorumVerifier(s1.getQuorumVerifier());\n<line33>    // 1 follower out of 3 is not a majority\n<line34>    p.addAck(Long.valueOf(1));\n<line35>    assertEquals(false, p.hasAllQuorums());\n<line36>    // 4 and 5 are observers, their vote shouldn't count\n<line37>    p.addAck(Long.valueOf(4));\n<line38>    p.addAck(Long.valueOf(5));\n<line39>    assertEquals(false, p.hasAllQuorums());\n<line40>    // 6 is not in the view - its vote shouldn't count\n<line41>    p.addAck(Long.valueOf(6));\n<line42>    assertEquals(false, p.hasAllQuorums());\n<line43>    // 2 followers out of 3 are a majority of the voting view\n<line44>    p.addAck(Long.valueOf(2));\n<line45>    assertEquals(true, p.hasAllQuorums());\n<line46>}","output":"<line1>{\n<line2>    LOG.info(\"Verify QuorumPeer#electionTimeTaken jmx bean attribute\");\n<line3>    ArrayList<QuorumPeer> peers = getPeerList();\n<line4>    for (int i = 1; i <= peers.size(); i++) {\n<line5>        QuorumPeer qp = peers.get(i - 1);\n<line6>        Long electionTimeTaken = -1L;\n<line7>        String bean = \"\";\n<line8>        if (qp.getPeerState() == ServerState.FOLLOWING) {\n<line9>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower\", MBeanRegistry.DOMAIN, i, i);\n<line10>        } else if (qp.getPeerState() == ServerState.LEADING) {\n<line11>            bean = String.format(\"%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader\", MBeanRegistry.DOMAIN, i, i);\n<line12>        }\n<line13>        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, \"ElectionTimeTaken\");\n<line14>        assertTrue(electionTimeTaken >= 0, \"Wrong electionTimeTaken value!\");\n<line15>    }\n<line16>    //setup servers 1-5 to be followers\n<line17>    setUp(false, true);\n<line18>    Proposal p = new Proposal();\n<line19>    p.addQuorumVerifier(s1.getQuorumVerifier());\n<line20>    // 2 followers out of 5 is not a majority\n<line21>    p.addAck(Long.valueOf(1));\n<line22>    p.addAck(Long.valueOf(2));\n<line23>    assertEquals(false, p.hasAllQuorums());\n<line24>    // 6 is not in the view - its vote shouldn't count\n<line25>    p.addAck(Long.valueOf(6));\n<line26>    assertEquals(false, p.hasAllQuorums());\n<line27>    // 3 followers out of 5 are a majority of the voting view\n<line28>    p.addAck(Long.valueOf(3));\n<line29>    assertEquals(true, p.hasAllQuorums());\n<line30>    //setup servers 1-3 to be followers and 4 and 5 to be observers\n<line31>    setUp(true, true);\n<line32>    p = new Proposal();\n<line33>    p.addQuorumVerifier(s1.getQuorumVerifier());\n<line34>    // 1 follower out of 3 is not a majority\n<line35>    p.addAck(Long.valueOf(1));\n<line36>    assertEquals(false, p.hasAllQuorums());\n<line37>    // 4 and 5 are observers, their vote shouldn't count\n<line38>    p.addAck(Long.valueOf(4));\n<line39>    p.addAck(Long.valueOf(5));\n<line40>    assertEquals(false, p.hasAllQuorums());\n<line41>    // 6 is not in the view - its vote shouldn't count\n<line42>    p.addAck(Long.valueOf(6));\n<line43>    assertEquals(false, p.hasAllQuorums());\n<line44>    // 2 followers out of 3 are a majority of the voting view\n<line45>    p.addAck(Long.valueOf(2));\n<line46>    assertEquals(true, p.hasAllQuorums());\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.localSessionsEnabled = true;\n<line3>    qb.localSessionsUpgradingEnabled = false;\n<line4>    qb.setUp();\n<line5>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING quorum {}\", getClass().getName());\n<line3>    qb.localSessionsEnabled = true;\n<line4>    qb.localSessionsUpgradingEnabled = false;\n<line5>    qb.setUp();\n<line6>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING quorum {}\", getClass().getName());\n<line3>    qb.tearDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    stopServer();\n<line3>    // Point server at testDir\n<line4>    File oldTmpDir = tmpDir;\n<line5>    tmpDir = testDir;\n<line6>    try {\n<line7>        startServer();\n<line8>        fail(failureMsg);\n<line9>    } catch (IOException e) {\n<line10>    } finally {\n<line11>        tmpDir = oldTmpDir;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    stopServer();\n<line3>    // Point server at testDir\n<line4>    File oldTmpDir = tmpDir;\n<line5>    tmpDir = testDir;\n<line6>    try {\n<line7>        startServer();\n<line8>        fail(failureMsg);\n<line9>    } catch (IOException e) {\n<line10>        LOG.debug(\"Successfully caught IOException\", e);\n<line11>    } finally {\n<line12>        tmpDir = oldTmpDir;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Successfully caught IOException\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    Stat writeStat = new Stat();\n<line4>    Stat readStat = new Stat();\n<line5>    byte[] readData = null;\n<line6>    int reads = 10;\n<line7>    long expectedHits = 0;\n<line8>    long expectedMisses = 0;\n<line9>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line10>    zks.setResponseCachingEnabled(useCache);\n<line11>    if (useCache) {\n<line12>        assertEquals(zks.getReadResponseCache().getCacheSize(), 32);\n<line13>        assertEquals(zks.getGetChildrenResponseCache().getCacheSize(), 64);\n<line14>    }\n<line15>    byte[] writeData = \"test1\".getBytes();\n<line16>    zk.create(path, writeData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, writeStat);\n<line17>    for (int i = 0; i < reads; ++i) {\n<line18>        readData = zk.getData(path, false, readStat);\n<line19>        assertArrayEquals(writeData, readData);\n<line20>        assertEquals(writeStat, readStat);\n<line21>    }\n<line22>    if (useCache) {\n<line23>        expectedMisses += 1;\n<line24>        expectedHits += reads - 1;\n<line25>    }\n<line26>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_cache_hits\", \"response_packet_cache_misses\");\n<line27>    writeData = \"test2\".getBytes();\n<line28>    writeStat = zk.setData(path, writeData, -1);\n<line29>    for (int i = 0; i < 10; ++i) {\n<line30>        readData = zk.getData(path, false, readStat);\n<line31>        assertArrayEquals(writeData, readData);\n<line32>        assertEquals(writeStat, readStat);\n<line33>    }\n<line34>    if (useCache) {\n<line35>        expectedMisses += 1;\n<line36>        expectedHits += reads - 1;\n<line37>    }\n<line38>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_cache_hits\", \"response_packet_cache_misses\");\n<line39>    // Create a child beneath the tested node. This won't change the data of\n<line40>    // the tested node, but will change it's pzxid. The next read of the tested\n<line41>    // node should miss in the cache. The data should still match what was written\n<line42>    // before, but the stat information should not.\n<line43>    zk.create(path + \"/child\", \"child\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);\n<line44>    readData = zk.getData(path, false, readStat);\n<line45>    if (useCache) {\n<line46>        expectedMisses++;\n<line47>    }\n<line48>    assertArrayEquals(writeData, readData);\n<line49>    assertNotSame(writeStat, readStat);\n<line50>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_cache_hits\", \"response_packet_cache_misses\");\n<line51>    ServerMetrics.getMetrics().resetAll();\n<line52>    expectedHits = 0;\n<line53>    expectedMisses = 0;\n<line54>    createPath(path + \"/a\", zk);\n<line55>    createPath(path + \"/a/b\", zk);\n<line56>    createPath(path + \"/a/c\", zk);\n<line57>    createPath(path + \"/a/b/d\", zk);\n<line58>    createPath(path + \"/a/b/e\", zk);\n<line59>    createPath(path + \"/a/b/e/f\", zk);\n<line60>    createPath(path + \"/a/b/e/g\", zk);\n<line61>    createPath(path + \"/a/b/e/h\", zk);\n<line62>    checkPath(path + \"/a\", zk, 2);\n<line63>    checkPath(path + \"/a/b\", zk, 2);\n<line64>    checkPath(path + \"/a/c\", zk, 0);\n<line65>    checkPath(path + \"/a/b/d\", zk, 0);\n<line66>    checkPath(path + \"/a/b/e\", zk, 3);\n<line67>    checkPath(path + \"/a/b/e/h\", zk, 0);\n<line68>    if (useCache) {\n<line69>        expectedMisses += 6;\n<line70>    }\n<line71>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_get_children_cache_hits\", \"response_packet_get_children_cache_misses\");\n<line72>    checkPath(path + \"/a\", zk, 2);\n<line73>    checkPath(path + \"/a/b\", zk, 2);\n<line74>    checkPath(path + \"/a/c\", zk, 0);\n<line75>    if (useCache) {\n<line76>        expectedHits += 3;\n<line77>    }\n<line78>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_get_children_cache_hits\", \"response_packet_get_children_cache_misses\");\n<line79>}","output":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    Stat writeStat = new Stat();\n<line4>    Stat readStat = new Stat();\n<line5>    byte[] readData = null;\n<line6>    int reads = 10;\n<line7>    long expectedHits = 0;\n<line8>    long expectedMisses = 0;\n<line9>    ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n<line10>    zks.setResponseCachingEnabled(useCache);\n<line11>    LOG.info(\"caching: {}\", useCache);\n<line12>    if (useCache) {\n<line13>        assertEquals(zks.getReadResponseCache().getCacheSize(), 32);\n<line14>        assertEquals(zks.getGetChildrenResponseCache().getCacheSize(), 64);\n<line15>    }\n<line16>    byte[] writeData = \"test1\".getBytes();\n<line17>    zk.create(path, writeData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, writeStat);\n<line18>    for (int i = 0; i < reads; ++i) {\n<line19>        readData = zk.getData(path, false, readStat);\n<line20>        assertArrayEquals(writeData, readData);\n<line21>        assertEquals(writeStat, readStat);\n<line22>    }\n<line23>    if (useCache) {\n<line24>        expectedMisses += 1;\n<line25>        expectedHits += reads - 1;\n<line26>    }\n<line27>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_cache_hits\", \"response_packet_cache_misses\");\n<line28>    writeData = \"test2\".getBytes();\n<line29>    writeStat = zk.setData(path, writeData, -1);\n<line30>    for (int i = 0; i < 10; ++i) {\n<line31>        readData = zk.getData(path, false, readStat);\n<line32>        assertArrayEquals(writeData, readData);\n<line33>        assertEquals(writeStat, readStat);\n<line34>    }\n<line35>    if (useCache) {\n<line36>        expectedMisses += 1;\n<line37>        expectedHits += reads - 1;\n<line38>    }\n<line39>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_cache_hits\", \"response_packet_cache_misses\");\n<line40>    // Create a child beneath the tested node. This won't change the data of\n<line41>    // the tested node, but will change it's pzxid. The next read of the tested\n<line42>    // node should miss in the cache. The data should still match what was written\n<line43>    // before, but the stat information should not.\n<line44>    zk.create(path + \"/child\", \"child\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);\n<line45>    readData = zk.getData(path, false, readStat);\n<line46>    if (useCache) {\n<line47>        expectedMisses++;\n<line48>    }\n<line49>    assertArrayEquals(writeData, readData);\n<line50>    assertNotSame(writeStat, readStat);\n<line51>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_cache_hits\", \"response_packet_cache_misses\");\n<line52>    ServerMetrics.getMetrics().resetAll();\n<line53>    expectedHits = 0;\n<line54>    expectedMisses = 0;\n<line55>    createPath(path + \"/a\", zk);\n<line56>    createPath(path + \"/a/b\", zk);\n<line57>    createPath(path + \"/a/c\", zk);\n<line58>    createPath(path + \"/a/b/d\", zk);\n<line59>    createPath(path + \"/a/b/e\", zk);\n<line60>    createPath(path + \"/a/b/e/f\", zk);\n<line61>    createPath(path + \"/a/b/e/g\", zk);\n<line62>    createPath(path + \"/a/b/e/h\", zk);\n<line63>    checkPath(path + \"/a\", zk, 2);\n<line64>    checkPath(path + \"/a/b\", zk, 2);\n<line65>    checkPath(path + \"/a/c\", zk, 0);\n<line66>    checkPath(path + \"/a/b/d\", zk, 0);\n<line67>    checkPath(path + \"/a/b/e\", zk, 3);\n<line68>    checkPath(path + \"/a/b/e/h\", zk, 0);\n<line69>    if (useCache) {\n<line70>        expectedMisses += 6;\n<line71>    }\n<line72>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_get_children_cache_hits\", \"response_packet_get_children_cache_misses\");\n<line73>    checkPath(path + \"/a\", zk, 2);\n<line74>    checkPath(path + \"/a/b\", zk, 2);\n<line75>    checkPath(path + \"/a/c\", zk, 0);\n<line76>    if (useCache) {\n<line77>        expectedHits += 3;\n<line78>    }\n<line79>    checkCacheStatus(expectedHits, expectedMisses, \"response_packet_get_children_cache_hits\", \"response_packet_get_children_cache_misses\");\n<line80>}"},{"input":"","instruction":"<line1>{\n<line2>    watcher.reset();\n<line3>    TestableZooKeeper zk = new TestableZooKeeper(hp, timeout, watcher);\n<line4>    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {\n<line5>        if (exceptionOnFailedConnect) {\n<line6>            throw new ProtocolException(\"Unable to connect to server\");\n<line7>        }\n<line8>        fail(\"Unable to connect to server\");\n<line9>    }\n<line10>    synchronized (this) {\n<line11>        if (!allClientsSetup) {\n<line12>            fail(\"allClients never setup\");\n<line13>        }\n<line14>        if (allClients != null) {\n<line15>            allClients.add(zk);\n<line16>            JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));\n<line17>        } else {\n<line18>            // test done - close the zk, not needed\n<line19>            zk.close();\n<line20>        }\n<line21>    }\n<line22>    return zk;\n<line23>}","output":"<line1>{\n<line2>    watcher.reset();\n<line3>    TestableZooKeeper zk = new TestableZooKeeper(hp, timeout, watcher);\n<line4>    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {\n<line5>        if (exceptionOnFailedConnect) {\n<line6>            throw new ProtocolException(\"Unable to connect to server\");\n<line7>        }\n<line8>        fail(\"Unable to connect to server\");\n<line9>    }\n<line10>    synchronized (this) {\n<line11>        if (!allClientsSetup) {\n<line12>            LOG.error(\"allClients never setup\");\n<line13>            fail(\"allClients never setup\");\n<line14>        }\n<line15>        if (allClients != null) {\n<line16>            allClients.add(zk);\n<line17>            JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));\n<line18>        } else {\n<line19>            // test done - close the zk, not needed\n<line20>            zk.close();\n<line21>        }\n<line22>    }\n<line23>    return zk;\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!allClientsSetup) {\n<line3>        fail(\"allClients never setup\");\n<line4>    }\n<line5>    if (allClients != null) {\n<line6>        allClients.add(zk);\n<line7>        JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));\n<line8>    } else {\n<line9>        // test done - close the zk, not needed\n<line10>        zk.close();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (!allClientsSetup) {\n<line3>        LOG.error(\"allClients never setup\");\n<line4>        fail(\"allClients never setup\");\n<line5>    }\n<line6>    if (allClients != null) {\n<line7>        allClients.add(zk);\n<line8>        JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));\n<line9>    } else {\n<line10>        // test done - close the zk, not needed\n<line11>        zk.close();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"allClients never setup\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"allClients never setup\");\n<line3>    fail(\"allClients never setup\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    long start = Time.currentElapsedTime();\n<line3>    while (true) {\n<line4>        try {\n<line5>            // if there are multiple hostports, just take the first one\n<line6>            HostPort hpobj = parseHostPortList(hp).get(0);\n<line7>            String result = send4LetterWord(hpobj.host, hpobj.port, \"stat\", secure);\n<line8>            if (result.startsWith(\"Zookeeper version:\") && !result.contains(\"READ-ONLY\")) {\n<line9>                return true;\n<line10>            }\n<line11>        } catch (ConnectException e) {\n<line12>            // ignore as this is expected, do not log stacktrace\n<line13>        } catch (IOException e) {\n<line14>            // ignore as this is expected\n<line15>        } catch (SSLContextException e) {\n<line16>        }\n<line17>        if (Time.currentElapsedTime() > start + timeout) {\n<line18>            break;\n<line19>        }\n<line20>        try {\n<line21>            Thread.sleep(250);\n<line22>        } catch (InterruptedException e) {\n<line23>            // ignore\n<line24>        }\n<line25>    }\n<line26>    return false;\n<line27>}","output":"<line1>{\n<line2>    long start = Time.currentElapsedTime();\n<line3>    while (true) {\n<line4>        try {\n<line5>            // if there are multiple hostports, just take the first one\n<line6>            HostPort hpobj = parseHostPortList(hp).get(0);\n<line7>            String result = send4LetterWord(hpobj.host, hpobj.port, \"stat\", secure);\n<line8>            if (result.startsWith(\"Zookeeper version:\") && !result.contains(\"READ-ONLY\")) {\n<line9>                return true;\n<line10>            }\n<line11>        } catch (ConnectException e) {\n<line12>            // ignore as this is expected, do not log stacktrace\n<line13>            LOG.info(\"server {} not up: {}\", hp, e.toString());\n<line14>        } catch (IOException e) {\n<line15>            // ignore as this is expected\n<line16>            LOG.info(\"server {} not up\", hp, e);\n<line17>        } catch (SSLContextException e) {\n<line18>            LOG.error(\"server {} not up\", hp, e);\n<line19>        }\n<line20>        if (Time.currentElapsedTime() > start + timeout) {\n<line21>            break;\n<line22>        }\n<line23>        try {\n<line24>            Thread.sleep(250);\n<line25>        } catch (InterruptedException e) {\n<line26>            // ignore\n<line27>        }\n<line28>    }\n<line29>    return false;\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // if there are multiple hostports, just take the first one\n<line4>        HostPort hpobj = parseHostPortList(hp).get(0);\n<line5>        String result = send4LetterWord(hpobj.host, hpobj.port, \"stat\", secure);\n<line6>        if (result.startsWith(\"Zookeeper version:\") && !result.contains(\"READ-ONLY\")) {\n<line7>            return true;\n<line8>        }\n<line9>    } catch (ConnectException e) {\n<line10>        // ignore as this is expected, do not log stacktrace\n<line11>    } catch (IOException e) {\n<line12>        // ignore as this is expected\n<line13>    } catch (SSLContextException e) {\n<line14>    }\n<line15>    if (Time.currentElapsedTime() > start + timeout) {\n<line16>        break;\n<line17>    }\n<line18>    try {\n<line19>        Thread.sleep(250);\n<line20>    } catch (InterruptedException e) {\n<line21>        // ignore\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    try {\n<line3>        // if there are multiple hostports, just take the first one\n<line4>        HostPort hpobj = parseHostPortList(hp).get(0);\n<line5>        String result = send4LetterWord(hpobj.host, hpobj.port, \"stat\", secure);\n<line6>        if (result.startsWith(\"Zookeeper version:\") && !result.contains(\"READ-ONLY\")) {\n<line7>            return true;\n<line8>        }\n<line9>    } catch (ConnectException e) {\n<line10>        // ignore as this is expected, do not log stacktrace\n<line11>        LOG.info(\"server {} not up: {}\", hp, e.toString());\n<line12>    } catch (IOException e) {\n<line13>        // ignore as this is expected\n<line14>        LOG.info(\"server {} not up\", hp, e);\n<line15>    } catch (SSLContextException e) {\n<line16>        LOG.error(\"server {} not up\", hp, e);\n<line17>    }\n<line18>    if (Time.currentElapsedTime() > start + timeout) {\n<line19>        break;\n<line20>    }\n<line21>    try {\n<line22>        Thread.sleep(250);\n<line23>    } catch (InterruptedException e) {\n<line24>        // ignore\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    // ignore as this is expected, do not log stacktrace\n<line3>}","output":"<line1>{\n<line2>    // ignore as this is expected, do not log stacktrace\n<line3>    LOG.info(\"server {} not up: {}\", hp, e.toString());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // ignore as this is expected\n<line3>}","output":"<line1>{\n<line2>    // ignore as this is expected\n<line3>    LOG.info(\"server {} not up\", hp, e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"server {} not up\", hp, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    thread.join(millis);\n<line3>    if (thread.isAlive()) {\n<line4>        assertFalse(true, \"thread \" + thread.getName() + \" still alive after join\");\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    thread.join(millis);\n<line3>    if (thread.isAlive()) {\n<line4>        LOG.error(\"Thread {} : {}\", thread.getName(), Arrays.toString(thread.getStackTrace()));\n<line5>        assertFalse(true, \"thread \" + thread.getName() + \" still alive after join\");\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    assertFalse(true, \"thread \" + thread.getName() + \" still alive after join\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Thread {} : {}\", thread.getName(), Arrays.toString(thread.getStackTrace()));\n<line3>    assertFalse(true, \"thread \" + thread.getName() + \" still alive after join\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final int port = getPort(hostPort);\n<line3>    ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);\n<line4>    zks.setCreateSessionTrackerServerId(serverId);\n<line5>    factory.startup(zks);\n<line6>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + port, CONNECTION_TIMEOUT, factory.isSecure()), \"waiting for server up\");\n<line7>}","output":"<line1>{\n<line2>    final int port = getPort(hostPort);\n<line3>    LOG.info(\"STARTING server instance 127.0.0.1:{}\", port);\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);\n<line5>    zks.setCreateSessionTrackerServerId(serverId);\n<line6>    factory.startup(zks);\n<line7>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + port, CONNECTION_TIMEOUT, factory.isSecure()), \"waiting for server up\");\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    final int port = getPort(hostPort);\n<line3>    if (factory == null) {\n<line4>        factory = ServerCnxnFactory.createFactory(port, maxCnxns);\n<line5>    }\n<line6>    return factory;\n<line7>}","output":"<line1>{\n<line2>    final int port = getPort(hostPort);\n<line3>    LOG.info(\"CREATING server instance 127.0.0.1:{}\", port);\n<line4>    if (factory == null) {\n<line5>        factory = ServerCnxnFactory.createFactory(port, maxCnxns);\n<line6>    }\n<line7>    return factory;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    /* some useful information - log the number of fds used before\n<line3>         * and after a test is run. Helps to verify we are freeing resources\n<line4>         * correctly. Unfortunately this only works on unix systems (the\n<line5>         * only place sun has implemented as part of the mgmt bean api.\n<line6>         */\n<line7>    OSMXBean osMbean = new OSMXBean();\n<line8>    if (osMbean.getUnix()) {\n<line9>        initialFdCount = osMbean.getOpenFileDescriptorCount();\n<line10>    }\n<line11>    setupTestEnv();\n<line12>    setupCustomizedEnv();\n<line13>    JMXEnv.setUp();\n<line14>    setUpAll();\n<line15>    tmpDir = createTmpDir(testBaseDir, true);\n<line16>    startServer(serverId);\n<line17>}","output":"<line1>{\n<line2>    /* some useful information - log the number of fds used before\n<line3>         * and after a test is run. Helps to verify we are freeing resources\n<line4>         * correctly. Unfortunately this only works on unix systems (the\n<line5>         * only place sun has implemented as part of the mgmt bean api.\n<line6>         */\n<line7>    OSMXBean osMbean = new OSMXBean();\n<line8>    if (osMbean.getUnix()) {\n<line9>        initialFdCount = osMbean.getOpenFileDescriptorCount();\n<line10>        LOG.info(\"Initial fdcount is: {}\", initialFdCount);\n<line11>    }\n<line12>    setupTestEnv();\n<line13>    setupCustomizedEnv();\n<line14>    JMXEnv.setUp();\n<line15>    setUpAll();\n<line16>    tmpDir = createTmpDir(testBaseDir, true);\n<line17>    startServer(serverId);\n<line18>    LOG.info(\"Client test setup finished\");\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    initialFdCount = osMbean.getOpenFileDescriptorCount();\n<line3>}","output":"<line1>{\n<line2>    initialFdCount = osMbean.getOpenFileDescriptorCount();\n<line3>    LOG.info(\"Initial fdcount is: {}\", initialFdCount);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    serverFactory = createNewServerInstance(serverFactory, hostPort, maxCnxns);\n<line3>    startServerInstance(tmpDir, serverFactory, hostPort, serverId);\n<line4>    // ensure that server and data bean are registered\n<line5>    Set<ObjectName> children = JMXEnv.ensureParent(\"InMemoryDataTree\", \"StandaloneServer_port\");\n<line6>    // Remove beans which are related to zk client sessions. Strong\n<line7>    // assertions cannot be done for these client sessions because\n<line8>    // registeration of these beans with server will happen only on their\n<line9>    // respective reconnection interval\n<line10>    verifyUnexpectedBeans(children);\n<line11>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING server\");\n<line3>    serverFactory = createNewServerInstance(serverFactory, hostPort, maxCnxns);\n<line4>    startServerInstance(tmpDir, serverFactory, hostPort, serverId);\n<line5>    // ensure that server and data bean are registered\n<line6>    Set<ObjectName> children = JMXEnv.ensureParent(\"InMemoryDataTree\", \"StandaloneServer_port\");\n<line7>    // Remove beans which are related to zk client sessions. Strong\n<line8>    // assertions cannot be done for these client sessions because\n<line9>    // registeration of these beans with server will happen only on their\n<line10>    // respective reconnection interval\n<line11>    verifyUnexpectedBeans(children);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    if (allClients != null) {\n<line3>        for (ZooKeeper zkc : allClients) {\n<line4>            Iterator<ObjectName> childItr = children.iterator();\n<line5>            while (childItr.hasNext()) {\n<line6>                ObjectName clientBean = childItr.next();\n<line7>                if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line8>                    childItr.remove();\n<line9>                }\n<line10>            }\n<line11>        }\n<line12>    }\n<line13>    for (ObjectName bean : children) {\n<line14>    }\n<line15>    assertEquals(0, children.size(), \"Unexpected bean exists!\");\n<line16>}","output":"<line1>{\n<line2>    if (allClients != null) {\n<line3>        for (ZooKeeper zkc : allClients) {\n<line4>            Iterator<ObjectName> childItr = children.iterator();\n<line5>            while (childItr.hasNext()) {\n<line6>                ObjectName clientBean = childItr.next();\n<line7>                if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line8>                    LOG.info(\"found name:{} client bean:{}\", zkc.getSessionId(), clientBean.toString());\n<line9>                    childItr.remove();\n<line10>                }\n<line11>            }\n<line12>        }\n<line13>    }\n<line14>    for (ObjectName bean : children) {\n<line15>        LOG.info(\"unexpected:{}\", bean.toString());\n<line16>    }\n<line17>    assertEquals(0, children.size(), \"Unexpected bean exists!\");\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    for (ZooKeeper zkc : allClients) {\n<line3>        Iterator<ObjectName> childItr = children.iterator();\n<line4>        while (childItr.hasNext()) {\n<line5>            ObjectName clientBean = childItr.next();\n<line6>            if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line7>                childItr.remove();\n<line8>            }\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    for (ZooKeeper zkc : allClients) {\n<line3>        Iterator<ObjectName> childItr = children.iterator();\n<line4>        while (childItr.hasNext()) {\n<line5>            ObjectName clientBean = childItr.next();\n<line6>            if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line7>                LOG.info(\"found name:{} client bean:{}\", zkc.getSessionId(), clientBean.toString());\n<line8>                childItr.remove();\n<line9>            }\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    Iterator<ObjectName> childItr = children.iterator();\n<line3>    while (childItr.hasNext()) {\n<line4>        ObjectName clientBean = childItr.next();\n<line5>        if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line6>            childItr.remove();\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    Iterator<ObjectName> childItr = children.iterator();\n<line3>    while (childItr.hasNext()) {\n<line4>        ObjectName clientBean = childItr.next();\n<line5>        if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line6>            LOG.info(\"found name:{} client bean:{}\", zkc.getSessionId(), clientBean.toString());\n<line7>            childItr.remove();\n<line8>        }\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    ObjectName clientBean = childItr.next();\n<line3>    if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line4>        childItr.remove();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    ObjectName clientBean = childItr.next();\n<line3>    if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {\n<line4>        LOG.info(\"found name:{} client bean:{}\", zkc.getSessionId(), clientBean.toString());\n<line5>        childItr.remove();\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    childItr.remove();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"found name:{} client bean:{}\", zkc.getSessionId(), clientBean.toString());\n<line3>    childItr.remove();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"unexpected:{}\", bean.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    shutdownServerInstance(serverFactory, hostPort);\n<line3>    serverFactory = null;\n<line4>    // ensure no beans are leftover\n<line5>    JMXEnv.ensureOnly();\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING server\");\n<line3>    shutdownServerInstance(serverFactory, hostPort);\n<line4>    serverFactory = null;\n<line5>    // ensure no beans are leftover\n<line6>    JMXEnv.ensureOnly();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    tearDownAll();\n<line3>    stopServer();\n<line4>    if (tmpDir != null) {\n<line5>        assertTrue(recursiveDelete(tmpDir), \"delete \" + tmpDir.toString());\n<line6>    }\n<line7>    // This has to be set to null when the same instance of this class is reused between test cases\n<line8>    serverFactory = null;\n<line9>    JMXEnv.tearDown();\n<line10>    /* some useful information - log the number of fds used before\n<line11>         * and after a test is run. Helps to verify we are freeing resources\n<line12>         * correctly. Unfortunately this only works on unix systems (the\n<line13>         * only place sun has implemented as part of the mgmt bean api.\n<line14>         */\n<line15>    OSMXBean osMbean = new OSMXBean();\n<line16>    if (osMbean.getUnix()) {\n<line17>        long fdCount = osMbean.getOpenFileDescriptorCount();\n<line18>        String message = \"fdcount after test is: \" + fdCount + \" at start it was \" + initialFdCount;\n<line19>        if (fdCount > initialFdCount) {\n<line20>            //Thread.sleep(60000);\n<line21>            //assertTrue(message, fdCount <= initialFdCount);\n<line22>        }\n<line23>    }\n<line24>    cleanUpCustomizedEnv();\n<line25>}","output":"<line1>{\n<line2>    LOG.info(\"tearDown starting\");\n<line3>    tearDownAll();\n<line4>    stopServer();\n<line5>    if (tmpDir != null) {\n<line6>        assertTrue(recursiveDelete(tmpDir), \"delete \" + tmpDir.toString());\n<line7>    }\n<line8>    // This has to be set to null when the same instance of this class is reused between test cases\n<line9>    serverFactory = null;\n<line10>    JMXEnv.tearDown();\n<line11>    /* some useful information - log the number of fds used before\n<line12>         * and after a test is run. Helps to verify we are freeing resources\n<line13>         * correctly. Unfortunately this only works on unix systems (the\n<line14>         * only place sun has implemented as part of the mgmt bean api.\n<line15>         */\n<line16>    OSMXBean osMbean = new OSMXBean();\n<line17>    if (osMbean.getUnix()) {\n<line18>        long fdCount = osMbean.getOpenFileDescriptorCount();\n<line19>        String message = \"fdcount after test is: \" + fdCount + \" at start it was \" + initialFdCount;\n<line20>        LOG.info(message);\n<line21>        if (fdCount > initialFdCount) {\n<line22>            LOG.info(\"sleeping for 20 secs\");\n<line23>            //Thread.sleep(60000);\n<line24>            //assertTrue(message, fdCount <= initialFdCount);\n<line25>        }\n<line26>    }\n<line27>    cleanUpCustomizedEnv();\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    long fdCount = osMbean.getOpenFileDescriptorCount();\n<line3>    String message = \"fdcount after test is: \" + fdCount + \" at start it was \" + initialFdCount;\n<line4>    if (fdCount > initialFdCount) {\n<line5>        //Thread.sleep(60000);\n<line6>        //assertTrue(message, fdCount <= initialFdCount);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    long fdCount = osMbean.getOpenFileDescriptorCount();\n<line3>    String message = \"fdcount after test is: \" + fdCount + \" at start it was \" + initialFdCount;\n<line4>    LOG.info(message);\n<line5>    if (fdCount > initialFdCount) {\n<line6>        LOG.info(\"sleeping for 20 secs\");\n<line7>        //Thread.sleep(60000);\n<line8>        //assertTrue(message, fdCount <= initialFdCount);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    //Thread.sleep(60000);\n<line3>    //assertTrue(message, fdCount <= initialFdCount);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"sleeping for 20 secs\");\n<line3>    //Thread.sleep(60000);\n<line4>    //assertTrue(message, fdCount <= initialFdCount);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    StringBuilder sb = new StringBuilder();\n<line3>    sb.append(\"Starting logAllStackTraces()\\n\");\n<line4>    Map<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();\n<line5>    for (Entry<Thread, StackTraceElement[]> e : threads.entrySet()) {\n<line6>        sb.append(\"Thread \" + e.getKey().getName() + \"\\n\");\n<line7>        for (StackTraceElement elem : e.getValue()) {\n<line8>            sb.append(\"\\tat \" + elem + \"\\n\");\n<line9>        }\n<line10>    }\n<line11>    sb.append(\"Ending logAllStackTraces()\\n\");\n<line12>}","output":"<line1>{\n<line2>    StringBuilder sb = new StringBuilder();\n<line3>    sb.append(\"Starting logAllStackTraces()\\n\");\n<line4>    Map<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();\n<line5>    for (Entry<Thread, StackTraceElement[]> e : threads.entrySet()) {\n<line6>        sb.append(\"Thread \" + e.getKey().getName() + \"\\n\");\n<line7>        for (StackTraceElement elem : e.getValue()) {\n<line8>            sb.append(\"\\tat \" + elem + \"\\n\");\n<line9>        }\n<line10>    }\n<line11>    sb.append(\"Ending logAllStackTraces()\\n\");\n<line12>    LOG.error(sb.toString());\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] parts = hostPort.split(\",\");\n<line3>    // run through till the counts no longer change on each server\n<line4>    // max 15 tries, with 2 second sleeps, so approx 30 seconds\n<line5>    int[] counts = new int[parts.length];\n<line6>    int failed = 0;\n<line7>    for (int j = 0; j < 100; j++) {\n<line8>        int[] newcounts = new int[parts.length];\n<line9>        int i = 0;\n<line10>        for (String hp : parts) {\n<line11>            try {\n<line12>                ZooKeeper zk = createClient(hp);\n<line13>                try {\n<line14>                    newcounts[i++] = zk.getChildren(\"/\", false).size();\n<line15>                } finally {\n<line16>                    zk.close();\n<line17>                }\n<line18>            } catch (Throwable t) {\n<line19>                failed++;\n<line20>                // if session creation fails dump the thread stack\n<line21>                // and try the next server\n<line22>                logAllStackTraces();\n<line23>            }\n<line24>        }\n<line25>        if (Arrays.equals(newcounts, counts)) {\n<line26>            counts = newcounts;\n<line27>            break;\n<line28>        } else {\n<line29>            counts = newcounts;\n<line30>            Thread.sleep(10000);\n<line31>        }\n<line32>        // don't keep this up too long, will assert false below\n<line33>        if (failed > 10) {\n<line34>            break;\n<line35>        }\n<line36>    }\n<line37>    // verify all the servers reporting same number of nodes\n<line38>    String logmsg = \"node count not consistent{} {}\";\n<line39>    for (int i = 1; i < parts.length; i++) {\n<line40>        if (counts[i - 1] != counts[i]) {\n<line41>        } else {\n<line42>        }\n<line43>    }\n<line44>}","output":"<line1>{\n<line2>    String[] parts = hostPort.split(\",\");\n<line3>    // run through till the counts no longer change on each server\n<line4>    // max 15 tries, with 2 second sleeps, so approx 30 seconds\n<line5>    int[] counts = new int[parts.length];\n<line6>    int failed = 0;\n<line7>    for (int j = 0; j < 100; j++) {\n<line8>        int[] newcounts = new int[parts.length];\n<line9>        int i = 0;\n<line10>        for (String hp : parts) {\n<line11>            try {\n<line12>                ZooKeeper zk = createClient(hp);\n<line13>                try {\n<line14>                    newcounts[i++] = zk.getChildren(\"/\", false).size();\n<line15>                } finally {\n<line16>                    zk.close();\n<line17>                }\n<line18>            } catch (Throwable t) {\n<line19>                failed++;\n<line20>                // if session creation fails dump the thread stack\n<line21>                // and try the next server\n<line22>                logAllStackTraces();\n<line23>            }\n<line24>        }\n<line25>        if (Arrays.equals(newcounts, counts)) {\n<line26>            LOG.info(\"Found match with array:{}\", Arrays.toString(newcounts));\n<line27>            counts = newcounts;\n<line28>            break;\n<line29>        } else {\n<line30>            counts = newcounts;\n<line31>            Thread.sleep(10000);\n<line32>        }\n<line33>        // don't keep this up too long, will assert false below\n<line34>        if (failed > 10) {\n<line35>            break;\n<line36>        }\n<line37>    }\n<line38>    // verify all the servers reporting same number of nodes\n<line39>    String logmsg = \"node count not consistent{} {}\";\n<line40>    for (int i = 1; i < parts.length; i++) {\n<line41>        if (counts[i - 1] != counts[i]) {\n<line42>            LOG.error(logmsg, counts[i - 1], counts[i]);\n<line43>        } else {\n<line44>            LOG.info(logmsg, counts[i - 1], counts[i]);\n<line45>        }\n<line46>    }\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    int[] newcounts = new int[parts.length];\n<line3>    int i = 0;\n<line4>    for (String hp : parts) {\n<line5>        try {\n<line6>            ZooKeeper zk = createClient(hp);\n<line7>            try {\n<line8>                newcounts[i++] = zk.getChildren(\"/\", false).size();\n<line9>            } finally {\n<line10>                zk.close();\n<line11>            }\n<line12>        } catch (Throwable t) {\n<line13>            failed++;\n<line14>            // if session creation fails dump the thread stack\n<line15>            // and try the next server\n<line16>            logAllStackTraces();\n<line17>        }\n<line18>    }\n<line19>    if (Arrays.equals(newcounts, counts)) {\n<line20>        counts = newcounts;\n<line21>        break;\n<line22>    } else {\n<line23>        counts = newcounts;\n<line24>        Thread.sleep(10000);\n<line25>    }\n<line26>    // don't keep this up too long, will assert false below\n<line27>    if (failed > 10) {\n<line28>        break;\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    int[] newcounts = new int[parts.length];\n<line3>    int i = 0;\n<line4>    for (String hp : parts) {\n<line5>        try {\n<line6>            ZooKeeper zk = createClient(hp);\n<line7>            try {\n<line8>                newcounts[i++] = zk.getChildren(\"/\", false).size();\n<line9>            } finally {\n<line10>                zk.close();\n<line11>            }\n<line12>        } catch (Throwable t) {\n<line13>            failed++;\n<line14>            // if session creation fails dump the thread stack\n<line15>            // and try the next server\n<line16>            logAllStackTraces();\n<line17>        }\n<line18>    }\n<line19>    if (Arrays.equals(newcounts, counts)) {\n<line20>        LOG.info(\"Found match with array:{}\", Arrays.toString(newcounts));\n<line21>        counts = newcounts;\n<line22>        break;\n<line23>    } else {\n<line24>        counts = newcounts;\n<line25>        Thread.sleep(10000);\n<line26>    }\n<line27>    // don't keep this up too long, will assert false below\n<line28>    if (failed > 10) {\n<line29>        break;\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    counts = newcounts;\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Found match with array:{}\", Arrays.toString(newcounts));\n<line3>    counts = newcounts;\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (counts[i - 1] != counts[i]) {\n<line3>    } else {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (counts[i - 1] != counts[i]) {\n<line3>        LOG.error(logmsg, counts[i - 1], counts[i]);\n<line4>    } else {\n<line5>        LOG.info(logmsg, counts[i - 1], counts[i]);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(logmsg, counts[i - 1], counts[i]);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(logmsg, counts[i - 1], counts[i]);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.localSessionsEnabled = true;\n<line3>    qb.localSessionsUpgradingEnabled = true;\n<line4>    qb.setUp();\n<line5>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING quorum {}\", getClass().getName());\n<line3>    qb.localSessionsEnabled = true;\n<line4>    qb.localSessionsUpgradingEnabled = true;\n<line5>    qb.setUp();\n<line6>    ClientBase.waitForServerUp(qb.hostPort, 10000);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    qb.tearDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING quorum {}\", getClass().getName());\n<line3>    qb.tearDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(1000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    ZooKeeper zk;\n<line10>    final ArrayList<ACL> CREATOR_ALL_AND_WORLD_READABLE = new ArrayList<ACL>() {\n<line11>\n<line12>        {\n<line13>            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));\n<line14>            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));\n<line15>            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));\n<line16>            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));\n<line17>        }\n<line18>    };\n<line19>    try {\n<line20>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line21>        zk = ClientBase.createZKClient(HOSTPORT);\n<line22>        zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line23>        zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line24>        String path = \"/path\";\n<line25>        try {\n<line26>            assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());\n<line27>        } catch (Exception e) {\n<line28>            throw e;\n<line29>        }\n<line30>        zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);\n<line31>        List<ACL> acls = zk.getACL(\"/path\", new Stat());\n<line32>        assertEquals(2, acls.size());\n<line33>    } catch (Exception e) {\n<line34>        // test failed somehow.\n<line35>        assertTrue(false);\n<line36>    }\n<line37>    f.shutdown();\n<line38>    zks.shutdown();\n<line39>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(1000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    ZooKeeper zk;\n<line10>    final ArrayList<ACL> CREATOR_ALL_AND_WORLD_READABLE = new ArrayList<ACL>() {\n<line11>\n<line12>        {\n<line13>            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));\n<line14>            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));\n<line15>            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));\n<line16>            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));\n<line17>        }\n<line18>    };\n<line19>    try {\n<line20>        LOG.info(\"starting up the zookeeper server .. waiting\");\n<line21>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line22>        zk = ClientBase.createZKClient(HOSTPORT);\n<line23>        zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line24>        zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line25>        String path = \"/path\";\n<line26>        try {\n<line27>            assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());\n<line28>        } catch (Exception e) {\n<line29>            LOG.error(\"Something is fundamentally wrong with ArrayList's add() method. add()ing four times to an empty ArrayList should result in an ArrayList with 4 members.\");\n<line30>            throw e;\n<line31>        }\n<line32>        zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);\n<line33>        List<ACL> acls = zk.getACL(\"/path\", new Stat());\n<line34>        assertEquals(2, acls.size());\n<line35>    } catch (Exception e) {\n<line36>        // test failed somehow.\n<line37>        assertTrue(false);\n<line38>    }\n<line39>    f.shutdown();\n<line40>    zks.shutdown();\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line3>    zk = ClientBase.createZKClient(HOSTPORT);\n<line4>    zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line5>    zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line6>    String path = \"/path\";\n<line7>    try {\n<line8>        assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());\n<line9>    } catch (Exception e) {\n<line10>        throw e;\n<line11>    }\n<line12>    zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);\n<line13>    List<ACL> acls = zk.getACL(\"/path\", new Stat());\n<line14>    assertEquals(2, acls.size());\n<line15>}","output":"<line1>{\n<line2>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line3>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line4>    zk = ClientBase.createZKClient(HOSTPORT);\n<line5>    zk.addAuthInfo(\"digest\", \"pat:test\".getBytes());\n<line6>    zk.setACL(\"/\", Ids.CREATOR_ALL_ACL, -1);\n<line7>    String path = \"/path\";\n<line8>    try {\n<line9>        assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());\n<line10>    } catch (Exception e) {\n<line11>        LOG.error(\"Something is fundamentally wrong with ArrayList's add() method. add()ing four times to an empty ArrayList should result in an ArrayList with 4 members.\");\n<line12>        throw e;\n<line13>    }\n<line14>    zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);\n<line15>    List<ACL> acls = zk.getACL(\"/path\", new Stat());\n<line16>    assertEquals(2, acls.size());\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Something is fundamentally wrong with ArrayList's add() method. add()ing four times to an empty ArrayList should result in an ArrayList with 4 members.\");\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>}","output":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>    LOG.info(\"Constructor: {}\", getName());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        while (true) {\n<line5>            peer.setPeerState(ServerState.LOOKING);\n<line6>            v = peer.getElectionAlg().lookForLeader();\n<line7>            if (v == null) {\n<line8>                break;\n<line9>            }\n<line10>            /*\n<line11>                     * A real zookeeper would take care of setting the current vote. Here\n<line12>                     * we do it manually.\n<line13>                     */\n<line14>            peer.setCurrentVote(v);\n<line15>            //votes[i] = v;\n<line16>            switch(i) {\n<line17>                case 0:\n<line18>                    if (peerRound == 0) {\n<line19>                        QuorumBase.shutdown(peer);\n<line20>                        restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line21>                        peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line22>                        peer.startLeaderElection();\n<line23>                        peerRound++;\n<line24>                    } else {\n<line25>                        finish.release(2);\n<line26>                        return;\n<line27>                    }\n<line28>                    break;\n<line29>                case 1:\n<line30>                    finish.acquire();\n<line31>                    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line32>                    return;\n<line33>                case 2:\n<line34>                    finish.acquire();\n<line35>                    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line36>                    return;\n<line37>            }\n<line38>        }\n<line39>    } catch (Exception e) {\n<line40>        e.printStackTrace();\n<line41>    }\n<line42>}","output":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        while (true) {\n<line5>            peer.setPeerState(ServerState.LOOKING);\n<line6>            LOG.info(\"Going to call leader election again.\");\n<line7>            v = peer.getElectionAlg().lookForLeader();\n<line8>            if (v == null) {\n<line9>                LOG.info(\"Thread {} got a null vote\", i);\n<line10>                break;\n<line11>            }\n<line12>            /*\n<line13>                     * A real zookeeper would take care of setting the current vote. Here\n<line14>                     * we do it manually.\n<line15>                     */\n<line16>            peer.setCurrentVote(v);\n<line17>            LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line18>            //votes[i] = v;\n<line19>            switch(i) {\n<line20>                case 0:\n<line21>                    if (peerRound == 0) {\n<line22>                        LOG.info(\"First peer, shutting it down\");\n<line23>                        QuorumBase.shutdown(peer);\n<line24>                        restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line25>                        peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line26>                        peer.startLeaderElection();\n<line27>                        peerRound++;\n<line28>                    } else {\n<line29>                        finish.release(2);\n<line30>                        return;\n<line31>                    }\n<line32>                    break;\n<line33>                case 1:\n<line34>                    LOG.info(\"Second entering case\");\n<line35>                    finish.acquire();\n<line36>                    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line37>                    LOG.info(\"Release\");\n<line38>                    return;\n<line39>                case 2:\n<line40>                    LOG.info(\"First peer, do nothing, just join\");\n<line41>                    finish.acquire();\n<line42>                    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line43>                    LOG.info(\"Release\");\n<line44>                    return;\n<line45>            }\n<line46>        }\n<line47>    } catch (Exception e) {\n<line48>        e.printStackTrace();\n<line49>    }\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>    Vote v = null;\n<line3>    while (true) {\n<line4>        peer.setPeerState(ServerState.LOOKING);\n<line5>        v = peer.getElectionAlg().lookForLeader();\n<line6>        if (v == null) {\n<line7>            break;\n<line8>        }\n<line9>        /*\n<line10>                     * A real zookeeper would take care of setting the current vote. Here\n<line11>                     * we do it manually.\n<line12>                     */\n<line13>        peer.setCurrentVote(v);\n<line14>        //votes[i] = v;\n<line15>        switch(i) {\n<line16>            case 0:\n<line17>                if (peerRound == 0) {\n<line18>                    QuorumBase.shutdown(peer);\n<line19>                    restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line20>                    peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line21>                    peer.startLeaderElection();\n<line22>                    peerRound++;\n<line23>                } else {\n<line24>                    finish.release(2);\n<line25>                    return;\n<line26>                }\n<line27>                break;\n<line28>            case 1:\n<line29>                finish.acquire();\n<line30>                //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line31>                return;\n<line32>            case 2:\n<line33>                finish.acquire();\n<line34>                //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line35>                return;\n<line36>        }\n<line37>    }\n<line38>}","output":"<line1>{\n<line2>    Vote v = null;\n<line3>    while (true) {\n<line4>        peer.setPeerState(ServerState.LOOKING);\n<line5>        LOG.info(\"Going to call leader election again.\");\n<line6>        v = peer.getElectionAlg().lookForLeader();\n<line7>        if (v == null) {\n<line8>            LOG.info(\"Thread {} got a null vote\", i);\n<line9>            break;\n<line10>        }\n<line11>        /*\n<line12>                     * A real zookeeper would take care of setting the current vote. Here\n<line13>                     * we do it manually.\n<line14>                     */\n<line15>        peer.setCurrentVote(v);\n<line16>        LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line17>        //votes[i] = v;\n<line18>        switch(i) {\n<line19>            case 0:\n<line20>                if (peerRound == 0) {\n<line21>                    LOG.info(\"First peer, shutting it down\");\n<line22>                    QuorumBase.shutdown(peer);\n<line23>                    restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line24>                    peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line25>                    peer.startLeaderElection();\n<line26>                    peerRound++;\n<line27>                } else {\n<line28>                    finish.release(2);\n<line29>                    return;\n<line30>                }\n<line31>                break;\n<line32>            case 1:\n<line33>                LOG.info(\"Second entering case\");\n<line34>                finish.acquire();\n<line35>                //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line36>                LOG.info(\"Release\");\n<line37>                return;\n<line38>            case 2:\n<line39>                LOG.info(\"First peer, do nothing, just join\");\n<line40>                finish.acquire();\n<line41>                //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line42>                LOG.info(\"Release\");\n<line43>                return;\n<line44>        }\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    peer.setPeerState(ServerState.LOOKING);\n<line3>    v = peer.getElectionAlg().lookForLeader();\n<line4>    if (v == null) {\n<line5>        break;\n<line6>    }\n<line7>    /*\n<line8>                     * A real zookeeper would take care of setting the current vote. Here\n<line9>                     * we do it manually.\n<line10>                     */\n<line11>    peer.setCurrentVote(v);\n<line12>    //votes[i] = v;\n<line13>    switch(i) {\n<line14>        case 0:\n<line15>            if (peerRound == 0) {\n<line16>                QuorumBase.shutdown(peer);\n<line17>                restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line18>                peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line19>                peer.startLeaderElection();\n<line20>                peerRound++;\n<line21>            } else {\n<line22>                finish.release(2);\n<line23>                return;\n<line24>            }\n<line25>            break;\n<line26>        case 1:\n<line27>            finish.acquire();\n<line28>            //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line29>            return;\n<line30>        case 2:\n<line31>            finish.acquire();\n<line32>            //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line33>            return;\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    peer.setPeerState(ServerState.LOOKING);\n<line3>    LOG.info(\"Going to call leader election again.\");\n<line4>    v = peer.getElectionAlg().lookForLeader();\n<line5>    if (v == null) {\n<line6>        LOG.info(\"Thread {} got a null vote\", i);\n<line7>        break;\n<line8>    }\n<line9>    /*\n<line10>                     * A real zookeeper would take care of setting the current vote. Here\n<line11>                     * we do it manually.\n<line12>                     */\n<line13>    peer.setCurrentVote(v);\n<line14>    LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line15>    //votes[i] = v;\n<line16>    switch(i) {\n<line17>        case 0:\n<line18>            if (peerRound == 0) {\n<line19>                LOG.info(\"First peer, shutting it down\");\n<line20>                QuorumBase.shutdown(peer);\n<line21>                restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line22>                peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line23>                peer.startLeaderElection();\n<line24>                peerRound++;\n<line25>            } else {\n<line26>                finish.release(2);\n<line27>                return;\n<line28>            }\n<line29>            break;\n<line30>        case 1:\n<line31>            LOG.info(\"Second entering case\");\n<line32>            finish.acquire();\n<line33>            //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line34>            LOG.info(\"Release\");\n<line35>            return;\n<line36>        case 2:\n<line37>            LOG.info(\"First peer, do nothing, just join\");\n<line38>            finish.acquire();\n<line39>            //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line40>            LOG.info(\"Release\");\n<line41>            return;\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Thread {} got a null vote\", i);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumBase.shutdown(peer);\n<line3>    restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line4>    peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line5>    peer.startLeaderElection();\n<line6>    peerRound++;\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"First peer, shutting it down\");\n<line3>    QuorumBase.shutdown(peer);\n<line4>    restartThreads.get(i).peer.getElectionAlg().shutdown();\n<line5>    peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line6>    peer.startLeaderElection();\n<line7>    peerRound++;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < count; i++) {\n<line3>        peers.put((long) i, new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line4>        tmpdir[i] = ClientBase.createTmpDir();\n<line5>        port[i] = PortAssignment.unique();\n<line6>    }\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line9>        peer.startLeaderElection();\n<line10>        FLERestartThread thread = new FLERestartThread(peer, i);\n<line11>        thread.start();\n<line12>        restartThreads.add(thread);\n<line13>    }\n<line14>    for (int i = 0; i < restartThreads.size(); i++) {\n<line15>        restartThreads.get(i).join(10000);\n<line16>        if (restartThreads.get(i).isAlive()) {\n<line17>            fail(\"Threads didn't join\");\n<line18>        }\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    LOG.info(\"TestLE: {}, {}\", getTestName(), count);\n<line3>    for (int i = 0; i < count; i++) {\n<line4>        peers.put((long) i, new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line5>        tmpdir[i] = ClientBase.createTmpDir();\n<line6>        port[i] = PortAssignment.unique();\n<line7>    }\n<line8>    for (int i = 0; i < count; i++) {\n<line9>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line10>        peer.startLeaderElection();\n<line11>        FLERestartThread thread = new FLERestartThread(peer, i);\n<line12>        thread.start();\n<line13>        restartThreads.add(thread);\n<line14>    }\n<line15>    LOG.info(\"Started threads {}\", getTestName());\n<line16>    for (int i = 0; i < restartThreads.size(); i++) {\n<line17>        restartThreads.get(i).join(10000);\n<line18>        if (restartThreads.get(i).isAlive()) {\n<line19>            fail(\"Threads didn't join\");\n<line20>        }\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] config = null;\n<line3>    String failure = null;\n<line4>    for (int j = 0; j < 30; j++) {\n<line5>        try {\n<line6>            config = zkAdmin.reconfigure(joiningServers, leavingServers, newMembers, fromConfig, new Stat());\n<line7>            failure = null;\n<line8>            break;\n<line9>        } catch (KeeperException.ConnectionLossException e) {\n<line10>            failure = \"client could not connect to reestablished quorum: giving up after 30+ seconds.\";\n<line11>        } catch (KeeperException.ReconfigInProgress e) {\n<line12>            failure = \"reconfig still in progress: giving up after 30+ seconds.\";\n<line13>        }\n<line14>        Thread.sleep(1000);\n<line15>    }\n<line16>    if (failure != null) {\n<line17>        fail(failure);\n<line18>    }\n<line19>    String configStr = new String(config);\n<line20>    List<ServerConfigLine> currentServerConfigs = Arrays.stream(configStr.split(\"\\n\")).map(String::trim).filter(s -> s.startsWith(\"server\")).map(ServerConfigLine::new).collect(toList());\n<line21>    if (joiningServers != null) {\n<line22>        for (String joiner : joiningServers) {\n<line23>            ServerConfigLine joinerServerConfigLine = new ServerConfigLine(joiner);\n<line24>            String errorMessage = format(\"expected joiner config \\\"%s\\\" not found in current config:\\n%s\", joiner, configStr);\n<line25>            assertTrue(currentServerConfigs.stream().anyMatch(c -> c.equals(joinerServerConfigLine)), errorMessage);\n<line26>        }\n<line27>    }\n<line28>    if (leavingServers != null) {\n<line29>        for (String leaving : leavingServers) {\n<line30>            String errorMessage = format(\"leaving server \\\"%s\\\" not removed from config: \\n%s\", leaving, configStr);\n<line31>            assertFalse(configStr.contains(format(\"server.%s=\", leaving)), errorMessage);\n<line32>        }\n<line33>    }\n<line34>    return configStr;\n<line35>}","output":"<line1>{\n<line2>    byte[] config = null;\n<line3>    String failure = null;\n<line4>    LOG.info(\"reconfig initiated by the test\");\n<line5>    for (int j = 0; j < 30; j++) {\n<line6>        try {\n<line7>            config = zkAdmin.reconfigure(joiningServers, leavingServers, newMembers, fromConfig, new Stat());\n<line8>            failure = null;\n<line9>            break;\n<line10>        } catch (KeeperException.ConnectionLossException e) {\n<line11>            failure = \"client could not connect to reestablished quorum: giving up after 30+ seconds.\";\n<line12>        } catch (KeeperException.ReconfigInProgress e) {\n<line13>            failure = \"reconfig still in progress: giving up after 30+ seconds.\";\n<line14>        }\n<line15>        Thread.sleep(1000);\n<line16>    }\n<line17>    if (failure != null) {\n<line18>        fail(failure);\n<line19>    }\n<line20>    String configStr = new String(config);\n<line21>    List<ServerConfigLine> currentServerConfigs = Arrays.stream(configStr.split(\"\\n\")).map(String::trim).filter(s -> s.startsWith(\"server\")).map(ServerConfigLine::new).collect(toList());\n<line22>    if (joiningServers != null) {\n<line23>        for (String joiner : joiningServers) {\n<line24>            ServerConfigLine joinerServerConfigLine = new ServerConfigLine(joiner);\n<line25>            String errorMessage = format(\"expected joiner config \\\"%s\\\" not found in current config:\\n%s\", joiner, configStr);\n<line26>            assertTrue(currentServerConfigs.stream().anyMatch(c -> c.equals(joinerServerConfigLine)), errorMessage);\n<line27>        }\n<line28>    }\n<line29>    if (leavingServers != null) {\n<line30>        for (String leaving : leavingServers) {\n<line31>            String errorMessage = format(\"leaving server \\\"%s\\\" not removed from config: \\n%s\", leaving, configStr);\n<line32>            assertFalse(configStr.contains(format(\"server.%s=\", leaving)), errorMessage);\n<line33>        }\n<line34>    }\n<line35>    return configStr;\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    if (localSessionEnabled) {\n<line3>        qu.enableLocalSession(true);\n<line4>    }\n<line5>    qu.startAll();\n<line6>    QuorumPeer leader = qu.getLeaderQuorumPeer();\n<line7>    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));\n<line8>    CreateRequest createRequest = new CreateRequest(\"/impossible\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());\n<line9>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line10>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line11>    createRequest.serialize(boa, \"request\");\n<line12>    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line13>    // Mimic sessionId generated by follower's local session tracker\n<line14>    long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();\n<line15>    long fakeSessionId = (sid << 56) + 1;\n<line16>    Request request = new Request(null, fakeSessionId, 0, OpCode.create, RequestRecord.fromBytes(bb), new ArrayList<Id>());\n<line17>    // Submit request directly to leader\n<line18>    leader.getActiveServer().submitRequest(request);\n<line19>    // Make sure that previous request is finished\n<line20>    zk.create(\"/ok\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line21>    Stat stat = zk.exists(\"/impossible\", null);\n<line22>    assertEquals(null, stat, \"Node from fake session get created\");\n<line23>}","output":"<line1>{\n<line2>    if (localSessionEnabled) {\n<line3>        qu.enableLocalSession(true);\n<line4>    }\n<line5>    qu.startAll();\n<line6>    QuorumPeer leader = qu.getLeaderQuorumPeer();\n<line7>    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));\n<line8>    CreateRequest createRequest = new CreateRequest(\"/impossible\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());\n<line9>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line10>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line11>    createRequest.serialize(boa, \"request\");\n<line12>    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line13>    // Mimic sessionId generated by follower's local session tracker\n<line14>    long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();\n<line15>    long fakeSessionId = (sid << 56) + 1;\n<line16>    LOG.info(\"Fake session Id: {}\", Long.toHexString(fakeSessionId));\n<line17>    Request request = new Request(null, fakeSessionId, 0, OpCode.create, RequestRecord.fromBytes(bb), new ArrayList<Id>());\n<line18>    // Submit request directly to leader\n<line19>    leader.getActiveServer().submitRequest(request);\n<line20>    // Make sure that previous request is finished\n<line21>    zk.create(\"/ok\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line22>    Stat stat = zk.exists(\"/impossible\", null);\n<line23>    assertEquals(null, stat, \"Node from fake session get created\");\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.enableLocalSession(true);\n<line3>    qu.startAll();\n<line4>    QuorumPeer leader = qu.getLeaderQuorumPeer();\n<line5>    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));\n<line6>    CreateRequest createRequest = new CreateRequest(\"/success\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag());\n<line7>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line8>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line9>    createRequest.serialize(boa, \"request\");\n<line10>    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line11>    // Mimic sessionId generated by follower's local session tracker\n<line12>    long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();\n<line13>    long locallSession = (sid << 56) + 1;\n<line14>    Request request = new Request(null, locallSession, 0, OpCode.create, RequestRecord.fromBytes(bb), new ArrayList<Id>());\n<line15>    // Submit request directly to leader\n<line16>    leader.getActiveServer().submitRequest(request);\n<line17>    // Make sure that previous request is finished\n<line18>    zk.create(\"/ok\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line19>    Stat stat = zk.exists(\"/success\", null);\n<line20>    assertTrue(stat != null, \"Request from local sesson failed\");\n<line21>}","output":"<line1>{\n<line2>    qu.enableLocalSession(true);\n<line3>    qu.startAll();\n<line4>    QuorumPeer leader = qu.getLeaderQuorumPeer();\n<line5>    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));\n<line6>    CreateRequest createRequest = new CreateRequest(\"/success\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag());\n<line7>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line8>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line9>    createRequest.serialize(boa, \"request\");\n<line10>    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line11>    // Mimic sessionId generated by follower's local session tracker\n<line12>    long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();\n<line13>    long locallSession = (sid << 56) + 1;\n<line14>    LOG.info(\"Local session Id: {}\", Long.toHexString(locallSession));\n<line15>    Request request = new Request(null, locallSession, 0, OpCode.create, RequestRecord.fromBytes(bb), new ArrayList<Id>());\n<line16>    // Submit request directly to leader\n<line17>    leader.getActiveServer().submitRequest(request);\n<line18>    // Make sure that previous request is finished\n<line19>    zk.create(\"/ok\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line20>    Stat stat = zk.exists(\"/success\", null);\n<line21>    assertTrue(stat != null, \"Request from local sesson failed\");\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>}","output":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>    LOG.info(\"Constructor: {}\", getName());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean flag = true;\n<line3>    try {\n<line4>        while (flag) {\n<line5>            Vote v = null;\n<line6>            peer.setPeerState(ServerState.LOOKING);\n<line7>            v = peer.getElectionAlg().lookForLeader();\n<line8>            if (v == null) {\n<line9>                fail(\"Thread \" + i + \" got a null vote\");\n<line10>            }\n<line11>            /*\n<line12>                     * A real zookeeper would take care of setting the current vote. Here\n<line13>                     * we do it manually.\n<line14>                     */\n<line15>            peer.setCurrentVote(v);\n<line16>            //votes[i] = v;\n<line17>            switch(i) {\n<line18>                case 0:\n<line19>                    if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line20>                        //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line21>                        flag = false;\n<line22>                    }\n<line23>                    break;\n<line24>                case 1:\n<line25>                    if (round[1] != 0) {\n<line26>                        finish0.release();\n<line27>                        flag = false;\n<line28>                    } else {\n<line29>                        finish3.acquire();\n<line30>                        start0.release();\n<line31>                    }\n<line32>                    round[1]++;\n<line33>                    break;\n<line34>                case 2:\n<line35>                    QuorumBase.shutdown(peer);\n<line36>                    flag = false;\n<line37>                    round[2] = 1;\n<line38>                    finish3.release();\n<line39>                    break;\n<line40>            }\n<line41>        }\n<line42>    } catch (Exception e) {\n<line43>        e.printStackTrace();\n<line44>    }\n<line45>}","output":"<line1>{\n<line2>    boolean flag = true;\n<line3>    try {\n<line4>        while (flag) {\n<line5>            Vote v = null;\n<line6>            peer.setPeerState(ServerState.LOOKING);\n<line7>            LOG.info(\"Going to call leader election again: {}\", i);\n<line8>            v = peer.getElectionAlg().lookForLeader();\n<line9>            if (v == null) {\n<line10>                fail(\"Thread \" + i + \" got a null vote\");\n<line11>            }\n<line12>            /*\n<line13>                     * A real zookeeper would take care of setting the current vote. Here\n<line14>                     * we do it manually.\n<line15>                     */\n<line16>            peer.setCurrentVote(v);\n<line17>            LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line18>            //votes[i] = v;\n<line19>            switch(i) {\n<line20>                case 0:\n<line21>                    LOG.info(\"First peer, do nothing, just join\");\n<line22>                    if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line23>                        //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line24>                        LOG.info(\"Setting flag to false\");\n<line25>                        flag = false;\n<line26>                    }\n<line27>                    break;\n<line28>                case 1:\n<line29>                    LOG.info(\"Second entering case\");\n<line30>                    if (round[1] != 0) {\n<line31>                        finish0.release();\n<line32>                        flag = false;\n<line33>                    } else {\n<line34>                        finish3.acquire();\n<line35>                        start0.release();\n<line36>                    }\n<line37>                    LOG.info(\"Second is going to start second round\");\n<line38>                    round[1]++;\n<line39>                    break;\n<line40>                case 2:\n<line41>                    LOG.info(\"Third peer, shutting it down\");\n<line42>                    QuorumBase.shutdown(peer);\n<line43>                    flag = false;\n<line44>                    round[2] = 1;\n<line45>                    finish3.release();\n<line46>                    LOG.info(\"Third leaving\");\n<line47>                    break;\n<line48>            }\n<line49>        }\n<line50>    } catch (Exception e) {\n<line51>        e.printStackTrace();\n<line52>    }\n<line53>}"},{"input":"","instruction":"<line1>{\n<line2>    while (flag) {\n<line3>        Vote v = null;\n<line4>        peer.setPeerState(ServerState.LOOKING);\n<line5>        v = peer.getElectionAlg().lookForLeader();\n<line6>        if (v == null) {\n<line7>            fail(\"Thread \" + i + \" got a null vote\");\n<line8>        }\n<line9>        /*\n<line10>                     * A real zookeeper would take care of setting the current vote. Here\n<line11>                     * we do it manually.\n<line12>                     */\n<line13>        peer.setCurrentVote(v);\n<line14>        //votes[i] = v;\n<line15>        switch(i) {\n<line16>            case 0:\n<line17>                if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line18>                    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line19>                    flag = false;\n<line20>                }\n<line21>                break;\n<line22>            case 1:\n<line23>                if (round[1] != 0) {\n<line24>                    finish0.release();\n<line25>                    flag = false;\n<line26>                } else {\n<line27>                    finish3.acquire();\n<line28>                    start0.release();\n<line29>                }\n<line30>                round[1]++;\n<line31>                break;\n<line32>            case 2:\n<line33>                QuorumBase.shutdown(peer);\n<line34>                flag = false;\n<line35>                round[2] = 1;\n<line36>                finish3.release();\n<line37>                break;\n<line38>        }\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    while (flag) {\n<line3>        Vote v = null;\n<line4>        peer.setPeerState(ServerState.LOOKING);\n<line5>        LOG.info(\"Going to call leader election again: {}\", i);\n<line6>        v = peer.getElectionAlg().lookForLeader();\n<line7>        if (v == null) {\n<line8>            fail(\"Thread \" + i + \" got a null vote\");\n<line9>        }\n<line10>        /*\n<line11>                     * A real zookeeper would take care of setting the current vote. Here\n<line12>                     * we do it manually.\n<line13>                     */\n<line14>        peer.setCurrentVote(v);\n<line15>        LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line16>        //votes[i] = v;\n<line17>        switch(i) {\n<line18>            case 0:\n<line19>                LOG.info(\"First peer, do nothing, just join\");\n<line20>                if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line21>                    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line22>                    LOG.info(\"Setting flag to false\");\n<line23>                    flag = false;\n<line24>                }\n<line25>                break;\n<line26>            case 1:\n<line27>                LOG.info(\"Second entering case\");\n<line28>                if (round[1] != 0) {\n<line29>                    finish0.release();\n<line30>                    flag = false;\n<line31>                } else {\n<line32>                    finish3.acquire();\n<line33>                    start0.release();\n<line34>                }\n<line35>                LOG.info(\"Second is going to start second round\");\n<line36>                round[1]++;\n<line37>                break;\n<line38>            case 2:\n<line39>                LOG.info(\"Third peer, shutting it down\");\n<line40>                QuorumBase.shutdown(peer);\n<line41>                flag = false;\n<line42>                round[2] = 1;\n<line43>                finish3.release();\n<line44>                LOG.info(\"Third leaving\");\n<line45>                break;\n<line46>        }\n<line47>    }\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>    Vote v = null;\n<line3>    peer.setPeerState(ServerState.LOOKING);\n<line4>    v = peer.getElectionAlg().lookForLeader();\n<line5>    if (v == null) {\n<line6>        fail(\"Thread \" + i + \" got a null vote\");\n<line7>    }\n<line8>    /*\n<line9>                     * A real zookeeper would take care of setting the current vote. Here\n<line10>                     * we do it manually.\n<line11>                     */\n<line12>    peer.setCurrentVote(v);\n<line13>    //votes[i] = v;\n<line14>    switch(i) {\n<line15>        case 0:\n<line16>            if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line17>                //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line18>                flag = false;\n<line19>            }\n<line20>            break;\n<line21>        case 1:\n<line22>            if (round[1] != 0) {\n<line23>                finish0.release();\n<line24>                flag = false;\n<line25>            } else {\n<line26>                finish3.acquire();\n<line27>                start0.release();\n<line28>            }\n<line29>            round[1]++;\n<line30>            break;\n<line31>        case 2:\n<line32>            QuorumBase.shutdown(peer);\n<line33>            flag = false;\n<line34>            round[2] = 1;\n<line35>            finish3.release();\n<line36>            break;\n<line37>    }\n<line38>}","output":"<line1>{\n<line2>    Vote v = null;\n<line3>    peer.setPeerState(ServerState.LOOKING);\n<line4>    LOG.info(\"Going to call leader election again: {}\", i);\n<line5>    v = peer.getElectionAlg().lookForLeader();\n<line6>    if (v == null) {\n<line7>        fail(\"Thread \" + i + \" got a null vote\");\n<line8>    }\n<line9>    /*\n<line10>                     * A real zookeeper would take care of setting the current vote. Here\n<line11>                     * we do it manually.\n<line12>                     */\n<line13>    peer.setCurrentVote(v);\n<line14>    LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line15>    //votes[i] = v;\n<line16>    switch(i) {\n<line17>        case 0:\n<line18>            LOG.info(\"First peer, do nothing, just join\");\n<line19>            if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line20>                //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line21>                LOG.info(\"Setting flag to false\");\n<line22>                flag = false;\n<line23>            }\n<line24>            break;\n<line25>        case 1:\n<line26>            LOG.info(\"Second entering case\");\n<line27>            if (round[1] != 0) {\n<line28>                finish0.release();\n<line29>                flag = false;\n<line30>            } else {\n<line31>                finish3.acquire();\n<line32>                start0.release();\n<line33>            }\n<line34>            LOG.info(\"Second is going to start second round\");\n<line35>            round[1]++;\n<line36>            break;\n<line37>        case 2:\n<line38>            LOG.info(\"Third peer, shutting it down\");\n<line39>            QuorumBase.shutdown(peer);\n<line40>            flag = false;\n<line41>            round[2] = 1;\n<line42>            finish3.release();\n<line43>            LOG.info(\"Third leaving\");\n<line44>            break;\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line3>    flag = false;\n<line4>}","output":"<line1>{\n<line2>    //if(threads.get(0).peer.getPeerState() == ServerState.LEADING ){\n<line3>    LOG.info(\"Setting flag to false\");\n<line4>    flag = false;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < count; i++) {\n<line3>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line4>        tmpdir[i] = ClientBase.createTmpDir();\n<line5>        port[i] = PortAssignment.unique();\n<line6>    }\n<line7>    for (int i = 1; i < count; i++) {\n<line8>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line9>        peer.startLeaderElection();\n<line10>        LEThread thread = new LEThread(peer, i);\n<line11>        thread.start();\n<line12>        threads.add(thread);\n<line13>    }\n<line14>    if (!start0.tryAcquire(4000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line15>        fail(\"First leader election failed\");\n<line16>    }\n<line17>    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);\n<line18>    peer.startLeaderElection();\n<line19>    LEThread thread = new LEThread(peer, 0);\n<line20>    thread.start();\n<line21>    threads.add(thread);\n<line22>    for (int i = 0; i < threads.size(); i++) {\n<line23>        threads.get(i).join(10000);\n<line24>        if (threads.get(i).isAlive()) {\n<line25>            fail(\"Threads didn't join\");\n<line26>        }\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    LOG.info(\"TestLE: {}, {}\", getTestName(), count);\n<line3>    for (int i = 0; i < count; i++) {\n<line4>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line5>        tmpdir[i] = ClientBase.createTmpDir();\n<line6>        port[i] = PortAssignment.unique();\n<line7>    }\n<line8>    for (int i = 1; i < count; i++) {\n<line9>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);\n<line10>        peer.startLeaderElection();\n<line11>        LEThread thread = new LEThread(peer, i);\n<line12>        thread.start();\n<line13>        threads.add(thread);\n<line14>    }\n<line15>    if (!start0.tryAcquire(4000, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n<line16>        fail(\"First leader election failed\");\n<line17>    }\n<line18>    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);\n<line19>    peer.startLeaderElection();\n<line20>    LEThread thread = new LEThread(peer, 0);\n<line21>    thread.start();\n<line22>    threads.add(thread);\n<line23>    LOG.info(\"Started threads {}\", getTestName());\n<line24>    for (int i = 0; i < threads.size(); i++) {\n<line25>        threads.get(i).join(10000);\n<line26>        if (threads.get(i).isAlive()) {\n<line27>            fail(\"Threads didn't join\");\n<line28>        }\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>}","output":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>    LOG.info(\"Constructor: {}\", getName());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        fail = false;\n<line5>        while (true) {\n<line6>            //while(true) {\n<line7>            peer.setPeerState(ServerState.LOOKING);\n<line8>            v = peer.getElectionAlg().lookForLeader();\n<line9>            if (v == null) {\n<line10>                return;\n<line11>            }\n<line12>            /*\n<line13>                     * A real zookeeper would take care of setting the current vote. Here\n<line14>                     * we do it manually.\n<line15>                     */\n<line16>            peer.setCurrentVote(v);\n<line17>            votes[i] = v;\n<line18>            if ((peer.getPeerState() == ServerState.LEADING) && (peer.getMyId() > 2)) {\n<line19>                fail = true;\n<line20>            }\n<line21>            if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {\n<line22>                break;\n<line23>            }\n<line24>        }\n<line25>    } catch (InterruptedException e) {\n<line26>        e.printStackTrace();\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        fail = false;\n<line5>        while (true) {\n<line6>            //while(true) {\n<line7>            peer.setPeerState(ServerState.LOOKING);\n<line8>            LOG.info(\"Going to call leader election.\");\n<line9>            v = peer.getElectionAlg().lookForLeader();\n<line10>            if (v == null) {\n<line11>                LOG.info(\"Thread {} got a null vote\", i);\n<line12>                return;\n<line13>            }\n<line14>            /*\n<line15>                     * A real zookeeper would take care of setting the current vote. Here\n<line16>                     * we do it manually.\n<line17>                     */\n<line18>            peer.setCurrentVote(v);\n<line19>            LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line20>            votes[i] = v;\n<line21>            if ((peer.getPeerState() == ServerState.LEADING) && (peer.getMyId() > 2)) {\n<line22>                fail = true;\n<line23>            }\n<line24>            if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {\n<line25>                break;\n<line26>            }\n<line27>        }\n<line28>        LOG.debug(\"Thread {} votes {}\", i, v);\n<line29>    } catch (InterruptedException e) {\n<line30>        e.printStackTrace();\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    Vote v = null;\n<line3>    fail = false;\n<line4>    while (true) {\n<line5>        //while(true) {\n<line6>        peer.setPeerState(ServerState.LOOKING);\n<line7>        v = peer.getElectionAlg().lookForLeader();\n<line8>        if (v == null) {\n<line9>            return;\n<line10>        }\n<line11>        /*\n<line12>                     * A real zookeeper would take care of setting the current vote. Here\n<line13>                     * we do it manually.\n<line14>                     */\n<line15>        peer.setCurrentVote(v);\n<line16>        votes[i] = v;\n<line17>        if ((peer.getPeerState() == ServerState.LEADING) && (peer.getMyId() > 2)) {\n<line18>            fail = true;\n<line19>        }\n<line20>        if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {\n<line21>            break;\n<line22>        }\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    Vote v = null;\n<line3>    fail = false;\n<line4>    while (true) {\n<line5>        //while(true) {\n<line6>        peer.setPeerState(ServerState.LOOKING);\n<line7>        LOG.info(\"Going to call leader election.\");\n<line8>        v = peer.getElectionAlg().lookForLeader();\n<line9>        if (v == null) {\n<line10>            LOG.info(\"Thread {} got a null vote\", i);\n<line11>            return;\n<line12>        }\n<line13>        /*\n<line14>                     * A real zookeeper would take care of setting the current vote. Here\n<line15>                     * we do it manually.\n<line16>                     */\n<line17>        peer.setCurrentVote(v);\n<line18>        LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line19>        votes[i] = v;\n<line20>        if ((peer.getPeerState() == ServerState.LEADING) && (peer.getMyId() > 2)) {\n<line21>            fail = true;\n<line22>        }\n<line23>        if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {\n<line24>            break;\n<line25>        }\n<line26>    }\n<line27>    LOG.debug(\"Thread {} votes {}\", i, v);\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    //while(true) {\n<line3>    peer.setPeerState(ServerState.LOOKING);\n<line4>    v = peer.getElectionAlg().lookForLeader();\n<line5>    if (v == null) {\n<line6>        return;\n<line7>    }\n<line8>    /*\n<line9>                     * A real zookeeper would take care of setting the current vote. Here\n<line10>                     * we do it manually.\n<line11>                     */\n<line12>    peer.setCurrentVote(v);\n<line13>    votes[i] = v;\n<line14>    if ((peer.getPeerState() == ServerState.LEADING) && (peer.getMyId() > 2)) {\n<line15>        fail = true;\n<line16>    }\n<line17>    if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {\n<line18>        break;\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    //while(true) {\n<line3>    peer.setPeerState(ServerState.LOOKING);\n<line4>    LOG.info(\"Going to call leader election.\");\n<line5>    v = peer.getElectionAlg().lookForLeader();\n<line6>    if (v == null) {\n<line7>        LOG.info(\"Thread {} got a null vote\", i);\n<line8>        return;\n<line9>    }\n<line10>    /*\n<line11>                     * A real zookeeper would take care of setting the current vote. Here\n<line12>                     * we do it manually.\n<line13>                     */\n<line14>    peer.setCurrentVote(v);\n<line15>    LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line16>    votes[i] = v;\n<line17>    if ((peer.getPeerState() == ServerState.LEADING) && (peer.getMyId() > 2)) {\n<line18>        fail = true;\n<line19>    }\n<line20>    if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {\n<line21>        break;\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Thread {} got a null vote\", i);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < count; i++) {\n<line3>        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique());\n<line4>        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique());\n<line5>        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique());\n<line6>        port[i] = addr3.getPort();\n<line7>        qp.setProperty(\"server.\" + i, \"127.0.0.1:\" + addr1.getPort() + \":\" + addr2.getPort() + \";\" + port[i]);\n<line8>        peers.put(Long.valueOf(i), new QuorumServer(i, addr1, addr2, addr3));\n<line9>        tmpdir[i] = ClientBase.createTmpDir();\n<line10>    }\n<line11>    for (int i = 0; i < count; i++) {\n<line12>        QuorumHierarchical hq = new QuorumHierarchical(qp);\n<line13>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2, hq);\n<line14>        peer.startLeaderElection();\n<line15>        LEThread thread = new LEThread(peer, i);\n<line16>        thread.start();\n<line17>        threads.add(thread);\n<line18>    }\n<line19>    for (int i = 0; i < threads.size(); i++) {\n<line20>        threads.get(i).join(15000);\n<line21>        if (threads.get(i).isAlive()) {\n<line22>            fail(\"Threads didn't join\");\n<line23>        } else {\n<line24>            if (threads.get(i).fail) {\n<line25>                fail(\"Elected zero-weight server\");\n<line26>            }\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    LOG.info(\"TestZeroWeightQuorum: {}, {}\", getTestName(), count);\n<line3>    for (int i = 0; i < count; i++) {\n<line4>        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique());\n<line5>        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique());\n<line6>        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique());\n<line7>        port[i] = addr3.getPort();\n<line8>        qp.setProperty(\"server.\" + i, \"127.0.0.1:\" + addr1.getPort() + \":\" + addr2.getPort() + \";\" + port[i]);\n<line9>        peers.put(Long.valueOf(i), new QuorumServer(i, addr1, addr2, addr3));\n<line10>        tmpdir[i] = ClientBase.createTmpDir();\n<line11>    }\n<line12>    for (int i = 0; i < count; i++) {\n<line13>        QuorumHierarchical hq = new QuorumHierarchical(qp);\n<line14>        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2, hq);\n<line15>        peer.startLeaderElection();\n<line16>        LEThread thread = new LEThread(peer, i);\n<line17>        thread.start();\n<line18>        threads.add(thread);\n<line19>    }\n<line20>    LOG.info(\"Started threads {}\", getTestName());\n<line21>    for (int i = 0; i < threads.size(); i++) {\n<line22>        threads.get(i).join(15000);\n<line23>        if (threads.get(i).isAlive()) {\n<line24>            fail(\"Threads didn't join\");\n<line25>        } else {\n<line26>            if (threads.get(i).fail) {\n<line27>                fail(\"Elected zero-weight server\");\n<line28>            }\n<line29>        }\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    super.setUp();\n<line3>    zk = createClient();\n<line4>    zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line5>}","output":"<line1>{\n<line2>    super.setUp();\n<line3>    LOG.info(\"Creating client {}\", getTestName());\n<line4>    zk = createClient();\n<line5>    zk.addAuthInfo(\"digest\", \"ben:passwd\".getBytes());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.close();\n<line3>    super.tearDown();\n<line4>}","output":"<line1>{\n<line2>    zk.close();\n<line3>    super.tearDown();\n<line4>    LOG.info(\"Test clients shutting down\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.enableLocalSession(true);\n<line3>    qu.startQuorum();\n<line4>    qu.shutdown(2);\n<line5>    CountdownWatcher watcher = new CountdownWatcher();\n<line6>    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line7>    watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line8>    assertSame(States.CONNECTEDREADONLY, zk.getState(), \"should be in r/o mode\");\n<line9>    long fakeId = zk.getSessionId();\n<line10>    watcher.reset();\n<line11>    qu.start(2);\n<line12>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line13>    // ZOOKEEPER-2722: wait until we can connect to a read-write server after the quorum\n<line14>    // is formed. Otherwise, it is possible that client first connects to a read-only server,\n<line15>    // then drops the connection because of shutting down of the read-only server caused\n<line16>    // by leader election / quorum forming between the read-only server and the newly started\n<line17>    // server. If we happen to execute the zk.create after the read-only server is shutdown and\n<line18>    // before the quorum is formed, we will get a ConnectLossException.\n<line19>    watcher.waitForSyncConnected(CONNECTION_TIMEOUT);\n<line20>    assertEquals(States.CONNECTED, zk.getState(), \"Should be in read-write mode\");\n<line21>    zk.create(\"/test\", \"test\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line22>    assertFalse(zk.getSessionId() == fakeId, \"fake session and real session have same id\");\n<line23>    zk.close();\n<line24>}","output":"<line1>{\n<line2>    qu.enableLocalSession(true);\n<line3>    qu.startQuorum();\n<line4>    qu.shutdown(2);\n<line5>    CountdownWatcher watcher = new CountdownWatcher();\n<line6>    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line7>    watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line8>    assertSame(States.CONNECTEDREADONLY, zk.getState(), \"should be in r/o mode\");\n<line9>    long fakeId = zk.getSessionId();\n<line10>    LOG.info(\"Connected as r/o mode with state {} and session id {}\", zk.getState(), fakeId);\n<line11>    watcher.reset();\n<line12>    qu.start(2);\n<line13>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT), \"waiting for server up\");\n<line14>    LOG.info(\"Server 127.0.0.1:{} is up\", qu.getPeer(2).clientPort);\n<line15>    // ZOOKEEPER-2722: wait until we can connect to a read-write server after the quorum\n<line16>    // is formed. Otherwise, it is possible that client first connects to a read-only server,\n<line17>    // then drops the connection because of shutting down of the read-only server caused\n<line18>    // by leader election / quorum forming between the read-only server and the newly started\n<line19>    // server. If we happen to execute the zk.create after the read-only server is shutdown and\n<line20>    // before the quorum is formed, we will get a ConnectLossException.\n<line21>    watcher.waitForSyncConnected(CONNECTION_TIMEOUT);\n<line22>    assertEquals(States.CONNECTED, zk.getState(), \"Should be in read-write mode\");\n<line23>    LOG.info(\"Connected as rw mode with state {} and session id {}\", zk.getState(), zk.getSessionId());\n<line24>    zk.create(\"/test\", \"test\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line25>    assertFalse(zk.getSessionId() == fakeId, \"fake session and real session have same id\");\n<line26>    zk.close();\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    qu.startQuorum();\n<line3>    CountdownWatcher watcher = new CountdownWatcher();\n<line4>    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line5>    watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line6>    watcher.reset();\n<line7>    qu.shutdown(2);\n<line8>    try {\n<line9>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line10>        fail(\"Should not be able to renew a global session\");\n<line11>    } catch (TimeoutException e) {\n<line12>    }\n<line13>    zk.close();\n<line14>    watcher.reset();\n<line15>    zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line16>    try {\n<line17>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line18>        fail(\"Should not be able to create a global session\");\n<line19>    } catch (TimeoutException e) {\n<line20>    }\n<line21>    zk.close();\n<line22>    qu.getPeer(1).peer.enableLocalSessions(true);\n<line23>    zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line24>    try {\n<line25>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line26>    } catch (TimeoutException e) {\n<line27>        fail(\"Should be able to create a local session\");\n<line28>    }\n<line29>    zk.close();\n<line30>}","output":"<line1>{\n<line2>    qu.startQuorum();\n<line3>    CountdownWatcher watcher = new CountdownWatcher();\n<line4>    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line5>    watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line6>    LOG.info(\"global session created 0x{}\", Long.toHexString(zk.getSessionId()));\n<line7>    watcher.reset();\n<line8>    qu.shutdown(2);\n<line9>    try {\n<line10>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line11>        fail(\"Should not be able to renew a global session\");\n<line12>    } catch (TimeoutException e) {\n<line13>    }\n<line14>    zk.close();\n<line15>    watcher.reset();\n<line16>    zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line17>    try {\n<line18>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line19>        fail(\"Should not be able to create a global session\");\n<line20>    } catch (TimeoutException e) {\n<line21>    }\n<line22>    zk.close();\n<line23>    qu.getPeer(1).peer.enableLocalSessions(true);\n<line24>    zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);\n<line25>    try {\n<line26>        watcher.waitForConnected(CONNECTION_TIMEOUT);\n<line27>    } catch (TimeoutException e) {\n<line28>        fail(\"Should be able to create a local session\");\n<line29>    }\n<line30>    zk.close();\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    String hp = hostPort;\n<line3>    hostPort = hostPort + \"/chrootasynctest\";\n<line4>    super.setUp();\n<line5>    ZooKeeper zk = createClient(hp);\n<line6>    try {\n<line7>        zk.create(\"/chrootasynctest\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    } finally {\n<line9>        zk.close();\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    String hp = hostPort;\n<line3>    hostPort = hostPort + \"/chrootasynctest\";\n<line4>    super.setUp();\n<line5>    LOG.info(\"Creating client {}\", getTestName());\n<line6>    ZooKeeper zk = createClient(hp);\n<line7>    try {\n<line8>        zk.create(\"/chrootasynctest\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>    } finally {\n<line10>        zk.close();\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    peers = new HashMap<>(3);\n<line3>    /*\n<line4>         * Creates list of peers.\n<line5>         */\n<line6>    for (int i = 0; i < 3; i++) {\n<line7>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line8>    }\n<line9>    /*\n<line10>         * Creating peer.\n<line11>         */\n<line12>    try {\n<line13>        File tmpDir = ClientBase.createTmpDir();\n<line14>        QuorumPeer peer = new QuorumPeer(peers, tmpDir, tmpDir, PortAssignment.unique(), 3, 0, 1000, 2, 2, 2);\n<line15>        MockFLE mock = new MockFLE(peer);\n<line16>        mock.start();\n<line17>        /*\n<line18>             * Lower epoch must return false\n<line19>             */\n<line20>        assertFalse(mock.predicate(4L, 0L, 0L, 3L, 0L, 2L));\n<line21>        /*\n<line22>             * Later epoch\n<line23>             */\n<line24>        assertTrue(mock.predicate(0L, 0L, 1L, 1L, 0L, 0L));\n<line25>        /*\n<line26>             * Higher zxid\n<line27>             */\n<line28>        assertTrue(mock.predicate(0L, 1L, 0L, 1L, 0L, 0L));\n<line29>        /*\n<line30>             * Higher id\n<line31>             */\n<line32>        assertTrue(mock.predicate(1L, 1L, 0L, 0L, 1L, 0L));\n<line33>    } catch (IOException e) {\n<line34>        fail(\"Exception while creating quorum peer\");\n<line35>    }\n<line36>}","output":"<line1>{\n<line2>    peers = new HashMap<>(3);\n<line3>    /*\n<line4>         * Creates list of peers.\n<line5>         */\n<line6>    for (int i = 0; i < 3; i++) {\n<line7>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique()), new InetSocketAddress(\"127.0.0.1\", PortAssignment.unique())));\n<line8>    }\n<line9>    /*\n<line10>         * Creating peer.\n<line11>         */\n<line12>    try {\n<line13>        File tmpDir = ClientBase.createTmpDir();\n<line14>        QuorumPeer peer = new QuorumPeer(peers, tmpDir, tmpDir, PortAssignment.unique(), 3, 0, 1000, 2, 2, 2);\n<line15>        MockFLE mock = new MockFLE(peer);\n<line16>        mock.start();\n<line17>        /*\n<line18>             * Lower epoch must return false\n<line19>             */\n<line20>        assertFalse(mock.predicate(4L, 0L, 0L, 3L, 0L, 2L));\n<line21>        /*\n<line22>             * Later epoch\n<line23>             */\n<line24>        assertTrue(mock.predicate(0L, 0L, 1L, 1L, 0L, 0L));\n<line25>        /*\n<line26>             * Higher zxid\n<line27>             */\n<line28>        assertTrue(mock.predicate(0L, 1L, 0L, 1L, 0L, 0L));\n<line29>        /*\n<line30>             * Higher id\n<line31>             */\n<line32>        assertTrue(mock.predicate(1L, 1L, 0L, 0L, 1L, 0L));\n<line33>    } catch (IOException e) {\n<line34>        LOG.error(\"Exception while creating quorum peer\", e);\n<line35>        fail(\"Exception while creating quorum peer\");\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"Exception while creating quorum peer\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while creating quorum peer\", e);\n<line3>    fail(\"Exception while creating quorum peer\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] b = new byte[256];\n<line3>    try {\n<line4>        for (; current < count; current++) {\n<line5>            // Simulate a bit of network latency...\n<line6>            Thread.sleep(HAMMERTHREAD_LATENCY);\n<line7>            zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>        }\n<line9>    } catch (Throwable t) {\n<line10>    } finally {\n<line11>        try {\n<line12>            zk.close();\n<line13>        } catch (InterruptedException e) {\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    byte[] b = new byte[256];\n<line3>    try {\n<line4>        for (; current < count; current++) {\n<line5>            // Simulate a bit of network latency...\n<line6>            Thread.sleep(HAMMERTHREAD_LATENCY);\n<line7>            zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>        }\n<line9>    } catch (Throwable t) {\n<line10>        LOG.error(\"Client create operation failed\", t);\n<line11>    } finally {\n<line12>        try {\n<line13>            zk.close();\n<line14>        } catch (InterruptedException e) {\n<line15>            LOG.warn(\"Unexpected\", e);\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Client create operation failed\", t);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] b = new byte[256];\n<line3>    try {\n<line4>        for (; current < count; current++) {\n<line5>            ZooKeeper zk = parent.createClient();\n<line6>            try {\n<line7>                zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>            } finally {\n<line9>                try {\n<line10>                    zk.close();\n<line11>                } catch (InterruptedException e) {\n<line12>                }\n<line13>            }\n<line14>        }\n<line15>    } catch (Throwable t) {\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    byte[] b = new byte[256];\n<line3>    try {\n<line4>        for (; current < count; current++) {\n<line5>            ZooKeeper zk = parent.createClient();\n<line6>            try {\n<line7>                zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>            } finally {\n<line9>                try {\n<line10>                    zk.close();\n<line11>                } catch (InterruptedException e) {\n<line12>                    LOG.warn(\"Unexpected\", e);\n<line13>                }\n<line14>            }\n<line15>        }\n<line16>    } catch (Throwable t) {\n<line17>        LOG.error(\"Client create operation failed\", t);\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Client create operation failed\", t);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        HammerThread[] threads = new HammerThread[threadCount];\n<line4>        long start = Time.currentElapsedTime();\n<line5>        for (int i = 0; i < threads.length; i++) {\n<line6>            ZooKeeper zk = createClient();\n<line7>            String prefix = \"/test-\" + i;\n<line8>            zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>            prefix += \"/\";\n<line10>            HammerThread thread = new BasicHammerThread(\"BasicHammerThread-\" + i, zk, prefix, childCount);\n<line11>            thread.start();\n<line12>            threads[i] = thread;\n<line13>        }\n<line14>        verifyHammer(start, threads, childCount);\n<line15>    } catch (Throwable t) {\n<line16>        throw t;\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        HammerThread[] threads = new HammerThread[threadCount];\n<line4>        long start = Time.currentElapsedTime();\n<line5>        for (int i = 0; i < threads.length; i++) {\n<line6>            ZooKeeper zk = createClient();\n<line7>            String prefix = \"/test-\" + i;\n<line8>            zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>            prefix += \"/\";\n<line10>            HammerThread thread = new BasicHammerThread(\"BasicHammerThread-\" + i, zk, prefix, childCount);\n<line11>            thread.start();\n<line12>            threads[i] = thread;\n<line13>        }\n<line14>        verifyHammer(start, threads, childCount);\n<line15>    } catch (Throwable t) {\n<line16>        LOG.error(\"test failed\", t);\n<line17>        throw t;\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    throw t;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"test failed\", t);\n<line3>    throw t;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        final int threadCount = 5;\n<line4>        final int childCount = 10;\n<line5>        HammerThread[] threads = new HammerThread[threadCount];\n<line6>        long start = Time.currentElapsedTime();\n<line7>        for (int i = 0; i < threads.length; i++) {\n<line8>            String prefix = \"/test-\" + i;\n<line9>            {\n<line10>                ZooKeeper zk = createClient();\n<line11>                try {\n<line12>                    zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line13>                } finally {\n<line14>                    zk.close();\n<line15>                }\n<line16>            }\n<line17>            prefix += \"/\";\n<line18>            HammerThread thread = new SuperHammerThread(\"SuperHammerThread-\" + i, this, prefix, childCount);\n<line19>            thread.start();\n<line20>            threads[i] = thread;\n<line21>        }\n<line22>        verifyHammer(start, threads, childCount);\n<line23>    } catch (Throwable t) {\n<line24>        throw t;\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    try {\n<line3>        final int threadCount = 5;\n<line4>        final int childCount = 10;\n<line5>        HammerThread[] threads = new HammerThread[threadCount];\n<line6>        long start = Time.currentElapsedTime();\n<line7>        for (int i = 0; i < threads.length; i++) {\n<line8>            String prefix = \"/test-\" + i;\n<line9>            {\n<line10>                ZooKeeper zk = createClient();\n<line11>                try {\n<line12>                    zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line13>                } finally {\n<line14>                    zk.close();\n<line15>                }\n<line16>            }\n<line17>            prefix += \"/\";\n<line18>            HammerThread thread = new SuperHammerThread(\"SuperHammerThread-\" + i, this, prefix, childCount);\n<line19>            thread.start();\n<line20>            threads[i] = thread;\n<line21>        }\n<line22>        verifyHammer(start, threads, childCount);\n<line23>    } catch (Throwable t) {\n<line24>        LOG.error(\"test failed\", t);\n<line25>        throw t;\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    throw t;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"test failed\", t);\n<line3>    throw t;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // look for the clients to finish their create operations\n<line3>    int workingCount = threads.length;\n<line4>    for (int i = 0; i < 120; i++) {\n<line5>        Thread.sleep(10000);\n<line6>        for (HammerThread h : threads) {\n<line7>            if (!h.isAlive() || h.current == h.count) {\n<line8>                workingCount--;\n<line9>            }\n<line10>        }\n<line11>        if (workingCount == 0) {\n<line12>            break;\n<line13>        }\n<line14>        workingCount = threads.length;\n<line15>    }\n<line16>    if (workingCount > 0) {\n<line17>        for (HammerThread h : threads) {\n<line18>        }\n<line19>    } else {\n<line20>    }\n<line21>    for (HammerThread h : threads) {\n<line22>        final int safetyFactor = 3;\n<line23>        verifyThreadTerminated(h, (long) threads.length * (long) childCount * HAMMERTHREAD_LATENCY * (long) safetyFactor);\n<line24>    }\n<line25>    ZooKeeper zk = createClient();\n<line26>    try {\n<line27>        for (int i = 0; i < threads.length; i++) {\n<line28>            List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line29>            assertEquals(childCount, children.size());\n<line30>            children = zk.getChildren(\"/test-\" + i, false, null);\n<line31>            assertEquals(childCount, children.size());\n<line32>        }\n<line33>        for (int i = 0; i < threads.length; i++) {\n<line34>            List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line35>            assertEquals(childCount, children.size());\n<line36>            children = zk.getChildren(\"/test-\" + i, false, null);\n<line37>            assertEquals(childCount, children.size());\n<line38>        }\n<line39>    } finally {\n<line40>        zk.close();\n<line41>    }\n<line42>}","output":"<line1>{\n<line2>    // look for the clients to finish their create operations\n<line3>    LOG.info(\"Starting check for completed hammers\");\n<line4>    int workingCount = threads.length;\n<line5>    for (int i = 0; i < 120; i++) {\n<line6>        Thread.sleep(10000);\n<line7>        for (HammerThread h : threads) {\n<line8>            if (!h.isAlive() || h.current == h.count) {\n<line9>                workingCount--;\n<line10>            }\n<line11>        }\n<line12>        if (workingCount == 0) {\n<line13>            break;\n<line14>        }\n<line15>        workingCount = threads.length;\n<line16>    }\n<line17>    if (workingCount > 0) {\n<line18>        for (HammerThread h : threads) {\n<line19>            LOG.warn(\"{} never finished creation, current:{}\", h.getName(), h.current);\n<line20>        }\n<line21>    } else {\n<line22>        LOG.info(\"Hammer threads completed creation operations\");\n<line23>    }\n<line24>    for (HammerThread h : threads) {\n<line25>        final int safetyFactor = 3;\n<line26>        verifyThreadTerminated(h, (long) threads.length * (long) childCount * HAMMERTHREAD_LATENCY * (long) safetyFactor);\n<line27>    }\n<line28>    LOG.info(\"{} Total time {}\", new Date(), (Time.currentElapsedTime() - start));\n<line29>    ZooKeeper zk = createClient();\n<line30>    try {\n<line31>        LOG.info(\"******************* Connected to ZooKeeper{}\", new Date());\n<line32>        for (int i = 0; i < threads.length; i++) {\n<line33>            LOG.info(\"Doing thread: {} {}\", i, new Date());\n<line34>            List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line35>            assertEquals(childCount, children.size());\n<line36>            children = zk.getChildren(\"/test-\" + i, false, null);\n<line37>            assertEquals(childCount, children.size());\n<line38>        }\n<line39>        for (int i = 0; i < threads.length; i++) {\n<line40>            List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line41>            assertEquals(childCount, children.size());\n<line42>            children = zk.getChildren(\"/test-\" + i, false, null);\n<line43>            assertEquals(childCount, children.size());\n<line44>        }\n<line45>    } finally {\n<line46>        zk.close();\n<line47>    }\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Hammer threads completed creation operations\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < threads.length; i++) {\n<line3>        List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line4>        assertEquals(childCount, children.size());\n<line5>        children = zk.getChildren(\"/test-\" + i, false, null);\n<line6>        assertEquals(childCount, children.size());\n<line7>    }\n<line8>    for (int i = 0; i < threads.length; i++) {\n<line9>        List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line10>        assertEquals(childCount, children.size());\n<line11>        children = zk.getChildren(\"/test-\" + i, false, null);\n<line12>        assertEquals(childCount, children.size());\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    LOG.info(\"******************* Connected to ZooKeeper{}\", new Date());\n<line3>    for (int i = 0; i < threads.length; i++) {\n<line4>        LOG.info(\"Doing thread: {} {}\", i, new Date());\n<line5>        List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line6>        assertEquals(childCount, children.size());\n<line7>        children = zk.getChildren(\"/test-\" + i, false, null);\n<line8>        assertEquals(childCount, children.size());\n<line9>    }\n<line10>    for (int i = 0; i < threads.length; i++) {\n<line11>        List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line12>        assertEquals(childCount, children.size());\n<line13>        children = zk.getChildren(\"/test-\" + i, false, null);\n<line14>        assertEquals(childCount, children.size());\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line3>    assertEquals(childCount, children.size());\n<line4>    children = zk.getChildren(\"/test-\" + i, false, null);\n<line5>    assertEquals(childCount, children.size());\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Doing thread: {} {}\", i, new Date());\n<line3>    List<String> children = zk.getChildren(\"/test-\" + i, false);\n<line4>    assertEquals(childCount, children.size());\n<line5>    children = zk.getChildren(\"/test-\" + i, false, null);\n<line6>    assertEquals(childCount, children.size());\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (useAsync) {\n<line3>        MyCallback c1 = new MyCallback(rc.intValue(), path);\n<line4>        zk.removeWatches(path, watcher, watcherType, local, c1, null);\n<line5>        assertTrue(c1.matches(), \"Didn't succeeds removeWatch operation\");\n<line6>        if (rc.intValue() != c1.rc) {\n<line7>            throw KeeperException.create(KeeperException.Code.get(c1.rc));\n<line8>        }\n<line9>    } else if (rc != Code.OK) {\n<line10>        try {\n<line11>            zk.removeWatches(path, watcher, watcherType, local);\n<line12>            fail(\"expect exception code \" + rc);\n<line13>        } catch (KeeperException ex) {\n<line14>            assertEquals(rc, ex.code());\n<line15>            assertEquals(path, ex.getPath());\n<line16>        }\n<line17>    } else {\n<line18>        zk.removeWatches(path, watcher, watcherType, local);\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    LOG.info(\"Sending removeWatches req using zk {} path: {} type: {} watcher: {} \", zk, path, watcherType, watcher);\n<line3>    if (useAsync) {\n<line4>        MyCallback c1 = new MyCallback(rc.intValue(), path);\n<line5>        zk.removeWatches(path, watcher, watcherType, local, c1, null);\n<line6>        assertTrue(c1.matches(), \"Didn't succeeds removeWatch operation\");\n<line7>        if (rc.intValue() != c1.rc) {\n<line8>            throw KeeperException.create(KeeperException.Code.get(c1.rc));\n<line9>        }\n<line10>    } else if (rc != Code.OK) {\n<line11>        try {\n<line12>            zk.removeWatches(path, watcher, watcherType, local);\n<line13>            fail(\"expect exception code \" + rc);\n<line14>        } catch (KeeperException ex) {\n<line15>            assertEquals(rc, ex.code());\n<line16>            assertEquals(path, ex.getPath());\n<line17>        }\n<line18>    } else {\n<line19>        zk.removeWatches(path, watcher, watcherType, local);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    if (useAsync) {\n<line3>        MyCallback c1 = new MyCallback(rc.intValue(), path);\n<line4>        zk.removeAllWatches(path, watcherType, local, c1, null);\n<line5>        assertTrue(c1.matches(), \"Didn't succeeds removeWatch operation\");\n<line6>        if (rc.intValue() != c1.rc) {\n<line7>            throw KeeperException.create(KeeperException.Code.get(c1.rc));\n<line8>        }\n<line9>    } else if (rc != Code.OK) {\n<line10>        try {\n<line11>            zk.removeAllWatches(path, watcherType, local);\n<line12>            fail(\"expect exception code \" + rc);\n<line13>        } catch (KeeperException ex) {\n<line14>            assertEquals(rc, ex.code());\n<line15>            assertEquals(path, ex.getPath());\n<line16>        }\n<line17>    } else {\n<line18>        zk.removeAllWatches(path, watcherType, local);\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    LOG.info(\"Sending removeWatches req using zk {} path: {} type: {} \", zk, path, watcherType);\n<line3>    if (useAsync) {\n<line4>        MyCallback c1 = new MyCallback(rc.intValue(), path);\n<line5>        zk.removeAllWatches(path, watcherType, local, c1, null);\n<line6>        assertTrue(c1.matches(), \"Didn't succeeds removeWatch operation\");\n<line7>        if (rc.intValue() != c1.rc) {\n<line8>            throw KeeperException.create(KeeperException.Code.get(c1.rc));\n<line9>        }\n<line10>    } else if (rc != Code.OK) {\n<line11>        try {\n<line12>            zk.removeAllWatches(path, watcherType, local);\n<line13>            fail(\"expect exception code \" + rc);\n<line14>        } catch (KeeperException ex) {\n<line15>            assertEquals(rc, ex.code());\n<line16>            assertEquals(path, ex.getPath());\n<line17>        }\n<line18>    } else {\n<line19>        zk.removeAllWatches(path, watcherType, local);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line3>    zk1.create(\"/node2\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line4>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    MyWatcher w2 = new MyWatcher(\"/node2\", 1);\n<line7>    assertNotNull(zk2.exists(\"/node2\", w2), \"Didn't set data watches\");\n<line8>    removeWatches(zk2, \"/node1\", w1, WatcherType.Data, false, Code.OK, useAsync);\n<line9>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line10>    assertEquals(\"/node2\", zk2.getDataWatches().get(0), \"Didn't find data watcher\");\n<line11>    removeWatches(zk2, \"/node2\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line12>    assertTrue(w2.matches(), \"Didn't remove data watcher\");\n<line13>    // closing session should remove ephemeral nodes and trigger data\n<line14>    // watches if any\n<line15>    if (zk1 != null) {\n<line16>        zk1.close();\n<line17>        zk1 = null;\n<line18>    }\n<line19>    List<EventType> events = w1.getEventsAfterWatchRemoval();\n<line20>    assertFalse(events.contains(EventType.NodeDeleted), \"Shouldn't get NodeDeletedEvent after watch removal\");\n<line21>    assertEquals(0, events.size(), \"Shouldn't get NodeDeletedEvent after watch removal\");\n<line22>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line3>    zk1.create(\"/node2\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line4>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    MyWatcher w2 = new MyWatcher(\"/node2\", 1);\n<line8>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line9>    assertNotNull(zk2.exists(\"/node2\", w2), \"Didn't set data watches\");\n<line10>    removeWatches(zk2, \"/node1\", w1, WatcherType.Data, false, Code.OK, useAsync);\n<line11>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line12>    assertEquals(\"/node2\", zk2.getDataWatches().get(0), \"Didn't find data watcher\");\n<line13>    removeWatches(zk2, \"/node2\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line14>    assertTrue(w2.matches(), \"Didn't remove data watcher\");\n<line15>    // closing session should remove ephemeral nodes and trigger data\n<line16>    // watches if any\n<line17>    if (zk1 != null) {\n<line18>        zk1.close();\n<line19>        zk1 = null;\n<line20>    }\n<line21>    List<EventType> events = w1.getEventsAfterWatchRemoval();\n<line22>    assertFalse(events.contains(EventType.NodeDeleted), \"Shouldn't get NodeDeletedEvent after watch removal\");\n<line23>    assertEquals(0, events.size(), \"Shouldn't get NodeDeletedEvent after watch removal\");\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line5>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line6>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line7>    removeWatches(zk2, \"/node1\", w2, WatcherType.Data, false, Code.OK, useAsync);\n<line8>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line9>    assertEquals(\"/node1\", zk2.getDataWatches().get(0), \"Didn't find data watcher\");\n<line10>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line11>    assertTrue(w2.matches(), \"Didn't remove data watcher\");\n<line12>    // closing session should remove ephemeral nodes and trigger data\n<line13>    // watches if any\n<line14>    if (zk1 != null) {\n<line15>        zk1.close();\n<line16>        zk1 = null;\n<line17>    }\n<line18>    List<EventType> events = w2.getEventsAfterWatchRemoval();\n<line19>    assertEquals(0, events.size(), \"Shouldn't get NodeDeletedEvent after watch removal\");\n<line20>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line7>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line8>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line9>    removeWatches(zk2, \"/node1\", w2, WatcherType.Data, false, Code.OK, useAsync);\n<line10>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line11>    assertEquals(\"/node1\", zk2.getDataWatches().get(0), \"Didn't find data watcher\");\n<line12>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line13>    assertTrue(w2.matches(), \"Didn't remove data watcher\");\n<line14>    // closing session should remove ephemeral nodes and trigger data\n<line15>    // watches if any\n<line16>    if (zk1 != null) {\n<line17>        zk1.close();\n<line18>        zk1 = null;\n<line19>    }\n<line20>    List<EventType> events = w2.getEventsAfterWatchRemoval();\n<line21>    assertEquals(0, events.size(), \"Shouldn't get NodeDeletedEvent after watch removal\");\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    zk2.getChildren(\"/node1\", w1);\n<line5>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line6>    zk2.getChildren(\"/node1\", w2);\n<line7>    removeWatches(zk2, \"/node1\", w2, WatcherType.Children, false, Code.OK, useAsync);\n<line8>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line9>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line10>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line11>    assertTrue(w1.matches(), \"Didn't remove child watcher\");\n<line12>    // create child to see NodeChildren notification\n<line13>    zk1.create(\"/node1/node2\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>    // waiting for child watchers to be notified\n<line15>    int count = 30;\n<line16>    while (count > 0) {\n<line17>        if (w1.getEventsAfterWatchRemoval().size() > 0) {\n<line18>            break;\n<line19>        }\n<line20>        count--;\n<line21>        Thread.sleep(100);\n<line22>    }\n<line23>    // watcher2\n<line24>    List<EventType> events = w2.getEventsAfterWatchRemoval();\n<line25>    assertEquals(0, events.size(), \"Shouldn't get NodeChildrenChanged event\");\n<line26>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line5>    zk2.getChildren(\"/node1\", w1);\n<line6>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line7>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line8>    zk2.getChildren(\"/node1\", w2);\n<line9>    removeWatches(zk2, \"/node1\", w2, WatcherType.Children, false, Code.OK, useAsync);\n<line10>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line11>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line12>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line13>    assertTrue(w1.matches(), \"Didn't remove child watcher\");\n<line14>    // create child to see NodeChildren notification\n<line15>    zk1.create(\"/node1/node2\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line16>    // waiting for child watchers to be notified\n<line17>    int count = 30;\n<line18>    while (count > 0) {\n<line19>        if (w1.getEventsAfterWatchRemoval().size() > 0) {\n<line20>            break;\n<line21>        }\n<line22>        count--;\n<line23>        Thread.sleep(100);\n<line24>    }\n<line25>    // watcher2\n<line26>    List<EventType> events = w2.getEventsAfterWatchRemoval();\n<line27>    assertEquals(0, events.size(), \"Shouldn't get NodeChildrenChanged event\");\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 2);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line7>    zk2.getChildren(\"/node1\", w1);\n<line8>    zk2.getChildren(\"/node1\", w2);\n<line9>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line10>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line11>    zk1.create(\"/node1/child\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line12>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line13>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line14>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 2);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line8>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line9>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line10>    zk2.getChildren(\"/node1\", w1);\n<line11>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line12>    zk2.getChildren(\"/node1\", w2);\n<line13>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line14>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line15>    zk1.create(\"/node1/child\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line16>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line17>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line7>    zk2.getChildren(\"/node1\", w1);\n<line8>    zk2.getChildren(\"/node1\", w2);\n<line9>    removeWatches(zk2, \"/node1\", w1, WatcherType.Data, false, Code.OK, useAsync);\n<line10>    removeWatches(zk2, \"/node1\", w2, WatcherType.Data, false, Code.OK, useAsync);\n<line11>    zk1.create(\"/node1/child\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line12>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line13>    assertTrue(w2.matches(), \"Didn't remove data watcher\");\n<line14>    // waiting for child watchers to be notified\n<line15>    int count = 10;\n<line16>    while (count > 0) {\n<line17>        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {\n<line18>            break;\n<line19>        }\n<line20>        count--;\n<line21>        Thread.sleep(1000);\n<line22>    }\n<line23>    // watcher1\n<line24>    List<EventType> events = w1.getEventsAfterWatchRemoval();\n<line25>    assertEquals(1, events.size(), \"Didn't get NodeChildrenChanged event\");\n<line26>    assertTrue(events.contains(EventType.NodeChildrenChanged), \"Didn't get NodeChildrenChanged event\");\n<line27>    // watcher2\n<line28>    events = w2.getEventsAfterWatchRemoval();\n<line29>    assertEquals(1, events.size(), \"Didn't get NodeChildrenChanged event\");\n<line30>    assertTrue(events.contains(EventType.NodeChildrenChanged), \"Didn't get NodeChildrenChanged event\");\n<line31>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line8>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line9>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line10>    zk2.getChildren(\"/node1\", w1);\n<line11>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line12>    zk2.getChildren(\"/node1\", w2);\n<line13>    removeWatches(zk2, \"/node1\", w1, WatcherType.Data, false, Code.OK, useAsync);\n<line14>    removeWatches(zk2, \"/node1\", w2, WatcherType.Data, false, Code.OK, useAsync);\n<line15>    zk1.create(\"/node1/child\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line16>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line17>    assertTrue(w2.matches(), \"Didn't remove data watcher\");\n<line18>    // waiting for child watchers to be notified\n<line19>    int count = 10;\n<line20>    while (count > 0) {\n<line21>        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {\n<line22>            break;\n<line23>        }\n<line24>        count--;\n<line25>        Thread.sleep(1000);\n<line26>    }\n<line27>    // watcher1\n<line28>    List<EventType> events = w1.getEventsAfterWatchRemoval();\n<line29>    assertEquals(1, events.size(), \"Didn't get NodeChildrenChanged event\");\n<line30>    assertTrue(events.contains(EventType.NodeChildrenChanged), \"Didn't get NodeChildrenChanged event\");\n<line31>    // watcher2\n<line32>    events = w2.getEventsAfterWatchRemoval();\n<line33>    assertEquals(1, events.size(), \"Didn't get NodeChildrenChanged event\");\n<line34>    assertTrue(events.contains(EventType.NodeChildrenChanged), \"Didn't get NodeChildrenChanged event\");\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line7>    zk2.getChildren(\"/node1\", w1);\n<line8>    zk2.getChildren(\"/node1\", w2);\n<line9>    removeWatches(zk2, \"/node1\", w1, WatcherType.Children, false, Code.OK, useAsync);\n<line10>    removeWatches(zk2, \"/node1\", w2, WatcherType.Children, false, Code.OK, useAsync);\n<line11>    zk1.setData(\"/node1\", \"test\".getBytes(), -1);\n<line12>    assertTrue(w1.matches(), \"Didn't remove child watcher\");\n<line13>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line14>    // waiting for child watchers to be notified\n<line15>    int count = 10;\n<line16>    while (count > 0) {\n<line17>        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {\n<line18>            break;\n<line19>        }\n<line20>        count--;\n<line21>        Thread.sleep(1000);\n<line22>    }\n<line23>    // watcher1\n<line24>    List<EventType> events = w1.getEventsAfterWatchRemoval();\n<line25>    assertEquals(1, events.size(), \"Didn't get NodeDataChanged event\");\n<line26>    assertTrue(events.contains(EventType.NodeDataChanged), \"Didn't get NodeDataChanged event\");\n<line27>    // watcher2\n<line28>    events = w2.getEventsAfterWatchRemoval();\n<line29>    assertEquals(1, events.size(), \"Didn't get NodeDataChanged event\");\n<line30>    assertTrue(events.contains(EventType.NodeDataChanged), \"Didn't get NodeDataChanged event\");\n<line31>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line8>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line9>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line10>    zk2.getChildren(\"/node1\", w1);\n<line11>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line12>    zk2.getChildren(\"/node1\", w2);\n<line13>    removeWatches(zk2, \"/node1\", w1, WatcherType.Children, false, Code.OK, useAsync);\n<line14>    removeWatches(zk2, \"/node1\", w2, WatcherType.Children, false, Code.OK, useAsync);\n<line15>    zk1.setData(\"/node1\", \"test\".getBytes(), -1);\n<line16>    assertTrue(w1.matches(), \"Didn't remove child watcher\");\n<line17>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line18>    // waiting for child watchers to be notified\n<line19>    int count = 10;\n<line20>    while (count > 0) {\n<line21>        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {\n<line22>            break;\n<line23>        }\n<line24>        count--;\n<line25>        Thread.sleep(1000);\n<line26>    }\n<line27>    // watcher1\n<line28>    List<EventType> events = w1.getEventsAfterWatchRemoval();\n<line29>    assertEquals(1, events.size(), \"Didn't get NodeDataChanged event\");\n<line30>    assertTrue(events.contains(EventType.NodeDataChanged), \"Didn't get NodeDataChanged event\");\n<line31>    // watcher2\n<line32>    events = w2.getEventsAfterWatchRemoval();\n<line33>    assertEquals(1, events.size(), \"Didn't get NodeDataChanged event\");\n<line34>    assertTrue(events.contains(EventType.NodeDataChanged), \"Didn't get NodeDataChanged event\");\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 2);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    assertNull(zk2.exists(\"/node2\", w2), \"Didn't set data watches\");\n<line7>    zk2.getChildren(\"/node1\", w1);\n<line8>    zk2.getChildren(\"/node1\", w2);\n<line9>    // New Watcher which will be used for removal\n<line10>    MyWatcher w3 = new MyWatcher(\"/node1\", 2);\n<line11>    removeWatches(zk2, \"/node1\", w3, WatcherType.Any, false, Code.NOWATCHER, useAsync);\n<line12>    removeWatches(zk2, \"/node1\", w3, WatcherType.Children, false, Code.NOWATCHER, useAsync);\n<line13>    removeWatches(zk2, \"/node1\", w3, WatcherType.Data, false, Code.NOWATCHER, useAsync);\n<line14>    removeWatches(zk2, \"/nonexists\", w3, WatcherType.Data, false, Code.NOWATCHER, useAsync);\n<line15>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 2);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line8>    assertNull(zk2.exists(\"/node2\", w2), \"Didn't set data watches\");\n<line9>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line10>    zk2.getChildren(\"/node1\", w1);\n<line11>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line12>    zk2.getChildren(\"/node1\", w2);\n<line13>    // New Watcher which will be used for removal\n<line14>    MyWatcher w3 = new MyWatcher(\"/node1\", 2);\n<line15>    removeWatches(zk2, \"/node1\", w3, WatcherType.Any, false, Code.NOWATCHER, useAsync);\n<line16>    removeWatches(zk2, \"/node1\", w3, WatcherType.Children, false, Code.NOWATCHER, useAsync);\n<line17>    removeWatches(zk2, \"/node1\", w3, WatcherType.Data, false, Code.NOWATCHER, useAsync);\n<line18>    removeWatches(zk2, \"/nonexists\", w3, WatcherType.Data, false, Code.NOWATCHER, useAsync);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 2);\n<line5>    // Add multiple data watches\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line8>    // Add child watch\n<line9>    zk2.getChildren(\"/node1\", w2);\n<line10>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line11>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line12>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line13>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line14>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line15>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line16>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 1);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 2);\n<line5>    // Add multiple data watches\n<line6>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line7>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line8>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line9>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line10>    // Add child watch\n<line11>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line12>    zk2.getChildren(\"/node1\", w2);\n<line13>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line14>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line15>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line16>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line17>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line18>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    // Add multiple child watches\n<line7>    zk2.getChildren(\"/node1\", w2);\n<line8>    zk2.getChildren(\"/node1\", w1);\n<line9>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line10>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line11>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line12>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line13>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line14>    assertTrue(w1.matches(), \"Didn't remove watchers\");\n<line15>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    // Add multiple child watches\n<line8>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line9>    zk2.getChildren(\"/node1\", w2);\n<line10>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line11>    zk2.getChildren(\"/node1\", w1);\n<line12>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line13>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line14>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line15>    assertEquals(1, zk2.getDataWatches().size(), \"Didn't find data watcher\");\n<line16>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line17>    assertTrue(w1.matches(), \"Didn't remove watchers\");\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line6>    // Add multiple child watches\n<line7>    zk2.getChildren(\"/node1\", w1);\n<line8>    zk2.getChildren(\"/node1\", w2);\n<line9>    stopServer();\n<line10>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, true, Code.OK, useAsync);\n<line11>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line12>    assertFalse(w1.matches(), \"Shouldn't remove data watcher\");\n<line13>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.CONNECTIONLOSS, useAsync);\n<line14>    assertFalse(w1.matches(), \"Shouldn't remove data watcher\");\n<line15>    // when local=true, here if connection not available, simply removes\n<line16>    // from local session\n<line17>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, true, Code.OK, useAsync);\n<line18>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line19>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line4>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line5>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line6>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line7>    // Add multiple child watches\n<line8>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line9>    zk2.getChildren(\"/node1\", w1);\n<line10>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line11>    zk2.getChildren(\"/node1\", w2);\n<line12>    stopServer();\n<line13>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, true, Code.OK, useAsync);\n<line14>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line15>    assertFalse(w1.matches(), \"Shouldn't remove data watcher\");\n<line16>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.CONNECTIONLOSS, useAsync);\n<line17>    assertFalse(w1.matches(), \"Shouldn't remove data watcher\");\n<line18>    // when local=true, here if connection not available, simply removes\n<line19>    // from local session\n<line20>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, true, Code.OK, useAsync);\n<line21>    assertTrue(w1.matches(), \"Didn't remove data watcher\");\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    int count = 50;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Exists watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        final String nodePath = path + i;\n<line9>        w = new MyWatcher(nodePath, 1);\n<line10>        wList.add(w);\n<line11>        zk1.exists(nodePath, w);\n<line12>    }\n<line13>    assertEquals(count, zk1.getExistWatches().size(), \"Failed to add watchers!\");\n<line14>    for (int i = 0; i < count; i++) {\n<line15>        final MyWatcher watcher = wList.get(i);\n<line16>        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK, useAsync);\n<line17>        assertTrue(watcher.matches(), \"Didn't remove data watcher\");\n<line18>    }\n<line19>    assertEquals(0, zk1.getExistWatches().size(), \"Didn't remove watch references!\");\n<line20>}","output":"<line1>{\n<line2>    int count = 50;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Exists watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        final String nodePath = path + i;\n<line9>        w = new MyWatcher(nodePath, 1);\n<line10>        wList.add(w);\n<line11>        LOG.info(\"Adding pre node watcher {} on path {}\", w, nodePath);\n<line12>        zk1.exists(nodePath, w);\n<line13>    }\n<line14>    assertEquals(count, zk1.getExistWatches().size(), \"Failed to add watchers!\");\n<line15>    for (int i = 0; i < count; i++) {\n<line16>        final MyWatcher watcher = wList.get(i);\n<line17>        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK, useAsync);\n<line18>        assertTrue(watcher.matches(), \"Didn't remove data watcher\");\n<line19>    }\n<line20>    assertEquals(0, zk1.getExistWatches().size(), \"Didn't remove watch references!\");\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    final String nodePath = path + i;\n<line3>    w = new MyWatcher(nodePath, 1);\n<line4>    wList.add(w);\n<line5>    zk1.exists(nodePath, w);\n<line6>}","output":"<line1>{\n<line2>    final String nodePath = path + i;\n<line3>    w = new MyWatcher(nodePath, 1);\n<line4>    wList.add(w);\n<line5>    LOG.info(\"Adding pre node watcher {} on path {}\", w, nodePath);\n<line6>    zk1.exists(nodePath, w);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    int count = 50;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Child watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        String nodePath = path + i;\n<line9>        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>        nodePath += \"/\";\n<line11>    }\n<line12>    for (int i = 0; i < count; i++) {\n<line13>        String nodePath = path + i;\n<line14>        w = new MyWatcher(path + i, 1);\n<line15>        wList.add(w);\n<line16>        zk1.getChildren(nodePath, w);\n<line17>        nodePath += \"/\";\n<line18>    }\n<line19>    assertEquals(count, zk1.getChildWatches().size(), \"Failed to add watchers!\");\n<line20>    for (int i = 0; i < count; i++) {\n<line21>        final MyWatcher watcher = wList.get(i);\n<line22>        removeWatches(zk1, path + i, watcher, WatcherType.Children, false, Code.OK, useAsync);\n<line23>        assertTrue(watcher.matches(), \"Didn't remove child watcher\");\n<line24>    }\n<line25>    assertEquals(0, zk1.getChildWatches().size(), \"Didn't remove watch references!\");\n<line26>}","output":"<line1>{\n<line2>    int count = 50;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Child watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        String nodePath = path + i;\n<line9>        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>        nodePath += \"/\";\n<line11>    }\n<line12>    for (int i = 0; i < count; i++) {\n<line13>        String nodePath = path + i;\n<line14>        w = new MyWatcher(path + i, 1);\n<line15>        wList.add(w);\n<line16>        LOG.info(\"Adding child watcher {} on path {}\", w, nodePath);\n<line17>        zk1.getChildren(nodePath, w);\n<line18>        nodePath += \"/\";\n<line19>    }\n<line20>    assertEquals(count, zk1.getChildWatches().size(), \"Failed to add watchers!\");\n<line21>    for (int i = 0; i < count; i++) {\n<line22>        final MyWatcher watcher = wList.get(i);\n<line23>        removeWatches(zk1, path + i, watcher, WatcherType.Children, false, Code.OK, useAsync);\n<line24>        assertTrue(watcher.matches(), \"Didn't remove child watcher\");\n<line25>    }\n<line26>    assertEquals(0, zk1.getChildWatches().size(), \"Didn't remove watch references!\");\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = new MyWatcher(path + i, 1);\n<line4>    wList.add(w);\n<line5>    zk1.getChildren(nodePath, w);\n<line6>    nodePath += \"/\";\n<line7>}","output":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = new MyWatcher(path + i, 1);\n<line4>    wList.add(w);\n<line5>    LOG.info(\"Adding child watcher {} on path {}\", w, nodePath);\n<line6>    zk1.getChildren(nodePath, w);\n<line7>    nodePath += \"/\";\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    int count = 50;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Data watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        String nodePath = path + i;\n<line9>        w = new MyWatcher(path + i, 1);\n<line10>        wList.add(w);\n<line11>        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line12>        zk1.getData(nodePath, w, null);\n<line13>        nodePath += \"/\";\n<line14>    }\n<line15>    assertEquals(count, zk1.getDataWatches().size(), \"Failed to add watchers!\");\n<line16>    for (int i = 0; i < count; i++) {\n<line17>        final MyWatcher watcher = wList.get(i);\n<line18>        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK, useAsync);\n<line19>        assertTrue(watcher.matches(), \"Didn't remove data watcher\");\n<line20>    }\n<line21>    assertEquals(0, zk1.getDataWatches().size(), \"Didn't remove watch references!\");\n<line22>}","output":"<line1>{\n<line2>    int count = 50;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Data watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        String nodePath = path + i;\n<line9>        w = new MyWatcher(path + i, 1);\n<line10>        wList.add(w);\n<line11>        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line12>        LOG.info(\"Adding data watcher {} on path {}\", w, nodePath);\n<line13>        zk1.getData(nodePath, w, null);\n<line14>        nodePath += \"/\";\n<line15>    }\n<line16>    assertEquals(count, zk1.getDataWatches().size(), \"Failed to add watchers!\");\n<line17>    for (int i = 0; i < count; i++) {\n<line18>        final MyWatcher watcher = wList.get(i);\n<line19>        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK, useAsync);\n<line20>        assertTrue(watcher.matches(), \"Didn't remove data watcher\");\n<line21>    }\n<line22>    assertEquals(0, zk1.getDataWatches().size(), \"Didn't remove watch references!\");\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = new MyWatcher(path + i, 1);\n<line4>    wList.add(w);\n<line5>    zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    zk1.getData(nodePath, w, null);\n<line7>    nodePath += \"/\";\n<line8>}","output":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = new MyWatcher(path + i, 1);\n<line4>    wList.add(w);\n<line5>    zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    LOG.info(\"Adding data watcher {} on path {}\", w, nodePath);\n<line7>    zk1.getData(nodePath, w, null);\n<line8>    nodePath += \"/\";\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    int count = 3;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Child watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        String nodePath = path + i;\n<line9>        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>        nodePath += \"/\";\n<line11>    }\n<line12>    for (int i = 0; i < count; i++) {\n<line13>        String nodePath = path + i;\n<line14>        w = new MyWatcher(path + i, 2);\n<line15>        wList.add(w);\n<line16>        zk1.getChildren(nodePath, w);\n<line17>        nodePath += \"/\";\n<line18>    }\n<line19>    assertEquals(count, zk1.getChildWatches().size(), \"Failed to add watchers!\");\n<line20>    // Data watcher\n<line21>    for (int i = 0; i < count; i++) {\n<line22>        String nodePath = path + i;\n<line23>        w = wList.get(i);\n<line24>        zk1.getData(nodePath, w, null);\n<line25>        nodePath += \"/\";\n<line26>    }\n<line27>    assertEquals(count, zk1.getDataWatches().size(), \"Failed to add watchers!\");\n<line28>    stopServer();\n<line29>    for (int i = 0; i < count; i++) {\n<line30>        final MyWatcher watcher = wList.get(i);\n<line31>        removeWatches(zk1, path + i, watcher, WatcherType.Any, true, Code.OK, useAsync);\n<line32>        assertTrue(watcher.matches(), \"Didn't remove watcher\");\n<line33>    }\n<line34>    assertEquals(0, zk1.getChildWatches().size(), \"Didn't remove watch references!\");\n<line35>    assertEquals(0, zk1.getDataWatches().size(), \"Didn't remove watch references!\");\n<line36>}","output":"<line1>{\n<line2>    int count = 3;\n<line3>    List<MyWatcher> wList = new ArrayList<>(count);\n<line4>    MyWatcher w;\n<line5>    String path = \"/node\";\n<line6>    // Child watcher\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        String nodePath = path + i;\n<line9>        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>        nodePath += \"/\";\n<line11>    }\n<line12>    for (int i = 0; i < count; i++) {\n<line13>        String nodePath = path + i;\n<line14>        w = new MyWatcher(path + i, 2);\n<line15>        wList.add(w);\n<line16>        LOG.info(\"Adding child watcher {} on path {}\", w, nodePath);\n<line17>        zk1.getChildren(nodePath, w);\n<line18>        nodePath += \"/\";\n<line19>    }\n<line20>    assertEquals(count, zk1.getChildWatches().size(), \"Failed to add watchers!\");\n<line21>    // Data watcher\n<line22>    for (int i = 0; i < count; i++) {\n<line23>        String nodePath = path + i;\n<line24>        w = wList.get(i);\n<line25>        LOG.info(\"Adding data watcher {} on path {}\", w, nodePath);\n<line26>        zk1.getData(nodePath, w, null);\n<line27>        nodePath += \"/\";\n<line28>    }\n<line29>    assertEquals(count, zk1.getDataWatches().size(), \"Failed to add watchers!\");\n<line30>    stopServer();\n<line31>    for (int i = 0; i < count; i++) {\n<line32>        final MyWatcher watcher = wList.get(i);\n<line33>        removeWatches(zk1, path + i, watcher, WatcherType.Any, true, Code.OK, useAsync);\n<line34>        assertTrue(watcher.matches(), \"Didn't remove watcher\");\n<line35>    }\n<line36>    assertEquals(0, zk1.getChildWatches().size(), \"Didn't remove watch references!\");\n<line37>    assertEquals(0, zk1.getDataWatches().size(), \"Didn't remove watch references!\");\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = new MyWatcher(path + i, 2);\n<line4>    wList.add(w);\n<line5>    zk1.getChildren(nodePath, w);\n<line6>    nodePath += \"/\";\n<line7>}","output":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = new MyWatcher(path + i, 2);\n<line4>    wList.add(w);\n<line5>    LOG.info(\"Adding child watcher {} on path {}\", w, nodePath);\n<line6>    zk1.getChildren(nodePath, w);\n<line7>    nodePath += \"/\";\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = wList.get(i);\n<line4>    zk1.getData(nodePath, w, null);\n<line5>    nodePath += \"/\";\n<line6>}","output":"<line1>{\n<line2>    String nodePath = path + i;\n<line3>    w = wList.get(i);\n<line4>    LOG.info(\"Adding data watcher {} on path {}\", w, nodePath);\n<line5>    zk1.getData(nodePath, w, null);\n<line6>    nodePath += \"/\";\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    // creating the subtree for chRoot clients.\n<line3>    String chRoot = \"/appsX\";\n<line4>    zk1.create(\"/appsX\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    if (zk1 != null) {\n<line6>        zk1.close();\n<line7>    }\n<line8>    if (zk2 != null) {\n<line9>        zk2.close();\n<line10>    }\n<line11>    // Creating chRoot client.\n<line12>    zk1 = createClient(this.hostPort + chRoot);\n<line13>    zk2 = createClient(this.hostPort + chRoot);\n<line14>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line16>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line17>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line18>    // Add multiple child watches\n<line19>    zk2.getChildren(\"/node1\", w2);\n<line20>    zk2.getChildren(\"/node1\", w1);\n<line21>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line22>    assertTrue(w1.matches(), \"Didn't remove child watcher\");\n<line23>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line24>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line25>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line26>}","output":"<line1>{\n<line2>    // creating the subtree for chRoot clients.\n<line3>    String chRoot = \"/appsX\";\n<line4>    zk1.create(\"/appsX\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line5>    if (zk1 != null) {\n<line6>        zk1.close();\n<line7>    }\n<line8>    if (zk2 != null) {\n<line9>        zk2.close();\n<line10>    }\n<line11>    // Creating chRoot client.\n<line12>    zk1 = createClient(this.hostPort + chRoot);\n<line13>    zk2 = createClient(this.hostPort + chRoot);\n<line14>    LOG.info(\"Creating child znode /node1 using chRoot client\");\n<line15>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line16>    MyWatcher w1 = new MyWatcher(\"/node1\", 2);\n<line17>    MyWatcher w2 = new MyWatcher(\"/node1\", 1);\n<line18>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line19>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line20>    // Add multiple child watches\n<line21>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line22>    zk2.getChildren(\"/node1\", w2);\n<line23>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line24>    zk2.getChildren(\"/node1\", w1);\n<line25>    removeWatches(zk2, \"/node1\", w1, WatcherType.Any, false, Code.OK, useAsync);\n<line26>    assertTrue(w1.matches(), \"Didn't remove child watcher\");\n<line27>    assertEquals(1, zk2.getChildWatches().size(), \"Didn't find child watcher\");\n<line28>    removeWatches(zk2, \"/node1\", w2, WatcherType.Any, false, Code.OK, useAsync);\n<line29>    assertTrue(w2.matches(), \"Didn't remove child watcher\");\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    final CountDownLatch dataWatchCount = new CountDownLatch(1);\n<line4>    final CountDownLatch rmWatchCount = new CountDownLatch(1);\n<line5>    Watcher w1 = event -> {\n<line6>        if (event.getType() == EventType.DataWatchRemoved) {\n<line7>            rmWatchCount.countDown();\n<line8>        }\n<line9>    };\n<line10>    Watcher w2 = event -> {\n<line11>        if (event.getType() == EventType.NodeDataChanged) {\n<line12>            dataWatchCount.countDown();\n<line13>        }\n<line14>    };\n<line15>    // Add multiple data watches\n<line16>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line17>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line18>    removeWatches(zk2, \"/node1\", w1, WatcherType.Data, false, Code.OK, useAsync);\n<line19>    assertTrue(rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't remove data watcher\");\n<line20>    zk1.setData(\"/node1\", \"test\".getBytes(), -1);\n<line21>    assertTrue(dataWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't get data watch notification!\");\n<line22>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    final CountDownLatch dataWatchCount = new CountDownLatch(1);\n<line4>    final CountDownLatch rmWatchCount = new CountDownLatch(1);\n<line5>    Watcher w1 = event -> {\n<line6>        if (event.getType() == EventType.DataWatchRemoved) {\n<line7>            rmWatchCount.countDown();\n<line8>        }\n<line9>    };\n<line10>    Watcher w2 = event -> {\n<line11>        if (event.getType() == EventType.NodeDataChanged) {\n<line12>            dataWatchCount.countDown();\n<line13>        }\n<line14>    };\n<line15>    // Add multiple data watches\n<line16>    LOG.info(\"Adding data watcher {} on path {}\", w1, \"/node1\");\n<line17>    assertNotNull(zk2.exists(\"/node1\", w1), \"Didn't set data watches\");\n<line18>    LOG.info(\"Adding data watcher {} on path {}\", w2, \"/node1\");\n<line19>    assertNotNull(zk2.exists(\"/node1\", w2), \"Didn't set data watches\");\n<line20>    removeWatches(zk2, \"/node1\", w1, WatcherType.Data, false, Code.OK, useAsync);\n<line21>    assertTrue(rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't remove data watcher\");\n<line22>    zk1.setData(\"/node1\", \"test\".getBytes(), -1);\n<line23>    LOG.info(\"Waiting for data watchers to be notified\");\n<line24>    assertTrue(dataWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't get data watch notification!\");\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    final CountDownLatch childWatchCount = new CountDownLatch(1);\n<line4>    final CountDownLatch rmWatchCount = new CountDownLatch(1);\n<line5>    Watcher w1 = event -> {\n<line6>        if (event.getType() == EventType.ChildWatchRemoved) {\n<line7>            rmWatchCount.countDown();\n<line8>        }\n<line9>    };\n<line10>    Watcher w2 = event -> {\n<line11>        if (event.getType() == EventType.NodeChildrenChanged) {\n<line12>            childWatchCount.countDown();\n<line13>        }\n<line14>    };\n<line15>    // Add multiple child watches\n<line16>    assertEquals(0, zk2.getChildren(\"/node1\", w1).size(), \"Didn't set child watches\");\n<line17>    assertEquals(0, zk2.getChildren(\"/node1\", w2).size(), \"Didn't set child watches\");\n<line18>    removeWatches(zk2, \"/node1\", w1, WatcherType.Children, false, Code.OK, useAsync);\n<line19>    assertTrue(rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't remove child watcher\");\n<line20>    zk1.create(\"/node1/node2\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line21>    assertTrue(childWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't get child watch notification!\");\n<line22>}","output":"<line1>{\n<line2>    zk1.create(\"/node1\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    final CountDownLatch childWatchCount = new CountDownLatch(1);\n<line4>    final CountDownLatch rmWatchCount = new CountDownLatch(1);\n<line5>    Watcher w1 = event -> {\n<line6>        if (event.getType() == EventType.ChildWatchRemoved) {\n<line7>            rmWatchCount.countDown();\n<line8>        }\n<line9>    };\n<line10>    Watcher w2 = event -> {\n<line11>        if (event.getType() == EventType.NodeChildrenChanged) {\n<line12>            childWatchCount.countDown();\n<line13>        }\n<line14>    };\n<line15>    // Add multiple child watches\n<line16>    LOG.info(\"Adding child watcher {} on path {}\", w1, \"/node1\");\n<line17>    assertEquals(0, zk2.getChildren(\"/node1\", w1).size(), \"Didn't set child watches\");\n<line18>    LOG.info(\"Adding child watcher {} on path {}\", w2, \"/node1\");\n<line19>    assertEquals(0, zk2.getChildren(\"/node1\", w2).size(), \"Didn't set child watches\");\n<line20>    removeWatches(zk2, \"/node1\", w1, WatcherType.Children, false, Code.OK, useAsync);\n<line21>    assertTrue(rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't remove child watcher\");\n<line22>    zk1.create(\"/node1/node2\", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line23>    LOG.info(\"Waiting for child watchers to be notified\");\n<line24>    assertTrue(childWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS), \"Didn't get child watch notification!\");\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    this.eventPath = event.getPath();\n<line3>    // notifies watcher removal\n<line4>    if (latch.getCount() == 0) {\n<line5>        if (event.getType() != EventType.None) {\n<line6>            eventsAfterWatchRemoval.add(event.getType());\n<line7>        }\n<line8>    }\n<line9>    if (event.getType() == EventType.ChildWatchRemoved || event.getType() == EventType.DataWatchRemoved) {\n<line10>        latch.countDown();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.debug(\"Event path : {}, eventPath : {}\", path, event.getPath());\n<line3>    this.eventPath = event.getPath();\n<line4>    // notifies watcher removal\n<line5>    if (latch.getCount() == 0) {\n<line6>        if (event.getType() != EventType.None) {\n<line7>            eventsAfterWatchRemoval.add(event.getType());\n<line8>        }\n<line9>    }\n<line10>    if (event.getType() == EventType.ChildWatchRemoved || event.getType() == EventType.DataWatchRemoved) {\n<line11>        latch.countDown();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {\n<line3>        return false;\n<line4>    }\n<line5>    return path.equals(eventPath);\n<line6>}","output":"<line1>{\n<line2>    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {\n<line3>        LOG.error(\"Failed waiting to remove the watches\");\n<line4>        return false;\n<line5>    }\n<line6>    LOG.debug(\"Client path : {} eventPath : {}\", path, eventPath);\n<line7>    return path.equals(eventPath);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed waiting to remove the watches\");\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return event -> {\n<line3>        Event.EventType type = event.getType();\n<line4>        if (type == Event.EventType.None) {\n<line5>            Event.KeeperState state = event.getState();\n<line6>            if (state == Event.KeeperState.SyncConnected) {\n<line7>                countDownLatch.countDown();\n<line8>            } else if (state == Event.KeeperState.Expired) {\n<line9>            } else if (state == Event.KeeperState.Disconnected) {\n<line10>            } else if (state == Event.KeeperState.AuthFailed) {\n<line11>            }\n<line12>        }\n<line13>    };\n<line14>}","output":"<line1>{\n<line2>    return event -> {\n<line3>        Event.EventType type = event.getType();\n<line4>        if (type == Event.EventType.None) {\n<line5>            Event.KeeperState state = event.getState();\n<line6>            if (state == Event.KeeperState.SyncConnected) {\n<line7>                LOG.info(\"Event.KeeperState.SyncConnected\");\n<line8>                countDownLatch.countDown();\n<line9>            } else if (state == Event.KeeperState.Expired) {\n<line10>                LOG.info(\"Event.KeeperState.Expired\");\n<line11>            } else if (state == Event.KeeperState.Disconnected) {\n<line12>                LOG.info(\"Event.KeeperState.Disconnected\");\n<line13>            } else if (state == Event.KeeperState.AuthFailed) {\n<line14>                LOG.info(\"Event.KeeperState.AuthFailed\");\n<line15>            }\n<line16>        }\n<line17>    };\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    Event.EventType type = event.getType();\n<line3>    if (type == Event.EventType.None) {\n<line4>        Event.KeeperState state = event.getState();\n<line5>        if (state == Event.KeeperState.SyncConnected) {\n<line6>            countDownLatch.countDown();\n<line7>        } else if (state == Event.KeeperState.Expired) {\n<line8>        } else if (state == Event.KeeperState.Disconnected) {\n<line9>        } else if (state == Event.KeeperState.AuthFailed) {\n<line10>        }\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    Event.EventType type = event.getType();\n<line3>    if (type == Event.EventType.None) {\n<line4>        Event.KeeperState state = event.getState();\n<line5>        if (state == Event.KeeperState.SyncConnected) {\n<line6>            LOG.info(\"Event.KeeperState.SyncConnected\");\n<line7>            countDownLatch.countDown();\n<line8>        } else if (state == Event.KeeperState.Expired) {\n<line9>            LOG.info(\"Event.KeeperState.Expired\");\n<line10>        } else if (state == Event.KeeperState.Disconnected) {\n<line11>            LOG.info(\"Event.KeeperState.Disconnected\");\n<line12>        } else if (state == Event.KeeperState.AuthFailed) {\n<line13>            LOG.info(\"Event.KeeperState.AuthFailed\");\n<line14>        }\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    Event.KeeperState state = event.getState();\n<line3>    if (state == Event.KeeperState.SyncConnected) {\n<line4>        countDownLatch.countDown();\n<line5>    } else if (state == Event.KeeperState.Expired) {\n<line6>    } else if (state == Event.KeeperState.Disconnected) {\n<line7>    } else if (state == Event.KeeperState.AuthFailed) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    Event.KeeperState state = event.getState();\n<line3>    if (state == Event.KeeperState.SyncConnected) {\n<line4>        LOG.info(\"Event.KeeperState.SyncConnected\");\n<line5>        countDownLatch.countDown();\n<line6>    } else if (state == Event.KeeperState.Expired) {\n<line7>        LOG.info(\"Event.KeeperState.Expired\");\n<line8>    } else if (state == Event.KeeperState.Disconnected) {\n<line9>        LOG.info(\"Event.KeeperState.Disconnected\");\n<line10>    } else if (state == Event.KeeperState.AuthFailed) {\n<line11>        LOG.info(\"Event.KeeperState.AuthFailed\");\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    countDownLatch.countDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Event.KeeperState.SyncConnected\");\n<line3>    countDownLatch.countDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Event.KeeperState.Expired\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Event.KeeperState.Disconnected\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Event.KeeperState.AuthFailed\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // By default, disable starting a JettyAdminServer in tests to avoid\n<line3>    // accidentally attempting to start multiple admin servers on the\n<line4>    // same port.\n<line5>    System.setProperty(\"zookeeper.admin.enableServer\", \"false\");\n<line6>    // disable rate limiting\n<line7>    System.setProperty(\"zookeeper.admin.rateLimiterIntervalInMS\", \"0\");\n<line8>    // ZOOKEEPER-2693 disables all 4lw by default.\n<line9>    // Here we enable the 4lw which ZooKeeper tests depends.\n<line10>    System.setProperty(\"zookeeper.4lw.commands.whitelist\", \"*\");\n<line11>}","output":"<line1>{\n<line2>    // By default, disable starting a JettyAdminServer in tests to avoid\n<line3>    // accidentally attempting to start multiple admin servers on the\n<line4>    // same port.\n<line5>    System.setProperty(\"zookeeper.admin.enableServer\", \"false\");\n<line6>    // disable rate limiting\n<line7>    System.setProperty(\"zookeeper.admin.rateLimiterIntervalInMS\", \"0\");\n<line8>    // ZOOKEEPER-2693 disables all 4lw by default.\n<line9>    // Here we enable the 4lw which ZooKeeper tests depends.\n<line10>    System.setProperty(\"zookeeper.4lw.commands.whitelist\", \"*\");\n<line11>    LOG.info(\"STARTING {}\", testInfo.getTestMethod());\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"FINISHED {}\", testInfo.getTestMethod());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String errorMessage = String.format(\"metric \\\"%s\\\" failed to match after %d seconds\", metricKey, timeoutInSeconds);\n<line3>    waitFor(errorMessage, () -> {\n<line4>        @SuppressWarnings(\"unchecked\")\n<line5>        T actual = (T) MetricsUtils.currentServerMetrics().get(metricKey);\n<line6>        if (!matcher.matches(actual)) {\n<line7>            Description description = new StringDescription();\n<line8>            matcher.describeMismatch(actual, description);\n<line9>            return false;\n<line10>        }\n<line11>        return true;\n<line12>    }, timeoutInSeconds);\n<line13>}","output":"<line1>{\n<line2>    String errorMessage = String.format(\"metric \\\"%s\\\" failed to match after %d seconds\", metricKey, timeoutInSeconds);\n<line3>    waitFor(errorMessage, () -> {\n<line4>        @SuppressWarnings(\"unchecked\")\n<line5>        T actual = (T) MetricsUtils.currentServerMetrics().get(metricKey);\n<line6>        if (!matcher.matches(actual)) {\n<line7>            Description description = new StringDescription();\n<line8>            matcher.describeMismatch(actual, description);\n<line9>            LOG.info(\"match failed for metric {}: {}\", metricKey, description);\n<line10>            return false;\n<line11>        }\n<line12>        return true;\n<line13>    }, timeoutInSeconds);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    @SuppressWarnings(\"unchecked\")\n<line3>    T actual = (T) MetricsUtils.currentServerMetrics().get(metricKey);\n<line4>    if (!matcher.matches(actual)) {\n<line5>        Description description = new StringDescription();\n<line6>        matcher.describeMismatch(actual, description);\n<line7>        return false;\n<line8>    }\n<line9>    return true;\n<line10>}","output":"<line1>{\n<line2>    @SuppressWarnings(\"unchecked\")\n<line3>    T actual = (T) MetricsUtils.currentServerMetrics().get(metricKey);\n<line4>    if (!matcher.matches(actual)) {\n<line5>        Description description = new StringDescription();\n<line6>        matcher.describeMismatch(actual, description);\n<line7>        LOG.info(\"match failed for metric {}: {}\", metricKey, description);\n<line8>        return false;\n<line9>    }\n<line10>    return true;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    Description description = new StringDescription();\n<line3>    matcher.describeMismatch(actual, description);\n<line4>    return false;\n<line5>}","output":"<line1>{\n<line2>    Description description = new StringDescription();\n<line3>    matcher.describeMismatch(actual, description);\n<line4>    LOG.info(\"match failed for metric {}: {}\", metricKey, description);\n<line5>    return false;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    // create a quorum of 3 servers\n<line4>    QuorumUtil util = new QuorumUtil(1);\n<line5>    // disable local session to make sure we create a global session\n<line6>    util.enableLocalSession(false);\n<line7>    util.startAll();\n<line8>    int follower1 = (int) util.getFollowerQuorumPeers().get(0).getMyId();\n<line9>    int follower2 = (int) util.getFollowerQuorumPeers().get(1).getMyId();\n<line10>    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();\n<line11>    // create a connection to follower\n<line12>    ZooKeeper zk = new ZooKeeper(util.getConnectionStringForServer(follower1), ClientBase.CONNECTION_TIMEOUT, watcher);\n<line13>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line14>    // update the connection to allow to connect to the other follower\n<line15>    zk.updateServerList(util.getConnectionStringForServer(follower2));\n<line16>    // follower is shut down and zk should be disconnected\n<line17>    util.shutdown(follower1);\n<line18>    watcher.waitForDisconnected(ClientBase.CONNECTION_TIMEOUT);\n<line19>    // should reconnect to another follower, will ask leader to revalidate\n<line20>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line21>    Map<String, Object> values = MetricsUtils.currentServerMetrics();\n<line22>    assertEquals(1L, values.get(\"connection_revalidate_count\"));\n<line23>    assertEquals(1L, values.get(\"revalidate_count\"));\n<line24>    zk.close();\n<line25>    util.shutdownAll();\n<line26>}","output":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    // create a quorum of 3 servers\n<line4>    QuorumUtil util = new QuorumUtil(1);\n<line5>    // disable local session to make sure we create a global session\n<line6>    util.enableLocalSession(false);\n<line7>    util.startAll();\n<line8>    int follower1 = (int) util.getFollowerQuorumPeers().get(0).getMyId();\n<line9>    int follower2 = (int) util.getFollowerQuorumPeers().get(1).getMyId();\n<line10>    LOG.info(\"connecting to server: {}\", follower1);\n<line11>    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();\n<line12>    // create a connection to follower\n<line13>    ZooKeeper zk = new ZooKeeper(util.getConnectionStringForServer(follower1), ClientBase.CONNECTION_TIMEOUT, watcher);\n<line14>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line15>    LOG.info(\"connected\");\n<line16>    // update the connection to allow to connect to the other follower\n<line17>    zk.updateServerList(util.getConnectionStringForServer(follower2));\n<line18>    // follower is shut down and zk should be disconnected\n<line19>    util.shutdown(follower1);\n<line20>    watcher.waitForDisconnected(ClientBase.CONNECTION_TIMEOUT);\n<line21>    LOG.info(\"disconnected\");\n<line22>    // should reconnect to another follower, will ask leader to revalidate\n<line23>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line24>    LOG.info(\"reconnected\");\n<line25>    Map<String, Object> values = MetricsUtils.currentServerMetrics();\n<line26>    assertEquals(1L, values.get(\"connection_revalidate_count\"));\n<line27>    assertEquals(1L, values.get(\"revalidate_count\"));\n<line28>    zk.close();\n<line29>    util.shutdownAll();\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(serverFactory instanceof NettyServerCnxnFactory, \"Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!\");\n<line3>    final ZooKeeper zk = createClient();\n<line4>    final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();\n<line5>    final String path = \"/a\";\n<line6>    try {\n<line7>        // make sure zkclient works\n<line8>        zk.create(path, \"test\".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>        // set on watch\n<line10>        assertNotNull(zk.exists(path, true), \"Didn't create znode:\" + path);\n<line11>        assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line12>        Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line13>        assertEquals(1, serverFactory.getNumAliveConnections(), \"Mismatch in number of live connections!\");\n<line14>        for (ServerCnxn serverCnxn : connections) {\n<line15>            serverCnxn.sendCloseSession();\n<line16>        }\n<line17>        int timeout = 0;\n<line18>        while (serverFactory.getNumAliveConnections() != 0) {\n<line19>            Thread.sleep(1000);\n<line20>            timeout += 1000;\n<line21>            if (timeout > CONNECTION_TIMEOUT) {\n<line22>                fail(\"The number of live connections should be 0\");\n<line23>            }\n<line24>        }\n<line25>        // make sure the watch is removed when the connection closed\n<line26>        assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line27>    } finally {\n<line28>        zk.close();\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    assertTrue(serverFactory instanceof NettyServerCnxnFactory, \"Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!\");\n<line3>    final ZooKeeper zk = createClient();\n<line4>    final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();\n<line5>    final String path = \"/a\";\n<line6>    try {\n<line7>        // make sure zkclient works\n<line8>        zk.create(path, \"test\".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>        // set on watch\n<line10>        assertNotNull(zk.exists(path, true), \"Didn't create znode:\" + path);\n<line11>        assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line12>        Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line13>        assertEquals(1, serverFactory.getNumAliveConnections(), \"Mismatch in number of live connections!\");\n<line14>        for (ServerCnxn serverCnxn : connections) {\n<line15>            serverCnxn.sendCloseSession();\n<line16>        }\n<line17>        LOG.info(\"Waiting for the channel disconnected event\");\n<line18>        int timeout = 0;\n<line19>        while (serverFactory.getNumAliveConnections() != 0) {\n<line20>            Thread.sleep(1000);\n<line21>            timeout += 1000;\n<line22>            if (timeout > CONNECTION_TIMEOUT) {\n<line23>                fail(\"The number of live connections should be 0\");\n<line24>            }\n<line25>        }\n<line26>        // make sure the watch is removed when the connection closed\n<line27>        assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line28>    } finally {\n<line29>        zk.close();\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    // make sure zkclient works\n<line3>    zk.create(path, \"test\".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line4>    // set on watch\n<line5>    assertNotNull(zk.exists(path, true), \"Didn't create znode:\" + path);\n<line6>    assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line7>    Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line8>    assertEquals(1, serverFactory.getNumAliveConnections(), \"Mismatch in number of live connections!\");\n<line9>    for (ServerCnxn serverCnxn : connections) {\n<line10>        serverCnxn.sendCloseSession();\n<line11>    }\n<line12>    int timeout = 0;\n<line13>    while (serverFactory.getNumAliveConnections() != 0) {\n<line14>        Thread.sleep(1000);\n<line15>        timeout += 1000;\n<line16>        if (timeout > CONNECTION_TIMEOUT) {\n<line17>            fail(\"The number of live connections should be 0\");\n<line18>        }\n<line19>    }\n<line20>    // make sure the watch is removed when the connection closed\n<line21>    assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line22>}","output":"<line1>{\n<line2>    // make sure zkclient works\n<line3>    zk.create(path, \"test\".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line4>    // set on watch\n<line5>    assertNotNull(zk.exists(path, true), \"Didn't create znode:\" + path);\n<line6>    assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line7>    Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line8>    assertEquals(1, serverFactory.getNumAliveConnections(), \"Mismatch in number of live connections!\");\n<line9>    for (ServerCnxn serverCnxn : connections) {\n<line10>        serverCnxn.sendCloseSession();\n<line11>    }\n<line12>    LOG.info(\"Waiting for the channel disconnected event\");\n<line13>    int timeout = 0;\n<line14>    while (serverFactory.getNumAliveConnections() != 0) {\n<line15>        Thread.sleep(1000);\n<line16>        timeout += 1000;\n<line17>        if (timeout > CONNECTION_TIMEOUT) {\n<line18>            fail(\"The number of live connections should be 0\");\n<line19>        }\n<line20>    }\n<line21>    // make sure the watch is removed when the connection closed\n<line22>    assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    ClientX509Util x509Util = null;\n<line3>    if (secure) {\n<line4>        x509Util = SSLAuthTest.setUpSecure();\n<line5>    }\n<line6>    try {\n<line7>        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n<line8>        factory.setAdvancedFlowControlEnabled(true);\n<line9>        if (secure) {\n<line10>            factory.setSecure(true);\n<line11>        }\n<line12>        final String path = \"/testEnableDisableThrottling\";\n<line13>        try (ZooKeeper zk = createClient()) {\n<line14>            zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>            // meanwhile start another thread to enable and disable recv\n<line16>            AtomicBoolean stopped = new AtomicBoolean(false);\n<line17>            Random random = new Random();\n<line18>            Thread enableDisableThread = null;\n<line19>            if (randomDisableEnable) {\n<line20>                enableDisableThread = new Thread() {\n<line21>\n<line22>                    @Override\n<line23>                    public void run() {\n<line24>                        while (!stopped.get()) {\n<line25>                            for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line26>                                boolean shouldDisableEnable = random.nextBoolean();\n<line27>                                if (shouldDisableEnable) {\n<line28>                                    cnxn.disableRecv();\n<line29>                                } else {\n<line30>                                    cnxn.enableRecv();\n<line31>                                }\n<line32>                            }\n<line33>                            try {\n<line34>                                Thread.sleep(10);\n<line35>                            } catch (InterruptedException e) {\n<line36>                                /* ignore */\n<line37>                            }\n<line38>                        }\n<line39>                        // always enable the recv at end\n<line40>                        for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line41>                            cnxn.enableRecv();\n<line42>                        }\n<line43>                    }\n<line44>                };\n<line45>            } else {\n<line46>                enableDisableThread = new Thread() {\n<line47>\n<line48>                    @Override\n<line49>                    public void run() {\n<line50>                        while (!stopped.get()) {\n<line51>                            for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line52>                                try {\n<line53>                                    cnxn.disableRecv();\n<line54>                                    Thread.sleep(10);\n<line55>                                    cnxn.enableRecv();\n<line56>                                    Thread.sleep(10);\n<line57>                                } catch (InterruptedException e) {\n<line58>                                    /* ignore */\n<line59>                                }\n<line60>                            }\n<line61>                        }\n<line62>                    }\n<line63>                };\n<line64>            }\n<line65>            enableDisableThread.start();\n<line66>            // start a thread to keep sending requests\n<line67>            int totalRequestsNum = 100000;\n<line68>            AtomicInteger successResponse = new AtomicInteger();\n<line69>            CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);\n<line70>            Thread clientThread = new Thread() {\n<line71>\n<line72>                @Override\n<line73>                public void run() {\n<line74>                    int requestIssued = 0;\n<line75>                    while (requestIssued++ < totalRequestsNum) {\n<line76>                        zk.getData(path, null, new DataCallback() {\n<line77>\n<line78>                            @Override\n<line79>                            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line80>                                if (rc == KeeperException.Code.OK.intValue()) {\n<line81>                                    successResponse.addAndGet(1);\n<line82>                                } else {\n<line83>                                }\n<line84>                                responseReceivedLatch.countDown();\n<line85>                            }\n<line86>                        }, null);\n<line87>                    }\n<line88>                }\n<line89>            };\n<line90>            clientThread.start();\n<line91>            // and verify the response received is same as what we issued\n<line92>            assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));\n<line93>            stopped.set(true);\n<line94>            enableDisableThread.join();\n<line95>            // wait another second for the left requests to finish\n<line96>            Thread.sleep(1000);\n<line97>            assertEquals(successResponse.get(), totalRequestsNum);\n<line98>        }\n<line99>    } finally {\n<line100>        if (secure) {\n<line101>            SSLAuthTest.clearSecureSetting(x509Util);\n<line102>        }\n<line103>    }\n<line104>}","output":"<line1>{\n<line2>    ClientX509Util x509Util = null;\n<line3>    if (secure) {\n<line4>        x509Util = SSLAuthTest.setUpSecure();\n<line5>    }\n<line6>    try {\n<line7>        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n<line8>        factory.setAdvancedFlowControlEnabled(true);\n<line9>        if (secure) {\n<line10>            factory.setSecure(true);\n<line11>        }\n<line12>        final String path = \"/testEnableDisableThrottling\";\n<line13>        try (ZooKeeper zk = createClient()) {\n<line14>            zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>            // meanwhile start another thread to enable and disable recv\n<line16>            AtomicBoolean stopped = new AtomicBoolean(false);\n<line17>            Random random = new Random();\n<line18>            Thread enableDisableThread = null;\n<line19>            if (randomDisableEnable) {\n<line20>                enableDisableThread = new Thread() {\n<line21>\n<line22>                    @Override\n<line23>                    public void run() {\n<line24>                        while (!stopped.get()) {\n<line25>                            for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line26>                                boolean shouldDisableEnable = random.nextBoolean();\n<line27>                                if (shouldDisableEnable) {\n<line28>                                    cnxn.disableRecv();\n<line29>                                } else {\n<line30>                                    cnxn.enableRecv();\n<line31>                                }\n<line32>                            }\n<line33>                            try {\n<line34>                                Thread.sleep(10);\n<line35>                            } catch (InterruptedException e) {\n<line36>                                /* ignore */\n<line37>                            }\n<line38>                        }\n<line39>                        // always enable the recv at end\n<line40>                        for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line41>                            cnxn.enableRecv();\n<line42>                        }\n<line43>                    }\n<line44>                };\n<line45>            } else {\n<line46>                enableDisableThread = new Thread() {\n<line47>\n<line48>                    @Override\n<line49>                    public void run() {\n<line50>                        while (!stopped.get()) {\n<line51>                            for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line52>                                try {\n<line53>                                    cnxn.disableRecv();\n<line54>                                    Thread.sleep(10);\n<line55>                                    cnxn.enableRecv();\n<line56>                                    Thread.sleep(10);\n<line57>                                } catch (InterruptedException e) {\n<line58>                                    /* ignore */\n<line59>                                }\n<line60>                            }\n<line61>                        }\n<line62>                    }\n<line63>                };\n<line64>            }\n<line65>            enableDisableThread.start();\n<line66>            LOG.info(\"started thread to enable and disable recv\");\n<line67>            // start a thread to keep sending requests\n<line68>            int totalRequestsNum = 100000;\n<line69>            AtomicInteger successResponse = new AtomicInteger();\n<line70>            CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);\n<line71>            Thread clientThread = new Thread() {\n<line72>\n<line73>                @Override\n<line74>                public void run() {\n<line75>                    int requestIssued = 0;\n<line76>                    while (requestIssued++ < totalRequestsNum) {\n<line77>                        zk.getData(path, null, new DataCallback() {\n<line78>\n<line79>                            @Override\n<line80>                            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line81>                                if (rc == KeeperException.Code.OK.intValue()) {\n<line82>                                    successResponse.addAndGet(1);\n<line83>                                } else {\n<line84>                                    LOG.info(\"failed response is {}\", rc);\n<line85>                                }\n<line86>                                responseReceivedLatch.countDown();\n<line87>                            }\n<line88>                        }, null);\n<line89>                    }\n<line90>                }\n<line91>            };\n<line92>            clientThread.start();\n<line93>            LOG.info(\"started thread to issue {} async requests\", totalRequestsNum);\n<line94>            // and verify the response received is same as what we issued\n<line95>            assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));\n<line96>            LOG.info(\"received all {} responses\", totalRequestsNum);\n<line97>            stopped.set(true);\n<line98>            enableDisableThread.join();\n<line99>            LOG.info(\"enable and disable recv thread exited\");\n<line100>            // wait another second for the left requests to finish\n<line101>            LOG.info(\"waiting another 1s for the requests to go through\");\n<line102>            Thread.sleep(1000);\n<line103>            assertEquals(successResponse.get(), totalRequestsNum);\n<line104>        }\n<line105>    } finally {\n<line106>        if (secure) {\n<line107>            SSLAuthTest.clearSecureSetting(x509Util);\n<line108>        }\n<line109>    }\n<line110>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n<line3>    factory.setAdvancedFlowControlEnabled(true);\n<line4>    if (secure) {\n<line5>        factory.setSecure(true);\n<line6>    }\n<line7>    final String path = \"/testEnableDisableThrottling\";\n<line8>    try (ZooKeeper zk = createClient()) {\n<line9>        zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>        // meanwhile start another thread to enable and disable recv\n<line11>        AtomicBoolean stopped = new AtomicBoolean(false);\n<line12>        Random random = new Random();\n<line13>        Thread enableDisableThread = null;\n<line14>        if (randomDisableEnable) {\n<line15>            enableDisableThread = new Thread() {\n<line16>\n<line17>                @Override\n<line18>                public void run() {\n<line19>                    while (!stopped.get()) {\n<line20>                        for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line21>                            boolean shouldDisableEnable = random.nextBoolean();\n<line22>                            if (shouldDisableEnable) {\n<line23>                                cnxn.disableRecv();\n<line24>                            } else {\n<line25>                                cnxn.enableRecv();\n<line26>                            }\n<line27>                        }\n<line28>                        try {\n<line29>                            Thread.sleep(10);\n<line30>                        } catch (InterruptedException e) {\n<line31>                            /* ignore */\n<line32>                        }\n<line33>                    }\n<line34>                    // always enable the recv at end\n<line35>                    for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line36>                        cnxn.enableRecv();\n<line37>                    }\n<line38>                }\n<line39>            };\n<line40>        } else {\n<line41>            enableDisableThread = new Thread() {\n<line42>\n<line43>                @Override\n<line44>                public void run() {\n<line45>                    while (!stopped.get()) {\n<line46>                        for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line47>                            try {\n<line48>                                cnxn.disableRecv();\n<line49>                                Thread.sleep(10);\n<line50>                                cnxn.enableRecv();\n<line51>                                Thread.sleep(10);\n<line52>                            } catch (InterruptedException e) {\n<line53>                                /* ignore */\n<line54>                            }\n<line55>                        }\n<line56>                    }\n<line57>                }\n<line58>            };\n<line59>        }\n<line60>        enableDisableThread.start();\n<line61>        // start a thread to keep sending requests\n<line62>        int totalRequestsNum = 100000;\n<line63>        AtomicInteger successResponse = new AtomicInteger();\n<line64>        CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);\n<line65>        Thread clientThread = new Thread() {\n<line66>\n<line67>            @Override\n<line68>            public void run() {\n<line69>                int requestIssued = 0;\n<line70>                while (requestIssued++ < totalRequestsNum) {\n<line71>                    zk.getData(path, null, new DataCallback() {\n<line72>\n<line73>                        @Override\n<line74>                        public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line75>                            if (rc == KeeperException.Code.OK.intValue()) {\n<line76>                                successResponse.addAndGet(1);\n<line77>                            } else {\n<line78>                            }\n<line79>                            responseReceivedLatch.countDown();\n<line80>                        }\n<line81>                    }, null);\n<line82>                }\n<line83>            }\n<line84>        };\n<line85>        clientThread.start();\n<line86>        // and verify the response received is same as what we issued\n<line87>        assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));\n<line88>        stopped.set(true);\n<line89>        enableDisableThread.join();\n<line90>        // wait another second for the left requests to finish\n<line91>        Thread.sleep(1000);\n<line92>        assertEquals(successResponse.get(), totalRequestsNum);\n<line93>    }\n<line94>}","output":"<line1>{\n<line2>    NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n<line3>    factory.setAdvancedFlowControlEnabled(true);\n<line4>    if (secure) {\n<line5>        factory.setSecure(true);\n<line6>    }\n<line7>    final String path = \"/testEnableDisableThrottling\";\n<line8>    try (ZooKeeper zk = createClient()) {\n<line9>        zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>        // meanwhile start another thread to enable and disable recv\n<line11>        AtomicBoolean stopped = new AtomicBoolean(false);\n<line12>        Random random = new Random();\n<line13>        Thread enableDisableThread = null;\n<line14>        if (randomDisableEnable) {\n<line15>            enableDisableThread = new Thread() {\n<line16>\n<line17>                @Override\n<line18>                public void run() {\n<line19>                    while (!stopped.get()) {\n<line20>                        for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line21>                            boolean shouldDisableEnable = random.nextBoolean();\n<line22>                            if (shouldDisableEnable) {\n<line23>                                cnxn.disableRecv();\n<line24>                            } else {\n<line25>                                cnxn.enableRecv();\n<line26>                            }\n<line27>                        }\n<line28>                        try {\n<line29>                            Thread.sleep(10);\n<line30>                        } catch (InterruptedException e) {\n<line31>                            /* ignore */\n<line32>                        }\n<line33>                    }\n<line34>                    // always enable the recv at end\n<line35>                    for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line36>                        cnxn.enableRecv();\n<line37>                    }\n<line38>                }\n<line39>            };\n<line40>        } else {\n<line41>            enableDisableThread = new Thread() {\n<line42>\n<line43>                @Override\n<line44>                public void run() {\n<line45>                    while (!stopped.get()) {\n<line46>                        for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line47>                            try {\n<line48>                                cnxn.disableRecv();\n<line49>                                Thread.sleep(10);\n<line50>                                cnxn.enableRecv();\n<line51>                                Thread.sleep(10);\n<line52>                            } catch (InterruptedException e) {\n<line53>                                /* ignore */\n<line54>                            }\n<line55>                        }\n<line56>                    }\n<line57>                }\n<line58>            };\n<line59>        }\n<line60>        enableDisableThread.start();\n<line61>        LOG.info(\"started thread to enable and disable recv\");\n<line62>        // start a thread to keep sending requests\n<line63>        int totalRequestsNum = 100000;\n<line64>        AtomicInteger successResponse = new AtomicInteger();\n<line65>        CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);\n<line66>        Thread clientThread = new Thread() {\n<line67>\n<line68>            @Override\n<line69>            public void run() {\n<line70>                int requestIssued = 0;\n<line71>                while (requestIssued++ < totalRequestsNum) {\n<line72>                    zk.getData(path, null, new DataCallback() {\n<line73>\n<line74>                        @Override\n<line75>                        public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line76>                            if (rc == KeeperException.Code.OK.intValue()) {\n<line77>                                successResponse.addAndGet(1);\n<line78>                            } else {\n<line79>                                LOG.info(\"failed response is {}\", rc);\n<line80>                            }\n<line81>                            responseReceivedLatch.countDown();\n<line82>                        }\n<line83>                    }, null);\n<line84>                }\n<line85>            }\n<line86>        };\n<line87>        clientThread.start();\n<line88>        LOG.info(\"started thread to issue {} async requests\", totalRequestsNum);\n<line89>        // and verify the response received is same as what we issued\n<line90>        assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));\n<line91>        LOG.info(\"received all {} responses\", totalRequestsNum);\n<line92>        stopped.set(true);\n<line93>        enableDisableThread.join();\n<line94>        LOG.info(\"enable and disable recv thread exited\");\n<line95>        // wait another second for the left requests to finish\n<line96>        LOG.info(\"waiting another 1s for the requests to go through\");\n<line97>        Thread.sleep(1000);\n<line98>        assertEquals(successResponse.get(), totalRequestsNum);\n<line99>    }\n<line100>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    // meanwhile start another thread to enable and disable recv\n<line4>    AtomicBoolean stopped = new AtomicBoolean(false);\n<line5>    Random random = new Random();\n<line6>    Thread enableDisableThread = null;\n<line7>    if (randomDisableEnable) {\n<line8>        enableDisableThread = new Thread() {\n<line9>\n<line10>            @Override\n<line11>            public void run() {\n<line12>                while (!stopped.get()) {\n<line13>                    for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line14>                        boolean shouldDisableEnable = random.nextBoolean();\n<line15>                        if (shouldDisableEnable) {\n<line16>                            cnxn.disableRecv();\n<line17>                        } else {\n<line18>                            cnxn.enableRecv();\n<line19>                        }\n<line20>                    }\n<line21>                    try {\n<line22>                        Thread.sleep(10);\n<line23>                    } catch (InterruptedException e) {\n<line24>                        /* ignore */\n<line25>                    }\n<line26>                }\n<line27>                // always enable the recv at end\n<line28>                for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line29>                    cnxn.enableRecv();\n<line30>                }\n<line31>            }\n<line32>        };\n<line33>    } else {\n<line34>        enableDisableThread = new Thread() {\n<line35>\n<line36>            @Override\n<line37>            public void run() {\n<line38>                while (!stopped.get()) {\n<line39>                    for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line40>                        try {\n<line41>                            cnxn.disableRecv();\n<line42>                            Thread.sleep(10);\n<line43>                            cnxn.enableRecv();\n<line44>                            Thread.sleep(10);\n<line45>                        } catch (InterruptedException e) {\n<line46>                            /* ignore */\n<line47>                        }\n<line48>                    }\n<line49>                }\n<line50>            }\n<line51>        };\n<line52>    }\n<line53>    enableDisableThread.start();\n<line54>    // start a thread to keep sending requests\n<line55>    int totalRequestsNum = 100000;\n<line56>    AtomicInteger successResponse = new AtomicInteger();\n<line57>    CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);\n<line58>    Thread clientThread = new Thread() {\n<line59>\n<line60>        @Override\n<line61>        public void run() {\n<line62>            int requestIssued = 0;\n<line63>            while (requestIssued++ < totalRequestsNum) {\n<line64>                zk.getData(path, null, new DataCallback() {\n<line65>\n<line66>                    @Override\n<line67>                    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line68>                        if (rc == KeeperException.Code.OK.intValue()) {\n<line69>                            successResponse.addAndGet(1);\n<line70>                        } else {\n<line71>                        }\n<line72>                        responseReceivedLatch.countDown();\n<line73>                    }\n<line74>                }, null);\n<line75>            }\n<line76>        }\n<line77>    };\n<line78>    clientThread.start();\n<line79>    // and verify the response received is same as what we issued\n<line80>    assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));\n<line81>    stopped.set(true);\n<line82>    enableDisableThread.join();\n<line83>    // wait another second for the left requests to finish\n<line84>    Thread.sleep(1000);\n<line85>    assertEquals(successResponse.get(), totalRequestsNum);\n<line86>}","output":"<line1>{\n<line2>    zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line3>    // meanwhile start another thread to enable and disable recv\n<line4>    AtomicBoolean stopped = new AtomicBoolean(false);\n<line5>    Random random = new Random();\n<line6>    Thread enableDisableThread = null;\n<line7>    if (randomDisableEnable) {\n<line8>        enableDisableThread = new Thread() {\n<line9>\n<line10>            @Override\n<line11>            public void run() {\n<line12>                while (!stopped.get()) {\n<line13>                    for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line14>                        boolean shouldDisableEnable = random.nextBoolean();\n<line15>                        if (shouldDisableEnable) {\n<line16>                            cnxn.disableRecv();\n<line17>                        } else {\n<line18>                            cnxn.enableRecv();\n<line19>                        }\n<line20>                    }\n<line21>                    try {\n<line22>                        Thread.sleep(10);\n<line23>                    } catch (InterruptedException e) {\n<line24>                        /* ignore */\n<line25>                    }\n<line26>                }\n<line27>                // always enable the recv at end\n<line28>                for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line29>                    cnxn.enableRecv();\n<line30>                }\n<line31>            }\n<line32>        };\n<line33>    } else {\n<line34>        enableDisableThread = new Thread() {\n<line35>\n<line36>            @Override\n<line37>            public void run() {\n<line38>                while (!stopped.get()) {\n<line39>                    for (final ServerCnxn cnxn : serverFactory.cnxns) {\n<line40>                        try {\n<line41>                            cnxn.disableRecv();\n<line42>                            Thread.sleep(10);\n<line43>                            cnxn.enableRecv();\n<line44>                            Thread.sleep(10);\n<line45>                        } catch (InterruptedException e) {\n<line46>                            /* ignore */\n<line47>                        }\n<line48>                    }\n<line49>                }\n<line50>            }\n<line51>        };\n<line52>    }\n<line53>    enableDisableThread.start();\n<line54>    LOG.info(\"started thread to enable and disable recv\");\n<line55>    // start a thread to keep sending requests\n<line56>    int totalRequestsNum = 100000;\n<line57>    AtomicInteger successResponse = new AtomicInteger();\n<line58>    CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);\n<line59>    Thread clientThread = new Thread() {\n<line60>\n<line61>        @Override\n<line62>        public void run() {\n<line63>            int requestIssued = 0;\n<line64>            while (requestIssued++ < totalRequestsNum) {\n<line65>                zk.getData(path, null, new DataCallback() {\n<line66>\n<line67>                    @Override\n<line68>                    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line69>                        if (rc == KeeperException.Code.OK.intValue()) {\n<line70>                            successResponse.addAndGet(1);\n<line71>                        } else {\n<line72>                            LOG.info(\"failed response is {}\", rc);\n<line73>                        }\n<line74>                        responseReceivedLatch.countDown();\n<line75>                    }\n<line76>                }, null);\n<line77>            }\n<line78>        }\n<line79>    };\n<line80>    clientThread.start();\n<line81>    LOG.info(\"started thread to issue {} async requests\", totalRequestsNum);\n<line82>    // and verify the response received is same as what we issued\n<line83>    assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));\n<line84>    LOG.info(\"received all {} responses\", totalRequestsNum);\n<line85>    stopped.set(true);\n<line86>    enableDisableThread.join();\n<line87>    LOG.info(\"enable and disable recv thread exited\");\n<line88>    // wait another second for the left requests to finish\n<line89>    LOG.info(\"waiting another 1s for the requests to go through\");\n<line90>    Thread.sleep(1000);\n<line91>    assertEquals(successResponse.get(), totalRequestsNum);\n<line92>}"},{"input":"","instruction":"<line1>{\n<line2>    int requestIssued = 0;\n<line3>    while (requestIssued++ < totalRequestsNum) {\n<line4>        zk.getData(path, null, new DataCallback() {\n<line5>\n<line6>            @Override\n<line7>            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line8>                if (rc == KeeperException.Code.OK.intValue()) {\n<line9>                    successResponse.addAndGet(1);\n<line10>                } else {\n<line11>                }\n<line12>                responseReceivedLatch.countDown();\n<line13>            }\n<line14>        }, null);\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    int requestIssued = 0;\n<line3>    while (requestIssued++ < totalRequestsNum) {\n<line4>        zk.getData(path, null, new DataCallback() {\n<line5>\n<line6>            @Override\n<line7>            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line8>                if (rc == KeeperException.Code.OK.intValue()) {\n<line9>                    successResponse.addAndGet(1);\n<line10>                } else {\n<line11>                    LOG.info(\"failed response is {}\", rc);\n<line12>                }\n<line13>                responseReceivedLatch.countDown();\n<line14>            }\n<line15>        }, null);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.getData(path, null, new DataCallback() {\n<line3>\n<line4>        @Override\n<line5>        public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line6>            if (rc == KeeperException.Code.OK.intValue()) {\n<line7>                successResponse.addAndGet(1);\n<line8>            } else {\n<line9>            }\n<line10>            responseReceivedLatch.countDown();\n<line11>        }\n<line12>    }, null);\n<line13>}","output":"<line1>{\n<line2>    zk.getData(path, null, new DataCallback() {\n<line3>\n<line4>        @Override\n<line5>        public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n<line6>            if (rc == KeeperException.Code.OK.intValue()) {\n<line7>                successResponse.addAndGet(1);\n<line8>            } else {\n<line9>                LOG.info(\"failed response is {}\", rc);\n<line10>            }\n<line11>            responseReceivedLatch.countDown();\n<line12>        }\n<line13>    }, null);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (rc == KeeperException.Code.OK.intValue()) {\n<line3>        successResponse.addAndGet(1);\n<line4>    } else {\n<line5>    }\n<line6>    responseReceivedLatch.countDown();\n<line7>}","output":"<line1>{\n<line2>    if (rc == KeeperException.Code.OK.intValue()) {\n<line3>        successResponse.addAndGet(1);\n<line4>    } else {\n<line5>        LOG.info(\"failed response is {}\", rc);\n<line6>    }\n<line7>    responseReceivedLatch.countDown();\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"failed response is {}\", rc);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    this.toClose = toClose;\n<line3>    this.toClose2 = toClose2;\n<line4>    this.in = in;\n<line5>    this.out = out;\n<line6>}","output":"<line1>{\n<line2>    this.toClose = toClose;\n<line3>    this.toClose2 = toClose2;\n<line4>    this.in = in;\n<line5>    this.out = out;\n<line6>    // LOG.info(\"starting forward for \"+toClose);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread.currentThread().setName(toClose.toString() + \"-->\" + toClose2.toString());\n<line3>    byte[] buf = new byte[1024];\n<line4>    try {\n<line5>        while (true) {\n<line6>            try {\n<line7>                int read = this.in.read(buf);\n<line8>                if (read > 0) {\n<line9>                    try {\n<line10>                        this.out.write(buf, 0, read);\n<line11>                    } catch (IOException e) {\n<line12>                        break;\n<line13>                    }\n<line14>                } else if (read < 0) {\n<line15>                    throw new IOException(\"read \" + read);\n<line16>                }\n<line17>            } catch (SocketTimeoutException e) {\n<line18>            }\n<line19>        }\n<line20>        Thread.sleep(1);\n<line21>    } catch (InterruptedException e) {\n<line22>    } catch (SocketException e) {\n<line23>        if (!\"Socket closed\".equals(e.getMessage())) {\n<line24>        }\n<line25>    } catch (IOException e) {\n<line26>    } finally {\n<line27>        shutdown();\n<line28>    }\n<line29>    isFinished = true;\n<line30>}","output":"<line1>{\n<line2>    Thread.currentThread().setName(toClose.toString() + \"-->\" + toClose2.toString());\n<line3>    byte[] buf = new byte[1024];\n<line4>    try {\n<line5>        while (true) {\n<line6>            try {\n<line7>                int read = this.in.read(buf);\n<line8>                if (read > 0) {\n<line9>                    try {\n<line10>                        this.out.write(buf, 0, read);\n<line11>                    } catch (IOException e) {\n<line12>                        LOG.warn(\"exception during write\", e);\n<line13>                        break;\n<line14>                    }\n<line15>                } else if (read < 0) {\n<line16>                    throw new IOException(\"read \" + read);\n<line17>                }\n<line18>            } catch (SocketTimeoutException e) {\n<line19>                LOG.error(\"socket timeout\", e);\n<line20>            }\n<line21>        }\n<line22>        Thread.sleep(1);\n<line23>    } catch (InterruptedException e) {\n<line24>        LOG.warn(\"Interrupted\", e);\n<line25>    } catch (SocketException e) {\n<line26>        if (!\"Socket closed\".equals(e.getMessage())) {\n<line27>            LOG.error(\"Unexpected exception\", e);\n<line28>        }\n<line29>    } catch (IOException e) {\n<line30>        LOG.error(\"Unexpected exception\", e);\n<line31>    } finally {\n<line32>        shutdown();\n<line33>    }\n<line34>    LOG.info(\"Shutting down forward for {}\", toClose);\n<line35>    isFinished = true;\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    while (true) {\n<line3>        try {\n<line4>            int read = this.in.read(buf);\n<line5>            if (read > 0) {\n<line6>                try {\n<line7>                    this.out.write(buf, 0, read);\n<line8>                } catch (IOException e) {\n<line9>                    break;\n<line10>                }\n<line11>            } else if (read < 0) {\n<line12>                throw new IOException(\"read \" + read);\n<line13>            }\n<line14>        } catch (SocketTimeoutException e) {\n<line15>        }\n<line16>    }\n<line17>    Thread.sleep(1);\n<line18>}","output":"<line1>{\n<line2>    while (true) {\n<line3>        try {\n<line4>            int read = this.in.read(buf);\n<line5>            if (read > 0) {\n<line6>                try {\n<line7>                    this.out.write(buf, 0, read);\n<line8>                } catch (IOException e) {\n<line9>                    LOG.warn(\"exception during write\", e);\n<line10>                    break;\n<line11>                }\n<line12>            } else if (read < 0) {\n<line13>                throw new IOException(\"read \" + read);\n<line14>            }\n<line15>        } catch (SocketTimeoutException e) {\n<line16>            LOG.error(\"socket timeout\", e);\n<line17>        }\n<line18>    }\n<line19>    Thread.sleep(1);\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        int read = this.in.read(buf);\n<line4>        if (read > 0) {\n<line5>            try {\n<line6>                this.out.write(buf, 0, read);\n<line7>            } catch (IOException e) {\n<line8>                break;\n<line9>            }\n<line10>        } else if (read < 0) {\n<line11>            throw new IOException(\"read \" + read);\n<line12>        }\n<line13>    } catch (SocketTimeoutException e) {\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    try {\n<line3>        int read = this.in.read(buf);\n<line4>        if (read > 0) {\n<line5>            try {\n<line6>                this.out.write(buf, 0, read);\n<line7>            } catch (IOException e) {\n<line8>                LOG.warn(\"exception during write\", e);\n<line9>                break;\n<line10>            }\n<line11>        } else if (read < 0) {\n<line12>            throw new IOException(\"read \" + read);\n<line13>        }\n<line14>    } catch (SocketTimeoutException e) {\n<line15>        LOG.error(\"socket timeout\", e);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"socket timeout\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!\"Socket closed\".equals(e.getMessage())) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!\"Socket closed\".equals(e.getMessage())) {\n<line3>        LOG.error(\"Unexpected exception\", e);\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!stopped) {\n<line4>            Socket sock = null;\n<line5>            try {\n<line6>                sock = serverSocket.accept();\n<line7>                Socket target = null;\n<line8>                int retry = 10;\n<line9>                while (sock.isConnected()) {\n<line10>                    try {\n<line11>                        target = new Socket(\"localhost\", to);\n<line12>                        break;\n<line13>                    } catch (IOException e) {\n<line14>                        if (retry == 0) {\n<line15>                            throw e;\n<line16>                        }\n<line17>                    }\n<line18>                    Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line19>                    retry--;\n<line20>                }\n<line21>                sock.setSoTimeout(30000);\n<line22>                target.setSoTimeout(30000);\n<line23>                workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line24>                workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line25>                for (PortForwardWorker worker : workers) {\n<line26>                    workerExecutor.submit(worker);\n<line27>                }\n<line28>            } catch (SocketTimeoutException e) {\n<line29>            } catch (ConnectException e) {\n<line30>                sock.close();\n<line31>            } catch (IOException e) {\n<line32>                if (!\"Socket closed\".equals(e.getMessage())) {\n<line33>                    throw e;\n<line34>                }\n<line35>            }\n<line36>        }\n<line37>    } catch (IOException e) {\n<line38>    } catch (InterruptedException e) {\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!stopped) {\n<line4>            Socket sock = null;\n<line5>            try {\n<line6>                LOG.info(\"accepting socket local:{} to:{}\", serverSocket.getLocalPort(), to);\n<line7>                sock = serverSocket.accept();\n<line8>                LOG.info(\"accepted: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line9>                Socket target = null;\n<line10>                int retry = 10;\n<line11>                while (sock.isConnected()) {\n<line12>                    try {\n<line13>                        target = new Socket(\"localhost\", to);\n<line14>                        break;\n<line15>                    } catch (IOException e) {\n<line16>                        if (retry == 0) {\n<line17>                            throw e;\n<line18>                        }\n<line19>                        LOG.warn(\"connection failed, retrying({}): local:{} from:{} to:{}\", retry, sock.getLocalPort(), sock.getPort(), to, e);\n<line20>                    }\n<line21>                    Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line22>                    retry--;\n<line23>                }\n<line24>                LOG.info(\"connected: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line25>                sock.setSoTimeout(30000);\n<line26>                target.setSoTimeout(30000);\n<line27>                workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line28>                workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line29>                for (PortForwardWorker worker : workers) {\n<line30>                    workerExecutor.submit(worker);\n<line31>                }\n<line32>            } catch (SocketTimeoutException e) {\n<line33>                LOG.warn(\"socket timed out\", e);\n<line34>            } catch (ConnectException e) {\n<line35>                LOG.warn(\"connection exception local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to, e);\n<line36>                sock.close();\n<line37>            } catch (IOException e) {\n<line38>                if (!\"Socket closed\".equals(e.getMessage())) {\n<line39>                    LOG.warn(\"unexpected exception local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to, e);\n<line40>                    throw e;\n<line41>                }\n<line42>            }\n<line43>        }\n<line44>    } catch (IOException e) {\n<line45>        LOG.error(\"Unexpected exception to:{}\", to, e);\n<line46>    } catch (InterruptedException e) {\n<line47>        LOG.error(\"Interrupted to:{}\", to, e);\n<line48>    }\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>    while (!stopped) {\n<line3>        Socket sock = null;\n<line4>        try {\n<line5>            sock = serverSocket.accept();\n<line6>            Socket target = null;\n<line7>            int retry = 10;\n<line8>            while (sock.isConnected()) {\n<line9>                try {\n<line10>                    target = new Socket(\"localhost\", to);\n<line11>                    break;\n<line12>                } catch (IOException e) {\n<line13>                    if (retry == 0) {\n<line14>                        throw e;\n<line15>                    }\n<line16>                }\n<line17>                Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line18>                retry--;\n<line19>            }\n<line20>            sock.setSoTimeout(30000);\n<line21>            target.setSoTimeout(30000);\n<line22>            workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line23>            workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line24>            for (PortForwardWorker worker : workers) {\n<line25>                workerExecutor.submit(worker);\n<line26>            }\n<line27>        } catch (SocketTimeoutException e) {\n<line28>        } catch (ConnectException e) {\n<line29>            sock.close();\n<line30>        } catch (IOException e) {\n<line31>            if (!\"Socket closed\".equals(e.getMessage())) {\n<line32>                throw e;\n<line33>            }\n<line34>        }\n<line35>    }\n<line36>}","output":"<line1>{\n<line2>    while (!stopped) {\n<line3>        Socket sock = null;\n<line4>        try {\n<line5>            LOG.info(\"accepting socket local:{} to:{}\", serverSocket.getLocalPort(), to);\n<line6>            sock = serverSocket.accept();\n<line7>            LOG.info(\"accepted: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line8>            Socket target = null;\n<line9>            int retry = 10;\n<line10>            while (sock.isConnected()) {\n<line11>                try {\n<line12>                    target = new Socket(\"localhost\", to);\n<line13>                    break;\n<line14>                } catch (IOException e) {\n<line15>                    if (retry == 0) {\n<line16>                        throw e;\n<line17>                    }\n<line18>                    LOG.warn(\"connection failed, retrying({}): local:{} from:{} to:{}\", retry, sock.getLocalPort(), sock.getPort(), to, e);\n<line19>                }\n<line20>                Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line21>                retry--;\n<line22>            }\n<line23>            LOG.info(\"connected: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line24>            sock.setSoTimeout(30000);\n<line25>            target.setSoTimeout(30000);\n<line26>            workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line27>            workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line28>            for (PortForwardWorker worker : workers) {\n<line29>                workerExecutor.submit(worker);\n<line30>            }\n<line31>        } catch (SocketTimeoutException e) {\n<line32>            LOG.warn(\"socket timed out\", e);\n<line33>        } catch (ConnectException e) {\n<line34>            LOG.warn(\"connection exception local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to, e);\n<line35>            sock.close();\n<line36>        } catch (IOException e) {\n<line37>            if (!\"Socket closed\".equals(e.getMessage())) {\n<line38>                LOG.warn(\"unexpected exception local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to, e);\n<line39>                throw e;\n<line40>            }\n<line41>        }\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket sock = null;\n<line3>    try {\n<line4>        sock = serverSocket.accept();\n<line5>        Socket target = null;\n<line6>        int retry = 10;\n<line7>        while (sock.isConnected()) {\n<line8>            try {\n<line9>                target = new Socket(\"localhost\", to);\n<line10>                break;\n<line11>            } catch (IOException e) {\n<line12>                if (retry == 0) {\n<line13>                    throw e;\n<line14>                }\n<line15>            }\n<line16>            Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line17>            retry--;\n<line18>        }\n<line19>        sock.setSoTimeout(30000);\n<line20>        target.setSoTimeout(30000);\n<line21>        workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line22>        workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line23>        for (PortForwardWorker worker : workers) {\n<line24>            workerExecutor.submit(worker);\n<line25>        }\n<line26>    } catch (SocketTimeoutException e) {\n<line27>    } catch (ConnectException e) {\n<line28>        sock.close();\n<line29>    } catch (IOException e) {\n<line30>        if (!\"Socket closed\".equals(e.getMessage())) {\n<line31>            throw e;\n<line32>        }\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    Socket sock = null;\n<line3>    try {\n<line4>        LOG.info(\"accepting socket local:{} to:{}\", serverSocket.getLocalPort(), to);\n<line5>        sock = serverSocket.accept();\n<line6>        LOG.info(\"accepted: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line7>        Socket target = null;\n<line8>        int retry = 10;\n<line9>        while (sock.isConnected()) {\n<line10>            try {\n<line11>                target = new Socket(\"localhost\", to);\n<line12>                break;\n<line13>            } catch (IOException e) {\n<line14>                if (retry == 0) {\n<line15>                    throw e;\n<line16>                }\n<line17>                LOG.warn(\"connection failed, retrying({}): local:{} from:{} to:{}\", retry, sock.getLocalPort(), sock.getPort(), to, e);\n<line18>            }\n<line19>            Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line20>            retry--;\n<line21>        }\n<line22>        LOG.info(\"connected: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line23>        sock.setSoTimeout(30000);\n<line24>        target.setSoTimeout(30000);\n<line25>        workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line26>        workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line27>        for (PortForwardWorker worker : workers) {\n<line28>            workerExecutor.submit(worker);\n<line29>        }\n<line30>    } catch (SocketTimeoutException e) {\n<line31>        LOG.warn(\"socket timed out\", e);\n<line32>    } catch (ConnectException e) {\n<line33>        LOG.warn(\"connection exception local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to, e);\n<line34>        sock.close();\n<line35>    } catch (IOException e) {\n<line36>        if (!\"Socket closed\".equals(e.getMessage())) {\n<line37>            LOG.warn(\"unexpected exception local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to, e);\n<line38>            throw e;\n<line39>        }\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    sock = serverSocket.accept();\n<line3>    Socket target = null;\n<line4>    int retry = 10;\n<line5>    while (sock.isConnected()) {\n<line6>        try {\n<line7>            target = new Socket(\"localhost\", to);\n<line8>            break;\n<line9>        } catch (IOException e) {\n<line10>            if (retry == 0) {\n<line11>                throw e;\n<line12>            }\n<line13>        }\n<line14>        Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line15>        retry--;\n<line16>    }\n<line17>    sock.setSoTimeout(30000);\n<line18>    target.setSoTimeout(30000);\n<line19>    workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line20>    workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line21>    for (PortForwardWorker worker : workers) {\n<line22>        workerExecutor.submit(worker);\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    LOG.info(\"accepting socket local:{} to:{}\", serverSocket.getLocalPort(), to);\n<line3>    sock = serverSocket.accept();\n<line4>    LOG.info(\"accepted: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line5>    Socket target = null;\n<line6>    int retry = 10;\n<line7>    while (sock.isConnected()) {\n<line8>        try {\n<line9>            target = new Socket(\"localhost\", to);\n<line10>            break;\n<line11>        } catch (IOException e) {\n<line12>            if (retry == 0) {\n<line13>                throw e;\n<line14>            }\n<line15>            LOG.warn(\"connection failed, retrying({}): local:{} from:{} to:{}\", retry, sock.getLocalPort(), sock.getPort(), to, e);\n<line16>        }\n<line17>        Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n<line18>        retry--;\n<line19>    }\n<line20>    LOG.info(\"connected: local:{} from:{} to:{}\", sock.getLocalPort(), sock.getPort(), to);\n<line21>    sock.setSoTimeout(30000);\n<line22>    target.setSoTimeout(30000);\n<line23>    workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));\n<line24>    workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));\n<line25>    for (PortForwardWorker worker : workers) {\n<line26>        workerExecutor.submit(worker);\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception to:{}\", to, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted to:{}\", to, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    BinaryInputArchive ia;\n<line3>    int count;\n<line4>    {\n<line5>        DataTree tree = new DataTree();\n<line6>        SerializationPerfTest.createNodes(tree, \"/\", depth, width, tree.getNode(\"/\").stat.getCversion(), new byte[len]);\n<line7>        count = tree.getNodeCount();\n<line8>        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line9>        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);\n<line10>        tree.serialize(oa, \"test\");\n<line11>        baos.flush();\n<line12>        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n<line13>        ia = BinaryInputArchive.getArchive(bais);\n<line14>    }\n<line15>    DataTree dserTree = new DataTree();\n<line16>    System.gc();\n<line17>    long start = System.nanoTime();\n<line18>    dserTree.deserialize(ia, \"test\");\n<line19>    long end = System.nanoTime();\n<line20>    long durationms = (end - start) / 1000000L;\n<line21>    long pernodeus = ((end - start) / 1000L) / count;\n<line22>    assertEquals(count, dserTree.getNodeCount());\n<line23>}","output":"<line1>{\n<line2>    BinaryInputArchive ia;\n<line3>    int count;\n<line4>    {\n<line5>        DataTree tree = new DataTree();\n<line6>        SerializationPerfTest.createNodes(tree, \"/\", depth, width, tree.getNode(\"/\").stat.getCversion(), new byte[len]);\n<line7>        count = tree.getNodeCount();\n<line8>        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line9>        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);\n<line10>        tree.serialize(oa, \"test\");\n<line11>        baos.flush();\n<line12>        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n<line13>        ia = BinaryInputArchive.getArchive(bais);\n<line14>    }\n<line15>    DataTree dserTree = new DataTree();\n<line16>    System.gc();\n<line17>    long start = System.nanoTime();\n<line18>    dserTree.deserialize(ia, \"test\");\n<line19>    long end = System.nanoTime();\n<line20>    long durationms = (end - start) / 1000000L;\n<line21>    long pernodeus = ((end - start) / 1000L) / count;\n<line22>    assertEquals(count, dserTree.getNodeCount());\n<line23>    LOG.info(\"Deserialized {} nodes in {} ms ({}us/node), depth={} width={} datalen={}\", count, durationms, pernodeus, depth, width, len);\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(150);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line10>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line11>    try {\n<line12>        for (int i = 0; i < 2000; i++) {\n<line13>            zk.create(\"/crctest- \" + i, (\"/crctest- \" + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>        }\n<line15>    } finally {\n<line16>        zk.close();\n<line17>    }\n<line18>    f.shutdown();\n<line19>    zks.shutdown();\n<line20>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line21>    File versionDir = new File(tmpDir, \"version-2\");\n<line22>    File[] list = versionDir.listFiles();\n<line23>    //there should be only two files\n<line24>    // one the snapshot and the other logFile\n<line25>    File snapFile = null;\n<line26>    File logFile = null;\n<line27>    for (File file : list) {\n<line28>        if (file.getName().startsWith(\"log\")) {\n<line29>            logFile = file;\n<line30>            corruptFile(logFile);\n<line31>        }\n<line32>    }\n<line33>    FileTxnLog flog = new FileTxnLog(versionDir);\n<line34>    //we will get a checksum failure\n<line35>    try {\n<line36>        while (itr.next()) {\n<line37>            // no op\n<line38>        }\n<line39>        fail();\n<line40>    } catch (IOException ie) {\n<line41>    }\n<line42>    itr.close();\n<line43>    // find the last snapshot\n<line44>    FileSnap snap = new FileSnap(versionDir);\n<line45>    List<File> snapFiles = snap.findNRecentSnapshots(2);\n<line46>    snapFile = snapFiles.get(0);\n<line47>    corruptFile(snapFile);\n<line48>    boolean cfile;\n<line49>    try {\n<line50>        cfile = getCheckSum(snapFile);\n<line51>    } catch (IOException ie) {\n<line52>        //the last snapshot seems incomplete\n<line53>        // corrupt the last but one\n<line54>        // and use that\n<line55>        snapFile = snapFiles.get(1);\n<line56>        corruptFile(snapFile);\n<line57>        cfile = getCheckSum(snapFile);\n<line58>    }\n<line59>    assertTrue(cfile);\n<line60>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line5>    SyncRequestProcessor.setSnapCount(150);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line10>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line11>    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line12>    try {\n<line13>        for (int i = 0; i < 2000; i++) {\n<line14>            zk.create(\"/crctest- \" + i, (\"/crctest- \" + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line15>        }\n<line16>    } finally {\n<line17>        zk.close();\n<line18>    }\n<line19>    f.shutdown();\n<line20>    zks.shutdown();\n<line21>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server down\");\n<line22>    File versionDir = new File(tmpDir, \"version-2\");\n<line23>    File[] list = versionDir.listFiles();\n<line24>    //there should be only two files\n<line25>    // one the snapshot and the other logFile\n<line26>    File snapFile = null;\n<line27>    File logFile = null;\n<line28>    for (File file : list) {\n<line29>        LOG.info(\"file is {}\", file);\n<line30>        if (file.getName().startsWith(\"log\")) {\n<line31>            logFile = file;\n<line32>            corruptFile(logFile);\n<line33>        }\n<line34>    }\n<line35>    FileTxnLog flog = new FileTxnLog(versionDir);\n<line36>    TxnIterator itr = flog.read(1);\n<line37>    //we will get a checksum failure\n<line38>    try {\n<line39>        while (itr.next()) {\n<line40>            // no op\n<line41>        }\n<line42>        fail();\n<line43>    } catch (IOException ie) {\n<line44>        LOG.warn(\"crc corruption\", ie);\n<line45>    }\n<line46>    itr.close();\n<line47>    // find the last snapshot\n<line48>    FileSnap snap = new FileSnap(versionDir);\n<line49>    List<File> snapFiles = snap.findNRecentSnapshots(2);\n<line50>    snapFile = snapFiles.get(0);\n<line51>    corruptFile(snapFile);\n<line52>    boolean cfile;\n<line53>    try {\n<line54>        cfile = getCheckSum(snapFile);\n<line55>    } catch (IOException ie) {\n<line56>        //the last snapshot seems incomplete\n<line57>        // corrupt the last but one\n<line58>        // and use that\n<line59>        snapFile = snapFiles.get(1);\n<line60>        corruptFile(snapFile);\n<line61>        cfile = getCheckSum(snapFile);\n<line62>    }\n<line63>    assertTrue(cfile);\n<line64>}"},{"input":"","instruction":"<line1>{\n<line2>    if (file.getName().startsWith(\"log\")) {\n<line3>        logFile = file;\n<line4>        corruptFile(logFile);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"file is {}\", file);\n<line3>    if (file.getName().startsWith(\"log\")) {\n<line4>        logFile = file;\n<line5>        corruptFile(logFile);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeper zk = createClient();\n<line3>    try {\n<line4>        for (int i = 0; i < 2000; i++) {\n<line5>            zk.create(\"/invalidsnap-\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>        }\n<line7>    } finally {\n<line8>        zk.close();\n<line9>    }\n<line10>    NIOServerCnxnFactory factory = (NIOServerCnxnFactory) serverFactory;\n<line11>    stopServer();\n<line12>    // now corrupt the snapshot\n<line13>    File snapFile = factory.zkServer.getTxnLogFactory().findMostRecentSnapshot();\n<line14>    RandomAccessFile raf = new RandomAccessFile(snapFile, \"rws\");\n<line15>    raf.setLength(3);\n<line16>    raf.close();\n<line17>    // now restart the server\n<line18>    startServer();\n<line19>    // verify that the expected data exists and wasn't lost\n<line20>    zk = createClient();\n<line21>    try {\n<line22>        assertTrue((zk.exists(\"/invalidsnap-1999\", false) != null), \"the node should exist\");\n<line23>    } finally {\n<line24>        zk.close();\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    ZooKeeper zk = createClient();\n<line3>    try {\n<line4>        for (int i = 0; i < 2000; i++) {\n<line5>            zk.create(\"/invalidsnap-\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>        }\n<line7>    } finally {\n<line8>        zk.close();\n<line9>    }\n<line10>    NIOServerCnxnFactory factory = (NIOServerCnxnFactory) serverFactory;\n<line11>    stopServer();\n<line12>    // now corrupt the snapshot\n<line13>    File snapFile = factory.zkServer.getTxnLogFactory().findMostRecentSnapshot();\n<line14>    LOG.info(\"Corrupting {}\", snapFile);\n<line15>    RandomAccessFile raf = new RandomAccessFile(snapFile, \"rws\");\n<line16>    raf.setLength(3);\n<line17>    raf.close();\n<line18>    // now restart the server\n<line19>    startServer();\n<line20>    // verify that the expected data exists and wasn't lost\n<line21>    zk = createClient();\n<line22>    try {\n<line23>        assertTrue((zk.exists(\"/invalidsnap-1999\", false) != null), \"the node should exist\");\n<line24>    } finally {\n<line25>        zk.close();\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    Security.addProvider(new BouncyCastleProvider());\n<line3>    File tmpDir = null;\n<line4>    X509TestContext x509TestContext = null;\n<line5>    try {\n<line6>        tmpDir = ClientBase.createEmptyTestDir();\n<line7>        x509TestContext = X509TestContext.newBuilder().setTempDir(tmpDir).setKeyStorePassword(\"\").setKeyStoreKeyType(X509KeyType.EC).setTrustStorePassword(\"\").setTrustStoreKeyType(X509KeyType.EC).build();\n<line8>        System.setProperty(\"zookeeper.ssl.quorum.keyStore.location\", x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath());\n<line9>        System.setProperty(\"zookeeper.ssl.quorum.trustStore.location\", x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath());\n<line10>    } catch (Exception e) {\n<line11>    }\n<line12>    System.setProperty(\"zookeeper.ssl.quorum.keyStore.password\", \"\");\n<line13>    System.setProperty(\"zookeeper.ssl.quorum.keyStore.type\", \"PEM\");\n<line14>    System.setProperty(\"zookeeper.ssl.quorum.trustStore.password\", \"\");\n<line15>    System.setProperty(\"zookeeper.ssl.quorum.trustStore.type\", \"PEM\");\n<line16>    System.setProperty(\"zookeeper.admin.portUnification\", \"true\");\n<line17>    // Create a trust manager that does not validate certificate chains\n<line18>    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n<line19>\n<line20>        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n<line21>            return null;\n<line22>        }\n<line23>\n<line24>        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n<line25>        }\n<line26>\n<line27>        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n<line28>        }\n<line29>    } };\n<line30>    // Create all-trusting trust manager\n<line31>    SSLContext sc = null;\n<line32>    try {\n<line33>        sc = SSLContext.getInstance(\"SSL\");\n<line34>        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n<line35>    } catch (Exception e) {\n<line36>    }\n<line37>    // Create all-trusting hostname verifier\n<line38>    HostnameVerifier allValid = new HostnameVerifier() {\n<line39>\n<line40>        public boolean verify(String hostname, SSLSession session) {\n<line41>            return true;\n<line42>        }\n<line43>    };\n<line44>    // This is a temporary fix while we do not yet have certificates set up to make\n<line45>    // HTTPS requests correctly. This is equivalent to the \"-k\" option in curl.\n<line46>    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n<line47>    HttpsURLConnection.setDefaultHostnameVerifier(allValid);\n<line48>}","output":"<line1>{\n<line2>    Security.addProvider(new BouncyCastleProvider());\n<line3>    File tmpDir = null;\n<line4>    X509TestContext x509TestContext = null;\n<line5>    try {\n<line6>        tmpDir = ClientBase.createEmptyTestDir();\n<line7>        x509TestContext = X509TestContext.newBuilder().setTempDir(tmpDir).setKeyStorePassword(\"\").setKeyStoreKeyType(X509KeyType.EC).setTrustStorePassword(\"\").setTrustStoreKeyType(X509KeyType.EC).build();\n<line8>        System.setProperty(\"zookeeper.ssl.quorum.keyStore.location\", x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath());\n<line9>        System.setProperty(\"zookeeper.ssl.quorum.trustStore.location\", x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath());\n<line10>    } catch (Exception e) {\n<line11>        LOG.info(\"Problems encountered while setting up encryption for Jetty admin server test\", e);\n<line12>    }\n<line13>    System.setProperty(\"zookeeper.ssl.quorum.keyStore.password\", \"\");\n<line14>    System.setProperty(\"zookeeper.ssl.quorum.keyStore.type\", \"PEM\");\n<line15>    System.setProperty(\"zookeeper.ssl.quorum.trustStore.password\", \"\");\n<line16>    System.setProperty(\"zookeeper.ssl.quorum.trustStore.type\", \"PEM\");\n<line17>    System.setProperty(\"zookeeper.admin.portUnification\", \"true\");\n<line18>    // Create a trust manager that does not validate certificate chains\n<line19>    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n<line20>\n<line21>        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n<line22>            return null;\n<line23>        }\n<line24>\n<line25>        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n<line26>        }\n<line27>\n<line28>        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n<line29>        }\n<line30>    } };\n<line31>    // Create all-trusting trust manager\n<line32>    SSLContext sc = null;\n<line33>    try {\n<line34>        sc = SSLContext.getInstance(\"SSL\");\n<line35>        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n<line36>    } catch (Exception e) {\n<line37>        LOG.error(\"Failed to customize encryption for HTTPS\", e);\n<line38>    }\n<line39>    // Create all-trusting hostname verifier\n<line40>    HostnameVerifier allValid = new HostnameVerifier() {\n<line41>\n<line42>        public boolean verify(String hostname, SSLSession session) {\n<line43>            return true;\n<line44>        }\n<line45>    };\n<line46>    // This is a temporary fix while we do not yet have certificates set up to make\n<line47>    // HTTPS requests correctly. This is equivalent to the \"-k\" option in curl.\n<line48>    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n<line49>    HttpsURLConnection.setDefaultHostnameVerifier(allValid);\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Problems encountered while setting up encryption for Jetty admin server test\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to customize encryption for HTTPS\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final int threadCount = 2;\n<line3>    final int nodeCount = 50;\n<line4>    final String restoreTestPath = \"/restore_test\";\n<line5>    // take snapshot\n<line6>    final File snapshotFile = takeSnapshotAndValidate(jettyAdminPort, dataDir);\n<line7>    final ExecutorService service = Executors.newFixedThreadPool(threadCount);\n<line8>    final CountDownLatch latch = new CountDownLatch(threadCount);\n<line9>    final AtomicBoolean createSucceeded = new AtomicBoolean(false);\n<line10>    final AtomicBoolean restoreSucceeded = new AtomicBoolean(false);\n<line11>    // thread 1 creates data\n<line12>    service.submit(() -> {\n<line13>        try {\n<line14>            createData(zk, restoreTestPath, nodeCount);\n<line15>            createSucceeded.set(true);\n<line16>        } catch (final Exception e) {\n<line17>            e.printStackTrace();\n<line18>        } finally {\n<line19>            latch.countDown();\n<line20>        }\n<line21>    });\n<line22>    // thread 2 performs restore operation\n<line23>    service.submit(() -> {\n<line24>        try {\n<line25>            performRestoreAndValidate(jettyAdminPort, snapshotFile);\n<line26>            restoreSucceeded.set(true);\n<line27>        } catch (final Exception e) {\n<line28>            e.printStackTrace();\n<line29>        } finally {\n<line30>            latch.countDown();\n<line31>        }\n<line32>    });\n<line33>    // wait for operations completed\n<line34>    latch.await();\n<line35>    // validate all client requests succeeded\n<line36>    if (createSucceeded.get() && restoreSucceeded.get()) {\n<line37>        assertEquals(nodeCount, zk.getAllChildrenNumber(restoreTestPath));\n<line38>    }\n<line39>}","output":"<line1>{\n<line2>    final int threadCount = 2;\n<line3>    final int nodeCount = 50;\n<line4>    final String restoreTestPath = \"/restore_test\";\n<line5>    // take snapshot\n<line6>    final File snapshotFile = takeSnapshotAndValidate(jettyAdminPort, dataDir);\n<line7>    final ExecutorService service = Executors.newFixedThreadPool(threadCount);\n<line8>    final CountDownLatch latch = new CountDownLatch(threadCount);\n<line9>    final AtomicBoolean createSucceeded = new AtomicBoolean(false);\n<line10>    final AtomicBoolean restoreSucceeded = new AtomicBoolean(false);\n<line11>    // thread 1 creates data\n<line12>    service.submit(() -> {\n<line13>        try {\n<line14>            createData(zk, restoreTestPath, nodeCount);\n<line15>            createSucceeded.set(true);\n<line16>        } catch (final Exception e) {\n<line17>            LOG.error(e.getMessage());\n<line18>            e.printStackTrace();\n<line19>        } finally {\n<line20>            latch.countDown();\n<line21>        }\n<line22>    });\n<line23>    // thread 2 performs restore operation\n<line24>    service.submit(() -> {\n<line25>        try {\n<line26>            performRestoreAndValidate(jettyAdminPort, snapshotFile);\n<line27>            restoreSucceeded.set(true);\n<line28>        } catch (final Exception e) {\n<line29>            LOG.error(e.getMessage());\n<line30>            e.printStackTrace();\n<line31>        } finally {\n<line32>            latch.countDown();\n<line33>        }\n<line34>    });\n<line35>    // wait for operations completed\n<line36>    latch.await();\n<line37>    // validate all client requests succeeded\n<line38>    if (createSucceeded.get() && restoreSucceeded.get()) {\n<line39>        assertEquals(nodeCount, zk.getAllChildrenNumber(restoreTestPath));\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        createData(zk, restoreTestPath, nodeCount);\n<line4>        createSucceeded.set(true);\n<line5>    } catch (final Exception e) {\n<line6>        e.printStackTrace();\n<line7>    } finally {\n<line8>        latch.countDown();\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    try {\n<line3>        createData(zk, restoreTestPath, nodeCount);\n<line4>        createSucceeded.set(true);\n<line5>    } catch (final Exception e) {\n<line6>        LOG.error(e.getMessage());\n<line7>        e.printStackTrace();\n<line8>    } finally {\n<line9>        latch.countDown();\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    e.printStackTrace();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(e.getMessage());\n<line3>    e.printStackTrace();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        performRestoreAndValidate(jettyAdminPort, snapshotFile);\n<line4>        restoreSucceeded.set(true);\n<line5>    } catch (final Exception e) {\n<line6>        e.printStackTrace();\n<line7>    } finally {\n<line8>        latch.countDown();\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    try {\n<line3>        performRestoreAndValidate(jettyAdminPort, snapshotFile);\n<line4>        restoreSucceeded.set(true);\n<line5>    } catch (final Exception e) {\n<line6>        LOG.error(e.getMessage());\n<line7>        e.printStackTrace();\n<line8>    } finally {\n<line9>        latch.countDown();\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    e.printStackTrace();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(e.getMessage());\n<line3>    e.printStackTrace();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    assertNotNull(conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_LAST_ZXID));\n<line3>    assertNotNull(conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE));\n<line4>    assertTrue(Integer.parseInt(conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE)) > 0);\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Header:{}, Value:{}\", Commands.SnapshotCommand.RESPONSE_HEADER_LAST_ZXID, conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_LAST_ZXID));\n<line3>    assertNotNull(conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_LAST_ZXID));\n<line4>    LOG.info(\"Header:{}, Value:{}\", Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE, conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE));\n<line5>    assertNotNull(conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE));\n<line6>    assertTrue(Integer.parseInt(conn.getHeaderField(Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE)) > 0);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    final StringBuilder sb = new StringBuilder();\n<line3>    try (final BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n<line4>        String inputLine;\n<line5>        while ((inputLine = in.readLine()) != null) {\n<line6>            sb.append(inputLine);\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    final StringBuilder sb = new StringBuilder();\n<line3>    try (final BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n<line4>        String inputLine;\n<line5>        while ((inputLine = in.readLine()) != null) {\n<line6>            sb.append(inputLine);\n<line7>        }\n<line8>        LOG.info(\"Response payload: {}\", sb);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    String inputLine;\n<line3>    while ((inputLine = in.readLine()) != null) {\n<line4>        sb.append(inputLine);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    String inputLine;\n<line3>    while ((inputLine = in.readLine()) != null) {\n<line4>        sb.append(inputLine);\n<line5>    }\n<line6>    LOG.info(\"Response payload: {}\", sb);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ClientBase.setupTestEnv();\n<line3>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line4>    SyncRequestProcessor.setSnapCount(30);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line9>    final ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line10>    final CountDownLatch doPurge = new CountDownLatch(1);\n<line11>    final CountDownLatch purgeFinished = new CountDownLatch(1);\n<line12>    final AtomicBoolean opFailed = new AtomicBoolean(false);\n<line13>    new Thread() {\n<line14>\n<line15>        public void run() {\n<line16>            try {\n<line17>                doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);\n<line18>                PurgeTxnLog.purge(tmpDir, tmpDir, 3);\n<line19>            } catch (IOException ioe) {\n<line20>                opFailed.set(true);\n<line21>            } catch (InterruptedException ie) {\n<line22>                opFailed.set(true);\n<line23>            } finally {\n<line24>                purgeFinished.countDown();\n<line25>            }\n<line26>        }\n<line27>    }.start();\n<line28>    final int thCount = 3;\n<line29>    List<String> znodes = manyClientOps(zk, doPurge, thCount, \"/invalidsnap\");\n<line30>    assertTrue(purgeFinished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS), \"Purging is not finished!\");\n<line31>    assertFalse(opFailed.get(), \"Purging failed!\");\n<line32>    for (String znode : znodes) {\n<line33>        try {\n<line34>            zk.getData(znode, false, null);\n<line35>        } catch (Exception ke) {\n<line36>            fail(\"Unexpected exception when visiting znode!\");\n<line37>        }\n<line38>    }\n<line39>    zk.close();\n<line40>    f.shutdown();\n<line41>    zks.shutdown();\n<line42>    zks.getTxnLogFactory().close();\n<line43>}","output":"<line1>{\n<line2>    ClientBase.setupTestEnv();\n<line3>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line4>    SyncRequestProcessor.setSnapCount(30);\n<line5>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line6>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line7>    f.startup(zks);\n<line8>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line9>    final ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n<line10>    final CountDownLatch doPurge = new CountDownLatch(1);\n<line11>    final CountDownLatch purgeFinished = new CountDownLatch(1);\n<line12>    final AtomicBoolean opFailed = new AtomicBoolean(false);\n<line13>    new Thread() {\n<line14>\n<line15>        public void run() {\n<line16>            try {\n<line17>                doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);\n<line18>                PurgeTxnLog.purge(tmpDir, tmpDir, 3);\n<line19>            } catch (IOException ioe) {\n<line20>                LOG.error(\"Exception when purge\", ioe);\n<line21>                opFailed.set(true);\n<line22>            } catch (InterruptedException ie) {\n<line23>                LOG.error(\"Exception when purge\", ie);\n<line24>                opFailed.set(true);\n<line25>            } finally {\n<line26>                purgeFinished.countDown();\n<line27>            }\n<line28>        }\n<line29>    }.start();\n<line30>    final int thCount = 3;\n<line31>    List<String> znodes = manyClientOps(zk, doPurge, thCount, \"/invalidsnap\");\n<line32>    assertTrue(purgeFinished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS), \"Purging is not finished!\");\n<line33>    assertFalse(opFailed.get(), \"Purging failed!\");\n<line34>    for (String znode : znodes) {\n<line35>        try {\n<line36>            zk.getData(znode, false, null);\n<line37>        } catch (Exception ke) {\n<line38>            LOG.error(\"Unexpected exception when visiting znode!\", ke);\n<line39>            fail(\"Unexpected exception when visiting znode!\");\n<line40>        }\n<line41>    }\n<line42>    zk.close();\n<line43>    f.shutdown();\n<line44>    zks.shutdown();\n<line45>    zks.getTxnLogFactory().close();\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);\n<line4>        PurgeTxnLog.purge(tmpDir, tmpDir, 3);\n<line5>    } catch (IOException ioe) {\n<line6>        opFailed.set(true);\n<line7>    } catch (InterruptedException ie) {\n<line8>        opFailed.set(true);\n<line9>    } finally {\n<line10>        purgeFinished.countDown();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);\n<line4>        PurgeTxnLog.purge(tmpDir, tmpDir, 3);\n<line5>    } catch (IOException ioe) {\n<line6>        LOG.error(\"Exception when purge\", ioe);\n<line7>        opFailed.set(true);\n<line8>    } catch (InterruptedException ie) {\n<line9>        LOG.error(\"Exception when purge\", ie);\n<line10>        opFailed.set(true);\n<line11>    } finally {\n<line12>        purgeFinished.countDown();\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    opFailed.set(true);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception when purge\", ioe);\n<line3>    opFailed.set(true);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    opFailed.set(true);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception when purge\", ie);\n<line3>    opFailed.set(true);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zk.getData(znode, false, null);\n<line4>    } catch (Exception ke) {\n<line5>        fail(\"Unexpected exception when visiting znode!\");\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        zk.getData(znode, false, null);\n<line4>    } catch (Exception ke) {\n<line5>        LOG.error(\"Unexpected exception when visiting znode!\", ke);\n<line6>        fail(\"Unexpected exception when visiting znode!\");\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"Unexpected exception when visiting znode!\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception when visiting znode!\", ke);\n<line3>    fail(\"Unexpected exception when visiting znode!\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread[] ths = new Thread[thCount];\n<line3>    final List<String> znodes = Collections.synchronizedList(new ArrayList<>());\n<line4>    final CountDownLatch finished = new CountDownLatch(thCount);\n<line5>    final AtomicReference<Exception> exception = new AtomicReference<>();\n<line6>    for (int indx = 0; indx < thCount; indx++) {\n<line7>        final String myprefix = prefix + \"-\" + indx;\n<line8>        Thread th = new Thread(() -> {\n<line9>            for (int i = 0; i < 750; i++) {\n<line10>                try {\n<line11>                    String mynode = myprefix + \"-\" + i;\n<line12>                    znodes.add(mynode);\n<line13>                    zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>                } catch (Exception e) {\n<line15>                    exception.set(e);\n<line16>                }\n<line17>                if (i == 200) {\n<line18>                    doPurge.countDown();\n<line19>                }\n<line20>            }\n<line21>            finished.countDown();\n<line22>        });\n<line23>        ths[indx] = th;\n<line24>    }\n<line25>    for (Thread thread : ths) {\n<line26>        thread.start();\n<line27>    }\n<line28>    try {\n<line29>        boolean operationsFinishedSuccessfully = finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS);\n<line30>        if (exception.get() != null) {\n<line31>            fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n<line32>        }\n<line33>        assertTrue(operationsFinishedSuccessfully, \"ZkClient ops not finished in time!\");\n<line34>    } catch (InterruptedException ie) {\n<line35>        fail(\"Unexpected exception occurred!\");\n<line36>    }\n<line37>    return znodes;\n<line38>}","output":"<line1>{\n<line2>    Thread[] ths = new Thread[thCount];\n<line3>    final List<String> znodes = Collections.synchronizedList(new ArrayList<>());\n<line4>    final CountDownLatch finished = new CountDownLatch(thCount);\n<line5>    final AtomicReference<Exception> exception = new AtomicReference<>();\n<line6>    for (int indx = 0; indx < thCount; indx++) {\n<line7>        final String myprefix = prefix + \"-\" + indx;\n<line8>        Thread th = new Thread(() -> {\n<line9>            for (int i = 0; i < 750; i++) {\n<line10>                try {\n<line11>                    String mynode = myprefix + \"-\" + i;\n<line12>                    znodes.add(mynode);\n<line13>                    zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line14>                } catch (Exception e) {\n<line15>                    LOG.error(\"Unexpected exception during ZkClient ops\", e);\n<line16>                    exception.set(e);\n<line17>                }\n<line18>                if (i == 200) {\n<line19>                    doPurge.countDown();\n<line20>                }\n<line21>            }\n<line22>            finished.countDown();\n<line23>        });\n<line24>        ths[indx] = th;\n<line25>    }\n<line26>    for (Thread thread : ths) {\n<line27>        thread.start();\n<line28>    }\n<line29>    try {\n<line30>        boolean operationsFinishedSuccessfully = finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS);\n<line31>        if (exception.get() != null) {\n<line32>            LOG.error(\"unexpected exception during running ZkClient ops:\", exception.get());\n<line33>            fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n<line34>        }\n<line35>        assertTrue(operationsFinishedSuccessfully, \"ZkClient ops not finished in time!\");\n<line36>    } catch (InterruptedException ie) {\n<line37>        LOG.error(\"Unexpected exception\", ie);\n<line38>        fail(\"Unexpected exception occurred!\");\n<line39>    }\n<line40>    return znodes;\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    final String myprefix = prefix + \"-\" + indx;\n<line3>    Thread th = new Thread(() -> {\n<line4>        for (int i = 0; i < 750; i++) {\n<line5>            try {\n<line6>                String mynode = myprefix + \"-\" + i;\n<line7>                znodes.add(mynode);\n<line8>                zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>            } catch (Exception e) {\n<line10>                exception.set(e);\n<line11>            }\n<line12>            if (i == 200) {\n<line13>                doPurge.countDown();\n<line14>            }\n<line15>        }\n<line16>        finished.countDown();\n<line17>    });\n<line18>    ths[indx] = th;\n<line19>}","output":"<line1>{\n<line2>    final String myprefix = prefix + \"-\" + indx;\n<line3>    Thread th = new Thread(() -> {\n<line4>        for (int i = 0; i < 750; i++) {\n<line5>            try {\n<line6>                String mynode = myprefix + \"-\" + i;\n<line7>                znodes.add(mynode);\n<line8>                zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>            } catch (Exception e) {\n<line10>                LOG.error(\"Unexpected exception during ZkClient ops\", e);\n<line11>                exception.set(e);\n<line12>            }\n<line13>            if (i == 200) {\n<line14>                doPurge.countDown();\n<line15>            }\n<line16>        }\n<line17>        finished.countDown();\n<line18>    });\n<line19>    ths[indx] = th;\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < 750; i++) {\n<line3>        try {\n<line4>            String mynode = myprefix + \"-\" + i;\n<line5>            znodes.add(mynode);\n<line6>            zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        } catch (Exception e) {\n<line8>            exception.set(e);\n<line9>        }\n<line10>        if (i == 200) {\n<line11>            doPurge.countDown();\n<line12>        }\n<line13>    }\n<line14>    finished.countDown();\n<line15>}","output":"<line1>{\n<line2>    for (int i = 0; i < 750; i++) {\n<line3>        try {\n<line4>            String mynode = myprefix + \"-\" + i;\n<line5>            znodes.add(mynode);\n<line6>            zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        } catch (Exception e) {\n<line8>            LOG.error(\"Unexpected exception during ZkClient ops\", e);\n<line9>            exception.set(e);\n<line10>        }\n<line11>        if (i == 200) {\n<line12>            doPurge.countDown();\n<line13>        }\n<line14>    }\n<line15>    finished.countDown();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String mynode = myprefix + \"-\" + i;\n<line4>        znodes.add(mynode);\n<line5>        zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    } catch (Exception e) {\n<line7>        exception.set(e);\n<line8>    }\n<line9>    if (i == 200) {\n<line10>        doPurge.countDown();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        String mynode = myprefix + \"-\" + i;\n<line4>        znodes.add(mynode);\n<line5>        zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    } catch (Exception e) {\n<line7>        LOG.error(\"Unexpected exception during ZkClient ops\", e);\n<line8>        exception.set(e);\n<line9>    }\n<line10>    if (i == 200) {\n<line11>        doPurge.countDown();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    exception.set(e);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception during ZkClient ops\", e);\n<line3>    exception.set(e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean operationsFinishedSuccessfully = finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS);\n<line3>    if (exception.get() != null) {\n<line4>        fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n<line5>    }\n<line6>    assertTrue(operationsFinishedSuccessfully, \"ZkClient ops not finished in time!\");\n<line7>}","output":"<line1>{\n<line2>    boolean operationsFinishedSuccessfully = finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS);\n<line3>    if (exception.get() != null) {\n<line4>        LOG.error(\"unexpected exception during running ZkClient ops:\", exception.get());\n<line5>        fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n<line6>    }\n<line7>    assertTrue(operationsFinishedSuccessfully, \"ZkClient ops not finished in time!\");\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"unexpected exception during running ZkClient ops:\", exception.get());\n<line3>    fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"Unexpected exception occurred!\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception\", ie);\n<line3>    fail(\"Unexpected exception occurred!\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // start a server and create a client\n<line3>    File tmpDir = ClientBase.createTmpDir();\n<line4>    ClientBase.setupTestEnv();\n<line5>    zks = new TestZooKeeperServer(tmpDir, tmpDir, 3000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line10>    resumeProcess = null;\n<line11>    submitted = null;\n<line12>    zk = ClientBase.createZKClient(HOSTPORT);\n<line13>}","output":"<line1>{\n<line2>    // start a server and create a client\n<line3>    File tmpDir = ClientBase.createTmpDir();\n<line4>    ClientBase.setupTestEnv();\n<line5>    zks = new TestZooKeeperServer(tmpDir, tmpDir, 3000);\n<line6>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line7>    f = ServerCnxnFactory.createFactory(PORT, -1);\n<line8>    f.startup(zks);\n<line9>    LOG.info(\"starting up the zookeeper server .. waiting\");\n<line10>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up\");\n<line11>    resumeProcess = null;\n<line12>    submitted = null;\n<line13>    zk = ClientBase.createZKClient(HOSTPORT);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    // we only allow two requests in the pipeline\n<line4>    RequestThrottler.setMaxRequests(2);\n<line5>    RequestThrottler.setStallTime(STALL_TIME);\n<line6>    RequestThrottler.setDropStaleRequests(true);\n<line7>    // no requests can go through the pipeline unless we raise the latch\n<line8>    resumeProcess = new CountDownLatch(1);\n<line9>    submitted = new CountDownLatch(TOTAL_REQUESTS);\n<line10>    throttled = new CountDownLatch(1);\n<line11>    throttling = new CountDownLatch(1);\n<line12>    // send 5 requests asynchronously\n<line13>    for (int i = 0; i < TOTAL_REQUESTS; i++) {\n<line14>        zk.create(\"/request_throttle_test- \" + i, (\"/request_throttle_test- \" + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {\n<line15>        }, null);\n<line16>    }\n<line17>    // make sure the server received all 5 requests\n<line18>    assertTrue(submitted.await(5, TimeUnit.SECONDS));\n<line19>    // stale throttled requests\n<line20>    assertTrue(throttling.await(5, TimeUnit.SECONDS));\n<line21>    for (ServerCnxn cnxn : f.cnxns) {\n<line22>        cnxn.setStale();\n<line23>    }\n<line24>    throttled.countDown();\n<line25>    zk = null;\n<line26>    // only first three requests are counted as finished\n<line27>    finished = new CountDownLatch(3);\n<line28>    // let the requests go through the pipeline\n<line29>    resumeProcess.countDown();\n<line30>    while (zks.getInflight() > 0) {\n<line31>        Thread.sleep(50);\n<line32>    }\n<line33>    assertTrue(finished.await(5, TimeUnit.SECONDS));\n<line34>    // assert after all requests processed to avoid concurrent issues as metrics are\n<line35>    // counted in different threads.\n<line36>    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n<line37>    // only two requests can get into the pipeline because of the throttler\n<line38>    assertEquals(2L, (long) metrics.get(\"prep_processor_request_queued\"));\n<line39>    // the rest of the 3 requests will be dropped\n<line40>    // but only the first one for a connection will be counted\n<line41>    assertEquals(1L, (long) metrics.get(\"request_throttle_wait_count\"));\n<line42>    assertEquals(1, (long) metrics.get(\"stale_requests_dropped\"));\n<line43>}","output":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    // we only allow two requests in the pipeline\n<line4>    RequestThrottler.setMaxRequests(2);\n<line5>    RequestThrottler.setStallTime(STALL_TIME);\n<line6>    RequestThrottler.setDropStaleRequests(true);\n<line7>    // no requests can go through the pipeline unless we raise the latch\n<line8>    resumeProcess = new CountDownLatch(1);\n<line9>    submitted = new CountDownLatch(TOTAL_REQUESTS);\n<line10>    throttled = new CountDownLatch(1);\n<line11>    throttling = new CountDownLatch(1);\n<line12>    // send 5 requests asynchronously\n<line13>    for (int i = 0; i < TOTAL_REQUESTS; i++) {\n<line14>        zk.create(\"/request_throttle_test- \" + i, (\"/request_throttle_test- \" + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {\n<line15>        }, null);\n<line16>    }\n<line17>    // make sure the server received all 5 requests\n<line18>    assertTrue(submitted.await(5, TimeUnit.SECONDS));\n<line19>    // stale throttled requests\n<line20>    assertTrue(throttling.await(5, TimeUnit.SECONDS));\n<line21>    for (ServerCnxn cnxn : f.cnxns) {\n<line22>        cnxn.setStale();\n<line23>    }\n<line24>    throttled.countDown();\n<line25>    zk = null;\n<line26>    // only first three requests are counted as finished\n<line27>    finished = new CountDownLatch(3);\n<line28>    // let the requests go through the pipeline\n<line29>    resumeProcess.countDown();\n<line30>    LOG.info(\"raise the latch\");\n<line31>    while (zks.getInflight() > 0) {\n<line32>        Thread.sleep(50);\n<line33>    }\n<line34>    assertTrue(finished.await(5, TimeUnit.SECONDS));\n<line35>    // assert after all requests processed to avoid concurrent issues as metrics are\n<line36>    // counted in different threads.\n<line37>    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n<line38>    // only two requests can get into the pipeline because of the throttler\n<line39>    assertEquals(2L, (long) metrics.get(\"prep_processor_request_queued\"));\n<line40>    // the rest of the 3 requests will be dropped\n<line41>    // but only the first one for a connection will be counted\n<line42>    assertEquals(1L, (long) metrics.get(\"request_throttle_wait_count\"));\n<line43>    assertEquals(1, (long) metrics.get(\"stale_requests_dropped\"));\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    TxnHeader hdr = request.getHdr();\n<line3>    if (hdr != null && hdr.getZxid() == skipAppendZxid) {\n<line4>        return true;\n<line5>    }\n<line6>    return invocation.proceed(request);\n<line7>}","output":"<line1>{\n<line2>    TxnHeader hdr = request.getHdr();\n<line3>    if (hdr != null && hdr.getZxid() == skipAppendZxid) {\n<line4>        LOG.info(\"skipping txn {}\", skipAppendZxid);\n<line5>        return true;\n<line6>    }\n<line7>    return invocation.proceed(request);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return true;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"skipping txn {}\", skipAppendZxid);\n<line3>    return true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int maxTokens = 5;\n<line3>    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());\n<line4>    throttler.setMaxTokens(maxTokens);\n<line5>    throttler.setFillCount(maxTokens);\n<line6>    throttler.setFillTime(1000);\n<line7>    throttler.setFreezeTime(100);\n<line8>    throttler.setDropIncrease(0.5);\n<line9>    for (int i = 0; i < maxTokens; i++) {\n<line10>        throttler.checkLimit(1);\n<line11>    }\n<line12>    assertEquals(throttler.getMaxTokens(), throttler.getDeficit(), \"All tokens should be used up by now\");\n<line13>    Thread.sleep(120);\n<line14>    //this will trigger dropping probability being increased\n<line15>    throttler.checkLimit(1);\n<line16>    assertTrue(throttler.getDropChance() > 0, \"Dropping probability should be increased\");\n<line17>    //allow bucket to be refilled\n<line18>    Thread.sleep(1100);\n<line19>    int accepted = 0;\n<line20>    for (int i = 0; i < maxTokens; i++) {\n<line21>        if (throttler.checkLimit(1)) {\n<line22>            accepted++;\n<line23>        }\n<line24>    }\n<line25>    assertTrue(accepted < maxTokens, \"The dropping should be distributed\");\n<line26>    accepted = 0;\n<line27>    for (int i = 0; i < maxTokens; i++) {\n<line28>        if (throttler.checkLimit(1)) {\n<line29>            accepted++;\n<line30>        }\n<line31>    }\n<line32>    assertTrue(accepted > 0, \"Later requests should have a chance\");\n<line33>}","output":"<line1>{\n<line2>    int maxTokens = 5;\n<line3>    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());\n<line4>    throttler.setMaxTokens(maxTokens);\n<line5>    throttler.setFillCount(maxTokens);\n<line6>    throttler.setFillTime(1000);\n<line7>    throttler.setFreezeTime(100);\n<line8>    throttler.setDropIncrease(0.5);\n<line9>    for (int i = 0; i < maxTokens; i++) {\n<line10>        throttler.checkLimit(1);\n<line11>    }\n<line12>    assertEquals(throttler.getMaxTokens(), throttler.getDeficit(), \"All tokens should be used up by now\");\n<line13>    Thread.sleep(120);\n<line14>    //this will trigger dropping probability being increased\n<line15>    throttler.checkLimit(1);\n<line16>    assertTrue(throttler.getDropChance() > 0, \"Dropping probability should be increased\");\n<line17>    LOG.info(\"Dropping probability is {}\", throttler.getDropChance());\n<line18>    //allow bucket to be refilled\n<line19>    Thread.sleep(1100);\n<line20>    LOG.info(\"Bucket is refilled with {} tokens.\", maxTokens);\n<line21>    int accepted = 0;\n<line22>    for (int i = 0; i < maxTokens; i++) {\n<line23>        if (throttler.checkLimit(1)) {\n<line24>            accepted++;\n<line25>        }\n<line26>    }\n<line27>    LOG.info(\"Send {} requests, {} are accepted\", maxTokens, accepted);\n<line28>    assertTrue(accepted < maxTokens, \"The dropping should be distributed\");\n<line29>    accepted = 0;\n<line30>    for (int i = 0; i < maxTokens; i++) {\n<line31>        if (throttler.checkLimit(1)) {\n<line32>            accepted++;\n<line33>        }\n<line34>    }\n<line35>    LOG.info(\"Send another {} requests, {} are accepted\", maxTokens, accepted);\n<line36>    assertTrue(accepted > 0, \"Later requests should have a chance\");\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    String connStr = quorumUtil.getConnectionStringForServer(1);\n<line3>    int connected = 0;\n<line4>    zks = new ZooKeeper[n];\n<line5>    watchers = new ClientBase.CountdownWatcher[n];\n<line6>    for (int i = 0; i < n; i++) {\n<line7>        watchers[i] = new ClientBase.CountdownWatcher();\n<line8>        zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);\n<line9>        try {\n<line10>            watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line11>            connected++;\n<line12>        } catch (TimeoutException e) {\n<line13>            break;\n<line14>        }\n<line15>    }\n<line16>    return connected;\n<line17>}","output":"<line1>{\n<line2>    String connStr = quorumUtil.getConnectionStringForServer(1);\n<line3>    int connected = 0;\n<line4>    zks = new ZooKeeper[n];\n<line5>    watchers = new ClientBase.CountdownWatcher[n];\n<line6>    for (int i = 0; i < n; i++) {\n<line7>        watchers[i] = new ClientBase.CountdownWatcher();\n<line8>        zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);\n<line9>        try {\n<line10>            watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line11>            connected++;\n<line12>        } catch (TimeoutException e) {\n<line13>            LOG.info(\"Connection denied by the throttler due to insufficient tokens\");\n<line14>            break;\n<line15>        }\n<line16>    }\n<line17>    return connected;\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    watchers[i] = new ClientBase.CountdownWatcher();\n<line3>    zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);\n<line4>    try {\n<line5>        watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line6>        connected++;\n<line7>    } catch (TimeoutException e) {\n<line8>        break;\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    watchers[i] = new ClientBase.CountdownWatcher();\n<line3>    zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);\n<line4>    try {\n<line5>        watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line6>        connected++;\n<line7>    } catch (TimeoutException e) {\n<line8>        LOG.info(\"Connection denied by the throttler due to insufficient tokens\");\n<line9>        break;\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Connection denied by the throttler due to insufficient tokens\");\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // this test depends on the session weights set to the default values\n<line3>    // 3 for global session, 2 for renew sessions, 1 for local sessions\n<line4>    BlueThrottle.setConnectionWeightEnabled(true);\n<line5>    quorumUtil.enableLocalSession(true);\n<line6>    quorumUtil.startAll();\n<line7>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);\n<line8>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line9>    //try to create 11 local sessions, 10 created, because we have only 10 tokens\n<line10>    int connected = connect(11);\n<line11>    assertEquals(10, connected);\n<line12>    shutdownQuorum();\n<line13>    quorumUtil.enableLocalSession(false);\n<line14>    quorumUtil.startAll();\n<line15>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);\n<line16>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line17>    //tyr to create 11 global sessions, 3 created, because we have 10 tokens and each connection needs 3\n<line18>    connected = connect(11);\n<line19>    assertEquals(3, connected);\n<line20>    shutdownQuorum();\n<line21>    quorumUtil.startAll();\n<line22>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);\n<line23>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line24>    connected = connect(2);\n<line25>    assertEquals(2, connected);\n<line26>    quorumUtil.shutdown(1);\n<line27>    watchers[0].waitForDisconnected(RAPID_TIMEOUT);\n<line28>    watchers[1].waitForDisconnected(RAPID_TIMEOUT);\n<line29>    quorumUtil.restart(1);\n<line30>    //client will try to reconnect\n<line31>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(3);\n<line32>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line33>    int reconnected = 0;\n<line34>    for (int i = 0; i < 2; i++) {\n<line35>        try {\n<line36>            watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line37>            reconnected++;\n<line38>        } catch (TimeoutException e) {\n<line39>        }\n<line40>    }\n<line41>    //each reconnect takes two tokens, we have 3, so only one reconnects\n<line42>    assertEquals(1, reconnected);\n<line43>    shutdownQuorum();\n<line44>}","output":"<line1>{\n<line2>    // this test depends on the session weights set to the default values\n<line3>    // 3 for global session, 2 for renew sessions, 1 for local sessions\n<line4>    BlueThrottle.setConnectionWeightEnabled(true);\n<line5>    quorumUtil.enableLocalSession(true);\n<line6>    quorumUtil.startAll();\n<line7>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);\n<line8>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line9>    //try to create 11 local sessions, 10 created, because we have only 10 tokens\n<line10>    int connected = connect(11);\n<line11>    assertEquals(10, connected);\n<line12>    shutdownQuorum();\n<line13>    quorumUtil.enableLocalSession(false);\n<line14>    quorumUtil.startAll();\n<line15>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);\n<line16>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line17>    //tyr to create 11 global sessions, 3 created, because we have 10 tokens and each connection needs 3\n<line18>    connected = connect(11);\n<line19>    assertEquals(3, connected);\n<line20>    shutdownQuorum();\n<line21>    quorumUtil.startAll();\n<line22>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);\n<line23>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line24>    connected = connect(2);\n<line25>    assertEquals(2, connected);\n<line26>    quorumUtil.shutdown(1);\n<line27>    watchers[0].waitForDisconnected(RAPID_TIMEOUT);\n<line28>    watchers[1].waitForDisconnected(RAPID_TIMEOUT);\n<line29>    quorumUtil.restart(1);\n<line30>    //client will try to reconnect\n<line31>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(3);\n<line32>    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);\n<line33>    int reconnected = 0;\n<line34>    for (int i = 0; i < 2; i++) {\n<line35>        try {\n<line36>            watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line37>            reconnected++;\n<line38>        } catch (TimeoutException e) {\n<line39>            LOG.info(\"One reconnect fails due to insufficient tokens\");\n<line40>        }\n<line41>    }\n<line42>    //each reconnect takes two tokens, we have 3, so only one reconnects\n<line43>    LOG.info(\"reconnected {}\", reconnected);\n<line44>    assertEquals(1, reconnected);\n<line45>    shutdownQuorum();\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line4>        reconnected++;\n<line5>    } catch (TimeoutException e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        watchers[i].waitForConnected(RAPID_TIMEOUT);\n<line4>        reconnected++;\n<line5>    } catch (TimeoutException e) {\n<line6>        LOG.info(\"One reconnect fails due to insufficient tokens\");\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"One reconnect fails due to insufficient tokens\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // NO-OP. Derived classes should override if required.\n<line3>}","output":"<line1>{\n<line2>    // NO-OP. Derived classes should override if required.\n<line3>    LOG.info(\"WatchedEvent: {}\", event);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // NO-OP. Derived classes to implement if required.\n<line3>}","output":"<line1>{\n<line2>    // NO-OP. Derived classes to implement if required.\n<line3>    LOG.info(\"StringCallback: {}, {}, {}, {}\", rc, path, ctx, name);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean shouldNotify = false;\n<line3>    synchronized (lockMe) {\n<line4>        if (!statesToWaitFor.isEmpty() && statesToWaitFor.getFirst() == event.getState()) {\n<line5>            statesToWaitFor.removeFirst();\n<line6>            shouldNotify = statesToWaitFor.isEmpty();\n<line7>        }\n<line8>    }\n<line9>    if (shouldNotify) {\n<line10>        notifyListener();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"State transition: {}\", event.getState());\n<line3>    boolean shouldNotify = false;\n<line4>    synchronized (lockMe) {\n<line5>        if (!statesToWaitFor.isEmpty() && statesToWaitFor.getFirst() == event.getState()) {\n<line6>            statesToWaitFor.removeFirst();\n<line7>            shouldNotify = statesToWaitFor.isEmpty();\n<line8>        }\n<line9>    }\n<line10>    if (shouldNotify) {\n<line11>        notifyListener();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (pathToNotifyOn != null && event.getType() == requiredEventType && pathToNotifyOn.equalsIgnoreCase(event.getPath())) {\n<line3>        notifyListener();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"WatchEvent {} for path {}\", event.getType(), event.getPath());\n<line3>    if (pathToNotifyOn != null && event.getType() == requiredEventType && pathToNotifyOn.equalsIgnoreCase(event.getPath())) {\n<line4>        notifyListener();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    startSimpleZKServer(startupDelayLatch);\n<line5>    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;\n<line6>    assertTrue(simplezks.waitForStartupInvocation(10), \"Failed to invoke zks#startup() method during server startup\");\n<line7>    CountdownWatcher watcher = new CountdownWatcher();\n<line8>    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);\n<line9>    assertFalse(simplezks.waitForSessionCreation(5), \"Since server is not fully started, zks#createSession() shouldn't be invoked\");\n<line10>    startupDelayLatch.countDown();\n<line11>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line12>    assertTrue(simplezks.waitForSessionCreation(5), \"Failed to invoke zks#createSession() method during client session creation\");\n<line13>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line14>    zkClient.close();\n<line15>}","output":"<line1>{\n<line2>    tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    startSimpleZKServer(startupDelayLatch);\n<line5>    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;\n<line6>    assertTrue(simplezks.waitForStartupInvocation(10), \"Failed to invoke zks#startup() method during server startup\");\n<line7>    CountdownWatcher watcher = new CountdownWatcher();\n<line8>    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);\n<line9>    assertFalse(simplezks.waitForSessionCreation(5), \"Since server is not fully started, zks#createSession() shouldn't be invoked\");\n<line10>    LOG.info(\"Decrements the count of the latch, so that server will proceed with startup\");\n<line11>    startupDelayLatch.countDown();\n<line12>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line13>    assertTrue(simplezks.waitForSessionCreation(5), \"Failed to invoke zks#createSession() method during client session creation\");\n<line14>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line15>    zkClient.close();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line5>    try {\n<line6>        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());\n<line7>        startSimpleZKServer(startupDelayLatch);\n<line8>        SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;\n<line9>        assertTrue(simplezks.waitForStartupInvocation(10), \"Failed to invoke zks#startup() method during server startup\");\n<line10>        CountdownWatcher watcher = new CountdownWatcher();\n<line11>        ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);\n<line12>        assertFalse(simplezks.waitForSessionCreation(5), \"Since server is not fully started, zks#createSession() shouldn't be invoked\");\n<line13>        startupDelayLatch.countDown();\n<line14>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line15>        assertTrue(simplezks.waitForSessionCreation(5), \"Failed to invoke zks#createSession() method during client session creation\");\n<line16>        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line17>        zkClient.close();\n<line18>    } finally {\n<line19>        // reset cnxn factory\n<line20>        if (originalServerCnxnFactory == null) {\n<line21>            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line22>            return;\n<line23>        }\n<line24>        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line5>    try {\n<line6>        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());\n<line7>        startSimpleZKServer(startupDelayLatch);\n<line8>        SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;\n<line9>        assertTrue(simplezks.waitForStartupInvocation(10), \"Failed to invoke zks#startup() method during server startup\");\n<line10>        CountdownWatcher watcher = new CountdownWatcher();\n<line11>        ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);\n<line12>        assertFalse(simplezks.waitForSessionCreation(5), \"Since server is not fully started, zks#createSession() shouldn't be invoked\");\n<line13>        LOG.info(\"Decrements the count of the latch, so that server will proceed with startup\");\n<line14>        startupDelayLatch.countDown();\n<line15>        assertTrue(ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line16>        assertTrue(simplezks.waitForSessionCreation(5), \"Failed to invoke zks#createSession() method during client session creation\");\n<line17>        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line18>        zkClient.close();\n<line19>    } finally {\n<line20>        // reset cnxn factory\n<line21>        if (originalServerCnxnFactory == null) {\n<line22>            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line23>            return;\n<line24>        }\n<line25>        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());\n<line3>    startSimpleZKServer(startupDelayLatch);\n<line4>    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;\n<line5>    assertTrue(simplezks.waitForStartupInvocation(10), \"Failed to invoke zks#startup() method during server startup\");\n<line6>    CountdownWatcher watcher = new CountdownWatcher();\n<line7>    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);\n<line8>    assertFalse(simplezks.waitForSessionCreation(5), \"Since server is not fully started, zks#createSession() shouldn't be invoked\");\n<line9>    startupDelayLatch.countDown();\n<line10>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line11>    assertTrue(simplezks.waitForSessionCreation(5), \"Failed to invoke zks#createSession() method during client session creation\");\n<line12>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line13>    zkClient.close();\n<line14>}","output":"<line1>{\n<line2>    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());\n<line3>    startSimpleZKServer(startupDelayLatch);\n<line4>    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;\n<line5>    assertTrue(simplezks.waitForStartupInvocation(10), \"Failed to invoke zks#startup() method during server startup\");\n<line6>    CountdownWatcher watcher = new CountdownWatcher();\n<line7>    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);\n<line8>    assertFalse(simplezks.waitForSessionCreation(5), \"Since server is not fully started, zks#createSession() shouldn't be invoked\");\n<line9>    LOG.info(\"Decrements the count of the latch, so that server will proceed with startup\");\n<line10>    startupDelayLatch.countDown();\n<line11>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line12>    assertTrue(simplezks.waitForSessionCreation(5), \"Failed to invoke zks#createSession() method during client session creation\");\n<line13>    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line14>    zkClient.close();\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    assertTrue(resp.contains(expected), \"Unexpected response\");\n<line4>}","output":"<line1>{\n<line2>    String resp = sendRequest(cmd);\n<line3>    LOG.info(\"cmd {} expected {} got {}\", cmd, expected, resp);\n<line4>    assertTrue(resp.contains(expected), \"Unexpected response\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    zks = new SimpleZooKeeperServer(tmpDir, tmpDir, 3000, startupDelayLatch);\n<line3>    SyncRequestProcessor.setSnapCount(100);\n<line4>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line5>    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);\n<line6>    Thread startupThread = new Thread() {\n<line7>\n<line8>        public void run() {\n<line9>            try {\n<line10>                servcnxnf.startup(zks);\n<line11>            } catch (IOException e) {\n<line12>                // Ignoring exception. If there is an ioexception\n<line13>                // then one of the following assertion will fail\n<line14>            } catch (InterruptedException e) {\n<line15>                // Ignoring exception. If there is an interrupted exception\n<line16>                // then one of the following assertion will fail\n<line17>            }\n<line18>        }\n<line19>    };\n<line20>    startupThread.start();\n<line21>}","output":"<line1>{\n<line2>    zks = new SimpleZooKeeperServer(tmpDir, tmpDir, 3000, startupDelayLatch);\n<line3>    SyncRequestProcessor.setSnapCount(100);\n<line4>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line5>    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);\n<line6>    Thread startupThread = new Thread() {\n<line7>\n<line8>        public void run() {\n<line9>            try {\n<line10>                servcnxnf.startup(zks);\n<line11>            } catch (IOException e) {\n<line12>                LOG.error(\"Unexcepted exception during server startup\", e);\n<line13>                // Ignoring exception. If there is an ioexception\n<line14>                // then one of the following assertion will fail\n<line15>            } catch (InterruptedException e) {\n<line16>                LOG.error(\"Unexcepted exception during server startup\", e);\n<line17>                // Ignoring exception. If there is an interrupted exception\n<line18>                // then one of the following assertion will fail\n<line19>            }\n<line20>        }\n<line21>    };\n<line22>    LOG.info(\"Starting zk server {}\", HOSTPORT);\n<line23>    startupThread.start();\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        servcnxnf.startup(zks);\n<line4>    } catch (IOException e) {\n<line5>        // Ignoring exception. If there is an ioexception\n<line6>        // then one of the following assertion will fail\n<line7>    } catch (InterruptedException e) {\n<line8>        // Ignoring exception. If there is an interrupted exception\n<line9>        // then one of the following assertion will fail\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    try {\n<line3>        servcnxnf.startup(zks);\n<line4>    } catch (IOException e) {\n<line5>        LOG.error(\"Unexcepted exception during server startup\", e);\n<line6>        // Ignoring exception. If there is an ioexception\n<line7>        // then one of the following assertion will fail\n<line8>    } catch (InterruptedException e) {\n<line9>        LOG.error(\"Unexcepted exception during server startup\", e);\n<line10>        // Ignoring exception. If there is an interrupted exception\n<line11>        // then one of the following assertion will fail\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    // Ignoring exception. If there is an ioexception\n<line3>    // then one of the following assertion will fail\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unexcepted exception during server startup\", e);\n<line3>    // Ignoring exception. If there is an ioexception\n<line4>    // then one of the following assertion will fail\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // Ignoring exception. If there is an interrupted exception\n<line3>    // then one of the following assertion will fail\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unexcepted exception during server startup\", e);\n<line3>    // Ignoring exception. If there is an interrupted exception\n<line4>    // then one of the following assertion will fail\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    DataTree tree = new DataTree();\n<line3>    createNodes(tree, \"/\", depth, width, tree.getNode(\"/\").stat.getCversion(), new byte[len]);\n<line4>    int count = tree.getNodeCount();\n<line5>    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(new NullOutputStream());\n<line6>    System.gc();\n<line7>    long start = System.nanoTime();\n<line8>    tree.serialize(oa, \"test\");\n<line9>    long end = System.nanoTime();\n<line10>    long durationms = (end - start) / 1000000L;\n<line11>    long pernodeus = ((end - start) / 1000L) / count;\n<line12>}","output":"<line1>{\n<line2>    DataTree tree = new DataTree();\n<line3>    createNodes(tree, \"/\", depth, width, tree.getNode(\"/\").stat.getCversion(), new byte[len]);\n<line4>    int count = tree.getNodeCount();\n<line5>    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(new NullOutputStream());\n<line6>    System.gc();\n<line7>    long start = System.nanoTime();\n<line8>    tree.serialize(oa, \"test\");\n<line9>    long end = System.nanoTime();\n<line10>    long durationms = (end - start) / 1000000L;\n<line11>    long pernodeus = ((end - start) / 1000L) / count;\n<line12>    LOG.info(\"Serialized {} nodes in {} ms ({}us/node), depth={} width={} datalen={}\", count, durationms, pernodeus, depth, width, len);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] args = new String[1];\n<line3>    args[0] = confFile.toString();\n<line4>    try {\n<line5>        main.initializeAndRun(args);\n<line6>    } catch (Exception e) {\n<line7>        // test will still fail even though we just log/ignore\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    String[] args = new String[1];\n<line3>    args[0] = confFile.toString();\n<line4>    try {\n<line5>        main.initializeAndRun(args);\n<line6>    } catch (Exception e) {\n<line7>        // test will still fail even though we just log/ignore\n<line8>        LOG.error(\"unexpected exception in run\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    // test will still fail even though we just log/ignore\n<line3>}","output":"<line1>{\n<line2>    // test will still fail even though we just log/ignore\n<line3>    LOG.error(\"unexpected exception in run\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    SyncRequestProcessor.setSnapCount(100);\n<line3>    ServerCnxnFactory cnxnFactory = startServer();\n<line4>    String connectString = \"127.0.0.1:\" + cnxnFactory.getLocalPort();\n<line5>    // Snapshot in load data.\n<line6>    assertEquals(1L, MetricsUtils.currentServerMetrics().get(\"cnt_snapshottime\"));\n<line7>    byte[] data = new byte[500];\n<line8>    ZooKeeper zk = ClientBase.createZKClient(connectString);\n<line9>    for (int i = 0; i < 150; i++) {\n<line10>        zk.create(\"/path\" + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line11>    }\n<line12>    // It is possible that above writes will trigger more than one snapshot due to randomization.\n<line13>    waitForMetric(\"cnt_snapshottime\", greaterThanOrEqualTo(2L), 10);\n<line14>    // Pauses snapshot and logs more txns.\n<line15>    cnxnFactory.getZooKeeperServer().getTxnLogFactory().snapLog.close();\n<line16>    zk.create(\"/\" + 1000, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line17>    zk.create(\"/\" + 1001, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line18>    // Restart server to count startup metrics.\n<line19>    cnxnFactory.shutdown();\n<line20>    ServerMetrics.getMetrics().resetAll();\n<line21>    cnxnFactory = startServer();\n<line22>    Map<String, Object> values = MetricsUtils.currentServerMetrics();\n<line23>    assertEquals(1L, values.get(\"cnt_startup_txns_loaded\"));\n<line24>    assertThat((long) values.get(\"max_startup_txns_loaded\"), greaterThan(0L));\n<line25>    assertEquals(1L, values.get(\"cnt_startup_txns_load_time\"));\n<line26>    assertThat((long) values.get(\"max_startup_txns_load_time\"), greaterThanOrEqualTo(0L));\n<line27>    assertEquals(1L, values.get(\"cnt_startup_snap_load_time\"));\n<line28>    assertThat((long) values.get(\"max_startup_snap_load_time\"), greaterThan(0L));\n<line29>    cnxnFactory.shutdown();\n<line30>}","output":"<line1>{\n<line2>    SyncRequestProcessor.setSnapCount(100);\n<line3>    ServerCnxnFactory cnxnFactory = startServer();\n<line4>    String connectString = \"127.0.0.1:\" + cnxnFactory.getLocalPort();\n<line5>    // Snapshot in load data.\n<line6>    assertEquals(1L, MetricsUtils.currentServerMetrics().get(\"cnt_snapshottime\"));\n<line7>    byte[] data = new byte[500];\n<line8>    ZooKeeper zk = ClientBase.createZKClient(connectString);\n<line9>    for (int i = 0; i < 150; i++) {\n<line10>        zk.create(\"/path\" + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line11>    }\n<line12>    // It is possible that above writes will trigger more than one snapshot due to randomization.\n<line13>    waitForMetric(\"cnt_snapshottime\", greaterThanOrEqualTo(2L), 10);\n<line14>    // Pauses snapshot and logs more txns.\n<line15>    cnxnFactory.getZooKeeperServer().getTxnLogFactory().snapLog.close();\n<line16>    zk.create(\"/\" + 1000, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line17>    zk.create(\"/\" + 1001, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line18>    // Restart server to count startup metrics.\n<line19>    cnxnFactory.shutdown();\n<line20>    ServerMetrics.getMetrics().resetAll();\n<line21>    cnxnFactory = startServer();\n<line22>    Map<String, Object> values = MetricsUtils.currentServerMetrics();\n<line23>    LOG.info(\"txn loaded during start up {}\", values.get(\"max_startup_txns_loaded\"));\n<line24>    assertEquals(1L, values.get(\"cnt_startup_txns_loaded\"));\n<line25>    assertThat((long) values.get(\"max_startup_txns_loaded\"), greaterThan(0L));\n<line26>    assertEquals(1L, values.get(\"cnt_startup_txns_load_time\"));\n<line27>    assertThat((long) values.get(\"max_startup_txns_load_time\"), greaterThanOrEqualTo(0L));\n<line28>    assertEquals(1L, values.get(\"cnt_startup_snap_load_time\"));\n<line29>    assertThat((long) values.get(\"max_startup_snap_load_time\"), greaterThan(0L));\n<line30>    cnxnFactory.shutdown();\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    // Need to override preallocate set by setupTestEnv()\n<line5>    // We don't need to unset these values since each unit test run in\n<line6>    // a separate JVM instance\n<line7>    FileTxnLog.setPreallocSize(PREALLOCATE);\n<line8>    FileTxnLog.setTxnLogSizeLimit(LOG_SIZE_LIMIT);\n<line9>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line10>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line11>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line12>    f.startup(zks);\n<line13>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line14>    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);\n<line15>    // Generate transactions\n<line16>    HashSet<Long> zxids = new HashSet<>();\n<line17>    byte[] bytes = new byte[NODE_SIZE];\n<line18>    Random random = new Random();\n<line19>    random.nextBytes(bytes);\n<line20>    // We will create enough txn to generate 3 logs\n<line21>    long txnCount = LOG_SIZE_LIMIT / NODE_SIZE / 2 * 5;\n<line22>    try {\n<line23>        for (long i = 0; i < txnCount; i++) {\n<line24>            Stat stat = new Stat();\n<line25>            zk.create(\"/node-\" + i, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line26>            zk.getData(\"/node-\" + i, null, stat);\n<line27>            zxids.add(stat.getCzxid());\n<line28>        }\n<line29>    } finally {\n<line30>        zk.close();\n<line31>    }\n<line32>    // shutdown\n<line33>    f.shutdown();\n<line34>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server to shutdown\");\n<line35>    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);\n<line36>    File[] txnLogs = FileTxnLog.getLogFiles(logDir.listFiles(), 0);\n<line37>    assertEquals(3, txnLogs.length, \"Unexpected number of logs\");\n<line38>    // Log size should not exceed limit by more than one node size;\n<line39>    long threshold = LOG_SIZE_LIMIT + NODE_SIZE;\n<line40>    assertTrue(threshold > txnLogs[0].length(), \"Exceed log size limit: \" + txnLogs[0].length());\n<line41>    assertTrue(threshold > txnLogs[1].length(), \"Exceed log size limit \" + txnLogs[1].length());\n<line42>    // Start database only\n<line43>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line44>    zks.startdata();\n<line45>    ZKDatabase db = zks.getZKDatabase();\n<line46>    for (long i = 0; i < txnCount; i++) {\n<line47>        Stat stat = new Stat();\n<line48>        byte[] data = db.getData(\"/node-\" + i, stat, null);\n<line49>        assertArrayEquals(bytes, data, \"Missmatch data\");\n<line50>        assertTrue(zxids.contains(stat.getMzxid()), \"Unknown zxid \");\n<line51>    }\n<line52>}","output":"<line1>{\n<line2>    File tmpDir = ClientBase.createTmpDir();\n<line3>    ClientBase.setupTestEnv();\n<line4>    // Need to override preallocate set by setupTestEnv()\n<line5>    // We don't need to unset these values since each unit test run in\n<line6>    // a separate JVM instance\n<line7>    FileTxnLog.setPreallocSize(PREALLOCATE);\n<line8>    FileTxnLog.setTxnLogSizeLimit(LOG_SIZE_LIMIT);\n<line9>    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line10>    final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n<line11>    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n<line12>    f.startup(zks);\n<line13>    assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n<line14>    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);\n<line15>    // Generate transactions\n<line16>    HashSet<Long> zxids = new HashSet<>();\n<line17>    byte[] bytes = new byte[NODE_SIZE];\n<line18>    Random random = new Random();\n<line19>    random.nextBytes(bytes);\n<line20>    // We will create enough txn to generate 3 logs\n<line21>    long txnCount = LOG_SIZE_LIMIT / NODE_SIZE / 2 * 5;\n<line22>    LOG.info(\"Creating {} txns\", txnCount);\n<line23>    try {\n<line24>        for (long i = 0; i < txnCount; i++) {\n<line25>            Stat stat = new Stat();\n<line26>            zk.create(\"/node-\" + i, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line27>            zk.getData(\"/node-\" + i, null, stat);\n<line28>            zxids.add(stat.getCzxid());\n<line29>        }\n<line30>    } finally {\n<line31>        zk.close();\n<line32>    }\n<line33>    // shutdown\n<line34>    f.shutdown();\n<line35>    assertTrue(ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server to shutdown\");\n<line36>    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);\n<line37>    File[] txnLogs = FileTxnLog.getLogFiles(logDir.listFiles(), 0);\n<line38>    assertEquals(3, txnLogs.length, \"Unexpected number of logs\");\n<line39>    // Log size should not exceed limit by more than one node size;\n<line40>    long threshold = LOG_SIZE_LIMIT + NODE_SIZE;\n<line41>    LOG.info(txnLogs[0].getAbsolutePath());\n<line42>    assertTrue(threshold > txnLogs[0].length(), \"Exceed log size limit: \" + txnLogs[0].length());\n<line43>    LOG.info(txnLogs[1].getAbsolutePath());\n<line44>    assertTrue(threshold > txnLogs[1].length(), \"Exceed log size limit \" + txnLogs[1].length());\n<line45>    // Start database only\n<line46>    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n<line47>    zks.startdata();\n<line48>    ZKDatabase db = zks.getZKDatabase();\n<line49>    for (long i = 0; i < txnCount; i++) {\n<line50>        Stat stat = new Stat();\n<line51>        byte[] data = db.getData(\"/node-\" + i, stat, null);\n<line52>        assertArrayEquals(bytes, data, \"Missmatch data\");\n<line53>        assertTrue(zxids.contains(stat.getMzxid()), \"Unknown zxid \");\n<line54>    }\n<line55>}"},{"input":"","instruction":"<line1>{\n<line2>    System.setProperty(\"zookeeper.extendedTypesEnabled\", Boolean.toString(ttlsEnabled));\n<line3>    try {\n<line4>        super.setUpWithServerId(serverId);\n<line5>    } catch (RuntimeException e) {\n<line6>        if (ttlsEnabled && (serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {\n<line7>            // expected\n<line8>            return;\n<line9>        }\n<line10>        throw e;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    System.setProperty(\"zookeeper.extendedTypesEnabled\", Boolean.toString(ttlsEnabled));\n<line3>    LOG.info(\"ttlsEnabled: {} - ServerId: {}\", ttlsEnabled, serverId);\n<line4>    try {\n<line5>        super.setUpWithServerId(serverId);\n<line6>    } catch (RuntimeException e) {\n<line7>        if (ttlsEnabled && (serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {\n<line8>            // expected\n<line9>            return;\n<line10>        }\n<line11>        throw e;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    // setting up SSL params, but disable some debug logs\n<line3>    x509Util = SSLAuthTest.setUpSecure();\n<line4>    System.clearProperty(\"javax.net.debug\");\n<line5>    // starting a single server (it will be closed in the tearDown)\n<line6>    setUpWithServerId(1);\n<line7>    // initializing the statistics\n<line8>    SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;\n<line9>    tlsHandshakeExceeded.reset();\n<line10>    assertEquals(tlsHandshakeExceeded.get(), 0);\n<line11>    // setting the HandshakeLimit to 3, so only 3 SSL handshakes can happen in parallel\n<line12>    NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n<line13>    factory.setSecure(true);\n<line14>    factory.setOutstandingHandshakeLimit(3);\n<line15>    // starting the threads that will try to connect to the server\n<line16>    // we will have 3 threads, each of them establishing 3 connections\n<line17>    int threadNum = 3;\n<line18>    int cnxnPerThread = 3;\n<line19>    int cnxnLimit = threadNum * cnxnPerThread;\n<line20>    AtomicInteger cnxnCreated = new AtomicInteger(0);\n<line21>    CountDownLatch latch = new CountDownLatch(1);\n<line22>    Thread[] cnxnWorker = new Thread[threadNum];\n<line23>    for (int i = 0; i < cnxnWorker.length; i++) {\n<line24>        cnxnWorker[i] = new ClientConnectionGenerator(i, cnxnPerThread, cnxnCreated, cnxnLimit, latch, zooKeeperClients);\n<line25>        cnxnWorker[i].start();\n<line26>    }\n<line27>    // we might need to wait potentially for a longer time for all the connection to get established,\n<line28>    // as the ZooKeeper Server will close some of the connections and the clients will have to re-try\n<line29>    boolean allConnectionsCreatedInTime = latch.await(30, TimeUnit.SECONDS);\n<line30>    int actualConnections = cnxnCreated.get();\n<line31>    if (!allConnectionsCreatedInTime) {\n<line32>        fail(String.format(\"Only %d out of %d connections created!\", actualConnections, cnxnLimit));\n<line33>    }\n<line34>    // Assert the server refused some of the connections because the handshake limit was reached\n<line35>    // (throttling should be greater than 0)\n<line36>    long handshakeThrottledNum = tlsHandshakeExceeded.get();\n<line37>    assertThat(\"The number of handshake throttled should be \" + \"greater than 0\", handshakeThrottledNum, Matchers.greaterThan(0L));\n<line38>    // Assert there is no outstanding handshake anymore, all the clients connected in the end\n<line39>    int outstandingHandshakeNum = factory.getOutstandingHandshakeNum();\n<line40>    assertThat(\"The outstanding handshake number should be 0 \" + \"after all cnxns established\", outstandingHandshakeNum, Matchers.is(0));\n<line41>}","output":"<line1>{\n<line2>    // setting up SSL params, but disable some debug logs\n<line3>    x509Util = SSLAuthTest.setUpSecure();\n<line4>    System.clearProperty(\"javax.net.debug\");\n<line5>    // starting a single server (it will be closed in the tearDown)\n<line6>    setUpWithServerId(1);\n<line7>    // initializing the statistics\n<line8>    SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;\n<line9>    tlsHandshakeExceeded.reset();\n<line10>    assertEquals(tlsHandshakeExceeded.get(), 0);\n<line11>    // setting the HandshakeLimit to 3, so only 3 SSL handshakes can happen in parallel\n<line12>    NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n<line13>    factory.setSecure(true);\n<line14>    factory.setOutstandingHandshakeLimit(3);\n<line15>    // starting the threads that will try to connect to the server\n<line16>    // we will have 3 threads, each of them establishing 3 connections\n<line17>    int threadNum = 3;\n<line18>    int cnxnPerThread = 3;\n<line19>    int cnxnLimit = threadNum * cnxnPerThread;\n<line20>    AtomicInteger cnxnCreated = new AtomicInteger(0);\n<line21>    CountDownLatch latch = new CountDownLatch(1);\n<line22>    Thread[] cnxnWorker = new Thread[threadNum];\n<line23>    for (int i = 0; i < cnxnWorker.length; i++) {\n<line24>        cnxnWorker[i] = new ClientConnectionGenerator(i, cnxnPerThread, cnxnCreated, cnxnLimit, latch, zooKeeperClients);\n<line25>        cnxnWorker[i].start();\n<line26>    }\n<line27>    // we might need to wait potentially for a longer time for all the connection to get established,\n<line28>    // as the ZooKeeper Server will close some of the connections and the clients will have to re-try\n<line29>    boolean allConnectionsCreatedInTime = latch.await(30, TimeUnit.SECONDS);\n<line30>    int actualConnections = cnxnCreated.get();\n<line31>    LOG.info(\"created {} connections\", actualConnections);\n<line32>    if (!allConnectionsCreatedInTime) {\n<line33>        fail(String.format(\"Only %d out of %d connections created!\", actualConnections, cnxnLimit));\n<line34>    }\n<line35>    // Assert the server refused some of the connections because the handshake limit was reached\n<line36>    // (throttling should be greater than 0)\n<line37>    long handshakeThrottledNum = tlsHandshakeExceeded.get();\n<line38>    LOG.info(\"TLS_HANDSHAKE_EXCEEDED: {}\", handshakeThrottledNum);\n<line39>    assertThat(\"The number of handshake throttled should be \" + \"greater than 0\", handshakeThrottledNum, Matchers.greaterThan(0L));\n<line40>    // Assert there is no outstanding handshake anymore, all the clients connected in the end\n<line41>    int outstandingHandshakeNum = factory.getOutstandingHandshakeNum();\n<line42>    LOG.info(\"outstanding handshake is {}\", outstandingHandshakeNum);\n<line43>    assertThat(\"The outstanding handshake number should be 0 \" + \"after all cnxns established\", outstandingHandshakeNum, Matchers.is(0));\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event.getState() == Event.KeeperState.SyncConnected) {\n<line3>        int created = cnxnCreated.addAndGet(1);\n<line4>        if (created == cnxnLimit) {\n<line5>            latch.countDown();\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.info(String.format(\"WATCHER [thread: %d, cnx:%d] - new event: %s\", cnxnThreadId, cnxnId, event.toString()));\n<line3>    if (event.getState() == Event.KeeperState.SyncConnected) {\n<line4>        int created = cnxnCreated.addAndGet(1);\n<line5>        if (created == cnxnLimit) {\n<line6>            latch.countDown();\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int j = 0; j < cnxnPerThread; j++) {\n<line3>        try {\n<line4>            zks.add(new ZooKeeper(hostPort, 30000, new ClientConnectionWatcher(cnxnCreated, cnxnLimit, cnxnThreadId, j, latch)));\n<line5>        } catch (Exception e) {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    for (int j = 0; j < cnxnPerThread; j++) {\n<line3>        try {\n<line4>            zks.add(new ZooKeeper(hostPort, 30000, new ClientConnectionWatcher(cnxnCreated, cnxnLimit, cnxnThreadId, j, latch)));\n<line5>        } catch (Exception e) {\n<line6>            LOG.info(\"Error while creating zk client\", e);\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zks.add(new ZooKeeper(hostPort, 30000, new ClientConnectionWatcher(cnxnCreated, cnxnLimit, cnxnThreadId, j, latch)));\n<line4>    } catch (Exception e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        zks.add(new ZooKeeper(hostPort, 30000, new ClientConnectionWatcher(cnxnCreated, cnxnLimit, cnxnThreadId, j, latch)));\n<line4>    } catch (Exception e) {\n<line5>        LOG.info(\"Error while creating zk client\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Error while creating zk client\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] args = new String[1];\n<line3>    args[0] = confFile.toString();\n<line4>    try {\n<line5>        main.initializeAndRun(args);\n<line6>    } catch (Exception e) {\n<line7>        // test will still fail even though we just log/ignore\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    String[] args = new String[1];\n<line3>    args[0] = confFile.toString();\n<line4>    try {\n<line5>        main.initializeAndRun(args);\n<line6>    } catch (Exception e) {\n<line7>        // test will still fail even though we just log/ignore\n<line8>        LOG.error(\"unexpected exception in run\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    // test will still fail even though we just log/ignore\n<line3>}","output":"<line1>{\n<line2>    // test will still fail even though we just log/ignore\n<line3>    LOG.error(\"unexpected exception in run\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final Properties configZookeeper = getServerConfig();\n<line3>    try (ZooKeeperServerEmbedded zkServer = ZooKeeperServerEmbedded.builder().baseDir(dir1.toPath()).configuration(configZookeeper).exitHandler(ExitHandler.LOG_ONLY).build()) {\n<line4>        zkServer.start();\n<line5>        assertTrue(ClientBase.waitForServerUp(zkServer.getConnectionString(), 60000));\n<line6>        for (int i = 0; i < 100; i++) {\n<line7>            ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line8>            if (status.isLeader() && status.isStandaloneMode()) {\n<line9>                break;\n<line10>            }\n<line11>            Thread.sleep(100);\n<line12>        }\n<line13>        ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line14>        assertTrue(status.isLeader());\n<line15>        assertTrue(status.isStandaloneMode());\n<line16>        CountDownLatch l = new CountDownLatch(1);\n<line17>        ZKClientConfig zKClientConfig = getZKClientConfig();\n<line18>        // ZK client object created which will connect with keyStoreFile1 and trustStoreFile1 to the server.\n<line19>        try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line20>            switch(event.getState()) {\n<line21>                case SyncConnected:\n<line22>                    l.countDown();\n<line23>                    break;\n<line24>            }\n<line25>        }, zKClientConfig)) {\n<line26>            assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line27>            assertTrue(l.await(10, TimeUnit.SECONDS));\n<line28>        }\n<line29>        Log.info(\"Updating keyStore & trustStore files !!!!\");\n<line30>        // Update the keyStoreFile1 and trustStoreFile1 files in the filesystem with keyStoreFile2 & trustStoreFile2\n<line31>        FileUtils.writeStringToFile(keyStoreFile1, FileUtils.readFileToString(keyStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line32>        FileUtils.writeStringToFile(trustStoreFile1, FileUtils.readFileToString(trustStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line33>        // Till FileChangeWatcher thread is triggered & SSLContext options are reset, ZK client should continue connecting.\n<line34>        for (int i = 0; i < 5; i++) {\n<line35>            CountDownLatch l2 = new CountDownLatch(1);\n<line36>            Thread.sleep(5000);\n<line37>            try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line38>                switch(event.getState()) {\n<line39>                    case SyncConnected:\n<line40>                        l.countDown();\n<line41>                        break;\n<line42>                }\n<line43>            }, zKClientConfig)) {\n<line44>                if (!l2.await(5, TimeUnit.SECONDS)) {\n<line45>                    break;\n<line46>                }\n<line47>            }\n<line48>        }\n<line49>        // Use the updated keyStore and trustStore paths when creating the client; Refreshed server should authenticate the client.\n<line50>        zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile2.getAbsolutePath());\n<line51>        zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile2.getAbsolutePath());\n<line52>        zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PEM\");\n<line53>        zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PEM\");\n<line54>        CountDownLatch l3 = new CountDownLatch(1);\n<line55>        try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line56>            switch(event.getState()) {\n<line57>                case SyncConnected:\n<line58>                    l3.countDown();\n<line59>                    break;\n<line60>            }\n<line61>        }, zKClientConfig)) {\n<line62>            assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line63>            assertTrue(l3.await(10, TimeUnit.SECONDS));\n<line64>        }\n<line65>    }\n<line66>}","output":"<line1>{\n<line2>    final Properties configZookeeper = getServerConfig();\n<line3>    try (ZooKeeperServerEmbedded zkServer = ZooKeeperServerEmbedded.builder().baseDir(dir1.toPath()).configuration(configZookeeper).exitHandler(ExitHandler.LOG_ONLY).build()) {\n<line4>        zkServer.start();\n<line5>        assertTrue(ClientBase.waitForServerUp(zkServer.getConnectionString(), 60000));\n<line6>        for (int i = 0; i < 100; i++) {\n<line7>            ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line8>            if (status.isLeader() && status.isStandaloneMode()) {\n<line9>                break;\n<line10>            }\n<line11>            Thread.sleep(100);\n<line12>        }\n<line13>        ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line14>        assertTrue(status.isLeader());\n<line15>        assertTrue(status.isStandaloneMode());\n<line16>        CountDownLatch l = new CountDownLatch(1);\n<line17>        ZKClientConfig zKClientConfig = getZKClientConfig();\n<line18>        // ZK client object created which will connect with keyStoreFile1 and trustStoreFile1 to the server.\n<line19>        try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line20>            switch(event.getState()) {\n<line21>                case SyncConnected:\n<line22>                    l.countDown();\n<line23>                    break;\n<line24>            }\n<line25>        }, zKClientConfig)) {\n<line26>            assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line27>            assertTrue(l.await(10, TimeUnit.SECONDS));\n<line28>        }\n<line29>        Log.info(\"Updating keyStore & trustStore files !!!!\");\n<line30>        // Update the keyStoreFile1 and trustStoreFile1 files in the filesystem with keyStoreFile2 & trustStoreFile2\n<line31>        FileUtils.writeStringToFile(keyStoreFile1, FileUtils.readFileToString(keyStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line32>        FileUtils.writeStringToFile(trustStoreFile1, FileUtils.readFileToString(trustStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line33>        // Till FileChangeWatcher thread is triggered & SSLContext options are reset, ZK client should continue connecting.\n<line34>        for (int i = 0; i < 5; i++) {\n<line35>            CountDownLatch l2 = new CountDownLatch(1);\n<line36>            Thread.sleep(5000);\n<line37>            try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line38>                switch(event.getState()) {\n<line39>                    case SyncConnected:\n<line40>                        l.countDown();\n<line41>                        break;\n<line42>                }\n<line43>            }, zKClientConfig)) {\n<line44>                if (!l2.await(5, TimeUnit.SECONDS)) {\n<line45>                    LOG.error(\"Unable to connect to zk server\");\n<line46>                    break;\n<line47>                }\n<line48>            }\n<line49>        }\n<line50>        // Use the updated keyStore and trustStore paths when creating the client; Refreshed server should authenticate the client.\n<line51>        zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile2.getAbsolutePath());\n<line52>        zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile2.getAbsolutePath());\n<line53>        zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PEM\");\n<line54>        zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PEM\");\n<line55>        CountDownLatch l3 = new CountDownLatch(1);\n<line56>        try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line57>            switch(event.getState()) {\n<line58>                case SyncConnected:\n<line59>                    l3.countDown();\n<line60>                    break;\n<line61>            }\n<line62>        }, zKClientConfig)) {\n<line63>            assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line64>            assertTrue(l3.await(10, TimeUnit.SECONDS));\n<line65>        }\n<line66>    }\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    zkServer.start();\n<line3>    assertTrue(ClientBase.waitForServerUp(zkServer.getConnectionString(), 60000));\n<line4>    for (int i = 0; i < 100; i++) {\n<line5>        ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line6>        if (status.isLeader() && status.isStandaloneMode()) {\n<line7>            break;\n<line8>        }\n<line9>        Thread.sleep(100);\n<line10>    }\n<line11>    ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line12>    assertTrue(status.isLeader());\n<line13>    assertTrue(status.isStandaloneMode());\n<line14>    CountDownLatch l = new CountDownLatch(1);\n<line15>    ZKClientConfig zKClientConfig = getZKClientConfig();\n<line16>    // ZK client object created which will connect with keyStoreFile1 and trustStoreFile1 to the server.\n<line17>    try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line18>        switch(event.getState()) {\n<line19>            case SyncConnected:\n<line20>                l.countDown();\n<line21>                break;\n<line22>        }\n<line23>    }, zKClientConfig)) {\n<line24>        assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line25>        assertTrue(l.await(10, TimeUnit.SECONDS));\n<line26>    }\n<line27>    Log.info(\"Updating keyStore & trustStore files !!!!\");\n<line28>    // Update the keyStoreFile1 and trustStoreFile1 files in the filesystem with keyStoreFile2 & trustStoreFile2\n<line29>    FileUtils.writeStringToFile(keyStoreFile1, FileUtils.readFileToString(keyStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line30>    FileUtils.writeStringToFile(trustStoreFile1, FileUtils.readFileToString(trustStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line31>    // Till FileChangeWatcher thread is triggered & SSLContext options are reset, ZK client should continue connecting.\n<line32>    for (int i = 0; i < 5; i++) {\n<line33>        CountDownLatch l2 = new CountDownLatch(1);\n<line34>        Thread.sleep(5000);\n<line35>        try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line36>            switch(event.getState()) {\n<line37>                case SyncConnected:\n<line38>                    l.countDown();\n<line39>                    break;\n<line40>            }\n<line41>        }, zKClientConfig)) {\n<line42>            if (!l2.await(5, TimeUnit.SECONDS)) {\n<line43>                break;\n<line44>            }\n<line45>        }\n<line46>    }\n<line47>    // Use the updated keyStore and trustStore paths when creating the client; Refreshed server should authenticate the client.\n<line48>    zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile2.getAbsolutePath());\n<line49>    zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile2.getAbsolutePath());\n<line50>    zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PEM\");\n<line51>    zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PEM\");\n<line52>    CountDownLatch l3 = new CountDownLatch(1);\n<line53>    try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line54>        switch(event.getState()) {\n<line55>            case SyncConnected:\n<line56>                l3.countDown();\n<line57>                break;\n<line58>        }\n<line59>    }, zKClientConfig)) {\n<line60>        assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line61>        assertTrue(l3.await(10, TimeUnit.SECONDS));\n<line62>    }\n<line63>}","output":"<line1>{\n<line2>    zkServer.start();\n<line3>    assertTrue(ClientBase.waitForServerUp(zkServer.getConnectionString(), 60000));\n<line4>    for (int i = 0; i < 100; i++) {\n<line5>        ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line6>        if (status.isLeader() && status.isStandaloneMode()) {\n<line7>            break;\n<line8>        }\n<line9>        Thread.sleep(100);\n<line10>    }\n<line11>    ZookeeperServeInfo.ServerInfo status = ZookeeperServeInfo.getStatus(\"StandaloneServer*\");\n<line12>    assertTrue(status.isLeader());\n<line13>    assertTrue(status.isStandaloneMode());\n<line14>    CountDownLatch l = new CountDownLatch(1);\n<line15>    ZKClientConfig zKClientConfig = getZKClientConfig();\n<line16>    // ZK client object created which will connect with keyStoreFile1 and trustStoreFile1 to the server.\n<line17>    try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line18>        switch(event.getState()) {\n<line19>            case SyncConnected:\n<line20>                l.countDown();\n<line21>                break;\n<line22>        }\n<line23>    }, zKClientConfig)) {\n<line24>        assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line25>        assertTrue(l.await(10, TimeUnit.SECONDS));\n<line26>    }\n<line27>    Log.info(\"Updating keyStore & trustStore files !!!!\");\n<line28>    // Update the keyStoreFile1 and trustStoreFile1 files in the filesystem with keyStoreFile2 & trustStoreFile2\n<line29>    FileUtils.writeStringToFile(keyStoreFile1, FileUtils.readFileToString(keyStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line30>    FileUtils.writeStringToFile(trustStoreFile1, FileUtils.readFileToString(trustStoreFile2, StandardCharsets.US_ASCII), StandardCharsets.US_ASCII, false);\n<line31>    // Till FileChangeWatcher thread is triggered & SSLContext options are reset, ZK client should continue connecting.\n<line32>    for (int i = 0; i < 5; i++) {\n<line33>        CountDownLatch l2 = new CountDownLatch(1);\n<line34>        Thread.sleep(5000);\n<line35>        try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line36>            switch(event.getState()) {\n<line37>                case SyncConnected:\n<line38>                    l.countDown();\n<line39>                    break;\n<line40>            }\n<line41>        }, zKClientConfig)) {\n<line42>            if (!l2.await(5, TimeUnit.SECONDS)) {\n<line43>                LOG.error(\"Unable to connect to zk server\");\n<line44>                break;\n<line45>            }\n<line46>        }\n<line47>    }\n<line48>    // Use the updated keyStore and trustStore paths when creating the client; Refreshed server should authenticate the client.\n<line49>    zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile2.getAbsolutePath());\n<line50>    zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile2.getAbsolutePath());\n<line51>    zKClientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PEM\");\n<line52>    zKClientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PEM\");\n<line53>    CountDownLatch l3 = new CountDownLatch(1);\n<line54>    try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line55>        switch(event.getState()) {\n<line56>            case SyncConnected:\n<line57>                l3.countDown();\n<line58>                break;\n<line59>        }\n<line60>    }, zKClientConfig)) {\n<line61>        assertTrue(zk.getClientConfig().getBoolean(ZKClientConfig.SECURE_CLIENT));\n<line62>        assertTrue(l3.await(10, TimeUnit.SECONDS));\n<line63>    }\n<line64>}"},{"input":"","instruction":"<line1>{\n<line2>    CountDownLatch l2 = new CountDownLatch(1);\n<line3>    Thread.sleep(5000);\n<line4>    try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line5>        switch(event.getState()) {\n<line6>            case SyncConnected:\n<line7>                l.countDown();\n<line8>                break;\n<line9>        }\n<line10>    }, zKClientConfig)) {\n<line11>        if (!l2.await(5, TimeUnit.SECONDS)) {\n<line12>            break;\n<line13>        }\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    CountDownLatch l2 = new CountDownLatch(1);\n<line3>    Thread.sleep(5000);\n<line4>    try (ZooKeeper zk = new ZooKeeper(zkServer.getSecureConnectionString(), 60000, (WatchedEvent event) -> {\n<line5>        switch(event.getState()) {\n<line6>            case SyncConnected:\n<line7>                l.countDown();\n<line8>                break;\n<line9>        }\n<line10>    }, zKClientConfig)) {\n<line11>        if (!l2.await(5, TimeUnit.SECONDS)) {\n<line12>            LOG.error(\"Unable to connect to zk server\");\n<line13>            break;\n<line14>        }\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!l2.await(5, TimeUnit.SECONDS)) {\n<line3>        break;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (!l2.await(5, TimeUnit.SECONDS)) {\n<line3>        LOG.error(\"Unable to connect to zk server\");\n<line4>        break;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to connect to zk server\");\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int count = 1000;\n<line3>    long session = 1000;\n<line4>    long zxid = 2000;\n<line5>    final DataTree dataTree = new DataTree();\n<line6>    createEphemeralNode(session, dataTree, count);\n<line7>    final AtomicBoolean exceptionDuringDumpEphemerals = new AtomicBoolean(false);\n<line8>    final AtomicBoolean running = new AtomicBoolean(true);\n<line9>    Thread thread = new Thread() {\n<line10>\n<line11>        public void run() {\n<line12>            PrintWriter pwriter = new PrintWriter(new StringWriter());\n<line13>            try {\n<line14>                while (running.get()) {\n<line15>                    dataTree.dumpEphemerals(pwriter);\n<line16>                }\n<line17>            } catch (Exception e) {\n<line18>                exceptionDuringDumpEphemerals.set(true);\n<line19>            }\n<line20>        }\n<line21>    };\n<line22>    thread.start();\n<line23>    killZkClientSession(session, zxid, dataTree, count);\n<line24>    running.set(false);\n<line25>    thread.join();\n<line26>    assertFalse(exceptionDuringDumpEphemerals.get(), \"Should have got exception while dumpEphemerals!\");\n<line27>}","output":"<line1>{\n<line2>    int count = 1000;\n<line3>    long session = 1000;\n<line4>    long zxid = 2000;\n<line5>    final DataTree dataTree = new DataTree();\n<line6>    LOG.info(\"Create {} zkclient sessions and its ephemeral nodes\", count);\n<line7>    createEphemeralNode(session, dataTree, count);\n<line8>    final AtomicBoolean exceptionDuringDumpEphemerals = new AtomicBoolean(false);\n<line9>    final AtomicBoolean running = new AtomicBoolean(true);\n<line10>    Thread thread = new Thread() {\n<line11>\n<line12>        public void run() {\n<line13>            PrintWriter pwriter = new PrintWriter(new StringWriter());\n<line14>            try {\n<line15>                while (running.get()) {\n<line16>                    dataTree.dumpEphemerals(pwriter);\n<line17>                }\n<line18>            } catch (Exception e) {\n<line19>                LOG.error(\"Received exception while dumpEphemerals!\", e);\n<line20>                exceptionDuringDumpEphemerals.set(true);\n<line21>            }\n<line22>        }\n<line23>    };\n<line24>    thread.start();\n<line25>    LOG.debug(\"Killing {} zkclient sessions and its ephemeral nodes\", count);\n<line26>    killZkClientSession(session, zxid, dataTree, count);\n<line27>    running.set(false);\n<line28>    thread.join();\n<line29>    assertFalse(exceptionDuringDumpEphemerals.get(), \"Should have got exception while dumpEphemerals!\");\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    PrintWriter pwriter = new PrintWriter(new StringWriter());\n<line3>    try {\n<line4>        while (running.get()) {\n<line5>            dataTree.dumpEphemerals(pwriter);\n<line6>        }\n<line7>    } catch (Exception e) {\n<line8>        exceptionDuringDumpEphemerals.set(true);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    PrintWriter pwriter = new PrintWriter(new StringWriter());\n<line3>    try {\n<line4>        while (running.get()) {\n<line5>            dataTree.dumpEphemerals(pwriter);\n<line6>        }\n<line7>    } catch (Exception e) {\n<line8>        LOG.error(\"Received exception while dumpEphemerals!\", e);\n<line9>        exceptionDuringDumpEphemerals.set(true);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    exceptionDuringDumpEphemerals.set(true);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Received exception while dumpEphemerals!\", e);\n<line3>    exceptionDuringDumpEphemerals.set(true);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final ZooKeeper zk = createClient();\n<line3>    final String path = \"/a\";\n<line4>    try {\n<line5>        // make sure zkclient works\n<line6>        zk.create(path, \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        assertNotNull(zk.exists(path, false), \"Didn't create znode:\" + path);\n<line8>        // Defaults ServerCnxnFactory would be instantiated with\n<line9>        // NIOServerCnxnFactory\n<line10>        assertTrue(serverFactory instanceof NIOServerCnxnFactory, \"Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!\");\n<line11>        Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line12>        for (ServerCnxn serverCnxn : connections) {\n<line13>            serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line14>            try {\n<line15>                serverCnxn.toString();\n<line16>            } catch (Exception e) {\n<line17>                fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line18>            }\n<line19>        }\n<line20>    } finally {\n<line21>        zk.close();\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    final ZooKeeper zk = createClient();\n<line3>    final String path = \"/a\";\n<line4>    try {\n<line5>        // make sure zkclient works\n<line6>        zk.create(path, \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>        assertNotNull(zk.exists(path, false), \"Didn't create znode:\" + path);\n<line8>        // Defaults ServerCnxnFactory would be instantiated with\n<line9>        // NIOServerCnxnFactory\n<line10>        assertTrue(serverFactory instanceof NIOServerCnxnFactory, \"Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!\");\n<line11>        Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line12>        for (ServerCnxn serverCnxn : connections) {\n<line13>            serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line14>            try {\n<line15>                serverCnxn.toString();\n<line16>            } catch (Exception e) {\n<line17>                LOG.error(\"Exception while getting connection details!\", e);\n<line18>                fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line19>            }\n<line20>        }\n<line21>    } finally {\n<line22>        zk.close();\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    // make sure zkclient works\n<line3>    zk.create(path, \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line4>    assertNotNull(zk.exists(path, false), \"Didn't create znode:\" + path);\n<line5>    // Defaults ServerCnxnFactory would be instantiated with\n<line6>    // NIOServerCnxnFactory\n<line7>    assertTrue(serverFactory instanceof NIOServerCnxnFactory, \"Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!\");\n<line8>    Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line9>    for (ServerCnxn serverCnxn : connections) {\n<line10>        serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line11>        try {\n<line12>            serverCnxn.toString();\n<line13>        } catch (Exception e) {\n<line14>            fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    // make sure zkclient works\n<line3>    zk.create(path, \"test\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line4>    assertNotNull(zk.exists(path, false), \"Didn't create znode:\" + path);\n<line5>    // Defaults ServerCnxnFactory would be instantiated with\n<line6>    // NIOServerCnxnFactory\n<line7>    assertTrue(serverFactory instanceof NIOServerCnxnFactory, \"Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!\");\n<line8>    Iterable<ServerCnxn> connections = serverFactory.getConnections();\n<line9>    for (ServerCnxn serverCnxn : connections) {\n<line10>        serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line11>        try {\n<line12>            serverCnxn.toString();\n<line13>        } catch (Exception e) {\n<line14>            LOG.error(\"Exception while getting connection details!\", e);\n<line15>            fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line3>    try {\n<line4>        serverCnxn.toString();\n<line5>    } catch (Exception e) {\n<line6>        fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line3>    try {\n<line4>        serverCnxn.toString();\n<line5>    } catch (Exception e) {\n<line6>        LOG.error(\"Exception while getting connection details!\", e);\n<line7>        fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while getting connection details!\", e);\n<line3>    fail(\"Shouldn't throw exception while \" + \"getting connection details!\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    stopped = true;\n<line3>    zks.shutdown();\n<line4>    for (TestClientThread client : testClients) {\n<line5>        client.interrupt();\n<line6>        client.join();\n<line7>    }\n<line8>    if (tmpDir != null) {\n<line9>        assertTrue(ClientBase.recursiveDelete(tmpDir), \"delete \" + tmpDir.toString());\n<line10>    }\n<line11>    processedReadRequests.set(0);\n<line12>    processedWriteRequests.set(0);\n<line13>    testClients.clear();\n<line14>    commitProcessor.join();\n<line15>}","output":"<line1>{\n<line2>    LOG.info(\"tearDown starting\");\n<line3>    stopped = true;\n<line4>    zks.shutdown();\n<line5>    for (TestClientThread client : testClients) {\n<line6>        client.interrupt();\n<line7>        client.join();\n<line8>    }\n<line9>    if (tmpDir != null) {\n<line10>        assertTrue(ClientBase.recursiveDelete(tmpDir), \"delete \" + tmpDir.toString());\n<line11>    }\n<line12>    processedReadRequests.set(0);\n<line13>    processedWriteRequests.set(0);\n<line14>    testClients.clear();\n<line15>    commitProcessor.join();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    Random rand = new Random(Thread.currentThread().getId());\n<line3>    try {\n<line4>        sendWriteRequest();\n<line5>        while (!stopped) {\n<line6>            if (rand.nextInt(100) < writePercent) {\n<line7>                sendWriteRequest();\n<line8>            } else {\n<line9>                sendReadRequest();\n<line10>            }\n<line11>            Thread.sleep(5 + rand.nextInt(95));\n<line12>        }\n<line13>    } catch (Exception e) {\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    Random rand = new Random(Thread.currentThread().getId());\n<line3>    try {\n<line4>        sendWriteRequest();\n<line5>        while (!stopped) {\n<line6>            if (rand.nextInt(100) < writePercent) {\n<line7>                sendWriteRequest();\n<line8>            } else {\n<line9>                sendReadRequest();\n<line10>            }\n<line11>            Thread.sleep(5 + rand.nextInt(95));\n<line12>        }\n<line13>    } catch (Exception e) {\n<line14>        LOG.error(\"Uncaught exception in test: \", e);\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Uncaught exception in test: \", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    int numClients = 10;\n<line3>    setUp(0, numClients, 0);\n<line4>    synchronized (this) {\n<line5>        wait(TEST_RUN_TIME_IN_MS);\n<line6>    }\n<line7>    assertFalse(fail);\n<line8>    assertTrue(processedReadRequests.get() > 0, \"No read requests processed\");\n<line9>    // processedWriteRequests.get() == numClients since each client performs one write at the beginning (creates a znode)\n<line10>    assertTrue(processedWriteRequests.get() == numClients, \"Write requests processed\");\n<line11>}","output":"<line1>{\n<line2>    int numClients = 10;\n<line3>    LOG.info(\"testNoCommitWorkersReadOnlyWorkload\");\n<line4>    setUp(0, numClients, 0);\n<line5>    synchronized (this) {\n<line6>        wait(TEST_RUN_TIME_IN_MS);\n<line7>    }\n<line8>    assertFalse(fail);\n<line9>    assertTrue(processedReadRequests.get() > 0, \"No read requests processed\");\n<line10>    // processedWriteRequests.get() == numClients since each client performs one write at the beginning (creates a znode)\n<line11>    assertTrue(processedWriteRequests.get() == numClients, \"Write requests processed\");\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    int numClients = 10;\n<line3>    setUp(0, numClients, 25);\n<line4>    synchronized (this) {\n<line5>        wait(TEST_RUN_TIME_IN_MS);\n<line6>    }\n<line7>    assertFalse(fail);\n<line8>    checkProcessedRequest();\n<line9>}","output":"<line1>{\n<line2>    int numClients = 10;\n<line3>    LOG.info(\"testNoCommitWorkersMixedWorkload 25w/75r workload test\");\n<line4>    setUp(0, numClients, 25);\n<line5>    synchronized (this) {\n<line6>        wait(TEST_RUN_TIME_IN_MS);\n<line7>    }\n<line8>    assertFalse(fail);\n<line9>    checkProcessedRequest();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    int numClients = 10;\n<line3>    setUp(1, numClients, 0);\n<line4>    synchronized (this) {\n<line5>        wait(TEST_RUN_TIME_IN_MS);\n<line6>    }\n<line7>    assertFalse(fail);\n<line8>    assertTrue(processedReadRequests.get() > 0, \"No read requests processed\");\n<line9>    // processedWriteRequests.get() == numClients since each client performs one write at the beginning (creates a znode)\n<line10>    assertTrue(processedWriteRequests.get() == numClients, \"Write requests processed\");\n<line11>}","output":"<line1>{\n<line2>    int numClients = 10;\n<line3>    LOG.info(\"testOneCommitWorkerReadOnlyWorkload\");\n<line4>    setUp(1, numClients, 0);\n<line5>    synchronized (this) {\n<line6>        wait(TEST_RUN_TIME_IN_MS);\n<line7>    }\n<line8>    assertFalse(fail);\n<line9>    assertTrue(processedReadRequests.get() > 0, \"No read requests processed\");\n<line10>    // processedWriteRequests.get() == numClients since each client performs one write at the beginning (creates a znode)\n<line11>    assertTrue(processedWriteRequests.get() == numClients, \"Write requests processed\");\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    setUp(1, 10, 25);\n<line3>    synchronized (this) {\n<line4>        wait(TEST_RUN_TIME_IN_MS);\n<line5>    }\n<line6>    assertFalse(fail);\n<line7>    checkProcessedRequest();\n<line8>}","output":"<line1>{\n<line2>    setUp(1, 10, 25);\n<line3>    LOG.info(\"testOneCommitWorkerMixedWorkload 25w/75r workload test\");\n<line4>    synchronized (this) {\n<line5>        wait(TEST_RUN_TIME_IN_MS);\n<line6>    }\n<line7>    assertFalse(fail);\n<line8>    checkProcessedRequest();\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    int numClients = 10;\n<line3>    setUp(10, numClients, 0);\n<line4>    synchronized (this) {\n<line5>        wait(TEST_RUN_TIME_IN_MS);\n<line6>    }\n<line7>    assertFalse(fail);\n<line8>    assertTrue(processedReadRequests.get() > 0, \"No read requests processed\");\n<line9>    // processedWriteRequests.get() == numClients since each client performs one write at the beginning (creates a znode)\n<line10>    assertTrue(processedWriteRequests.get() == numClients, \"Write requests processed\");\n<line11>}","output":"<line1>{\n<line2>    int numClients = 10;\n<line3>    LOG.info(\"testManyCommitWorkersReadOnly\");\n<line4>    setUp(10, numClients, 0);\n<line5>    synchronized (this) {\n<line6>        wait(TEST_RUN_TIME_IN_MS);\n<line7>    }\n<line8>    assertFalse(fail);\n<line9>    assertTrue(processedReadRequests.get() > 0, \"No read requests processed\");\n<line10>    // processedWriteRequests.get() == numClients since each client performs one write at the beginning (creates a znode)\n<line11>    assertTrue(processedWriteRequests.get() == numClients, \"Write requests processed\");\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    setUp(16, 8, 8, 25);\n<line3>    synchronized (this) {\n<line4>        wait(TEST_RUN_TIME_IN_MS);\n<line5>    }\n<line6>    assertFalse(fail);\n<line7>    checkProcessedRequest();\n<line8>}","output":"<line1>{\n<line2>    setUp(16, 8, 8, 25);\n<line3>    LOG.info(\"testManyCommitWorkersMixedWorkload 8X0w/100r + 8X25w/75r workload test\");\n<line4>    synchronized (this) {\n<line5>        wait(TEST_RUN_TIME_IN_MS);\n<line6>    }\n<line7>    assertFalse(fail);\n<line8>    checkProcessedRequest();\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    proposals.clear();\n<line3>    if (commitProcessor != null) {\n<line4>        commitProcessor.shutdown();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"shutdown MockProposalRequestProcessor\");\n<line3>    proposals.clear();\n<line4>    if (commitProcessor != null) {\n<line5>        commitProcessor.shutdown();\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (stopped) {\n<line3>        return;\n<line4>    }\n<line5>    if (request.type == OpCode.closeSession) {\n<line6>        nextProcessor.processRequest(request);\n<line7>        return;\n<line8>    }\n<line9>    boolean isWriteRequest = commitProcessor.needCommit(request);\n<line10>    if (isWriteRequest) {\n<line11>        outstandingWriteRequests.incrementAndGet();\n<line12>        validateWriteRequestVariant(request);\n<line13>    } else {\n<line14>        outstandingReadRequests.incrementAndGet();\n<line15>        validateReadRequestVariant(request);\n<line16>    }\n<line17>    // Insert random delay to test thread race conditions\n<line18>    try {\n<line19>        Thread.sleep(5 + rand.nextInt(25));\n<line20>    } catch (InterruptedException e) {\n<line21>        // ignore\n<line22>    }\n<line23>    nextProcessor.processRequest(request);\n<line24>    /*\n<line25>             * The commit workers will have to execute this line before they\n<line26>             * wake up the commit processor. So this value is up-to-date when\n<line27>             * variant check is performed\n<line28>             */\n<line29>    if (isWriteRequest) {\n<line30>        outstandingWriteRequests.decrementAndGet();\n<line31>        processedWriteRequests.incrementAndGet();\n<line32>    } else {\n<line33>        outstandingReadRequests.decrementAndGet();\n<line34>        processedReadRequests.incrementAndGet();\n<line35>    }\n<line36>    validateRequest(request);\n<line37>}","output":"<line1>{\n<line2>    if (stopped) {\n<line3>        return;\n<line4>    }\n<line5>    if (request.type == OpCode.closeSession) {\n<line6>        LOG.debug(\"ValidateProcessor got closeSession request=\" + request);\n<line7>        nextProcessor.processRequest(request);\n<line8>        return;\n<line9>    }\n<line10>    boolean isWriteRequest = commitProcessor.needCommit(request);\n<line11>    if (isWriteRequest) {\n<line12>        outstandingWriteRequests.incrementAndGet();\n<line13>        validateWriteRequestVariant(request);\n<line14>        LOG.debug(\"Starting write request zxid={}\", request.zxid);\n<line15>    } else {\n<line16>        LOG.debug(\"Starting read request cxid={} for session 0x{}\", request.cxid, Long.toHexString(request.sessionId));\n<line17>        outstandingReadRequests.incrementAndGet();\n<line18>        validateReadRequestVariant(request);\n<line19>    }\n<line20>    // Insert random delay to test thread race conditions\n<line21>    try {\n<line22>        Thread.sleep(5 + rand.nextInt(25));\n<line23>    } catch (InterruptedException e) {\n<line24>        // ignore\n<line25>    }\n<line26>    nextProcessor.processRequest(request);\n<line27>    /*\n<line28>             * The commit workers will have to execute this line before they\n<line29>             * wake up the commit processor. So this value is up-to-date when\n<line30>             * variant check is performed\n<line31>             */\n<line32>    if (isWriteRequest) {\n<line33>        outstandingWriteRequests.decrementAndGet();\n<line34>        LOG.debug(\"Done write request zxid={}\", request.zxid);\n<line35>        processedWriteRequests.incrementAndGet();\n<line36>    } else {\n<line37>        outstandingReadRequests.decrementAndGet();\n<line38>        LOG.debug(\"Done read request cxid={} for session 0x{}\", request.cxid, Long.toHexString(request.sessionId));\n<line39>        processedReadRequests.incrementAndGet();\n<line40>    }\n<line41>    validateRequest(request);\n<line42>}"},{"input":"","instruction":"<line1>{\n<line2>    nextProcessor.processRequest(request);\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"ValidateProcessor got closeSession request=\" + request);\n<line3>    nextProcessor.processRequest(request);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    outstandingWriteRequests.incrementAndGet();\n<line3>    validateWriteRequestVariant(request);\n<line4>}","output":"<line1>{\n<line2>    outstandingWriteRequests.incrementAndGet();\n<line3>    validateWriteRequestVariant(request);\n<line4>    LOG.debug(\"Starting write request zxid={}\", request.zxid);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    outstandingReadRequests.incrementAndGet();\n<line3>    validateReadRequestVariant(request);\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"Starting read request cxid={} for session 0x{}\", request.cxid, Long.toHexString(request.sessionId));\n<line3>    outstandingReadRequests.incrementAndGet();\n<line4>    validateReadRequestVariant(request);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    outstandingWriteRequests.decrementAndGet();\n<line3>    processedWriteRequests.incrementAndGet();\n<line4>}","output":"<line1>{\n<line2>    outstandingWriteRequests.decrementAndGet();\n<line3>    LOG.debug(\"Done write request zxid={}\", request.zxid);\n<line4>    processedWriteRequests.incrementAndGet();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    outstandingReadRequests.decrementAndGet();\n<line3>    processedReadRequests.incrementAndGet();\n<line4>}","output":"<line1>{\n<line2>    outstandingReadRequests.decrementAndGet();\n<line3>    LOG.debug(\"Done read request cxid={} for session 0x{}\", request.cxid, Long.toHexString(request.sessionId));\n<line4>    processedReadRequests.incrementAndGet();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // Zxids should always be in order for write requests\n<line3>    if (request.getHdr() != null) {\n<line4>        long zxid = request.getHdr().getZxid();\n<line5>        if (!expectedZxid.compareAndSet(zxid, zxid + 1)) {\n<line6>            failTest(\"Write request, expected_zxid=\" + expectedZxid.get() + \"; req_zxid=\" + zxid);\n<line7>        }\n<line8>    }\n<line9>    // Each session should see its cxids in order\n<line10>    AtomicInteger sessionCxid = cxidMap.get(request.sessionId);\n<line11>    if (sessionCxid == null) {\n<line12>        sessionCxid = new AtomicInteger(request.cxid + 1);\n<line13>        AtomicInteger existingSessionCxid = cxidMap.putIfAbsent(request.sessionId, sessionCxid);\n<line14>        if (existingSessionCxid != null) {\n<line15>            failTest(\"Race condition adding cxid=\" + request.cxid + \" for session 0x\" + Long.toHexString(request.sessionId) + \" with other_cxid=\" + existingSessionCxid.get());\n<line16>        }\n<line17>    } else {\n<line18>        if (!sessionCxid.compareAndSet(request.cxid, request.cxid + 1)) {\n<line19>            failTest(\"Expected_cxid=\" + sessionCxid.get() + \"; req_cxid=\" + request.cxid);\n<line20>        }\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    LOG.debug(\"Got request {}\", request);\n<line3>    // Zxids should always be in order for write requests\n<line4>    if (request.getHdr() != null) {\n<line5>        long zxid = request.getHdr().getZxid();\n<line6>        if (!expectedZxid.compareAndSet(zxid, zxid + 1)) {\n<line7>            failTest(\"Write request, expected_zxid=\" + expectedZxid.get() + \"; req_zxid=\" + zxid);\n<line8>        }\n<line9>    }\n<line10>    // Each session should see its cxids in order\n<line11>    AtomicInteger sessionCxid = cxidMap.get(request.sessionId);\n<line12>    if (sessionCxid == null) {\n<line13>        sessionCxid = new AtomicInteger(request.cxid + 1);\n<line14>        AtomicInteger existingSessionCxid = cxidMap.putIfAbsent(request.sessionId, sessionCxid);\n<line15>        if (existingSessionCxid != null) {\n<line16>            failTest(\"Race condition adding cxid=\" + request.cxid + \" for session 0x\" + Long.toHexString(request.sessionId) + \" with other_cxid=\" + existingSessionCxid.get());\n<line17>        }\n<line18>    } else {\n<line19>        if (!sessionCxid.compareAndSet(request.cxid, request.cxid + 1)) {\n<line20>            failTest(\"Expected_cxid=\" + sessionCxid.get() + \"; req_cxid=\" + request.cxid);\n<line21>        }\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    cxidMap.clear();\n<line3>    expectedZxid = new AtomicLong(1);\n<line4>    if (nextProcessor != null) {\n<line5>        nextProcessor.shutdown();\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"shutdown validateReadRequestVariant\");\n<line3>    cxidMap.clear();\n<line4>    expectedZxid = new AtomicLong(1);\n<line5>    if (nextProcessor != null) {\n<line6>        nextProcessor.shutdown();\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    // setup the env with RetainDB and local session upgrading\n<line3>    ClientBase.setupTestEnv();\n<line4>    mt = new MainThread[SERVER_COUNT];\n<line5>    clientPorts = new int[SERVER_COUNT];\n<line6>    StringBuilder sb = new StringBuilder();\n<line7>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line8>        clientPorts[i] = PortAssignment.unique();\n<line9>        sb.append(\"server.\").append(i).append(\"=127.0.0.1:\").append(PortAssignment.unique()).append(\":\").append(PortAssignment.unique()).append(\"\\n\");\n<line10>    }\n<line11>    sb.append(\"localSessionsEnabled=true\\n\");\n<line12>    sb.append(\"localSessionsUpgradingEnabled=true\\n\");\n<line13>    String cfg = sb.toString();\n<line14>    // create a 3 server ensemble\n<line15>    qpMain = new TestQPMainDropSessionUpgrading[SERVER_COUNT];\n<line16>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line17>        final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();\n<line18>        qpMain[i] = qp;\n<line19>        mt[i] = new MainThread(i, clientPorts[i], cfg, false) {\n<line20>\n<line21>            @Override\n<line22>            public TestQPMain getTestQPMain() {\n<line23>                return qp;\n<line24>            }\n<line25>        };\n<line26>        mt[i].start();\n<line27>    }\n<line28>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line29>        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    LOG.info(\"STARTING quorum {}\", getClass().getName());\n<line3>    // setup the env with RetainDB and local session upgrading\n<line4>    ClientBase.setupTestEnv();\n<line5>    mt = new MainThread[SERVER_COUNT];\n<line6>    clientPorts = new int[SERVER_COUNT];\n<line7>    StringBuilder sb = new StringBuilder();\n<line8>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line9>        clientPorts[i] = PortAssignment.unique();\n<line10>        sb.append(\"server.\").append(i).append(\"=127.0.0.1:\").append(PortAssignment.unique()).append(\":\").append(PortAssignment.unique()).append(\"\\n\");\n<line11>    }\n<line12>    sb.append(\"localSessionsEnabled=true\\n\");\n<line13>    sb.append(\"localSessionsUpgradingEnabled=true\\n\");\n<line14>    String cfg = sb.toString();\n<line15>    // create a 3 server ensemble\n<line16>    qpMain = new TestQPMainDropSessionUpgrading[SERVER_COUNT];\n<line17>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line18>        final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();\n<line19>        qpMain[i] = qp;\n<line20>        mt[i] = new MainThread(i, clientPorts[i], cfg, false) {\n<line21>\n<line22>            @Override\n<line23>            public TestQPMain getTestQPMain() {\n<line24>                return qp;\n<line25>            }\n<line26>        };\n<line27>        mt[i].start();\n<line28>    }\n<line29>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line30>        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line3>        mt[i].shutdown();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"STOPPING quorum {}\", getClass().getName());\n<line3>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line4>        mt[i].shutdown();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    // select the candidate of follower\n<line3>    int leader = -1;\n<line4>    int followerA = -1;\n<line5>    for (int i = SERVER_COUNT - 1; i >= 0; i--) {\n<line6>        if (mt[i].main.quorumPeer.leader != null) {\n<line7>            leader = i;\n<line8>        } else if (followerA == -1) {\n<line9>            followerA = i;\n<line10>        }\n<line11>    }\n<line12>    qpMain[followerA].setDropCreateSession(true);\n<line13>    // create a client, and create an ephemeral node to trigger the\n<line14>    // upgrading process\n<line15>    final String node = \"/node-1\";\n<line16>    ZooKeeper zk = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line17>    waitForOne(zk, States.CONNECTED);\n<line18>    // clone the session id and passwd for later usage\n<line19>    long sessionId = zk.getSessionId();\n<line20>    // should fail because of the injection\n<line21>    try {\n<line22>        zk.create(node, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line23>        fail(\"expect to failed to upgrade session due to the \" + \"TestQPMainDropSessionUpgrading is being used\");\n<line24>    } catch (KeeperException e) {\n<line25>    }\n<line26>    // force to take snapshot\n<line27>    qpMain[followerA].quorumPeer.follower.zk.takeSnapshot(true);\n<line28>    // wait snapshot finish\n<line29>    Thread.sleep(500);\n<line30>    // shutdown all servers\n<line31>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line32>        mt[i].shutdown();\n<line33>    }\n<line34>    ArrayList<States> waitStates = new ArrayList<>();\n<line35>    waitStates.add(States.CONNECTING);\n<line36>    waitStates.add(States.CLOSED);\n<line37>    waitForOne(zk, waitStates);\n<line38>    // start the servers again, start follower A last as we want to\n<line39>    // keep it running as follower\n<line40>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line41>        mt[i].start();\n<line42>    }\n<line43>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line44>        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n<line45>    }\n<line46>    // check global session not exist on follower A\n<line47>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line48>        ConcurrentHashMap<Long, Integer> sessions = mt[i].main.quorumPeer.getZkDb().getSessionWithTimeOuts();\n<line49>        assertFalse(sessions.containsKey(sessionId), \"server \" + i + \" should not have global \" + \"session \" + sessionId);\n<line50>    }\n<line51>    zk.close();\n<line52>}","output":"<line1>{\n<line2>    // select the candidate of follower\n<line3>    int leader = -1;\n<line4>    int followerA = -1;\n<line5>    for (int i = SERVER_COUNT - 1; i >= 0; i--) {\n<line6>        if (mt[i].main.quorumPeer.leader != null) {\n<line7>            leader = i;\n<line8>        } else if (followerA == -1) {\n<line9>            followerA = i;\n<line10>        }\n<line11>    }\n<line12>    LOG.info(\"follower A is {}\", followerA);\n<line13>    qpMain[followerA].setDropCreateSession(true);\n<line14>    // create a client, and create an ephemeral node to trigger the\n<line15>    // upgrading process\n<line16>    final String node = \"/node-1\";\n<line17>    ZooKeeper zk = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line18>    waitForOne(zk, States.CONNECTED);\n<line19>    // clone the session id and passwd for later usage\n<line20>    long sessionId = zk.getSessionId();\n<line21>    // should fail because of the injection\n<line22>    try {\n<line23>        zk.create(node, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line24>        fail(\"expect to failed to upgrade session due to the \" + \"TestQPMainDropSessionUpgrading is being used\");\n<line25>    } catch (KeeperException e) {\n<line26>        LOG.info(\"KeeperException when create ephemeral node.\", e);\n<line27>    }\n<line28>    // force to take snapshot\n<line29>    qpMain[followerA].quorumPeer.follower.zk.takeSnapshot(true);\n<line30>    // wait snapshot finish\n<line31>    Thread.sleep(500);\n<line32>    // shutdown all servers\n<line33>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line34>        mt[i].shutdown();\n<line35>    }\n<line36>    ArrayList<States> waitStates = new ArrayList<>();\n<line37>    waitStates.add(States.CONNECTING);\n<line38>    waitStates.add(States.CLOSED);\n<line39>    waitForOne(zk, waitStates);\n<line40>    // start the servers again, start follower A last as we want to\n<line41>    // keep it running as follower\n<line42>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line43>        mt[i].start();\n<line44>    }\n<line45>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line46>        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n<line47>    }\n<line48>    // check global session not exist on follower A\n<line49>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line50>        ConcurrentHashMap<Long, Integer> sessions = mt[i].main.quorumPeer.getZkDb().getSessionWithTimeOuts();\n<line51>        assertFalse(sessions.containsKey(sessionId), \"server \" + i + \" should not have global \" + \"session \" + sessionId);\n<line52>    }\n<line53>    zk.close();\n<line54>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"KeeperException when create ephemeral node.\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    return new QuorumPeer() {\n<line3>\n<line4>        @Override\n<line5>        protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException {\n<line6>            return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.getZkDb()) {\n<line7>\n<line8>                @Override\n<line9>                public void submitRequestNow(Request si) {\n<line10>                    if (submitDelayMs > 0) {\n<line11>                        try {\n<line12>                            Thread.sleep(submitDelayMs);\n<line13>                        } catch (Exception e) {\n<line14>                        }\n<line15>                    }\n<line16>                    super.submitRequestNow(si);\n<line17>                }\n<line18>            });\n<line19>        }\n<line20>\n<line21>        @Override\n<line22>        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {\n<line23>            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {\n<line24>\n<line25>                @Override\n<line26>                public void submitRequestNow(Request si) {\n<line27>                    if (submitDelayMs > 0) {\n<line28>                        try {\n<line29>                            Thread.sleep(submitDelayMs);\n<line30>                        } catch (Exception e) {\n<line31>                        }\n<line32>                    }\n<line33>                    super.submitRequestNow(si);\n<line34>                }\n<line35>            }) {\n<line36>\n<line37>                @Override\n<line38>                protected void request(Request request) throws IOException {\n<line39>                    if (!shouldDrop) {\n<line40>                        super.request(request);\n<line41>                        return;\n<line42>                    }\n<line43>                    if (request.type == ZooDefs.OpCode.createSession) {\n<line44>                        return;\n<line45>                    }\n<line46>                    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {\n<line47>                        CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line48>                        try {\n<line49>                            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n<line50>                            if (createMode.isEphemeral()) {\n<line51>                                request.cnxn.sendCloseSession();\n<line52>                            }\n<line53>                        } catch (KeeperException ignore) {\n<line54>                        }\n<line55>                        return;\n<line56>                    }\n<line57>                    super.request(request);\n<line58>                }\n<line59>            };\n<line60>        }\n<line61>    };\n<line62>}","output":"<line1>{\n<line2>    return new QuorumPeer() {\n<line3>\n<line4>        @Override\n<line5>        protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException {\n<line6>            return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.getZkDb()) {\n<line7>\n<line8>                @Override\n<line9>                public void submitRequestNow(Request si) {\n<line10>                    if (submitDelayMs > 0) {\n<line11>                        try {\n<line12>                            Thread.sleep(submitDelayMs);\n<line13>                        } catch (Exception e) {\n<line14>                        }\n<line15>                    }\n<line16>                    super.submitRequestNow(si);\n<line17>                }\n<line18>            });\n<line19>        }\n<line20>\n<line21>        @Override\n<line22>        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {\n<line23>            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {\n<line24>\n<line25>                @Override\n<line26>                public void submitRequestNow(Request si) {\n<line27>                    if (submitDelayMs > 0) {\n<line28>                        try {\n<line29>                            Thread.sleep(submitDelayMs);\n<line30>                        } catch (Exception e) {\n<line31>                        }\n<line32>                    }\n<line33>                    super.submitRequestNow(si);\n<line34>                }\n<line35>            }) {\n<line36>\n<line37>                @Override\n<line38>                protected void request(Request request) throws IOException {\n<line39>                    if (!shouldDrop) {\n<line40>                        super.request(request);\n<line41>                        return;\n<line42>                    }\n<line43>                    LOG.info(\"request is {}, cnxn {}\", request.type, request.cnxn);\n<line44>                    if (request.type == ZooDefs.OpCode.createSession) {\n<line45>                        LOG.info(\"drop createSession request {}\", request);\n<line46>                        return;\n<line47>                    }\n<line48>                    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {\n<line49>                        CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line50>                        try {\n<line51>                            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n<line52>                            if (createMode.isEphemeral()) {\n<line53>                                request.cnxn.sendCloseSession();\n<line54>                            }\n<line55>                        } catch (KeeperException ignore) {\n<line56>                        }\n<line57>                        return;\n<line58>                    }\n<line59>                    super.request(request);\n<line60>                }\n<line61>            };\n<line62>        }\n<line63>    };\n<line64>}"},{"input":"","instruction":"<line1>{\n<line2>    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {\n<line3>\n<line4>        @Override\n<line5>        public void submitRequestNow(Request si) {\n<line6>            if (submitDelayMs > 0) {\n<line7>                try {\n<line8>                    Thread.sleep(submitDelayMs);\n<line9>                } catch (Exception e) {\n<line10>                }\n<line11>            }\n<line12>            super.submitRequestNow(si);\n<line13>        }\n<line14>    }) {\n<line15>\n<line16>        @Override\n<line17>        protected void request(Request request) throws IOException {\n<line18>            if (!shouldDrop) {\n<line19>                super.request(request);\n<line20>                return;\n<line21>            }\n<line22>            if (request.type == ZooDefs.OpCode.createSession) {\n<line23>                return;\n<line24>            }\n<line25>            if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {\n<line26>                CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line27>                try {\n<line28>                    CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n<line29>                    if (createMode.isEphemeral()) {\n<line30>                        request.cnxn.sendCloseSession();\n<line31>                    }\n<line32>                } catch (KeeperException ignore) {\n<line33>                }\n<line34>                return;\n<line35>            }\n<line36>            super.request(request);\n<line37>        }\n<line38>    };\n<line39>}","output":"<line1>{\n<line2>    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {\n<line3>\n<line4>        @Override\n<line5>        public void submitRequestNow(Request si) {\n<line6>            if (submitDelayMs > 0) {\n<line7>                try {\n<line8>                    Thread.sleep(submitDelayMs);\n<line9>                } catch (Exception e) {\n<line10>                }\n<line11>            }\n<line12>            super.submitRequestNow(si);\n<line13>        }\n<line14>    }) {\n<line15>\n<line16>        @Override\n<line17>        protected void request(Request request) throws IOException {\n<line18>            if (!shouldDrop) {\n<line19>                super.request(request);\n<line20>                return;\n<line21>            }\n<line22>            LOG.info(\"request is {}, cnxn {}\", request.type, request.cnxn);\n<line23>            if (request.type == ZooDefs.OpCode.createSession) {\n<line24>                LOG.info(\"drop createSession request {}\", request);\n<line25>                return;\n<line26>            }\n<line27>            if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {\n<line28>                CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line29>                try {\n<line30>                    CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n<line31>                    if (createMode.isEphemeral()) {\n<line32>                        request.cnxn.sendCloseSession();\n<line33>                    }\n<line34>                } catch (KeeperException ignore) {\n<line35>                }\n<line36>                return;\n<line37>            }\n<line38>            super.request(request);\n<line39>        }\n<line40>    };\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!shouldDrop) {\n<line3>        super.request(request);\n<line4>        return;\n<line5>    }\n<line6>    if (request.type == ZooDefs.OpCode.createSession) {\n<line7>        return;\n<line8>    }\n<line9>    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {\n<line10>        CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line11>        try {\n<line12>            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n<line13>            if (createMode.isEphemeral()) {\n<line14>                request.cnxn.sendCloseSession();\n<line15>            }\n<line16>        } catch (KeeperException ignore) {\n<line17>        }\n<line18>        return;\n<line19>    }\n<line20>    super.request(request);\n<line21>}","output":"<line1>{\n<line2>    if (!shouldDrop) {\n<line3>        super.request(request);\n<line4>        return;\n<line5>    }\n<line6>    LOG.info(\"request is {}, cnxn {}\", request.type, request.cnxn);\n<line7>    if (request.type == ZooDefs.OpCode.createSession) {\n<line8>        LOG.info(\"drop createSession request {}\", request);\n<line9>        return;\n<line10>    }\n<line11>    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {\n<line12>        CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line13>        try {\n<line14>            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n<line15>            if (createMode.isEphemeral()) {\n<line16>                request.cnxn.sendCloseSession();\n<line17>            }\n<line18>        } catch (KeeperException ignore) {\n<line19>        }\n<line20>        return;\n<line21>    }\n<line22>    super.request(request);\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"drop createSession request {}\", request);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;\n<line3>    while (!states.contains(zk.getState())) {\n<line4>        if (iterations-- == 0) {\n<line5>            throw new RuntimeException(\"Waiting too long\");\n<line6>        }\n<line7>        Thread.sleep(500);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;\n<line3>    while (!states.contains(zk.getState())) {\n<line4>        if (iterations-- == 0) {\n<line5>            LOG.info(\"state is {}\", zk.getState());\n<line6>            throw new RuntimeException(\"Waiting too long\");\n<line7>        }\n<line8>        Thread.sleep(500);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (iterations-- == 0) {\n<line3>        throw new RuntimeException(\"Waiting too long\");\n<line4>    }\n<line5>    Thread.sleep(500);\n<line6>}","output":"<line1>{\n<line2>    if (iterations-- == 0) {\n<line3>        LOG.info(\"state is {}\", zk.getState());\n<line4>        throw new RuntimeException(\"Waiting too long\");\n<line5>    }\n<line6>    Thread.sleep(500);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new RuntimeException(\"Waiting too long\");\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"state is {}\", zk.getState());\n<line3>    throw new RuntimeException(\"Waiting too long\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < count; i++) {\n<line3>        int clientport = PortAssignment.unique();\n<line4>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));\n<line5>        tmpdir[i] = ClientBase.createTmpDir();\n<line6>        port[i] = clientport;\n<line7>    }\n<line8>    ByteBuffer initialMsg0 = getMsg();\n<line9>    ByteBuffer initialMsg1 = getMsg();\n<line10>    /*\n<line11>         * Start server 0\n<line12>         */\n<line13>    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);\n<line14>    peer.startLeaderElection();\n<line15>    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 0);\n<line16>    thread.start();\n<line17>    /*\n<line18>         * Start mock server 1\n<line19>         */\n<line20>    QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);\n<line21>    cnxManagers[0] = mockPeer.createCnxnManager();\n<line22>    cnxManagers[0].listener.start();\n<line23>    cnxManagers[0].toSend(0L, initialMsg0);\n<line24>    /*\n<line25>         * Start mock server 2\n<line26>         */\n<line27>    mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2, 2);\n<line28>    cnxManagers[1] = mockPeer.createCnxnManager();\n<line29>    cnxManagers[1].listener.start();\n<line30>    cnxManagers[1].toSend(0L, initialMsg1);\n<line31>    /*\n<line32>         * Run another instance of leader election.\n<line33>         */\n<line34>    thread.join(5000);\n<line35>    thread = new FLETestUtils.LEThread(peer, 0);\n<line36>    thread.start();\n<line37>    /*\n<line38>         * Send the same messages, this time should not make 0 the leader.\n<line39>         */\n<line40>    cnxManagers[0].toSend(0L, initialMsg0);\n<line41>    cnxManagers[1].toSend(0L, initialMsg1);\n<line42>    thread.join(5000);\n<line43>    if (!thread.isAlive()) {\n<line44>        fail(\"Should not have joined\");\n<line45>    }\n<line46>}","output":"<line1>{\n<line2>    LOG.info(\"TestLE: {}, {}\", getTestName(), count);\n<line3>    for (int i = 0; i < count; i++) {\n<line4>        int clientport = PortAssignment.unique();\n<line5>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));\n<line6>        tmpdir[i] = ClientBase.createTmpDir();\n<line7>        port[i] = clientport;\n<line8>    }\n<line9>    ByteBuffer initialMsg0 = getMsg();\n<line10>    ByteBuffer initialMsg1 = getMsg();\n<line11>    /*\n<line12>         * Start server 0\n<line13>         */\n<line14>    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);\n<line15>    peer.startLeaderElection();\n<line16>    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 0);\n<line17>    thread.start();\n<line18>    /*\n<line19>         * Start mock server 1\n<line20>         */\n<line21>    QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);\n<line22>    cnxManagers[0] = mockPeer.createCnxnManager();\n<line23>    cnxManagers[0].listener.start();\n<line24>    cnxManagers[0].toSend(0L, initialMsg0);\n<line25>    /*\n<line26>         * Start mock server 2\n<line27>         */\n<line28>    mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2, 2);\n<line29>    cnxManagers[1] = mockPeer.createCnxnManager();\n<line30>    cnxManagers[1].listener.start();\n<line31>    cnxManagers[1].toSend(0L, initialMsg1);\n<line32>    /*\n<line33>         * Run another instance of leader election.\n<line34>         */\n<line35>    thread.join(5000);\n<line36>    thread = new FLETestUtils.LEThread(peer, 0);\n<line37>    thread.start();\n<line38>    /*\n<line39>         * Send the same messages, this time should not make 0 the leader.\n<line40>         */\n<line41>    cnxManagers[0].toSend(0L, initialMsg0);\n<line42>    cnxManagers[1].toSend(0L, initialMsg1);\n<line43>    thread.join(5000);\n<line44>    if (!thread.isAlive()) {\n<line45>        fail(\"Should not have joined\");\n<line46>    }\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    setUpData();\n<line3>    //start one server\n<line4>    startServer(leaderId, serverStrings.get(leaderId) + \"\\n\");\n<line5>    ReconfigTest.testServerHasConfig(zkHandles[leaderId], null, null);\n<line6>    //start and add 2 followers\n<line7>    startFollowers();\n<line8>    testReconfig(leaderId, true, reconfigServers);\n<line9>    //shutdown leader- quorum should still exist\n<line10>    shutDownServer(leaderId);\n<line11>    ReconfigTest.testNormalOperation(zkHandles[follower1], zkHandles[follower2]);\n<line12>    //should not be able to remove follower 2\n<line13>    //No quorum in new config (1/2)\n<line14>    reconfigServers.clear();\n<line15>    reconfigServers.add(Integer.toString(follower2));\n<line16>    try {\n<line17>        ReconfigTest.reconfig(zkAdminHandles[follower1], null, reconfigServers, null, -1);\n<line18>        fail(\"reconfig completed successfully even though there is no quorum up in new config!\");\n<line19>    } catch (KeeperException.NewConfigNoQuorum e) {\n<line20>    }\n<line21>    //reconfigure out leader and follower 1. Remaining follower\n<line22>    //2 should elect itself as leader and run by itself\n<line23>    reconfigServers.clear();\n<line24>    reconfigServers.add(Integer.toString(leaderId));\n<line25>    reconfigServers.add(Integer.toString(follower1));\n<line26>    testReconfig(follower2, false, reconfigServers);\n<line27>    // Kill server 1 to avoid it interferences with FLE of the quorum {2, 3, 4}.\n<line28>    shutDownServer(follower1);\n<line29>    // Try to remove follower2, which is the only remaining server. This should fail.\n<line30>    reconfigServers.clear();\n<line31>    reconfigServers.add(Integer.toString(follower2));\n<line32>    try {\n<line33>        zkAdminHandles[follower2].reconfigure(null, reconfigServers, null, -1, new Stat());\n<line34>        fail(\"reconfig completed successfully even though there is no quorum up in new config!\");\n<line35>    } catch (KeeperException.BadArgumentsException e) {\n<line36>        // This is expected.\n<line37>    } catch (Exception e) {\n<line38>        fail(\"Should have been BadArgumentsException!\");\n<line39>    }\n<line40>    //Add two participants and change them to observers to check\n<line41>    //that we can reconfigure down to one participant with observers.\n<line42>    ArrayList<String> observerStrings = new ArrayList<>();\n<line43>    startObservers(observerStrings);\n<line44>    //add partcipants\n<line45>    testReconfig(follower2, true, reconfigServers);\n<line46>    //change to observers\n<line47>    testReconfig(follower2, true, observerStrings);\n<line48>    shutDownData();\n<line49>}","output":"<line1>{\n<line2>    setUpData();\n<line3>    //start one server\n<line4>    startServer(leaderId, serverStrings.get(leaderId) + \"\\n\");\n<line5>    ReconfigTest.testServerHasConfig(zkHandles[leaderId], null, null);\n<line6>    LOG.info(\"Initial Configuration:\\n{}\", new String(zkHandles[leaderId].getConfig(this, new Stat())));\n<line7>    //start and add 2 followers\n<line8>    startFollowers();\n<line9>    testReconfig(leaderId, true, reconfigServers);\n<line10>    LOG.info(\"Configuration after adding 2 followers:\\n{}\", new String(zkHandles[leaderId].getConfig(this, new Stat())));\n<line11>    //shutdown leader- quorum should still exist\n<line12>    shutDownServer(leaderId);\n<line13>    ReconfigTest.testNormalOperation(zkHandles[follower1], zkHandles[follower2]);\n<line14>    //should not be able to remove follower 2\n<line15>    //No quorum in new config (1/2)\n<line16>    reconfigServers.clear();\n<line17>    reconfigServers.add(Integer.toString(follower2));\n<line18>    try {\n<line19>        ReconfigTest.reconfig(zkAdminHandles[follower1], null, reconfigServers, null, -1);\n<line20>        fail(\"reconfig completed successfully even though there is no quorum up in new config!\");\n<line21>    } catch (KeeperException.NewConfigNoQuorum e) {\n<line22>    }\n<line23>    //reconfigure out leader and follower 1. Remaining follower\n<line24>    //2 should elect itself as leader and run by itself\n<line25>    reconfigServers.clear();\n<line26>    reconfigServers.add(Integer.toString(leaderId));\n<line27>    reconfigServers.add(Integer.toString(follower1));\n<line28>    testReconfig(follower2, false, reconfigServers);\n<line29>    LOG.info(\"Configuration after removing leader and follower 1:\\n{}\", new String(zkHandles[follower2].getConfig(this, new Stat())));\n<line30>    // Kill server 1 to avoid it interferences with FLE of the quorum {2, 3, 4}.\n<line31>    shutDownServer(follower1);\n<line32>    // Try to remove follower2, which is the only remaining server. This should fail.\n<line33>    reconfigServers.clear();\n<line34>    reconfigServers.add(Integer.toString(follower2));\n<line35>    try {\n<line36>        zkAdminHandles[follower2].reconfigure(null, reconfigServers, null, -1, new Stat());\n<line37>        fail(\"reconfig completed successfully even though there is no quorum up in new config!\");\n<line38>    } catch (KeeperException.BadArgumentsException e) {\n<line39>        // This is expected.\n<line40>    } catch (Exception e) {\n<line41>        fail(\"Should have been BadArgumentsException!\");\n<line42>    }\n<line43>    //Add two participants and change them to observers to check\n<line44>    //that we can reconfigure down to one participant with observers.\n<line45>    ArrayList<String> observerStrings = new ArrayList<>();\n<line46>    startObservers(observerStrings);\n<line47>    //add partcipants\n<line48>    testReconfig(follower2, true, reconfigServers);\n<line49>    //change to observers\n<line50>    testReconfig(follower2, true, observerStrings);\n<line51>    LOG.info(\"Configuration after adding two observers:\\n{}\", new String(zkHandles[follower2].getConfig(this, new Stat())));\n<line52>    shutDownData();\n<line53>}"},{"input":"","instruction":"<line1>{\n<line2>    peers[id] = new MainThread(id, clientPorts[id], config);\n<line3>    peers[id].start();\n<line4>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[id], CONNECTION_TIMEOUT), \"Server \" + id + \" is not up\");\n<line5>    assertTrue(peers[id].isQuorumPeerRunning(), \"Error- Server started in Standalone Mode!\");\n<line6>    zkHandles[id] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[id]);\n<line7>    zkAdminHandles[id] = new ZooKeeperAdmin(\"127.0.0.1:\" + clientPorts[id], CONNECTION_TIMEOUT, this);\n<line8>    zkAdminHandles[id].addAuthInfo(\"digest\", \"super:test\".getBytes());\n<line9>    String statCommandOut = FourLetterWordMain.send4LetterWord(\"127.0.0.1\", clientPorts[id], \"stat\");\n<line10>}","output":"<line1>{\n<line2>    peers[id] = new MainThread(id, clientPorts[id], config);\n<line3>    peers[id].start();\n<line4>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[id], CONNECTION_TIMEOUT), \"Server \" + id + \" is not up\");\n<line5>    assertTrue(peers[id].isQuorumPeerRunning(), \"Error- Server started in Standalone Mode!\");\n<line6>    zkHandles[id] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[id]);\n<line7>    zkAdminHandles[id] = new ZooKeeperAdmin(\"127.0.0.1:\" + clientPorts[id], CONNECTION_TIMEOUT, this);\n<line8>    zkAdminHandles[id].addAuthInfo(\"digest\", \"super:test\".getBytes());\n<line9>    String statCommandOut = FourLetterWordMain.send4LetterWord(\"127.0.0.1\", clientPorts[id], \"stat\");\n<line10>    LOG.info(\"Started server id {} with config:\\n{}\\nStat output:\\n{}\", id, config, statCommandOut);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < count; i++) {\n<line3>        int clientport = PortAssignment.unique();\n<line4>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));\n<line5>        tmpdir[i] = ClientBase.createTmpDir();\n<line6>        port[i] = clientport;\n<line7>    }\n<line8>    /*\n<line9>         * Start server 0\n<line10>         */\n<line11>    QuorumPeer peer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);\n<line12>    peer.startLeaderElection();\n<line13>    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 1);\n<line14>    thread.start();\n<line15>    /*\n<line16>         * Start mock server 1\n<line17>         */\n<line18>    mockServer();\n<line19>    thread.join(5000);\n<line20>    if (thread.isAlive()) {\n<line21>        fail(\"Threads didn't join\");\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    LOG.info(\"TestLE: {}, {}\", getTestName(), count);\n<line3>    for (int i = 0; i < count; i++) {\n<line4>        int clientport = PortAssignment.unique();\n<line5>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));\n<line6>        tmpdir[i] = ClientBase.createTmpDir();\n<line7>        port[i] = clientport;\n<line8>    }\n<line9>    /*\n<line10>         * Start server 0\n<line11>         */\n<line12>    QuorumPeer peer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);\n<line13>    peer.startLeaderElection();\n<line14>    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 1);\n<line15>    thread.start();\n<line16>    /*\n<line17>         * Start mock server 1\n<line18>         */\n<line19>    mockServer();\n<line20>    thread.join(5000);\n<line21>    if (thread.isAlive()) {\n<line22>        fail(\"Threads didn't join\");\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!conf.keySet().containsAll(PROPERTIES)) {\n<line3>        Set<String> missingProperties = new HashSet<>(PROPERTIES);\n<line4>        missingProperties.removeAll(conf.keySet());\n<line5>        throw new IllegalArgumentException(\"Missing configuration properties: \" + missingProperties);\n<line6>    }\n<line7>    this.workDir = new File(workDir, Long.toString(System.currentTimeMillis()));\n<line8>    if (!this.workDir.exists() && !this.workDir.mkdirs()) {\n<line9>        throw new RuntimeException(\"Cannot create directory \" + this.workDir);\n<line10>    }\n<line11>    for (Map.Entry<?, ?> entry : conf.entrySet()) {\n<line12>    }\n<line13>    this.conf = conf;\n<line14>    port = Integer.parseInt(conf.getProperty(KDC_PORT));\n<line15>    String orgName = conf.getProperty(ORG_NAME);\n<line16>    String orgDomain = conf.getProperty(ORG_DOMAIN);\n<line17>    realm = orgName.toUpperCase(Locale.ENGLISH) + \".\" + orgDomain.toUpperCase(Locale.ENGLISH);\n<line18>}","output":"<line1>{\n<line2>    if (!conf.keySet().containsAll(PROPERTIES)) {\n<line3>        Set<String> missingProperties = new HashSet<>(PROPERTIES);\n<line4>        missingProperties.removeAll(conf.keySet());\n<line5>        throw new IllegalArgumentException(\"Missing configuration properties: \" + missingProperties);\n<line6>    }\n<line7>    this.workDir = new File(workDir, Long.toString(System.currentTimeMillis()));\n<line8>    if (!this.workDir.exists() && !this.workDir.mkdirs()) {\n<line9>        throw new RuntimeException(\"Cannot create directory \" + this.workDir);\n<line10>    }\n<line11>    LOG.info(\"Configuration:\");\n<line12>    LOG.info(\"---------------------------------------------------------------\");\n<line13>    for (Map.Entry<?, ?> entry : conf.entrySet()) {\n<line14>        LOG.info(\"  {}: {}\", entry.getKey(), entry.getValue());\n<line15>    }\n<line16>    LOG.info(\"---------------------------------------------------------------\");\n<line17>    this.conf = conf;\n<line18>    port = Integer.parseInt(conf.getProperty(KDC_PORT));\n<line19>    String orgName = conf.getProperty(ORG_NAME);\n<line20>    String orgDomain = conf.getProperty(ORG_DOMAIN);\n<line21>    realm = orgName.toUpperCase(Locale.ENGLISH) + \".\" + orgDomain.toUpperCase(Locale.ENGLISH);\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"  {}: {}\", entry.getKey(), entry.getValue());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (simpleKdc != null) {\n<line3>        throw new RuntimeException(\"Already started\");\n<line4>    }\n<line5>    simpleKdc = new SimpleKdcServer();\n<line6>    prepareKdcServer();\n<line7>    simpleKdc.init();\n<line8>    resetDefaultRealm();\n<line9>    simpleKdc.start();\n<line10>}","output":"<line1>{\n<line2>    if (simpleKdc != null) {\n<line3>        throw new RuntimeException(\"Already started\");\n<line4>    }\n<line5>    simpleKdc = new SimpleKdcServer();\n<line6>    prepareKdcServer();\n<line7>    simpleKdc.init();\n<line8>    resetDefaultRealm();\n<line9>    simpleKdc.start();\n<line10>    LOG.info(\"MiniKdc stated.\");\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (simpleKdc != null) {\n<line3>        try {\n<line4>            simpleKdc.stop();\n<line5>        } catch (KrbException e) {\n<line6>            e.printStackTrace();\n<line7>        } finally {\n<line8>            if (conf.getProperty(DEBUG) != null) {\n<line9>                System.setProperty(SUN_SECURITY_KRB5_DEBUG, Boolean.toString(krb5Debug));\n<line10>            }\n<line11>        }\n<line12>    }\n<line13>    delete(workDir);\n<line14>    try {\n<line15>        // Will be fixed in next Kerby version.\n<line16>        Thread.sleep(1000);\n<line17>    } catch (InterruptedException e) {\n<line18>        e.printStackTrace();\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    if (simpleKdc != null) {\n<line3>        try {\n<line4>            simpleKdc.stop();\n<line5>        } catch (KrbException e) {\n<line6>            e.printStackTrace();\n<line7>        } finally {\n<line8>            if (conf.getProperty(DEBUG) != null) {\n<line9>                System.setProperty(SUN_SECURITY_KRB5_DEBUG, Boolean.toString(krb5Debug));\n<line10>            }\n<line11>        }\n<line12>    }\n<line13>    delete(workDir);\n<line14>    try {\n<line15>        // Will be fixed in next Kerby version.\n<line16>        Thread.sleep(1000);\n<line17>    } catch (InterruptedException e) {\n<line18>        e.printStackTrace();\n<line19>    }\n<line20>    LOG.info(\"MiniKdc stopped.\");\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    simpleKdc.createPrincipals(principals);\n<line3>    if (keytabFile.exists() && !keytabFile.delete()) {\n<line4>    }\n<line5>    for (String principal : principals) {\n<line6>        simpleKdc.getKadmin().exportKeytab(keytabFile, principal);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    simpleKdc.createPrincipals(principals);\n<line3>    if (keytabFile.exists() && !keytabFile.delete()) {\n<line4>        LOG.error(\"Failed to delete keytab file: {}\", keytabFile);\n<line5>    }\n<line6>    for (String principal : principals) {\n<line7>        simpleKdc.getKadmin().exportKeytab(keytabFile, principal);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to delete keytab file: {}\", keytabFile);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        jaasConfigDir = ClientBase.createTmpDir();\n<line4>        File saslConfFile = new File(jaasConfigDir, \"jaas.conf\");\n<line5>        FileWriter fwriter = new FileWriter(saslConfFile);\n<line6>        fwriter.write(jaasEntries);\n<line7>        fwriter.close();\n<line8>        System.setProperty(\"java.security.auth.login.config\", saslConfFile.getAbsolutePath());\n<line9>    } catch (IOException ioe) {\n<line10>        // could not create tmp directory to hold JAAS conf file : test will\n<line11>        // fail now.\n<line12>    }\n<line13>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line14>    // even if other tests already have been executed and initialized the SASL configs before)\n<line15>    Configuration.getConfiguration().refresh();\n<line16>}","output":"<line1>{\n<line2>    try {\n<line3>        jaasConfigDir = ClientBase.createTmpDir();\n<line4>        File saslConfFile = new File(jaasConfigDir, \"jaas.conf\");\n<line5>        FileWriter fwriter = new FileWriter(saslConfFile);\n<line6>        fwriter.write(jaasEntries);\n<line7>        fwriter.close();\n<line8>        System.setProperty(\"java.security.auth.login.config\", saslConfFile.getAbsolutePath());\n<line9>    } catch (IOException ioe) {\n<line10>        LOG.error(\"Failed to create tmp directory to hold JAAS conf file\", ioe);\n<line11>        // could not create tmp directory to hold JAAS conf file : test will\n<line12>        // fail now.\n<line13>    }\n<line14>    // refresh the SASL configuration in this JVM (making sure that we use the latest config\n<line15>    // even if other tests already have been executed and initialized the SASL configs before)\n<line16>    Configuration.getConfiguration().refresh();\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    // could not create tmp directory to hold JAAS conf file : test will\n<line3>    // fail now.\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to create tmp directory to hold JAAS conf file\", ioe);\n<line3>    // could not create tmp directory to hold JAAS conf file : test will\n<line4>    // fail now.\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    MainThread m = shutdown(index);\n<line3>    startServer(m, authConfigs);\n<line4>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + m.getClientPort(), ClientBase.CONNECTION_TIMEOUT), \"waiting for server\" + index + \"being up\");\n<line5>    watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);\n<line6>    zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"Restarting server myid={}\", index);\n<line3>    MainThread m = shutdown(index);\n<line4>    startServer(m, authConfigs);\n<line5>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + m.getClientPort(), ClientBase.CONNECTION_TIMEOUT), \"waiting for server\" + index + \"being up\");\n<line6>    watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);\n<line7>    zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>}","output":"<line1>{\n<line2>    this.i = i;\n<line3>    this.peer = peer;\n<line4>    LOG.info(\"Constructor: {}\", getName());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        peer.setPeerState(ServerState.LOOKING);\n<line5>        v = peer.getElectionAlg().lookForLeader();\n<line6>        if (v == null) {\n<line7>            fail(\"Thread \" + i + \" got a null vote\");\n<line8>        }\n<line9>        /*\n<line10>                 * A real zookeeper would take care of setting the current vote. Here\n<line11>                 * we do it manually.\n<line12>                 */\n<line13>        peer.setCurrentVote(v);\n<line14>        assertTrue(peer.getPeerState() == ServerState.LEADING, \"State is not leading.\");\n<line15>    } catch (Exception e) {\n<line16>        e.printStackTrace();\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        Vote v = null;\n<line4>        peer.setPeerState(ServerState.LOOKING);\n<line5>        LOG.info(\"Going to call leader election: {}\", i);\n<line6>        v = peer.getElectionAlg().lookForLeader();\n<line7>        if (v == null) {\n<line8>            fail(\"Thread \" + i + \" got a null vote\");\n<line9>        }\n<line10>        /*\n<line11>                 * A real zookeeper would take care of setting the current vote. Here\n<line12>                 * we do it manually.\n<line13>                 */\n<line14>        peer.setCurrentVote(v);\n<line15>        LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line16>        assertTrue(peer.getPeerState() == ServerState.LEADING, \"State is not leading.\");\n<line17>    } catch (Exception e) {\n<line18>        e.printStackTrace();\n<line19>    }\n<line20>    LOG.info(\"Joining\");\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    Vote v = null;\n<line3>    peer.setPeerState(ServerState.LOOKING);\n<line4>    v = peer.getElectionAlg().lookForLeader();\n<line5>    if (v == null) {\n<line6>        fail(\"Thread \" + i + \" got a null vote\");\n<line7>    }\n<line8>    /*\n<line9>                 * A real zookeeper would take care of setting the current vote. Here\n<line10>                 * we do it manually.\n<line11>                 */\n<line12>    peer.setCurrentVote(v);\n<line13>    assertTrue(peer.getPeerState() == ServerState.LEADING, \"State is not leading.\");\n<line14>}","output":"<line1>{\n<line2>    Vote v = null;\n<line3>    peer.setPeerState(ServerState.LOOKING);\n<line4>    LOG.info(\"Going to call leader election: {}\", i);\n<line5>    v = peer.getElectionAlg().lookForLeader();\n<line6>    if (v == null) {\n<line7>        fail(\"Thread \" + i + \" got a null vote\");\n<line8>    }\n<line9>    /*\n<line10>                 * A real zookeeper would take care of setting the current vote. Here\n<line11>                 * we do it manually.\n<line12>                 */\n<line13>    peer.setCurrentVote(v);\n<line14>    LOG.info(\"Finished election: {}, {}\", i, v.getId());\n<line15>    assertTrue(peer.getPeerState() == ServerState.LEADING, \"State is not leading.\");\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (header != null && Long.toHexString(header.getZxid()).equals(skipTxnZxid)) {\n<line3>        ProcessTxnResult rc = new ProcessTxnResult();\n<line4>        rc.path = \"\";\n<line5>        rc.stat = new Stat();\n<line6>        rc.multiResult = new ArrayList<>();\n<line7>        return rc;\n<line8>    }\n<line9>    return invocation.proceed(header, txn, digest);\n<line10>}","output":"<line1>{\n<line2>    if (header != null && Long.toHexString(header.getZxid()).equals(skipTxnZxid)) {\n<line3>        LOG.info(\"skip process txn {}\", header.getZxid());\n<line4>        ProcessTxnResult rc = new ProcessTxnResult();\n<line5>        rc.path = \"\";\n<line6>        rc.stat = new Stat();\n<line7>        rc.multiResult = new ArrayList<>();\n<line8>        return rc;\n<line9>    }\n<line10>    return invocation.proceed(header, txn, digest);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    ProcessTxnResult rc = new ProcessTxnResult();\n<line3>    rc.path = \"\";\n<line4>    rc.stat = new Stat();\n<line5>    rc.multiResult = new ArrayList<>();\n<line6>    return rc;\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"skip process txn {}\", header.getZxid());\n<line3>    ProcessTxnResult rc = new ProcessTxnResult();\n<line4>    rc.path = \"\";\n<line5>    rc.stat = new Stat();\n<line6>    rc.multiResult = new ArrayList<>();\n<line7>    return rc;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);\n<line4>        QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line5>        QuorumCnxManager.Listener listener = cnxManager.listener;\n<line6>        if (listener != null) {\n<line7>            listener.start();\n<line8>        } else {\n<line9>        }\n<line10>        long sid = 1;\n<line11>        cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));\n<line12>        Message m = null;\n<line13>        int numRetries = 1;\n<line14>        while ((m == null) && (numRetries++ <= THRESHOLD)) {\n<line15>            m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line16>            if (m == null) {\n<line17>                cnxManager.connectAll();\n<line18>            }\n<line19>        }\n<line20>        if (numRetries > THRESHOLD) {\n<line21>            failed = true;\n<line22>            return;\n<line23>        }\n<line24>        cnxManager.testInitiateConnection(sid);\n<line25>        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line26>        if (m == null) {\n<line27>            failed = true;\n<line28>        }\n<line29>    } catch (Exception e) {\n<line30>        fail(\"Unexpected exception\");\n<line31>    }\n<line32>}","output":"<line1>{\n<line2>    try {\n<line3>        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);\n<line4>        QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line5>        QuorumCnxManager.Listener listener = cnxManager.listener;\n<line6>        if (listener != null) {\n<line7>            listener.start();\n<line8>        } else {\n<line9>            LOG.error(\"Null listener when initializing cnx manager\");\n<line10>        }\n<line11>        long sid = 1;\n<line12>        cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));\n<line13>        Message m = null;\n<line14>        int numRetries = 1;\n<line15>        while ((m == null) && (numRetries++ <= THRESHOLD)) {\n<line16>            m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line17>            if (m == null) {\n<line18>                cnxManager.connectAll();\n<line19>            }\n<line20>        }\n<line21>        if (numRetries > THRESHOLD) {\n<line22>            failed = true;\n<line23>            return;\n<line24>        }\n<line25>        cnxManager.testInitiateConnection(sid);\n<line26>        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line27>        if (m == null) {\n<line28>            failed = true;\n<line29>        }\n<line30>    } catch (Exception e) {\n<line31>        LOG.error(\"Exception while running mock thread\", e);\n<line32>        fail(\"Unexpected exception\");\n<line33>    }\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);\n<line3>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line4>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line5>    if (listener != null) {\n<line6>        listener.start();\n<line7>    } else {\n<line8>    }\n<line9>    long sid = 1;\n<line10>    cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));\n<line11>    Message m = null;\n<line12>    int numRetries = 1;\n<line13>    while ((m == null) && (numRetries++ <= THRESHOLD)) {\n<line14>        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line15>        if (m == null) {\n<line16>            cnxManager.connectAll();\n<line17>        }\n<line18>    }\n<line19>    if (numRetries > THRESHOLD) {\n<line20>        failed = true;\n<line21>        return;\n<line22>    }\n<line23>    cnxManager.testInitiateConnection(sid);\n<line24>    m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line25>    if (m == null) {\n<line26>        failed = true;\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);\n<line3>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line4>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line5>    if (listener != null) {\n<line6>        listener.start();\n<line7>    } else {\n<line8>        LOG.error(\"Null listener when initializing cnx manager\");\n<line9>    }\n<line10>    long sid = 1;\n<line11>    cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));\n<line12>    Message m = null;\n<line13>    int numRetries = 1;\n<line14>    while ((m == null) && (numRetries++ <= THRESHOLD)) {\n<line15>        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line16>        if (m == null) {\n<line17>            cnxManager.connectAll();\n<line18>        }\n<line19>    }\n<line20>    if (numRetries > THRESHOLD) {\n<line21>        failed = true;\n<line22>        return;\n<line23>    }\n<line24>    cnxManager.testInitiateConnection(sid);\n<line25>    m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line26>    if (m == null) {\n<line27>        failed = true;\n<line28>    }\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    fail(\"Unexpected exception\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while running mock thread\", e);\n<line3>    fail(\"Unexpected exception\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    CnxManagerThread thread = new CnxManagerThread();\n<line3>    thread.start();\n<line4>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line5>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line6>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line7>    if (listener != null) {\n<line8>        listener.start();\n<line9>    } else {\n<line10>    }\n<line11>    cnxManager.toSend(0L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));\n<line12>    Message m = null;\n<line13>    int numRetries = 1;\n<line14>    while ((m == null) && (numRetries++ <= THRESHOLD)) {\n<line15>        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line16>        if (m == null) {\n<line17>            cnxManager.connectAll();\n<line18>        }\n<line19>    }\n<line20>    assertTrue(numRetries <= THRESHOLD, \"Exceeded number of retries\");\n<line21>    thread.join(5000);\n<line22>    if (thread.isAlive()) {\n<line23>        fail(\"Thread didn't join\");\n<line24>    } else {\n<line25>        if (thread.failed) {\n<line26>            fail(\"Did not receive expected message\");\n<line27>        }\n<line28>    }\n<line29>    cnxManager.halt();\n<line30>    assertFalse(cnxManager.listener.isAlive());\n<line31>}","output":"<line1>{\n<line2>    CnxManagerThread thread = new CnxManagerThread();\n<line3>    thread.start();\n<line4>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line5>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line6>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line7>    if (listener != null) {\n<line8>        listener.start();\n<line9>    } else {\n<line10>        LOG.error(\"Null listener when initializing cnx manager\");\n<line11>    }\n<line12>    cnxManager.toSend(0L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));\n<line13>    Message m = null;\n<line14>    int numRetries = 1;\n<line15>    while ((m == null) && (numRetries++ <= THRESHOLD)) {\n<line16>        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line17>        if (m == null) {\n<line18>            cnxManager.connectAll();\n<line19>        }\n<line20>    }\n<line21>    assertTrue(numRetries <= THRESHOLD, \"Exceeded number of retries\");\n<line22>    thread.join(5000);\n<line23>    if (thread.isAlive()) {\n<line24>        fail(\"Thread didn't join\");\n<line25>    } else {\n<line26>        if (thread.failed) {\n<line27>            fail(\"Did not receive expected message\");\n<line28>        }\n<line29>    }\n<line30>    cnxManager.halt();\n<line31>    assertFalse(cnxManager.listener.isAlive());\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    int address = ThreadLocalRandom.current().nextInt(1, 255);\n<line3>    int deadPort = PortAssignment.unique();\n<line4>    String deadAddress = \"10.1.1.\" + address;\n<line5>    peers.put(2L, new QuorumServer(2, new InetSocketAddress(deadAddress, deadPort), new InetSocketAddress(deadAddress, PortAssignment.unique()), new InetSocketAddress(deadAddress, PortAssignment.unique())));\n<line6>    peerTmpdir[2] = ClientBase.createTmpDir();\n<line7>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line8>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line9>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line10>    if (listener != null) {\n<line11>        listener.start();\n<line12>    } else {\n<line13>    }\n<line14>    long begin = Time.currentElapsedTime();\n<line15>    cnxManager.toSend(2L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));\n<line16>    long end = Time.currentElapsedTime();\n<line17>    if ((end - begin) > 10_000) {\n<line18>        fail(\"Waited more than necessary\");\n<line19>    }\n<line20>    cnxManager.halt();\n<line21>    assertFalse(cnxManager.listener.isAlive());\n<line22>}","output":"<line1>{\n<line2>    int address = ThreadLocalRandom.current().nextInt(1, 255);\n<line3>    int deadPort = PortAssignment.unique();\n<line4>    String deadAddress = \"10.1.1.\" + address;\n<line5>    LOG.info(\"This is the dead address I'm trying: {}\", deadAddress);\n<line6>    peers.put(2L, new QuorumServer(2, new InetSocketAddress(deadAddress, deadPort), new InetSocketAddress(deadAddress, PortAssignment.unique()), new InetSocketAddress(deadAddress, PortAssignment.unique())));\n<line7>    peerTmpdir[2] = ClientBase.createTmpDir();\n<line8>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line9>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line10>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line11>    if (listener != null) {\n<line12>        listener.start();\n<line13>    } else {\n<line14>        LOG.error(\"Null listener when initializing cnx manager\");\n<line15>    }\n<line16>    long begin = Time.currentElapsedTime();\n<line17>    cnxManager.toSend(2L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));\n<line18>    long end = Time.currentElapsedTime();\n<line19>    if ((end - begin) > 10_000) {\n<line20>        fail(\"Waited more than necessary\");\n<line21>    }\n<line22>    cnxManager.halt();\n<line23>    assertFalse(cnxManager.listener.isAlive());\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line3>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line4>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line5>    if (listener != null) {\n<line6>        listener.start();\n<line7>    } else {\n<line8>    }\n<line9>    InetSocketAddress address = peers.get(peer.getMyId()).electionAddr.getReachableOrOne();\n<line10>    Thread.sleep(1000);\n<line11>    SocketChannel sc = SocketChannel.open();\n<line12>    sc.socket().connect(address, 5000);\n<line13>    InetSocketAddress otherAddr = peers.get(2L).electionAddr.getReachableOrOne();\n<line14>    DataOutputStream dout = new DataOutputStream(sc.socket().getOutputStream());\n<line15>    dout.writeLong(QuorumCnxManager.PROTOCOL_VERSION_V1);\n<line16>    dout.writeLong(2);\n<line17>    String addr = otherAddr.getHostString() + \":\" + otherAddr.getPort();\n<line18>    byte[] addr_bytes = addr.getBytes();\n<line19>    dout.writeInt(addr_bytes.length);\n<line20>    dout.write(addr_bytes);\n<line21>    dout.flush();\n<line22>    ByteBuffer msgBuffer = ByteBuffer.wrap(new byte[4]);\n<line23>    msgBuffer.putInt(-20);\n<line24>    msgBuffer.position(0);\n<line25>    sc.write(msgBuffer);\n<line26>    Thread.sleep(1000);\n<line27>    try {\n<line28>        /*\n<line29>             * Write a number of times until it\n<line30>             * detects that the socket is broken.\n<line31>             */\n<line32>        for (int i = 0; i < 100; i++) {\n<line33>            msgBuffer.position(0);\n<line34>            sc.write(msgBuffer);\n<line35>        }\n<line36>        fail(\"Socket has not been closed\");\n<line37>    } catch (Exception e) {\n<line38>    }\n<line39>    peer.shutdown();\n<line40>    cnxManager.halt();\n<line41>    assertFalse(cnxManager.listener.isAlive());\n<line42>}","output":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line3>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line4>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line5>    if (listener != null) {\n<line6>        listener.start();\n<line7>    } else {\n<line8>        LOG.error(\"Null listener when initializing cnx manager\");\n<line9>    }\n<line10>    InetSocketAddress address = peers.get(peer.getMyId()).electionAddr.getReachableOrOne();\n<line11>    LOG.info(\"Election port: {}\", address.getPort());\n<line12>    Thread.sleep(1000);\n<line13>    SocketChannel sc = SocketChannel.open();\n<line14>    sc.socket().connect(address, 5000);\n<line15>    InetSocketAddress otherAddr = peers.get(2L).electionAddr.getReachableOrOne();\n<line16>    DataOutputStream dout = new DataOutputStream(sc.socket().getOutputStream());\n<line17>    dout.writeLong(QuorumCnxManager.PROTOCOL_VERSION_V1);\n<line18>    dout.writeLong(2);\n<line19>    String addr = otherAddr.getHostString() + \":\" + otherAddr.getPort();\n<line20>    byte[] addr_bytes = addr.getBytes();\n<line21>    dout.writeInt(addr_bytes.length);\n<line22>    dout.write(addr_bytes);\n<line23>    dout.flush();\n<line24>    ByteBuffer msgBuffer = ByteBuffer.wrap(new byte[4]);\n<line25>    msgBuffer.putInt(-20);\n<line26>    msgBuffer.position(0);\n<line27>    sc.write(msgBuffer);\n<line28>    Thread.sleep(1000);\n<line29>    try {\n<line30>        /*\n<line31>             * Write a number of times until it\n<line32>             * detects that the socket is broken.\n<line33>             */\n<line34>        for (int i = 0; i < 100; i++) {\n<line35>            msgBuffer.position(0);\n<line36>            sc.write(msgBuffer);\n<line37>        }\n<line38>        fail(\"Socket has not been closed\");\n<line39>    } catch (Exception e) {\n<line40>        LOG.info(\"Socket has been closed as expected\");\n<line41>    }\n<line42>    peer.shutdown();\n<line43>    cnxManager.halt();\n<line44>    assertFalse(cnxManager.listener.isAlive());\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Socket has been closed as expected\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // the connecting peer (id = 2) is a 3.4.6 observer\n<line3>    peers.get(2L).type = LearnerType.OBSERVER;\n<line4>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line5>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line6>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line7>    if (listener != null) {\n<line8>        listener.start();\n<line9>    } else {\n<line10>    }\n<line11>    InetSocketAddress address = peers.get(peer.getMyId()).electionAddr.getReachableOrOne();\n<line12>    Thread.sleep(1000);\n<line13>    SocketChannel sc = SocketChannel.open();\n<line14>    sc.socket().connect(address, 5000);\n<line15>    /*\n<line16>         * Write id (3.4.6 protocol). This previously caused a NPE in\n<line17>         * QuorumCnxManager.\n<line18>         */\n<line19>    byte[] msgBytes = new byte[8];\n<line20>    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);\n<line21>    msgBuffer.putLong(2L);\n<line22>    msgBuffer.position(0);\n<line23>    sc.write(msgBuffer);\n<line24>    msgBuffer = ByteBuffer.wrap(new byte[8]);\n<line25>    // write length of message\n<line26>    msgBuffer.putInt(4);\n<line27>    // write message\n<line28>    msgBuffer.putInt(5);\n<line29>    msgBuffer.position(0);\n<line30>    sc.write(msgBuffer);\n<line31>    Message m = cnxManager.pollRecvQueue(1000, TimeUnit.MILLISECONDS);\n<line32>    assertNotNull(m);\n<line33>    peer.shutdown();\n<line34>    cnxManager.halt();\n<line35>    assertFalse(cnxManager.listener.isAlive());\n<line36>}","output":"<line1>{\n<line2>    // the connecting peer (id = 2) is a 3.4.6 observer\n<line3>    peers.get(2L).type = LearnerType.OBSERVER;\n<line4>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);\n<line5>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line6>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line7>    if (listener != null) {\n<line8>        listener.start();\n<line9>    } else {\n<line10>        LOG.error(\"Null listener when initializing cnx manager\");\n<line11>    }\n<line12>    InetSocketAddress address = peers.get(peer.getMyId()).electionAddr.getReachableOrOne();\n<line13>    LOG.info(\"Election port: {}\", address.getPort());\n<line14>    Thread.sleep(1000);\n<line15>    SocketChannel sc = SocketChannel.open();\n<line16>    sc.socket().connect(address, 5000);\n<line17>    /*\n<line18>         * Write id (3.4.6 protocol). This previously caused a NPE in\n<line19>         * QuorumCnxManager.\n<line20>         */\n<line21>    byte[] msgBytes = new byte[8];\n<line22>    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);\n<line23>    msgBuffer.putLong(2L);\n<line24>    msgBuffer.position(0);\n<line25>    sc.write(msgBuffer);\n<line26>    msgBuffer = ByteBuffer.wrap(new byte[8]);\n<line27>    // write length of message\n<line28>    msgBuffer.putInt(4);\n<line29>    // write message\n<line30>    msgBuffer.putInt(5);\n<line31>    msgBuffer.position(0);\n<line32>    sc.write(msgBuffer);\n<line33>    Message m = cnxManager.pollRecvQueue(1000, TimeUnit.MILLISECONDS);\n<line34>    assertNotNull(m);\n<line35>    peer.shutdown();\n<line36>    cnxManager.halt();\n<line37>    assertFalse(cnxManager.listener.isAlive());\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2, 2);\n<line3>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line4>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line5>    if (listener != null) {\n<line6>        listener.start();\n<line7>    } else {\n<line8>    }\n<line9>    InetSocketAddress address = peers.get(peer.getMyId()).electionAddr.getReachableOrOne();\n<line10>    Thread.sleep(1000);\n<line11>    Socket sock = new Socket();\n<line12>    sock.connect(address, 5000);\n<line13>    long begin = Time.currentElapsedTime();\n<line14>    // Read without sending data. Verify timeout.\n<line15>    cnxManager.receiveConnection(sock);\n<line16>    long end = Time.currentElapsedTime();\n<line17>    if ((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) {\n<line18>        fail(\"Waited more than necessary\");\n<line19>    }\n<line20>    cnxManager.halt();\n<line21>    assertFalse(cnxManager.listener.isAlive());\n<line22>}","output":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2, 2);\n<line3>    QuorumCnxManager cnxManager = peer.createCnxnManager();\n<line4>    QuorumCnxManager.Listener listener = cnxManager.listener;\n<line5>    if (listener != null) {\n<line6>        listener.start();\n<line7>    } else {\n<line8>        LOG.error(\"Null listener when initializing cnx manager\");\n<line9>    }\n<line10>    InetSocketAddress address = peers.get(peer.getMyId()).electionAddr.getReachableOrOne();\n<line11>    LOG.info(\"Election port: {}\", address.getPort());\n<line12>    Thread.sleep(1000);\n<line13>    Socket sock = new Socket();\n<line14>    sock.connect(address, 5000);\n<line15>    long begin = Time.currentElapsedTime();\n<line16>    // Read without sending data. Verify timeout.\n<line17>    cnxManager.receiveConnection(sock);\n<line18>    long end = Time.currentElapsedTime();\n<line19>    if ((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) {\n<line20>        fail(\"Waited more than necessary\");\n<line21>    }\n<line22>    cnxManager.halt();\n<line23>    assertFalse(cnxManager.listener.isAlive());\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ArrayList<QuorumPeer> peerList = new ArrayList<>();\n<line3>    try {\n<line4>        for (int sid = 0; sid < 3; sid++) {\n<line5>            QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);\n<line6>            peer.start();\n<line7>            peerList.add(sid, peer);\n<line8>        }\n<line9>        String failure = verifyThreadCount(peerList, 4);\n<line10>        assertNull(failure, failure);\n<line11>        for (int myid = 0; myid < 3; myid++) {\n<line12>            for (int i = 0; i < 5; i++) {\n<line13>                // halt one of the listeners and verify count\n<line14>                QuorumPeer peer = peerList.get(myid);\n<line15>                peer.shutdown();\n<line16>                peerList.remove(myid);\n<line17>                failure = verifyThreadCount(peerList, 2);\n<line18>                assertNull(failure, failure);\n<line19>                // Restart halted node and verify count\n<line20>                peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line21>                peer.start();\n<line22>                peerList.add(myid, peer);\n<line23>                failure = verifyThreadCount(peerList, 4);\n<line24>                assertNull(failure, failure);\n<line25>            }\n<line26>        }\n<line27>    } finally {\n<line28>        for (QuorumPeer quorumPeer : peerList) {\n<line29>            quorumPeer.shutdown();\n<line30>        }\n<line31>    }\n<line32>}","output":"<line1>{\n<line2>    ArrayList<QuorumPeer> peerList = new ArrayList<>();\n<line3>    try {\n<line4>        for (int sid = 0; sid < 3; sid++) {\n<line5>            QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);\n<line6>            LOG.info(\"Starting peer {}\", peer.getMyId());\n<line7>            peer.start();\n<line8>            peerList.add(sid, peer);\n<line9>        }\n<line10>        String failure = verifyThreadCount(peerList, 4);\n<line11>        assertNull(failure, failure);\n<line12>        for (int myid = 0; myid < 3; myid++) {\n<line13>            for (int i = 0; i < 5; i++) {\n<line14>                // halt one of the listeners and verify count\n<line15>                QuorumPeer peer = peerList.get(myid);\n<line16>                LOG.info(\"Round {}, halting peer {}\", i, peer.getMyId());\n<line17>                peer.shutdown();\n<line18>                peerList.remove(myid);\n<line19>                failure = verifyThreadCount(peerList, 2);\n<line20>                assertNull(failure, failure);\n<line21>                // Restart halted node and verify count\n<line22>                peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line23>                LOG.info(\"Round {}, restarting peer {}\", i, peer.getMyId());\n<line24>                peer.start();\n<line25>                peerList.add(myid, peer);\n<line26>                failure = verifyThreadCount(peerList, 4);\n<line27>                assertNull(failure, failure);\n<line28>            }\n<line29>        }\n<line30>    } finally {\n<line31>        for (QuorumPeer quorumPeer : peerList) {\n<line32>            quorumPeer.shutdown();\n<line33>        }\n<line34>    }\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int sid = 0; sid < 3; sid++) {\n<line3>        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);\n<line4>        peer.start();\n<line5>        peerList.add(sid, peer);\n<line6>    }\n<line7>    String failure = verifyThreadCount(peerList, 4);\n<line8>    assertNull(failure, failure);\n<line9>    for (int myid = 0; myid < 3; myid++) {\n<line10>        for (int i = 0; i < 5; i++) {\n<line11>            // halt one of the listeners and verify count\n<line12>            QuorumPeer peer = peerList.get(myid);\n<line13>            peer.shutdown();\n<line14>            peerList.remove(myid);\n<line15>            failure = verifyThreadCount(peerList, 2);\n<line16>            assertNull(failure, failure);\n<line17>            // Restart halted node and verify count\n<line18>            peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line19>            peer.start();\n<line20>            peerList.add(myid, peer);\n<line21>            failure = verifyThreadCount(peerList, 4);\n<line22>            assertNull(failure, failure);\n<line23>        }\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    for (int sid = 0; sid < 3; sid++) {\n<line3>        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);\n<line4>        LOG.info(\"Starting peer {}\", peer.getMyId());\n<line5>        peer.start();\n<line6>        peerList.add(sid, peer);\n<line7>    }\n<line8>    String failure = verifyThreadCount(peerList, 4);\n<line9>    assertNull(failure, failure);\n<line10>    for (int myid = 0; myid < 3; myid++) {\n<line11>        for (int i = 0; i < 5; i++) {\n<line12>            // halt one of the listeners and verify count\n<line13>            QuorumPeer peer = peerList.get(myid);\n<line14>            LOG.info(\"Round {}, halting peer {}\", i, peer.getMyId());\n<line15>            peer.shutdown();\n<line16>            peerList.remove(myid);\n<line17>            failure = verifyThreadCount(peerList, 2);\n<line18>            assertNull(failure, failure);\n<line19>            // Restart halted node and verify count\n<line20>            peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line21>            LOG.info(\"Round {}, restarting peer {}\", i, peer.getMyId());\n<line22>            peer.start();\n<line23>            peerList.add(myid, peer);\n<line24>            failure = verifyThreadCount(peerList, 4);\n<line25>            assertNull(failure, failure);\n<line26>        }\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);\n<line3>    peer.start();\n<line4>    peerList.add(sid, peer);\n<line5>}","output":"<line1>{\n<line2>    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);\n<line3>    LOG.info(\"Starting peer {}\", peer.getMyId());\n<line4>    peer.start();\n<line5>    peerList.add(sid, peer);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < 5; i++) {\n<line3>        // halt one of the listeners and verify count\n<line4>        QuorumPeer peer = peerList.get(myid);\n<line5>        peer.shutdown();\n<line6>        peerList.remove(myid);\n<line7>        failure = verifyThreadCount(peerList, 2);\n<line8>        assertNull(failure, failure);\n<line9>        // Restart halted node and verify count\n<line10>        peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line11>        peer.start();\n<line12>        peerList.add(myid, peer);\n<line13>        failure = verifyThreadCount(peerList, 4);\n<line14>        assertNull(failure, failure);\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    for (int i = 0; i < 5; i++) {\n<line3>        // halt one of the listeners and verify count\n<line4>        QuorumPeer peer = peerList.get(myid);\n<line5>        LOG.info(\"Round {}, halting peer {}\", i, peer.getMyId());\n<line6>        peer.shutdown();\n<line7>        peerList.remove(myid);\n<line8>        failure = verifyThreadCount(peerList, 2);\n<line9>        assertNull(failure, failure);\n<line10>        // Restart halted node and verify count\n<line11>        peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line12>        LOG.info(\"Round {}, restarting peer {}\", i, peer.getMyId());\n<line13>        peer.start();\n<line14>        peerList.add(myid, peer);\n<line15>        failure = verifyThreadCount(peerList, 4);\n<line16>        assertNull(failure, failure);\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    // halt one of the listeners and verify count\n<line3>    QuorumPeer peer = peerList.get(myid);\n<line4>    peer.shutdown();\n<line5>    peerList.remove(myid);\n<line6>    failure = verifyThreadCount(peerList, 2);\n<line7>    assertNull(failure, failure);\n<line8>    // Restart halted node and verify count\n<line9>    peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line10>    peer.start();\n<line11>    peerList.add(myid, peer);\n<line12>    failure = verifyThreadCount(peerList, 4);\n<line13>    assertNull(failure, failure);\n<line14>}","output":"<line1>{\n<line2>    // halt one of the listeners and verify count\n<line3>    QuorumPeer peer = peerList.get(myid);\n<line4>    LOG.info(\"Round {}, halting peer {}\", i, peer.getMyId());\n<line5>    peer.shutdown();\n<line6>    peerList.remove(myid);\n<line7>    failure = verifyThreadCount(peerList, 2);\n<line8>    assertNull(failure, failure);\n<line9>    // Restart halted node and verify count\n<line10>    peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);\n<line11>    LOG.info(\"Round {}, restarting peer {}\", i, peer.getMyId());\n<line12>    peer.start();\n<line13>    peerList.add(myid, peer);\n<line14>    failure = verifyThreadCount(peerList, 4);\n<line15>    assertNull(failure, failure);\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {\n<line3>\n<line4>        @Override\n<line5>        protected void processPacket(QuorumPacket qp) throws Exception {\n<line6>            if (stopPing && qp.getType() == Leader.PING) {\n<line7>                throw new SocketException(\"Socket time out while sending the ping response\");\n<line8>            } else {\n<line9>                super.processPacket(qp);\n<line10>            }\n<line11>        }\n<line12>    };\n<line13>}","output":"<line1>{\n<line2>    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {\n<line3>\n<line4>        @Override\n<line5>        protected void processPacket(QuorumPacket qp) throws Exception {\n<line6>            if (stopPing && qp.getType() == Leader.PING) {\n<line7>                LOG.info(\"Follower skipped ping\");\n<line8>                throw new SocketException(\"Socket time out while sending the ping response\");\n<line9>            } else {\n<line10>                super.processPacket(qp);\n<line11>            }\n<line12>        }\n<line13>    };\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (stopPing && qp.getType() == Leader.PING) {\n<line3>        throw new SocketException(\"Socket time out while sending the ping response\");\n<line4>    } else {\n<line5>        super.processPacket(qp);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (stopPing && qp.getType() == Leader.PING) {\n<line3>        LOG.info(\"Follower skipped ping\");\n<line4>        throw new SocketException(\"Socket time out while sending the ping response\");\n<line5>    } else {\n<line6>        super.processPacket(qp);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new SocketException(\"Socket time out while sending the ping response\");\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Follower skipped ping\");\n<line3>    throw new SocketException(\"Socket time out while sending the ping response\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    // ensure no leaked parallelism properties\n<line4>    System.clearProperty(\"zookeeper.commitProcessor.maxReadBatchSize\");\n<line5>    System.clearProperty(\"zookeeper.commitProcessor.maxCommitBatchSize\");\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"setup\");\n<line3>    ServerMetrics.getMetrics().resetAll();\n<line4>    // ensure no leaked parallelism properties\n<line5>    System.clearProperty(\"zookeeper.commitProcessor.maxReadBatchSize\");\n<line6>    System.clearProperty(\"zookeeper.commitProcessor.maxCommitBatchSize\");\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    commitProcessor.shutdown();\n<line3>    commitProcessor.join();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"tearDown starting\");\n<line3>    commitProcessor.shutdown();\n<line4>    commitProcessor.join();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    super.workerPool = new TestWorkerService(numWorkerThreads);\n<line3>    super.start();\n<line4>    // Since there are two threads--the test thread that puts requests into the queue and the processor\n<line5>    // thread (this thread) that removes requests from the queue--the execution order in general is\n<line6>    // indeterminate, making it hard to check the test results.\n<line7>    //\n<line8>    // In some tests, we really want the requests processed one by one. To achieve this, we make sure that\n<line9>    // things happen in this order:\n<line10>    // processor thread gets into WAITING -> test thread sets requestProcessed latch -> test thread puts\n<line11>    // a request into the queue (which wakes up the processor thread in the WAITING state) and waits for\n<line12>    // the requestProcessed latch -> the processor thread wakes up and removes the request from the queue and\n<line13>    // processes it and opens the requestProcessed latch -> the test thread continues onto the next request\n<line14>    // So it is important for the processor thread to get into WAITING before any request is put into the queue.\n<line15>    // Otherwise, it would miss the wakeup signal and wouldn't process the request or open the latch and the\n<line16>    // test thread waiting on the latch would be stuck\n<line17>    Thread.State state = super.getState();\n<line18>    while (state != State.WAITING) {\n<line19>        try {\n<line20>            Thread.sleep(50);\n<line21>        } catch (Exception e) {\n<line22>        }\n<line23>        state = super.getState();\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    super.workerPool = new TestWorkerService(numWorkerThreads);\n<line3>    super.start();\n<line4>    // Since there are two threads--the test thread that puts requests into the queue and the processor\n<line5>    // thread (this thread) that removes requests from the queue--the execution order in general is\n<line6>    // indeterminate, making it hard to check the test results.\n<line7>    //\n<line8>    // In some tests, we really want the requests processed one by one. To achieve this, we make sure that\n<line9>    // things happen in this order:\n<line10>    // processor thread gets into WAITING -> test thread sets requestProcessed latch -> test thread puts\n<line11>    // a request into the queue (which wakes up the processor thread in the WAITING state) and waits for\n<line12>    // the requestProcessed latch -> the processor thread wakes up and removes the request from the queue and\n<line13>    // processes it and opens the requestProcessed latch -> the test thread continues onto the next request\n<line14>    // So it is important for the processor thread to get into WAITING before any request is put into the queue.\n<line15>    // Otherwise, it would miss the wakeup signal and wouldn't process the request or open the latch and the\n<line16>    // test thread waiting on the latch would be stuck\n<line17>    Thread.State state = super.getState();\n<line18>    while (state != State.WAITING) {\n<line19>        try {\n<line20>            Thread.sleep(50);\n<line21>        } catch (Exception e) {\n<line22>        }\n<line23>        state = super.getState();\n<line24>    }\n<line25>    LOG.info(\"numWorkerThreads in Test is {}\", numWorkerThreads);\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        leader.lead();\n<line4>    } catch (InterruptedException e) {\n<line5>    } catch (Exception e) {\n<line6>    } finally {\n<line7>        leader.shutdown(\"lead ended\");\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        leader.lead();\n<line4>    } catch (InterruptedException e) {\n<line5>        LOG.info(\"Leader thread interrupted\", e);\n<line6>    } catch (Exception e) {\n<line7>        LOG.warn(\"Unexpected exception in leader thread\", e);\n<line8>    } finally {\n<line9>        leader.shutdown(\"lead ended\");\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Leader thread interrupted\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n<line3>    tmpDir.delete();\n<line4>    tmpDir.mkdir();\n<line5>    Thread followerThread = null;\n<line6>    ConversableFollower follower = null;\n<line7>    QuorumPeer peer = null;\n<line8>    try {\n<line9>        peer = createQuorumPeer(tmpDir);\n<line10>        follower = createFollower(tmpDir, peer);\n<line11>        peer.follower = follower;\n<line12>        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n<line13>        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());\n<line14>        follower.setLeaderQuorumServer(leaderQS);\n<line15>        final Follower followerForThread = follower;\n<line16>        followerThread = new Thread() {\n<line17>\n<line18>            public void run() {\n<line19>                try {\n<line20>                    followerForThread.followLeader();\n<line21>                } catch (InterruptedException e) {\n<line22>                } catch (Exception e) {\n<line23>                }\n<line24>            }\n<line25>        };\n<line26>        followerThread.start();\n<line27>        Socket leaderSocket = ss.accept();\n<line28>        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());\n<line29>        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());\n<line30>        conversation.converseWithFollower(ia, oa, follower);\n<line31>    } finally {\n<line32>        if (follower != null) {\n<line33>            follower.shutdown();\n<line34>        }\n<line35>        if (followerThread != null) {\n<line36>            followerThread.interrupt();\n<line37>            followerThread.join();\n<line38>        }\n<line39>        if (peer != null) {\n<line40>            peer.shutdown();\n<line41>        }\n<line42>        TestUtils.deleteFileRecursively(tmpDir);\n<line43>    }\n<line44>}","output":"<line1>{\n<line2>    File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n<line3>    tmpDir.delete();\n<line4>    tmpDir.mkdir();\n<line5>    Thread followerThread = null;\n<line6>    ConversableFollower follower = null;\n<line7>    QuorumPeer peer = null;\n<line8>    try {\n<line9>        peer = createQuorumPeer(tmpDir);\n<line10>        follower = createFollower(tmpDir, peer);\n<line11>        peer.follower = follower;\n<line12>        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n<line13>        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());\n<line14>        follower.setLeaderQuorumServer(leaderQS);\n<line15>        final Follower followerForThread = follower;\n<line16>        followerThread = new Thread() {\n<line17>\n<line18>            public void run() {\n<line19>                try {\n<line20>                    followerForThread.followLeader();\n<line21>                } catch (InterruptedException e) {\n<line22>                    LOG.info(\"Follower thread interrupted\", e);\n<line23>                } catch (Exception e) {\n<line24>                    LOG.warn(\"Unexpected exception in follower thread\", e);\n<line25>                }\n<line26>            }\n<line27>        };\n<line28>        followerThread.start();\n<line29>        Socket leaderSocket = ss.accept();\n<line30>        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());\n<line31>        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());\n<line32>        conversation.converseWithFollower(ia, oa, follower);\n<line33>    } finally {\n<line34>        if (follower != null) {\n<line35>            follower.shutdown();\n<line36>        }\n<line37>        if (followerThread != null) {\n<line38>            followerThread.interrupt();\n<line39>            followerThread.join();\n<line40>        }\n<line41>        if (peer != null) {\n<line42>            peer.shutdown();\n<line43>        }\n<line44>        TestUtils.deleteFileRecursively(tmpDir);\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    peer = createQuorumPeer(tmpDir);\n<line3>    follower = createFollower(tmpDir, peer);\n<line4>    peer.follower = follower;\n<line5>    ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n<line6>    QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());\n<line7>    follower.setLeaderQuorumServer(leaderQS);\n<line8>    final Follower followerForThread = follower;\n<line9>    followerThread = new Thread() {\n<line10>\n<line11>        public void run() {\n<line12>            try {\n<line13>                followerForThread.followLeader();\n<line14>            } catch (InterruptedException e) {\n<line15>            } catch (Exception e) {\n<line16>            }\n<line17>        }\n<line18>    };\n<line19>    followerThread.start();\n<line20>    Socket leaderSocket = ss.accept();\n<line21>    InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());\n<line22>    OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());\n<line23>    conversation.converseWithFollower(ia, oa, follower);\n<line24>}","output":"<line1>{\n<line2>    peer = createQuorumPeer(tmpDir);\n<line3>    follower = createFollower(tmpDir, peer);\n<line4>    peer.follower = follower;\n<line5>    ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n<line6>    QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());\n<line7>    follower.setLeaderQuorumServer(leaderQS);\n<line8>    final Follower followerForThread = follower;\n<line9>    followerThread = new Thread() {\n<line10>\n<line11>        public void run() {\n<line12>            try {\n<line13>                followerForThread.followLeader();\n<line14>            } catch (InterruptedException e) {\n<line15>                LOG.info(\"Follower thread interrupted\", e);\n<line16>            } catch (Exception e) {\n<line17>                LOG.warn(\"Unexpected exception in follower thread\", e);\n<line18>            }\n<line19>        }\n<line20>    };\n<line21>    followerThread.start();\n<line22>    Socket leaderSocket = ss.accept();\n<line23>    InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());\n<line24>    OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());\n<line25>    conversation.converseWithFollower(ia, oa, follower);\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        followerForThread.followLeader();\n<line4>    } catch (InterruptedException e) {\n<line5>    } catch (Exception e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        followerForThread.followLeader();\n<line4>    } catch (InterruptedException e) {\n<line5>        LOG.info(\"Follower thread interrupted\", e);\n<line6>    } catch (Exception e) {\n<line7>        LOG.warn(\"Unexpected exception in follower thread\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Follower thread interrupted\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    testFollowerConversation(new FollowerConversation() {\n<line3>\n<line4>        @Override\n<line5>        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {\n<line6>            File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n<line7>            tmpDir.delete();\n<line8>            tmpDir.mkdir();\n<line9>            File logDir = f.fzk.getTxnLogFactory().getDataLogDir().getParentFile();\n<line10>            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();\n<line11>            //Spy on ZK so we can check if a snapshot happened or not.\n<line12>            f.zk = spy(f.zk);\n<line13>            try {\n<line14>                assertEquals(0, f.self.getAcceptedEpoch());\n<line15>                assertEquals(0, f.self.getCurrentEpoch());\n<line16>                // Setup a database with a single /foo node\n<line17>                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));\n<line18>                final long firstZxid = ZxidUtils.makeZxid(1, 1);\n<line19>                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn(\"/foo\", \"data1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1), null);\n<line20>                Stat stat = new Stat();\n<line21>                assertEquals(\"data1\", new String(zkDb.getData(\"/foo\", stat, null)));\n<line22>                QuorumPacket qp = new QuorumPacket();\n<line23>                readPacketSkippingPing(ia, qp);\n<line24>                assertEquals(Leader.FOLLOWERINFO, qp.getType());\n<line25>                assertEquals(qp.getZxid(), 0);\n<line26>                LearnerInfo learnInfo = new LearnerInfo();\n<line27>                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);\n<line28>                assertEquals(learnInfo.getProtocolVersion(), 0x10000);\n<line29>                assertEquals(learnInfo.getServerid(), 0);\n<line30>                // We are simulating an established leader, so the epoch is 1\n<line31>                qp.setType(Leader.LEADERINFO);\n<line32>                qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line33>                byte[] protoBytes = new byte[4];\n<line34>                ByteBuffer.wrap(protoBytes).putInt(0x10000);\n<line35>                qp.setData(protoBytes);\n<line36>                oa.writeRecord(qp, null);\n<line37>                readPacketSkippingPing(ia, qp);\n<line38>                assertEquals(Leader.ACKEPOCH, qp.getType());\n<line39>                assertEquals(0, qp.getZxid());\n<line40>                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());\n<line41>                assertEquals(1, f.self.getAcceptedEpoch());\n<line42>                assertEquals(0, f.self.getCurrentEpoch());\n<line43>                // Send a diff\n<line44>                qp.setType(Leader.DIFF);\n<line45>                qp.setData(new byte[0]);\n<line46>                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());\n<line47>                oa.writeRecord(qp, null);\n<line48>                final long createSessionZxid = ZxidUtils.makeZxid(1, 2);\n<line49>                proposeNewSession(qp, createSessionZxid, 0x333);\n<line50>                oa.writeRecord(qp, null);\n<line51>                qp.setType(Leader.COMMIT);\n<line52>                qp.setZxid(createSessionZxid);\n<line53>                oa.writeRecord(qp, null);\n<line54>                qp.setType(Leader.NEWLEADER);\n<line55>                qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line56>                qp.setData(null);\n<line57>                oa.writeRecord(qp, null);\n<line58>                qp.setType(Leader.UPTODATE);\n<line59>                qp.setZxid(0);\n<line60>                oa.writeRecord(qp, null);\n<line61>                // Read the uptodate ack\n<line62>                readPacketSkippingPing(ia, qp);\n<line63>                assertEquals(Leader.ACK, qp.getType());\n<line64>                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line65>                // Get the ack of the new leader\n<line66>                readPacketSkippingPing(ia, qp);\n<line67>                assertEquals(Leader.ACK, qp.getType());\n<line68>                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line69>                assertEquals(1, f.self.getAcceptedEpoch());\n<line70>                assertEquals(1, f.self.getCurrentEpoch());\n<line71>                //Wait for the transactions to be written out. The thread that writes them out\n<line72>                // does not send anything back when it is done.\n<line73>                long start = System.currentTimeMillis();\n<line74>                while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {\n<line75>                    Thread.sleep(1);\n<line76>                }\n<line77>                assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());\n<line78>                // Make sure the data was recorded in the filesystem ok\n<line79>                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));\n<line80>                start = System.currentTimeMillis();\n<line81>                zkDb2.loadDataBase();\n<line82>                while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {\n<line83>                    Thread.sleep(1);\n<line84>                    zkDb2.loadDataBase();\n<line85>                }\n<line86>                assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));\n<line87>                //Snapshot was never taken during very simple sync\n<line88>                verify(f.zk, never()).takeSnapshot();\n<line89>            } finally {\n<line90>                TestUtils.deleteFileRecursively(tmpDir);\n<line91>            }\n<line92>        }\n<line93>\n<line94>        private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException {\n<line95>            qp.setType(Leader.PROPOSAL);\n<line96>            qp.setZxid(zxid);\n<line97>            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);\n<line98>            CreateSessionTxn cst = new CreateSessionTxn(30000);\n<line99>            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line100>            OutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line101>            boa.writeRecord(hdr, null);\n<line102>            boa.writeRecord(cst, null);\n<line103>            qp.setData(baos.toByteArray());\n<line104>        }\n<line105>    });\n<line106>}","output":"<line1>{\n<line2>    testFollowerConversation(new FollowerConversation() {\n<line3>\n<line4>        @Override\n<line5>        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {\n<line6>            File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n<line7>            tmpDir.delete();\n<line8>            tmpDir.mkdir();\n<line9>            File logDir = f.fzk.getTxnLogFactory().getDataLogDir().getParentFile();\n<line10>            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();\n<line11>            //Spy on ZK so we can check if a snapshot happened or not.\n<line12>            f.zk = spy(f.zk);\n<line13>            try {\n<line14>                assertEquals(0, f.self.getAcceptedEpoch());\n<line15>                assertEquals(0, f.self.getCurrentEpoch());\n<line16>                // Setup a database with a single /foo node\n<line17>                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));\n<line18>                final long firstZxid = ZxidUtils.makeZxid(1, 1);\n<line19>                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn(\"/foo\", \"data1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1), null);\n<line20>                Stat stat = new Stat();\n<line21>                assertEquals(\"data1\", new String(zkDb.getData(\"/foo\", stat, null)));\n<line22>                QuorumPacket qp = new QuorumPacket();\n<line23>                readPacketSkippingPing(ia, qp);\n<line24>                assertEquals(Leader.FOLLOWERINFO, qp.getType());\n<line25>                assertEquals(qp.getZxid(), 0);\n<line26>                LearnerInfo learnInfo = new LearnerInfo();\n<line27>                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);\n<line28>                assertEquals(learnInfo.getProtocolVersion(), 0x10000);\n<line29>                assertEquals(learnInfo.getServerid(), 0);\n<line30>                // We are simulating an established leader, so the epoch is 1\n<line31>                qp.setType(Leader.LEADERINFO);\n<line32>                qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line33>                byte[] protoBytes = new byte[4];\n<line34>                ByteBuffer.wrap(protoBytes).putInt(0x10000);\n<line35>                qp.setData(protoBytes);\n<line36>                oa.writeRecord(qp, null);\n<line37>                readPacketSkippingPing(ia, qp);\n<line38>                assertEquals(Leader.ACKEPOCH, qp.getType());\n<line39>                assertEquals(0, qp.getZxid());\n<line40>                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());\n<line41>                assertEquals(1, f.self.getAcceptedEpoch());\n<line42>                assertEquals(0, f.self.getCurrentEpoch());\n<line43>                // Send a diff\n<line44>                qp.setType(Leader.DIFF);\n<line45>                qp.setData(new byte[0]);\n<line46>                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());\n<line47>                oa.writeRecord(qp, null);\n<line48>                final long createSessionZxid = ZxidUtils.makeZxid(1, 2);\n<line49>                proposeNewSession(qp, createSessionZxid, 0x333);\n<line50>                oa.writeRecord(qp, null);\n<line51>                qp.setType(Leader.COMMIT);\n<line52>                qp.setZxid(createSessionZxid);\n<line53>                oa.writeRecord(qp, null);\n<line54>                qp.setType(Leader.NEWLEADER);\n<line55>                qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line56>                qp.setData(null);\n<line57>                oa.writeRecord(qp, null);\n<line58>                qp.setType(Leader.UPTODATE);\n<line59>                qp.setZxid(0);\n<line60>                oa.writeRecord(qp, null);\n<line61>                // Read the uptodate ack\n<line62>                readPacketSkippingPing(ia, qp);\n<line63>                assertEquals(Leader.ACK, qp.getType());\n<line64>                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line65>                // Get the ack of the new leader\n<line66>                readPacketSkippingPing(ia, qp);\n<line67>                assertEquals(Leader.ACK, qp.getType());\n<line68>                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line69>                assertEquals(1, f.self.getAcceptedEpoch());\n<line70>                assertEquals(1, f.self.getCurrentEpoch());\n<line71>                //Wait for the transactions to be written out. The thread that writes them out\n<line72>                // does not send anything back when it is done.\n<line73>                long start = System.currentTimeMillis();\n<line74>                while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {\n<line75>                    Thread.sleep(1);\n<line76>                }\n<line77>                assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());\n<line78>                // Make sure the data was recorded in the filesystem ok\n<line79>                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));\n<line80>                start = System.currentTimeMillis();\n<line81>                zkDb2.loadDataBase();\n<line82>                while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {\n<line83>                    Thread.sleep(1);\n<line84>                    zkDb2.loadDataBase();\n<line85>                }\n<line86>                LOG.info(\"zkdb2 sessions:{}\", zkDb2.getSessions());\n<line87>                LOG.info(\"zkdb2 with timeouts:{}\", zkDb2.getSessionWithTimeOuts());\n<line88>                assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));\n<line89>                //Snapshot was never taken during very simple sync\n<line90>                verify(f.zk, never()).takeSnapshot();\n<line91>            } finally {\n<line92>                TestUtils.deleteFileRecursively(tmpDir);\n<line93>            }\n<line94>        }\n<line95>\n<line96>        private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException {\n<line97>            qp.setType(Leader.PROPOSAL);\n<line98>            qp.setZxid(zxid);\n<line99>            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);\n<line100>            CreateSessionTxn cst = new CreateSessionTxn(30000);\n<line101>            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line102>            OutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line103>            boa.writeRecord(hdr, null);\n<line104>            boa.writeRecord(cst, null);\n<line105>            qp.setData(baos.toByteArray());\n<line106>        }\n<line107>    });\n<line108>}"},{"input":"","instruction":"<line1>{\n<line2>    File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n<line3>    tmpDir.delete();\n<line4>    tmpDir.mkdir();\n<line5>    File logDir = f.fzk.getTxnLogFactory().getDataLogDir().getParentFile();\n<line6>    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();\n<line7>    //Spy on ZK so we can check if a snapshot happened or not.\n<line8>    f.zk = spy(f.zk);\n<line9>    try {\n<line10>        assertEquals(0, f.self.getAcceptedEpoch());\n<line11>        assertEquals(0, f.self.getCurrentEpoch());\n<line12>        // Setup a database with a single /foo node\n<line13>        ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));\n<line14>        final long firstZxid = ZxidUtils.makeZxid(1, 1);\n<line15>        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn(\"/foo\", \"data1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1), null);\n<line16>        Stat stat = new Stat();\n<line17>        assertEquals(\"data1\", new String(zkDb.getData(\"/foo\", stat, null)));\n<line18>        QuorumPacket qp = new QuorumPacket();\n<line19>        readPacketSkippingPing(ia, qp);\n<line20>        assertEquals(Leader.FOLLOWERINFO, qp.getType());\n<line21>        assertEquals(qp.getZxid(), 0);\n<line22>        LearnerInfo learnInfo = new LearnerInfo();\n<line23>        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);\n<line24>        assertEquals(learnInfo.getProtocolVersion(), 0x10000);\n<line25>        assertEquals(learnInfo.getServerid(), 0);\n<line26>        // We are simulating an established leader, so the epoch is 1\n<line27>        qp.setType(Leader.LEADERINFO);\n<line28>        qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line29>        byte[] protoBytes = new byte[4];\n<line30>        ByteBuffer.wrap(protoBytes).putInt(0x10000);\n<line31>        qp.setData(protoBytes);\n<line32>        oa.writeRecord(qp, null);\n<line33>        readPacketSkippingPing(ia, qp);\n<line34>        assertEquals(Leader.ACKEPOCH, qp.getType());\n<line35>        assertEquals(0, qp.getZxid());\n<line36>        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());\n<line37>        assertEquals(1, f.self.getAcceptedEpoch());\n<line38>        assertEquals(0, f.self.getCurrentEpoch());\n<line39>        // Send a diff\n<line40>        qp.setType(Leader.DIFF);\n<line41>        qp.setData(new byte[0]);\n<line42>        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());\n<line43>        oa.writeRecord(qp, null);\n<line44>        final long createSessionZxid = ZxidUtils.makeZxid(1, 2);\n<line45>        proposeNewSession(qp, createSessionZxid, 0x333);\n<line46>        oa.writeRecord(qp, null);\n<line47>        qp.setType(Leader.COMMIT);\n<line48>        qp.setZxid(createSessionZxid);\n<line49>        oa.writeRecord(qp, null);\n<line50>        qp.setType(Leader.NEWLEADER);\n<line51>        qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line52>        qp.setData(null);\n<line53>        oa.writeRecord(qp, null);\n<line54>        qp.setType(Leader.UPTODATE);\n<line55>        qp.setZxid(0);\n<line56>        oa.writeRecord(qp, null);\n<line57>        // Read the uptodate ack\n<line58>        readPacketSkippingPing(ia, qp);\n<line59>        assertEquals(Leader.ACK, qp.getType());\n<line60>        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line61>        // Get the ack of the new leader\n<line62>        readPacketSkippingPing(ia, qp);\n<line63>        assertEquals(Leader.ACK, qp.getType());\n<line64>        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line65>        assertEquals(1, f.self.getAcceptedEpoch());\n<line66>        assertEquals(1, f.self.getCurrentEpoch());\n<line67>        //Wait for the transactions to be written out. The thread that writes them out\n<line68>        // does not send anything back when it is done.\n<line69>        long start = System.currentTimeMillis();\n<line70>        while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {\n<line71>            Thread.sleep(1);\n<line72>        }\n<line73>        assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());\n<line74>        // Make sure the data was recorded in the filesystem ok\n<line75>        ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));\n<line76>        start = System.currentTimeMillis();\n<line77>        zkDb2.loadDataBase();\n<line78>        while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {\n<line79>            Thread.sleep(1);\n<line80>            zkDb2.loadDataBase();\n<line81>        }\n<line82>        assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));\n<line83>        //Snapshot was never taken during very simple sync\n<line84>        verify(f.zk, never()).takeSnapshot();\n<line85>    } finally {\n<line86>        TestUtils.deleteFileRecursively(tmpDir);\n<line87>    }\n<line88>}","output":"<line1>{\n<line2>    File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n<line3>    tmpDir.delete();\n<line4>    tmpDir.mkdir();\n<line5>    File logDir = f.fzk.getTxnLogFactory().getDataLogDir().getParentFile();\n<line6>    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();\n<line7>    //Spy on ZK so we can check if a snapshot happened or not.\n<line8>    f.zk = spy(f.zk);\n<line9>    try {\n<line10>        assertEquals(0, f.self.getAcceptedEpoch());\n<line11>        assertEquals(0, f.self.getCurrentEpoch());\n<line12>        // Setup a database with a single /foo node\n<line13>        ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));\n<line14>        final long firstZxid = ZxidUtils.makeZxid(1, 1);\n<line15>        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn(\"/foo\", \"data1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1), null);\n<line16>        Stat stat = new Stat();\n<line17>        assertEquals(\"data1\", new String(zkDb.getData(\"/foo\", stat, null)));\n<line18>        QuorumPacket qp = new QuorumPacket();\n<line19>        readPacketSkippingPing(ia, qp);\n<line20>        assertEquals(Leader.FOLLOWERINFO, qp.getType());\n<line21>        assertEquals(qp.getZxid(), 0);\n<line22>        LearnerInfo learnInfo = new LearnerInfo();\n<line23>        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);\n<line24>        assertEquals(learnInfo.getProtocolVersion(), 0x10000);\n<line25>        assertEquals(learnInfo.getServerid(), 0);\n<line26>        // We are simulating an established leader, so the epoch is 1\n<line27>        qp.setType(Leader.LEADERINFO);\n<line28>        qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line29>        byte[] protoBytes = new byte[4];\n<line30>        ByteBuffer.wrap(protoBytes).putInt(0x10000);\n<line31>        qp.setData(protoBytes);\n<line32>        oa.writeRecord(qp, null);\n<line33>        readPacketSkippingPing(ia, qp);\n<line34>        assertEquals(Leader.ACKEPOCH, qp.getType());\n<line35>        assertEquals(0, qp.getZxid());\n<line36>        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());\n<line37>        assertEquals(1, f.self.getAcceptedEpoch());\n<line38>        assertEquals(0, f.self.getCurrentEpoch());\n<line39>        // Send a diff\n<line40>        qp.setType(Leader.DIFF);\n<line41>        qp.setData(new byte[0]);\n<line42>        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());\n<line43>        oa.writeRecord(qp, null);\n<line44>        final long createSessionZxid = ZxidUtils.makeZxid(1, 2);\n<line45>        proposeNewSession(qp, createSessionZxid, 0x333);\n<line46>        oa.writeRecord(qp, null);\n<line47>        qp.setType(Leader.COMMIT);\n<line48>        qp.setZxid(createSessionZxid);\n<line49>        oa.writeRecord(qp, null);\n<line50>        qp.setType(Leader.NEWLEADER);\n<line51>        qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line52>        qp.setData(null);\n<line53>        oa.writeRecord(qp, null);\n<line54>        qp.setType(Leader.UPTODATE);\n<line55>        qp.setZxid(0);\n<line56>        oa.writeRecord(qp, null);\n<line57>        // Read the uptodate ack\n<line58>        readPacketSkippingPing(ia, qp);\n<line59>        assertEquals(Leader.ACK, qp.getType());\n<line60>        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line61>        // Get the ack of the new leader\n<line62>        readPacketSkippingPing(ia, qp);\n<line63>        assertEquals(Leader.ACK, qp.getType());\n<line64>        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line65>        assertEquals(1, f.self.getAcceptedEpoch());\n<line66>        assertEquals(1, f.self.getCurrentEpoch());\n<line67>        //Wait for the transactions to be written out. The thread that writes them out\n<line68>        // does not send anything back when it is done.\n<line69>        long start = System.currentTimeMillis();\n<line70>        while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {\n<line71>            Thread.sleep(1);\n<line72>        }\n<line73>        assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());\n<line74>        // Make sure the data was recorded in the filesystem ok\n<line75>        ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));\n<line76>        start = System.currentTimeMillis();\n<line77>        zkDb2.loadDataBase();\n<line78>        while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {\n<line79>            Thread.sleep(1);\n<line80>            zkDb2.loadDataBase();\n<line81>        }\n<line82>        LOG.info(\"zkdb2 sessions:{}\", zkDb2.getSessions());\n<line83>        LOG.info(\"zkdb2 with timeouts:{}\", zkDb2.getSessionWithTimeOuts());\n<line84>        assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));\n<line85>        //Snapshot was never taken during very simple sync\n<line86>        verify(f.zk, never()).takeSnapshot();\n<line87>    } finally {\n<line88>        TestUtils.deleteFileRecursively(tmpDir);\n<line89>    }\n<line90>}"},{"input":"","instruction":"<line1>{\n<line2>    assertEquals(0, f.self.getAcceptedEpoch());\n<line3>    assertEquals(0, f.self.getCurrentEpoch());\n<line4>    // Setup a database with a single /foo node\n<line5>    ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));\n<line6>    final long firstZxid = ZxidUtils.makeZxid(1, 1);\n<line7>    zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn(\"/foo\", \"data1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1), null);\n<line8>    Stat stat = new Stat();\n<line9>    assertEquals(\"data1\", new String(zkDb.getData(\"/foo\", stat, null)));\n<line10>    QuorumPacket qp = new QuorumPacket();\n<line11>    readPacketSkippingPing(ia, qp);\n<line12>    assertEquals(Leader.FOLLOWERINFO, qp.getType());\n<line13>    assertEquals(qp.getZxid(), 0);\n<line14>    LearnerInfo learnInfo = new LearnerInfo();\n<line15>    ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);\n<line16>    assertEquals(learnInfo.getProtocolVersion(), 0x10000);\n<line17>    assertEquals(learnInfo.getServerid(), 0);\n<line18>    // We are simulating an established leader, so the epoch is 1\n<line19>    qp.setType(Leader.LEADERINFO);\n<line20>    qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line21>    byte[] protoBytes = new byte[4];\n<line22>    ByteBuffer.wrap(protoBytes).putInt(0x10000);\n<line23>    qp.setData(protoBytes);\n<line24>    oa.writeRecord(qp, null);\n<line25>    readPacketSkippingPing(ia, qp);\n<line26>    assertEquals(Leader.ACKEPOCH, qp.getType());\n<line27>    assertEquals(0, qp.getZxid());\n<line28>    assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());\n<line29>    assertEquals(1, f.self.getAcceptedEpoch());\n<line30>    assertEquals(0, f.self.getCurrentEpoch());\n<line31>    // Send a diff\n<line32>    qp.setType(Leader.DIFF);\n<line33>    qp.setData(new byte[0]);\n<line34>    qp.setZxid(zkDb.getDataTreeLastProcessedZxid());\n<line35>    oa.writeRecord(qp, null);\n<line36>    final long createSessionZxid = ZxidUtils.makeZxid(1, 2);\n<line37>    proposeNewSession(qp, createSessionZxid, 0x333);\n<line38>    oa.writeRecord(qp, null);\n<line39>    qp.setType(Leader.COMMIT);\n<line40>    qp.setZxid(createSessionZxid);\n<line41>    oa.writeRecord(qp, null);\n<line42>    qp.setType(Leader.NEWLEADER);\n<line43>    qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line44>    qp.setData(null);\n<line45>    oa.writeRecord(qp, null);\n<line46>    qp.setType(Leader.UPTODATE);\n<line47>    qp.setZxid(0);\n<line48>    oa.writeRecord(qp, null);\n<line49>    // Read the uptodate ack\n<line50>    readPacketSkippingPing(ia, qp);\n<line51>    assertEquals(Leader.ACK, qp.getType());\n<line52>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line53>    // Get the ack of the new leader\n<line54>    readPacketSkippingPing(ia, qp);\n<line55>    assertEquals(Leader.ACK, qp.getType());\n<line56>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line57>    assertEquals(1, f.self.getAcceptedEpoch());\n<line58>    assertEquals(1, f.self.getCurrentEpoch());\n<line59>    //Wait for the transactions to be written out. The thread that writes them out\n<line60>    // does not send anything back when it is done.\n<line61>    long start = System.currentTimeMillis();\n<line62>    while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {\n<line63>        Thread.sleep(1);\n<line64>    }\n<line65>    assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());\n<line66>    // Make sure the data was recorded in the filesystem ok\n<line67>    ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));\n<line68>    start = System.currentTimeMillis();\n<line69>    zkDb2.loadDataBase();\n<line70>    while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {\n<line71>        Thread.sleep(1);\n<line72>        zkDb2.loadDataBase();\n<line73>    }\n<line74>    assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));\n<line75>    //Snapshot was never taken during very simple sync\n<line76>    verify(f.zk, never()).takeSnapshot();\n<line77>}","output":"<line1>{\n<line2>    assertEquals(0, f.self.getAcceptedEpoch());\n<line3>    assertEquals(0, f.self.getCurrentEpoch());\n<line4>    // Setup a database with a single /foo node\n<line5>    ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));\n<line6>    final long firstZxid = ZxidUtils.makeZxid(1, 1);\n<line7>    zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn(\"/foo\", \"data1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1), null);\n<line8>    Stat stat = new Stat();\n<line9>    assertEquals(\"data1\", new String(zkDb.getData(\"/foo\", stat, null)));\n<line10>    QuorumPacket qp = new QuorumPacket();\n<line11>    readPacketSkippingPing(ia, qp);\n<line12>    assertEquals(Leader.FOLLOWERINFO, qp.getType());\n<line13>    assertEquals(qp.getZxid(), 0);\n<line14>    LearnerInfo learnInfo = new LearnerInfo();\n<line15>    ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);\n<line16>    assertEquals(learnInfo.getProtocolVersion(), 0x10000);\n<line17>    assertEquals(learnInfo.getServerid(), 0);\n<line18>    // We are simulating an established leader, so the epoch is 1\n<line19>    qp.setType(Leader.LEADERINFO);\n<line20>    qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line21>    byte[] protoBytes = new byte[4];\n<line22>    ByteBuffer.wrap(protoBytes).putInt(0x10000);\n<line23>    qp.setData(protoBytes);\n<line24>    oa.writeRecord(qp, null);\n<line25>    readPacketSkippingPing(ia, qp);\n<line26>    assertEquals(Leader.ACKEPOCH, qp.getType());\n<line27>    assertEquals(0, qp.getZxid());\n<line28>    assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());\n<line29>    assertEquals(1, f.self.getAcceptedEpoch());\n<line30>    assertEquals(0, f.self.getCurrentEpoch());\n<line31>    // Send a diff\n<line32>    qp.setType(Leader.DIFF);\n<line33>    qp.setData(new byte[0]);\n<line34>    qp.setZxid(zkDb.getDataTreeLastProcessedZxid());\n<line35>    oa.writeRecord(qp, null);\n<line36>    final long createSessionZxid = ZxidUtils.makeZxid(1, 2);\n<line37>    proposeNewSession(qp, createSessionZxid, 0x333);\n<line38>    oa.writeRecord(qp, null);\n<line39>    qp.setType(Leader.COMMIT);\n<line40>    qp.setZxid(createSessionZxid);\n<line41>    oa.writeRecord(qp, null);\n<line42>    qp.setType(Leader.NEWLEADER);\n<line43>    qp.setZxid(ZxidUtils.makeZxid(1, 0));\n<line44>    qp.setData(null);\n<line45>    oa.writeRecord(qp, null);\n<line46>    qp.setType(Leader.UPTODATE);\n<line47>    qp.setZxid(0);\n<line48>    oa.writeRecord(qp, null);\n<line49>    // Read the uptodate ack\n<line50>    readPacketSkippingPing(ia, qp);\n<line51>    assertEquals(Leader.ACK, qp.getType());\n<line52>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line53>    // Get the ack of the new leader\n<line54>    readPacketSkippingPing(ia, qp);\n<line55>    assertEquals(Leader.ACK, qp.getType());\n<line56>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line57>    assertEquals(1, f.self.getAcceptedEpoch());\n<line58>    assertEquals(1, f.self.getCurrentEpoch());\n<line59>    //Wait for the transactions to be written out. The thread that writes them out\n<line60>    // does not send anything back when it is done.\n<line61>    long start = System.currentTimeMillis();\n<line62>    while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {\n<line63>        Thread.sleep(1);\n<line64>    }\n<line65>    assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());\n<line66>    // Make sure the data was recorded in the filesystem ok\n<line67>    ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));\n<line68>    start = System.currentTimeMillis();\n<line69>    zkDb2.loadDataBase();\n<line70>    while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {\n<line71>        Thread.sleep(1);\n<line72>        zkDb2.loadDataBase();\n<line73>    }\n<line74>    LOG.info(\"zkdb2 sessions:{}\", zkDb2.getSessions());\n<line75>    LOG.info(\"zkdb2 with timeouts:{}\", zkDb2.getSessionWithTimeOuts());\n<line76>    assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));\n<line77>    //Snapshot was never taken during very simple sync\n<line78>    verify(f.zk, never()).takeSnapshot();\n<line79>}"},{"input":"","instruction":"<line1>{\n<line2>    testLeaderConversation(new LeaderConversation() {\n<line3>\n<line4>        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException {\n<line5>            assertEquals(0, l.self.getAcceptedEpoch());\n<line6>            assertEquals(0, l.self.getCurrentEpoch());\n<line7>            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);\n<line8>            byte[] liBytes = new byte[20];\n<line9>            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));\n<line10>            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);\n<line11>            oa.writeRecord(qp, null);\n<line12>            readPacketSkippingPing(ia, qp);\n<line13>            assertEquals(Leader.LEADERINFO, qp.getType());\n<line14>            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line15>            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);\n<line16>            assertEquals(1, l.self.getAcceptedEpoch());\n<line17>            assertEquals(0, l.self.getCurrentEpoch());\n<line18>            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);\n<line19>            oa.writeRecord(qp, null);\n<line20>            readPacketSkippingPing(ia, qp);\n<line21>            assertEquals(Leader.DIFF, qp.getType());\n<line22>            readPacketSkippingPing(ia, qp);\n<line23>            assertEquals(Leader.NEWLEADER, qp.getType());\n<line24>            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line25>            assertEquals(1, l.self.getAcceptedEpoch());\n<line26>            assertCurrentEpochGotUpdated(1, l.self, ClientBase.CONNECTION_TIMEOUT);\n<line27>            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);\n<line28>            oa.writeRecord(qp, null);\n<line29>            readPacketSkippingPing(ia, qp);\n<line30>            assertEquals(Leader.UPTODATE, qp.getType());\n<line31>            long zxid = l.zk.getZxid();\n<line32>            l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn(\"/test\", \"hola\".getBytes(), null, true, 0), zxid));\n<line33>            readPacketSkippingPing(ia, qp);\n<line34>            assertEquals(Leader.PROPOSAL, qp.getType());\n<line35>            for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {\n<line36>                try {\n<line37>                    ia.readRecord(qp, null);\n<line38>                    qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line39>                    oa.writeRecord(qp, null);\n<line40>                } catch (EOFException e) {\n<line41>                    return;\n<line42>                }\n<line43>            }\n<line44>            fail(\"Connection hasn't been closed by leader after transaction times out.\");\n<line45>        }\n<line46>    });\n<line47>}","output":"<line1>{\n<line2>    testLeaderConversation(new LeaderConversation() {\n<line3>\n<line4>        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException {\n<line5>            assertEquals(0, l.self.getAcceptedEpoch());\n<line6>            assertEquals(0, l.self.getCurrentEpoch());\n<line7>            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);\n<line8>            byte[] liBytes = new byte[20];\n<line9>            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));\n<line10>            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);\n<line11>            oa.writeRecord(qp, null);\n<line12>            readPacketSkippingPing(ia, qp);\n<line13>            assertEquals(Leader.LEADERINFO, qp.getType());\n<line14>            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line15>            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);\n<line16>            assertEquals(1, l.self.getAcceptedEpoch());\n<line17>            assertEquals(0, l.self.getCurrentEpoch());\n<line18>            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);\n<line19>            oa.writeRecord(qp, null);\n<line20>            readPacketSkippingPing(ia, qp);\n<line21>            assertEquals(Leader.DIFF, qp.getType());\n<line22>            readPacketSkippingPing(ia, qp);\n<line23>            assertEquals(Leader.NEWLEADER, qp.getType());\n<line24>            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line25>            assertEquals(1, l.self.getAcceptedEpoch());\n<line26>            assertCurrentEpochGotUpdated(1, l.self, ClientBase.CONNECTION_TIMEOUT);\n<line27>            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);\n<line28>            oa.writeRecord(qp, null);\n<line29>            readPacketSkippingPing(ia, qp);\n<line30>            assertEquals(Leader.UPTODATE, qp.getType());\n<line31>            long zxid = l.zk.getZxid();\n<line32>            l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn(\"/test\", \"hola\".getBytes(), null, true, 0), zxid));\n<line33>            readPacketSkippingPing(ia, qp);\n<line34>            assertEquals(Leader.PROPOSAL, qp.getType());\n<line35>            LOG.info(\"Proposal sent.\");\n<line36>            for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {\n<line37>                try {\n<line38>                    ia.readRecord(qp, null);\n<line39>                    LOG.info(\"Ping received: {}\", i);\n<line40>                    qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line41>                    oa.writeRecord(qp, null);\n<line42>                } catch (EOFException e) {\n<line43>                    return;\n<line44>                }\n<line45>            }\n<line46>            fail(\"Connection hasn't been closed by leader after transaction times out.\");\n<line47>        }\n<line48>    });\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>    assertEquals(0, l.self.getAcceptedEpoch());\n<line3>    assertEquals(0, l.self.getCurrentEpoch());\n<line4>    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);\n<line5>    byte[] liBytes = new byte[20];\n<line6>    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));\n<line7>    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);\n<line8>    oa.writeRecord(qp, null);\n<line9>    readPacketSkippingPing(ia, qp);\n<line10>    assertEquals(Leader.LEADERINFO, qp.getType());\n<line11>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line12>    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);\n<line13>    assertEquals(1, l.self.getAcceptedEpoch());\n<line14>    assertEquals(0, l.self.getCurrentEpoch());\n<line15>    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);\n<line16>    oa.writeRecord(qp, null);\n<line17>    readPacketSkippingPing(ia, qp);\n<line18>    assertEquals(Leader.DIFF, qp.getType());\n<line19>    readPacketSkippingPing(ia, qp);\n<line20>    assertEquals(Leader.NEWLEADER, qp.getType());\n<line21>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line22>    assertEquals(1, l.self.getAcceptedEpoch());\n<line23>    assertCurrentEpochGotUpdated(1, l.self, ClientBase.CONNECTION_TIMEOUT);\n<line24>    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);\n<line25>    oa.writeRecord(qp, null);\n<line26>    readPacketSkippingPing(ia, qp);\n<line27>    assertEquals(Leader.UPTODATE, qp.getType());\n<line28>    long zxid = l.zk.getZxid();\n<line29>    l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn(\"/test\", \"hola\".getBytes(), null, true, 0), zxid));\n<line30>    readPacketSkippingPing(ia, qp);\n<line31>    assertEquals(Leader.PROPOSAL, qp.getType());\n<line32>    for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {\n<line33>        try {\n<line34>            ia.readRecord(qp, null);\n<line35>            qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line36>            oa.writeRecord(qp, null);\n<line37>        } catch (EOFException e) {\n<line38>            return;\n<line39>        }\n<line40>    }\n<line41>    fail(\"Connection hasn't been closed by leader after transaction times out.\");\n<line42>}","output":"<line1>{\n<line2>    assertEquals(0, l.self.getAcceptedEpoch());\n<line3>    assertEquals(0, l.self.getCurrentEpoch());\n<line4>    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);\n<line5>    byte[] liBytes = new byte[20];\n<line6>    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));\n<line7>    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);\n<line8>    oa.writeRecord(qp, null);\n<line9>    readPacketSkippingPing(ia, qp);\n<line10>    assertEquals(Leader.LEADERINFO, qp.getType());\n<line11>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line12>    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);\n<line13>    assertEquals(1, l.self.getAcceptedEpoch());\n<line14>    assertEquals(0, l.self.getCurrentEpoch());\n<line15>    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);\n<line16>    oa.writeRecord(qp, null);\n<line17>    readPacketSkippingPing(ia, qp);\n<line18>    assertEquals(Leader.DIFF, qp.getType());\n<line19>    readPacketSkippingPing(ia, qp);\n<line20>    assertEquals(Leader.NEWLEADER, qp.getType());\n<line21>    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());\n<line22>    assertEquals(1, l.self.getAcceptedEpoch());\n<line23>    assertCurrentEpochGotUpdated(1, l.self, ClientBase.CONNECTION_TIMEOUT);\n<line24>    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);\n<line25>    oa.writeRecord(qp, null);\n<line26>    readPacketSkippingPing(ia, qp);\n<line27>    assertEquals(Leader.UPTODATE, qp.getType());\n<line28>    long zxid = l.zk.getZxid();\n<line29>    l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn(\"/test\", \"hola\".getBytes(), null, true, 0), zxid));\n<line30>    readPacketSkippingPing(ia, qp);\n<line31>    assertEquals(Leader.PROPOSAL, qp.getType());\n<line32>    LOG.info(\"Proposal sent.\");\n<line33>    for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {\n<line34>        try {\n<line35>            ia.readRecord(qp, null);\n<line36>            LOG.info(\"Ping received: {}\", i);\n<line37>            qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line38>            oa.writeRecord(qp, null);\n<line39>        } catch (EOFException e) {\n<line40>            return;\n<line41>        }\n<line42>    }\n<line43>    fail(\"Connection hasn't been closed by leader after transaction times out.\");\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        ia.readRecord(qp, null);\n<line4>        qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line5>        oa.writeRecord(qp, null);\n<line6>    } catch (EOFException e) {\n<line7>        return;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        ia.readRecord(qp, null);\n<line4>        LOG.info(\"Ping received: {}\", i);\n<line5>        qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line6>        oa.writeRecord(qp, null);\n<line7>    } catch (EOFException e) {\n<line8>        return;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    ia.readRecord(qp, null);\n<line3>    qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line4>    oa.writeRecord(qp, null);\n<line5>}","output":"<line1>{\n<line2>    ia.readRecord(qp, null);\n<line3>    LOG.info(\"Ping received: {}\", i);\n<line4>    qp = new QuorumPacket(Leader.PING, qp.getZxid(), \"\".getBytes(), null);\n<line5>    oa.writeRecord(qp, null);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    final int LEADER_TIMEOUT_MS = 10_000;\n<line3>    // 1. start up server and wait for leader election to finish\n<line4>    ClientBase.setupTestEnv();\n<line5>    final int SERVER_COUNT = 3;\n<line6>    servers = LaunchServers(SERVER_COUNT);\n<line7>    waitForAll(servers, States.CONNECTED);\n<line8>    // we need to shutdown and start back up to make sure that the create session isn't the first transaction since\n<line9>    // that is rather innocuous.\n<line10>    servers.shutDownAllServers();\n<line11>    waitForAll(servers, States.CONNECTING);\n<line12>    servers.restartAllServersAndClients(this);\n<line13>    waitForAll(servers, States.CONNECTED);\n<line14>    // 2. kill all followers\n<line15>    int leader = servers.findLeader();\n<line16>    Map<Long, Proposal> outstanding = servers.mt[leader].main.quorumPeer.leader.outstandingProposals;\n<line17>    // increase the tick time to delay the leader going to looking\n<line18>    int previousTick = servers.mt[leader].main.quorumPeer.tickTime;\n<line19>    servers.mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;\n<line20>    // let the previous tick on the leader exhaust itself so the new tick time takes effect\n<line21>    Thread.sleep(previousTick);\n<line22>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line23>        if (i != leader) {\n<line24>            servers.mt[i].shutdown();\n<line25>        }\n<line26>    }\n<line27>    // 3. start up the followers to form a new quorum\n<line28>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line29>        if (i != leader) {\n<line30>            servers.mt[i].start();\n<line31>        }\n<line32>    }\n<line33>    // 4. wait one of the follower to be the new leader\n<line34>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line35>        if (i != leader) {\n<line36>            // Recreate a client session since the previous session was not persisted.\n<line37>            servers.restartClient(i, this);\n<line38>            waitForOne(servers.zk[i], States.CONNECTED);\n<line39>        }\n<line40>    }\n<line41>    // 5. send a create request to old leader and make sure it's synced to disk,\n<line42>    //    which means it acked from itself\n<line43>    try {\n<line44>        servers.zk[leader].create(\"/zk\" + leader, \"zk\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line45>        fail(\"create /zk\" + leader + \" should have failed\");\n<line46>    } catch (KeeperException e) {\n<line47>    }\n<line48>    // just make sure that we actually did get it in process at the\n<line49>    // leader\n<line50>    // there can be extra sessionClose proposals\n<line51>    assertTrue(outstanding.size() > 0);\n<line52>    Proposal p = findProposalOfType(outstanding, OpCode.create);\n<line53>    assertNotNull(p, \"Old leader doesn't have 'create' proposal\");\n<line54>    // make sure it has a chance to write it to disk\n<line55>    int sleepTime = 0;\n<line56>    Long longLeader = (long) leader;\n<line57>    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {\n<line58>        if (sleepTime > 2000) {\n<line59>            fail(\"Transaction not synced to disk within 1 second \" + p.qvAcksetPairs.get(0).getAckset() + \" expected \" + leader);\n<line60>        }\n<line61>        Thread.sleep(100);\n<line62>        sleepTime += 100;\n<line63>    }\n<line64>    // 6. wait for the leader to quit due to not enough followers and come back up as a part of the new quorum\n<line65>    sleepTime = 0;\n<line66>    Follower f = servers.mt[leader].main.quorumPeer.follower;\n<line67>    while (f == null || !f.isRunning()) {\n<line68>        if (sleepTime > LEADER_TIMEOUT_MS * 2) {\n<line69>            fail(\"Took too long for old leader to time out \" + servers.mt[leader].main.quorumPeer.getPeerState());\n<line70>        }\n<line71>        Thread.sleep(100);\n<line72>        sleepTime += 100;\n<line73>        f = servers.mt[leader].main.quorumPeer.follower;\n<line74>    }\n<line75>    int newLeader = servers.findLeader();\n<line76>    // make sure a different leader was elected\n<line77>    assertNotEquals(leader, newLeader);\n<line78>    // 7. restart the previous leader to force it to replay the edits and possibly come up in a bad state\n<line79>    servers.mt[leader].shutdown();\n<line80>    servers.mt[leader].start();\n<line81>    // old client session can expire, restart it\n<line82>    servers.restartClient(leader, this);\n<line83>    waitForAll(servers, States.CONNECTED);\n<line84>    // 8. check the node exist in previous leader but not others\n<line85>    //    make sure everything is consistent\n<line86>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line87>        assertNull(servers.zk[i].exists(\"/zk\" + leader, false), \"server \" + i + \" should not have /zk\" + leader);\n<line88>    }\n<line89>}","output":"<line1>{\n<line2>    final int LEADER_TIMEOUT_MS = 10_000;\n<line3>    // 1. start up server and wait for leader election to finish\n<line4>    ClientBase.setupTestEnv();\n<line5>    final int SERVER_COUNT = 3;\n<line6>    servers = LaunchServers(SERVER_COUNT);\n<line7>    waitForAll(servers, States.CONNECTED);\n<line8>    // we need to shutdown and start back up to make sure that the create session isn't the first transaction since\n<line9>    // that is rather innocuous.\n<line10>    servers.shutDownAllServers();\n<line11>    waitForAll(servers, States.CONNECTING);\n<line12>    servers.restartAllServersAndClients(this);\n<line13>    waitForAll(servers, States.CONNECTED);\n<line14>    // 2. kill all followers\n<line15>    int leader = servers.findLeader();\n<line16>    Map<Long, Proposal> outstanding = servers.mt[leader].main.quorumPeer.leader.outstandingProposals;\n<line17>    // increase the tick time to delay the leader going to looking\n<line18>    int previousTick = servers.mt[leader].main.quorumPeer.tickTime;\n<line19>    servers.mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;\n<line20>    // let the previous tick on the leader exhaust itself so the new tick time takes effect\n<line21>    Thread.sleep(previousTick);\n<line22>    LOG.warn(\"LEADER {}\", leader);\n<line23>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line24>        if (i != leader) {\n<line25>            servers.mt[i].shutdown();\n<line26>        }\n<line27>    }\n<line28>    // 3. start up the followers to form a new quorum\n<line29>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line30>        if (i != leader) {\n<line31>            servers.mt[i].start();\n<line32>        }\n<line33>    }\n<line34>    // 4. wait one of the follower to be the new leader\n<line35>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line36>        if (i != leader) {\n<line37>            // Recreate a client session since the previous session was not persisted.\n<line38>            servers.restartClient(i, this);\n<line39>            waitForOne(servers.zk[i], States.CONNECTED);\n<line40>        }\n<line41>    }\n<line42>    // 5. send a create request to old leader and make sure it's synced to disk,\n<line43>    //    which means it acked from itself\n<line44>    try {\n<line45>        servers.zk[leader].create(\"/zk\" + leader, \"zk\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line46>        fail(\"create /zk\" + leader + \" should have failed\");\n<line47>    } catch (KeeperException e) {\n<line48>    }\n<line49>    // just make sure that we actually did get it in process at the\n<line50>    // leader\n<line51>    // there can be extra sessionClose proposals\n<line52>    assertTrue(outstanding.size() > 0);\n<line53>    Proposal p = findProposalOfType(outstanding, OpCode.create);\n<line54>    LOG.info(\"Old leader id: {}. All proposals: {}\", leader, outstanding);\n<line55>    assertNotNull(p, \"Old leader doesn't have 'create' proposal\");\n<line56>    // make sure it has a chance to write it to disk\n<line57>    int sleepTime = 0;\n<line58>    Long longLeader = (long) leader;\n<line59>    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {\n<line60>        if (sleepTime > 2000) {\n<line61>            fail(\"Transaction not synced to disk within 1 second \" + p.qvAcksetPairs.get(0).getAckset() + \" expected \" + leader);\n<line62>        }\n<line63>        Thread.sleep(100);\n<line64>        sleepTime += 100;\n<line65>    }\n<line66>    // 6. wait for the leader to quit due to not enough followers and come back up as a part of the new quorum\n<line67>    LOG.info(\"Waiting for leader {} to timeout followers\", leader);\n<line68>    sleepTime = 0;\n<line69>    Follower f = servers.mt[leader].main.quorumPeer.follower;\n<line70>    while (f == null || !f.isRunning()) {\n<line71>        if (sleepTime > LEADER_TIMEOUT_MS * 2) {\n<line72>            fail(\"Took too long for old leader to time out \" + servers.mt[leader].main.quorumPeer.getPeerState());\n<line73>        }\n<line74>        Thread.sleep(100);\n<line75>        sleepTime += 100;\n<line76>        f = servers.mt[leader].main.quorumPeer.follower;\n<line77>    }\n<line78>    int newLeader = servers.findLeader();\n<line79>    // make sure a different leader was elected\n<line80>    assertNotEquals(leader, newLeader);\n<line81>    // 7. restart the previous leader to force it to replay the edits and possibly come up in a bad state\n<line82>    servers.mt[leader].shutdown();\n<line83>    servers.mt[leader].start();\n<line84>    // old client session can expire, restart it\n<line85>    servers.restartClient(leader, this);\n<line86>    waitForAll(servers, States.CONNECTED);\n<line87>    // 8. check the node exist in previous leader but not others\n<line88>    //    make sure everything is consistent\n<line89>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line90>        assertNull(servers.zk[i].exists(\"/zk\" + leader, false), \"server \" + i + \" should not have /zk\" + leader);\n<line91>    }\n<line92>}"},{"input":"","instruction":"<line1>{\n<line2>    long start = Time.currentElapsedTime();\n<line3>    while (true) {\n<line4>        QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;\n<line5>        if (quorumPeer != null) {\n<line6>            return quorumPeer;\n<line7>        }\n<line8>        if (Time.currentElapsedTime() > start + timeout) {\n<line9>            throw new TimeoutException();\n<line10>        }\n<line11>        try {\n<line12>            Thread.sleep(250);\n<line13>        } catch (InterruptedException e) {\n<line14>            // ignore\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    long start = Time.currentElapsedTime();\n<line3>    while (true) {\n<line4>        QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;\n<line5>        if (quorumPeer != null) {\n<line6>            return quorumPeer;\n<line7>        }\n<line8>        if (Time.currentElapsedTime() > start + timeout) {\n<line9>            LOG.error(\"Timed out while waiting for QuorumPeer\");\n<line10>            throw new TimeoutException();\n<line11>        }\n<line12>        try {\n<line13>            Thread.sleep(250);\n<line14>        } catch (InterruptedException e) {\n<line15>            // ignore\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;\n<line3>    if (quorumPeer != null) {\n<line4>        return quorumPeer;\n<line5>    }\n<line6>    if (Time.currentElapsedTime() > start + timeout) {\n<line7>        throw new TimeoutException();\n<line8>    }\n<line9>    try {\n<line10>        Thread.sleep(250);\n<line11>    } catch (InterruptedException e) {\n<line12>        // ignore\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;\n<line3>    if (quorumPeer != null) {\n<line4>        return quorumPeer;\n<line5>    }\n<line6>    if (Time.currentElapsedTime() > start + timeout) {\n<line7>        LOG.error(\"Timed out while waiting for QuorumPeer\");\n<line8>        throw new TimeoutException();\n<line9>    }\n<line10>    try {\n<line11>        Thread.sleep(250);\n<line12>    } catch (InterruptedException e) {\n<line13>        // ignore\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new TimeoutException();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Timed out while waiting for QuorumPeer\");\n<line3>    throw new TimeoutException();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // 1. set up an ensemble with 3 servers\n<line3>    final int ENSEMBLE_SERVERS = 3;\n<line4>    final int[] clientPorts = new int[ENSEMBLE_SERVERS];\n<line5>    StringBuilder sb = new StringBuilder();\n<line6>    String server;\n<line7>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line8>        clientPorts[i] = PortAssignment.unique();\n<line9>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line10>        sb.append(server + \"\\n\");\n<line11>    }\n<line12>    String currentQuorumCfgSection = sb.toString();\n<line13>    // start servers\n<line14>    MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];\n<line15>    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];\n<line16>    Context[] contexts = new Context[ENSEMBLE_SERVERS];\n<line17>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line18>        final Context context = new Context();\n<line19>        contexts[i] = context;\n<line20>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line21>\n<line22>            @Override\n<line23>            public TestQPMain getTestQPMain() {\n<line24>                return new CustomizedQPMain(context);\n<line25>            }\n<line26>        };\n<line27>        mt[i].start();\n<line28>        zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line29>    }\n<line30>    waitForAll(zk, States.CONNECTED);\n<line31>    String nodePath = \"/testInconsistentDueToNewLeader\";\n<line32>    int leaderId = -1;\n<line33>    int followerA = -1;\n<line34>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line35>        if (mt[i].main.quorumPeer.leader != null) {\n<line36>            leaderId = i;\n<line37>        } else if (followerA == -1) {\n<line38>            followerA = i;\n<line39>        }\n<line40>    }\n<line41>    mt[followerA].shutdown();\n<line42>    waitForOne(zk[followerA], States.CONNECTING);\n<line43>    try {\n<line44>        // 2. set force snapshot to be true\n<line45>        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line46>        // 3. create a node\n<line47>        String initialValue = \"1\";\n<line48>        final ZooKeeper leaderZk = zk[leaderId];\n<line49>        leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line50>        CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line51>        // 4. on the customized leader catch the startForwarding call\n<line52>        //    (without synchronized), set the node to value v1, then\n<line53>        //    call the super.startForwarding to generate the ongoing\n<line54>        //    txn proposal and commit for v1 value update\n<line55>        leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {\n<line56>\n<line57>            @Override\n<line58>            public void start() {\n<line59>                if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {\n<line60>                    return;\n<line61>                }\n<line62>                final String value = \"2\";\n<line63>                // use async, otherwise it will block the logLock in\n<line64>                // ZKDatabase and the setData request will timeout\n<line65>                try {\n<line66>                    leaderZk.setData(nodePath, value.getBytes(), -1, (rc, path, ctx, stat) -> {\n<line67>                    }, null);\n<line68>                    // wait for the setData txn being populated\n<line69>                    Thread.sleep(1000);\n<line70>                } catch (Exception e) {\n<line71>                }\n<line72>            }\n<line73>        });\n<line74>        // 5. on the customized leader catch the beginSnapshot call in\n<line75>        //    LearnerSyncThrottler to set the node to value v2,\n<line76>        //    wait it hit data tree\n<line77>        leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {\n<line78>\n<line79>            @Override\n<line80>            public void start() {\n<line81>                String value = \"3\";\n<line82>                try {\n<line83>                    leaderZk.setData(nodePath, value.getBytes(), -1);\n<line84>                } catch (Exception e) {\n<line85>                }\n<line86>            }\n<line87>        });\n<line88>        // 6. exit follower A after taking snapshot\n<line89>        CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);\n<line90>        contexts[followerA].exitWhenAckNewLeader = true;\n<line91>        CountDownLatch latch = new CountDownLatch(1);\n<line92>        final MainThread followerAMT = mt[followerA];\n<line93>        contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {\n<line94>\n<line95>            @Override\n<line96>            public void start() {\n<line97>                try {\n<line98>                    latch.countDown();\n<line99>                    followerAMT.shutdown();\n<line100>                } catch (Exception e) {\n<line101>                }\n<line102>            }\n<line103>        };\n<line104>        // 7. start follower A to do snapshot sync\n<line105>        mt[followerA].start();\n<line106>        assertTrue(latch.await(30, TimeUnit.SECONDS));\n<line107>        // 8. now we have invalid data on disk, let's load it and verify\n<line108>        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line109>        contexts[followerA].exitWhenAckNewLeader = true;\n<line110>        contexts[followerA].newLeaderAckCallback = null;\n<line111>        mt[followerA].start();\n<line112>        zk[followerA].close();\n<line113>        zk[followerA] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line114>        // 9. start follower A, after it's in broadcast state, make sure\n<line115>        //    the node value is same as what we have on leader\n<line116>        waitForOne(zk[followerA], States.CONNECTED);\n<line117>        assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));\n<line118>    } finally {\n<line119>        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);\n<line120>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line121>            mt[i].shutdown();\n<line122>            zk[i].close();\n<line123>        }\n<line124>    }\n<line125>}","output":"<line1>{\n<line2>    // 1. set up an ensemble with 3 servers\n<line3>    final int ENSEMBLE_SERVERS = 3;\n<line4>    final int[] clientPorts = new int[ENSEMBLE_SERVERS];\n<line5>    StringBuilder sb = new StringBuilder();\n<line6>    String server;\n<line7>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line8>        clientPorts[i] = PortAssignment.unique();\n<line9>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line10>        sb.append(server + \"\\n\");\n<line11>    }\n<line12>    String currentQuorumCfgSection = sb.toString();\n<line13>    // start servers\n<line14>    MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];\n<line15>    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];\n<line16>    Context[] contexts = new Context[ENSEMBLE_SERVERS];\n<line17>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line18>        final Context context = new Context();\n<line19>        contexts[i] = context;\n<line20>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line21>\n<line22>            @Override\n<line23>            public TestQPMain getTestQPMain() {\n<line24>                return new CustomizedQPMain(context);\n<line25>            }\n<line26>        };\n<line27>        mt[i].start();\n<line28>        zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line29>    }\n<line30>    waitForAll(zk, States.CONNECTED);\n<line31>    LOG.info(\"all servers started\");\n<line32>    String nodePath = \"/testInconsistentDueToNewLeader\";\n<line33>    int leaderId = -1;\n<line34>    int followerA = -1;\n<line35>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line36>        if (mt[i].main.quorumPeer.leader != null) {\n<line37>            leaderId = i;\n<line38>        } else if (followerA == -1) {\n<line39>            followerA = i;\n<line40>        }\n<line41>    }\n<line42>    LOG.info(\"shutdown follower {}\", followerA);\n<line43>    mt[followerA].shutdown();\n<line44>    waitForOne(zk[followerA], States.CONNECTING);\n<line45>    try {\n<line46>        // 2. set force snapshot to be true\n<line47>        LOG.info(\"force snapshot sync\");\n<line48>        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line49>        // 3. create a node\n<line50>        String initialValue = \"1\";\n<line51>        final ZooKeeper leaderZk = zk[leaderId];\n<line52>        leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line53>        LOG.info(\"created node {} with value {}\", nodePath, initialValue);\n<line54>        CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line55>        // 4. on the customized leader catch the startForwarding call\n<line56>        //    (without synchronized), set the node to value v1, then\n<line57>        //    call the super.startForwarding to generate the ongoing\n<line58>        //    txn proposal and commit for v1 value update\n<line59>        leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {\n<line60>\n<line61>            @Override\n<line62>            public void start() {\n<line63>                if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {\n<line64>                    return;\n<line65>                }\n<line66>                final String value = \"2\";\n<line67>                LOG.info(\"start forwarding, set {} to {}\", nodePath, value);\n<line68>                // use async, otherwise it will block the logLock in\n<line69>                // ZKDatabase and the setData request will timeout\n<line70>                try {\n<line71>                    leaderZk.setData(nodePath, value.getBytes(), -1, (rc, path, ctx, stat) -> {\n<line72>                    }, null);\n<line73>                    // wait for the setData txn being populated\n<line74>                    Thread.sleep(1000);\n<line75>                } catch (Exception e) {\n<line76>                    LOG.error(\"error when set {} to {}\", nodePath, value, e);\n<line77>                }\n<line78>            }\n<line79>        });\n<line80>        // 5. on the customized leader catch the beginSnapshot call in\n<line81>        //    LearnerSyncThrottler to set the node to value v2,\n<line82>        //    wait it hit data tree\n<line83>        leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {\n<line84>\n<line85>            @Override\n<line86>            public void start() {\n<line87>                String value = \"3\";\n<line88>                LOG.info(\"before sending snapshot, set {} to {}\", nodePath, value);\n<line89>                try {\n<line90>                    leaderZk.setData(nodePath, value.getBytes(), -1);\n<line91>                    LOG.info(\"successfully set {} to {}\", nodePath, value);\n<line92>                } catch (Exception e) {\n<line93>                    LOG.error(\"error when set {} to {}, {}\", nodePath, value, e);\n<line94>                }\n<line95>            }\n<line96>        });\n<line97>        // 6. exit follower A after taking snapshot\n<line98>        CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);\n<line99>        LOG.info(\"set exit when ack new leader packet on {}\", followerA);\n<line100>        contexts[followerA].exitWhenAckNewLeader = true;\n<line101>        CountDownLatch latch = new CountDownLatch(1);\n<line102>        final MainThread followerAMT = mt[followerA];\n<line103>        contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {\n<line104>\n<line105>            @Override\n<line106>            public void start() {\n<line107>                try {\n<line108>                    latch.countDown();\n<line109>                    followerAMT.shutdown();\n<line110>                } catch (Exception e) {\n<line111>                }\n<line112>            }\n<line113>        };\n<line114>        // 7. start follower A to do snapshot sync\n<line115>        LOG.info(\"starting follower {}\", followerA);\n<line116>        mt[followerA].start();\n<line117>        assertTrue(latch.await(30, TimeUnit.SECONDS));\n<line118>        // 8. now we have invalid data on disk, let's load it and verify\n<line119>        LOG.info(\"disable exit when ack new leader packet on {}\", followerA);\n<line120>        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line121>        contexts[followerA].exitWhenAckNewLeader = true;\n<line122>        contexts[followerA].newLeaderAckCallback = null;\n<line123>        LOG.info(\"restarting follower {}\", followerA);\n<line124>        mt[followerA].start();\n<line125>        zk[followerA].close();\n<line126>        zk[followerA] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line127>        // 9. start follower A, after it's in broadcast state, make sure\n<line128>        //    the node value is same as what we have on leader\n<line129>        waitForOne(zk[followerA], States.CONNECTED);\n<line130>        assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));\n<line131>    } finally {\n<line132>        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);\n<line133>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line134>            mt[i].shutdown();\n<line135>            zk[i].close();\n<line136>        }\n<line137>    }\n<line138>}"},{"input":"","instruction":"<line1>{\n<line2>    // 2. set force snapshot to be true\n<line3>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line4>    // 3. create a node\n<line5>    String initialValue = \"1\";\n<line6>    final ZooKeeper leaderZk = zk[leaderId];\n<line7>    leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line9>    // 4. on the customized leader catch the startForwarding call\n<line10>    //    (without synchronized), set the node to value v1, then\n<line11>    //    call the super.startForwarding to generate the ongoing\n<line12>    //    txn proposal and commit for v1 value update\n<line13>    leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {\n<line14>\n<line15>        @Override\n<line16>        public void start() {\n<line17>            if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {\n<line18>                return;\n<line19>            }\n<line20>            final String value = \"2\";\n<line21>            // use async, otherwise it will block the logLock in\n<line22>            // ZKDatabase and the setData request will timeout\n<line23>            try {\n<line24>                leaderZk.setData(nodePath, value.getBytes(), -1, (rc, path, ctx, stat) -> {\n<line25>                }, null);\n<line26>                // wait for the setData txn being populated\n<line27>                Thread.sleep(1000);\n<line28>            } catch (Exception e) {\n<line29>            }\n<line30>        }\n<line31>    });\n<line32>    // 5. on the customized leader catch the beginSnapshot call in\n<line33>    //    LearnerSyncThrottler to set the node to value v2,\n<line34>    //    wait it hit data tree\n<line35>    leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {\n<line36>\n<line37>        @Override\n<line38>        public void start() {\n<line39>            String value = \"3\";\n<line40>            try {\n<line41>                leaderZk.setData(nodePath, value.getBytes(), -1);\n<line42>            } catch (Exception e) {\n<line43>            }\n<line44>        }\n<line45>    });\n<line46>    // 6. exit follower A after taking snapshot\n<line47>    CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);\n<line48>    contexts[followerA].exitWhenAckNewLeader = true;\n<line49>    CountDownLatch latch = new CountDownLatch(1);\n<line50>    final MainThread followerAMT = mt[followerA];\n<line51>    contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {\n<line52>\n<line53>        @Override\n<line54>        public void start() {\n<line55>            try {\n<line56>                latch.countDown();\n<line57>                followerAMT.shutdown();\n<line58>            } catch (Exception e) {\n<line59>            }\n<line60>        }\n<line61>    };\n<line62>    // 7. start follower A to do snapshot sync\n<line63>    mt[followerA].start();\n<line64>    assertTrue(latch.await(30, TimeUnit.SECONDS));\n<line65>    // 8. now we have invalid data on disk, let's load it and verify\n<line66>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line67>    contexts[followerA].exitWhenAckNewLeader = true;\n<line68>    contexts[followerA].newLeaderAckCallback = null;\n<line69>    mt[followerA].start();\n<line70>    zk[followerA].close();\n<line71>    zk[followerA] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line72>    // 9. start follower A, after it's in broadcast state, make sure\n<line73>    //    the node value is same as what we have on leader\n<line74>    waitForOne(zk[followerA], States.CONNECTED);\n<line75>    assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));\n<line76>}","output":"<line1>{\n<line2>    // 2. set force snapshot to be true\n<line3>    LOG.info(\"force snapshot sync\");\n<line4>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line5>    // 3. create a node\n<line6>    String initialValue = \"1\";\n<line7>    final ZooKeeper leaderZk = zk[leaderId];\n<line8>    leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>    LOG.info(\"created node {} with value {}\", nodePath, initialValue);\n<line10>    CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line11>    // 4. on the customized leader catch the startForwarding call\n<line12>    //    (without synchronized), set the node to value v1, then\n<line13>    //    call the super.startForwarding to generate the ongoing\n<line14>    //    txn proposal and commit for v1 value update\n<line15>    leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {\n<line16>\n<line17>        @Override\n<line18>        public void start() {\n<line19>            if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {\n<line20>                return;\n<line21>            }\n<line22>            final String value = \"2\";\n<line23>            LOG.info(\"start forwarding, set {} to {}\", nodePath, value);\n<line24>            // use async, otherwise it will block the logLock in\n<line25>            // ZKDatabase and the setData request will timeout\n<line26>            try {\n<line27>                leaderZk.setData(nodePath, value.getBytes(), -1, (rc, path, ctx, stat) -> {\n<line28>                }, null);\n<line29>                // wait for the setData txn being populated\n<line30>                Thread.sleep(1000);\n<line31>            } catch (Exception e) {\n<line32>                LOG.error(\"error when set {} to {}\", nodePath, value, e);\n<line33>            }\n<line34>        }\n<line35>    });\n<line36>    // 5. on the customized leader catch the beginSnapshot call in\n<line37>    //    LearnerSyncThrottler to set the node to value v2,\n<line38>    //    wait it hit data tree\n<line39>    leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {\n<line40>\n<line41>        @Override\n<line42>        public void start() {\n<line43>            String value = \"3\";\n<line44>            LOG.info(\"before sending snapshot, set {} to {}\", nodePath, value);\n<line45>            try {\n<line46>                leaderZk.setData(nodePath, value.getBytes(), -1);\n<line47>                LOG.info(\"successfully set {} to {}\", nodePath, value);\n<line48>            } catch (Exception e) {\n<line49>                LOG.error(\"error when set {} to {}, {}\", nodePath, value, e);\n<line50>            }\n<line51>        }\n<line52>    });\n<line53>    // 6. exit follower A after taking snapshot\n<line54>    CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);\n<line55>    LOG.info(\"set exit when ack new leader packet on {}\", followerA);\n<line56>    contexts[followerA].exitWhenAckNewLeader = true;\n<line57>    CountDownLatch latch = new CountDownLatch(1);\n<line58>    final MainThread followerAMT = mt[followerA];\n<line59>    contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {\n<line60>\n<line61>        @Override\n<line62>        public void start() {\n<line63>            try {\n<line64>                latch.countDown();\n<line65>                followerAMT.shutdown();\n<line66>            } catch (Exception e) {\n<line67>            }\n<line68>        }\n<line69>    };\n<line70>    // 7. start follower A to do snapshot sync\n<line71>    LOG.info(\"starting follower {}\", followerA);\n<line72>    mt[followerA].start();\n<line73>    assertTrue(latch.await(30, TimeUnit.SECONDS));\n<line74>    // 8. now we have invalid data on disk, let's load it and verify\n<line75>    LOG.info(\"disable exit when ack new leader packet on {}\", followerA);\n<line76>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line77>    contexts[followerA].exitWhenAckNewLeader = true;\n<line78>    contexts[followerA].newLeaderAckCallback = null;\n<line79>    LOG.info(\"restarting follower {}\", followerA);\n<line80>    mt[followerA].start();\n<line81>    zk[followerA].close();\n<line82>    zk[followerA] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line83>    // 9. start follower A, after it's in broadcast state, make sure\n<line84>    //    the node value is same as what we have on leader\n<line85>    waitForOne(zk[followerA], States.CONNECTED);\n<line86>    assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));\n<line87>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {\n<line3>        return;\n<line4>    }\n<line5>    final String value = \"2\";\n<line6>    // use async, otherwise it will block the logLock in\n<line7>    // ZKDatabase and the setData request will timeout\n<line8>    try {\n<line9>        leaderZk.setData(nodePath, value.getBytes(), -1, (rc, path, ctx, stat) -> {\n<line10>        }, null);\n<line11>        // wait for the setData txn being populated\n<line12>        Thread.sleep(1000);\n<line13>    } catch (Exception e) {\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {\n<line3>        return;\n<line4>    }\n<line5>    final String value = \"2\";\n<line6>    LOG.info(\"start forwarding, set {} to {}\", nodePath, value);\n<line7>    // use async, otherwise it will block the logLock in\n<line8>    // ZKDatabase and the setData request will timeout\n<line9>    try {\n<line10>        leaderZk.setData(nodePath, value.getBytes(), -1, (rc, path, ctx, stat) -> {\n<line11>        }, null);\n<line12>        // wait for the setData txn being populated\n<line13>        Thread.sleep(1000);\n<line14>    } catch (Exception e) {\n<line15>        LOG.error(\"error when set {} to {}\", nodePath, value, e);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"error when set {} to {}\", nodePath, value, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String value = \"3\";\n<line3>    try {\n<line4>        leaderZk.setData(nodePath, value.getBytes(), -1);\n<line5>    } catch (Exception e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    String value = \"3\";\n<line3>    LOG.info(\"before sending snapshot, set {} to {}\", nodePath, value);\n<line4>    try {\n<line5>        leaderZk.setData(nodePath, value.getBytes(), -1);\n<line6>        LOG.info(\"successfully set {} to {}\", nodePath, value);\n<line7>    } catch (Exception e) {\n<line8>        LOG.error(\"error when set {} to {}, {}\", nodePath, value, e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    leaderZk.setData(nodePath, value.getBytes(), -1);\n<line3>}","output":"<line1>{\n<line2>    leaderZk.setData(nodePath, value.getBytes(), -1);\n<line3>    LOG.info(\"successfully set {} to {}\", nodePath, value);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"error when set {} to {}, {}\", nodePath, value, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final int ENSEMBLE_SERVERS = 3;\n<line3>    MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];\n<line4>    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];\n<line5>    try {\n<line6>        // 1. start a quorum\n<line7>        final int[] clientPorts = new int[ENSEMBLE_SERVERS];\n<line8>        StringBuilder sb = new StringBuilder();\n<line9>        String server;\n<line10>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line11>            clientPorts[i] = PortAssignment.unique();\n<line12>            server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line13>            sb.append(server + \"\\n\");\n<line14>        }\n<line15>        String currentQuorumCfgSection = sb.toString();\n<line16>        // start servers\n<line17>        Context[] contexts = new Context[ENSEMBLE_SERVERS];\n<line18>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line19>            final Context context = new Context();\n<line20>            contexts[i] = context;\n<line21>            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line22>\n<line23>                @Override\n<line24>                public TestQPMain getTestQPMain() {\n<line25>                    return new CustomizedQPMain(context);\n<line26>                }\n<line27>            };\n<line28>            mt[i].start();\n<line29>            zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line30>        }\n<line31>        waitForAll(zk, States.CONNECTED);\n<line32>        final String nodePath = \"/testDiffSyncAfterSnap\";\n<line33>        // 2. find leader and a follower\n<line34>        int leaderId = -1;\n<line35>        int followerA = -1;\n<line36>        for (int i = ENSEMBLE_SERVERS - 1; i >= 0; i--) {\n<line37>            if (mt[i].main.quorumPeer.leader != null) {\n<line38>                leaderId = i;\n<line39>            } else if (followerA == -1) {\n<line40>                followerA = i;\n<line41>            }\n<line42>        }\n<line43>        // 3. stop follower A\n<line44>        mt[followerA].shutdown();\n<line45>        waitForOne(zk[followerA], States.CONNECTING);\n<line46>        // 4. issue some traffic\n<line47>        int index = 0;\n<line48>        int numOfRequests = 10;\n<line49>        for (int i = 0; i < numOfRequests; i++) {\n<line50>            zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line51>        }\n<line52>        CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line53>        // 5. inject fault to cause the follower exit when received NEWLEADER\n<line54>        contexts[followerA].newLeaderReceivedCallback = new NewLeaderReceivedCallback() {\n<line55>\n<line56>            boolean processed = false;\n<line57>\n<line58>            @Override\n<line59>            public void process() throws IOException {\n<line60>                if (processed) {\n<line61>                    return;\n<line62>                }\n<line63>                processed = true;\n<line64>                System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line65>                throw new IOException(\"read timedout\");\n<line66>            }\n<line67>        };\n<line68>        // 6. force snap sync once\n<line69>        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line70>        // 7. start follower A\n<line71>        mt[followerA].start();\n<line72>        waitForOne(zk[followerA], States.CONNECTED);\n<line73>        for (int i = 0; i < index; i++) {\n<line74>            assertNotNull(zk[followerA].exists(nodePath + i, false));\n<line75>        }\n<line76>        // 8. issue another request which will be persisted on disk\n<line77>        zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line78>        // wait some time to let this get written to disk\n<line79>        Thread.sleep(500);\n<line80>        // 9. reload data from disk and make sure it's still consistent\n<line81>        mt[followerA].shutdown();\n<line82>        waitForOne(zk[followerA], States.CONNECTING);\n<line83>        mt[followerA].start();\n<line84>        waitForOne(zk[followerA], States.CONNECTED);\n<line85>        for (int i = 0; i < index; i++) {\n<line86>            assertNotNull(zk[followerA].exists(nodePath + i, false), \"node \" + i + \" should exist\");\n<line87>        }\n<line88>    } finally {\n<line89>        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);\n<line90>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line91>            mt[i].shutdown();\n<line92>            zk[i].close();\n<line93>        }\n<line94>    }\n<line95>}","output":"<line1>{\n<line2>    final int ENSEMBLE_SERVERS = 3;\n<line3>    MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];\n<line4>    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];\n<line5>    try {\n<line6>        // 1. start a quorum\n<line7>        final int[] clientPorts = new int[ENSEMBLE_SERVERS];\n<line8>        StringBuilder sb = new StringBuilder();\n<line9>        String server;\n<line10>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line11>            clientPorts[i] = PortAssignment.unique();\n<line12>            server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line13>            sb.append(server + \"\\n\");\n<line14>        }\n<line15>        String currentQuorumCfgSection = sb.toString();\n<line16>        // start servers\n<line17>        Context[] contexts = new Context[ENSEMBLE_SERVERS];\n<line18>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line19>            final Context context = new Context();\n<line20>            contexts[i] = context;\n<line21>            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line22>\n<line23>                @Override\n<line24>                public TestQPMain getTestQPMain() {\n<line25>                    return new CustomizedQPMain(context);\n<line26>                }\n<line27>            };\n<line28>            mt[i].start();\n<line29>            zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line30>        }\n<line31>        waitForAll(zk, States.CONNECTED);\n<line32>        LOG.info(\"all servers started\");\n<line33>        final String nodePath = \"/testDiffSyncAfterSnap\";\n<line34>        // 2. find leader and a follower\n<line35>        int leaderId = -1;\n<line36>        int followerA = -1;\n<line37>        for (int i = ENSEMBLE_SERVERS - 1; i >= 0; i--) {\n<line38>            if (mt[i].main.quorumPeer.leader != null) {\n<line39>                leaderId = i;\n<line40>            } else if (followerA == -1) {\n<line41>                followerA = i;\n<line42>            }\n<line43>        }\n<line44>        // 3. stop follower A\n<line45>        LOG.info(\"shutdown follower {}\", followerA);\n<line46>        mt[followerA].shutdown();\n<line47>        waitForOne(zk[followerA], States.CONNECTING);\n<line48>        // 4. issue some traffic\n<line49>        int index = 0;\n<line50>        int numOfRequests = 10;\n<line51>        for (int i = 0; i < numOfRequests; i++) {\n<line52>            zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line53>        }\n<line54>        CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line55>        // 5. inject fault to cause the follower exit when received NEWLEADER\n<line56>        contexts[followerA].newLeaderReceivedCallback = new NewLeaderReceivedCallback() {\n<line57>\n<line58>            boolean processed = false;\n<line59>\n<line60>            @Override\n<line61>            public void process() throws IOException {\n<line62>                if (processed) {\n<line63>                    return;\n<line64>                }\n<line65>                processed = true;\n<line66>                System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line67>                throw new IOException(\"read timedout\");\n<line68>            }\n<line69>        };\n<line70>        // 6. force snap sync once\n<line71>        LOG.info(\"force snapshot sync\");\n<line72>        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line73>        // 7. start follower A\n<line74>        mt[followerA].start();\n<line75>        waitForOne(zk[followerA], States.CONNECTED);\n<line76>        LOG.info(\"verify the nodes are exist in memory\");\n<line77>        for (int i = 0; i < index; i++) {\n<line78>            assertNotNull(zk[followerA].exists(nodePath + i, false));\n<line79>        }\n<line80>        // 8. issue another request which will be persisted on disk\n<line81>        zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line82>        // wait some time to let this get written to disk\n<line83>        Thread.sleep(500);\n<line84>        // 9. reload data from disk and make sure it's still consistent\n<line85>        LOG.info(\"restarting follower {}\", followerA);\n<line86>        mt[followerA].shutdown();\n<line87>        waitForOne(zk[followerA], States.CONNECTING);\n<line88>        mt[followerA].start();\n<line89>        waitForOne(zk[followerA], States.CONNECTED);\n<line90>        for (int i = 0; i < index; i++) {\n<line91>            assertNotNull(zk[followerA].exists(nodePath + i, false), \"node \" + i + \" should exist\");\n<line92>        }\n<line93>    } finally {\n<line94>        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);\n<line95>        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line96>            mt[i].shutdown();\n<line97>            zk[i].close();\n<line98>        }\n<line99>    }\n<line100>}"},{"input":"","instruction":"<line1>{\n<line2>    // 1. start a quorum\n<line3>    final int[] clientPorts = new int[ENSEMBLE_SERVERS];\n<line4>    StringBuilder sb = new StringBuilder();\n<line5>    String server;\n<line6>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line7>        clientPorts[i] = PortAssignment.unique();\n<line8>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line9>        sb.append(server + \"\\n\");\n<line10>    }\n<line11>    String currentQuorumCfgSection = sb.toString();\n<line12>    // start servers\n<line13>    Context[] contexts = new Context[ENSEMBLE_SERVERS];\n<line14>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line15>        final Context context = new Context();\n<line16>        contexts[i] = context;\n<line17>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line18>\n<line19>            @Override\n<line20>            public TestQPMain getTestQPMain() {\n<line21>                return new CustomizedQPMain(context);\n<line22>            }\n<line23>        };\n<line24>        mt[i].start();\n<line25>        zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line26>    }\n<line27>    waitForAll(zk, States.CONNECTED);\n<line28>    final String nodePath = \"/testDiffSyncAfterSnap\";\n<line29>    // 2. find leader and a follower\n<line30>    int leaderId = -1;\n<line31>    int followerA = -1;\n<line32>    for (int i = ENSEMBLE_SERVERS - 1; i >= 0; i--) {\n<line33>        if (mt[i].main.quorumPeer.leader != null) {\n<line34>            leaderId = i;\n<line35>        } else if (followerA == -1) {\n<line36>            followerA = i;\n<line37>        }\n<line38>    }\n<line39>    // 3. stop follower A\n<line40>    mt[followerA].shutdown();\n<line41>    waitForOne(zk[followerA], States.CONNECTING);\n<line42>    // 4. issue some traffic\n<line43>    int index = 0;\n<line44>    int numOfRequests = 10;\n<line45>    for (int i = 0; i < numOfRequests; i++) {\n<line46>        zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line47>    }\n<line48>    CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line49>    // 5. inject fault to cause the follower exit when received NEWLEADER\n<line50>    contexts[followerA].newLeaderReceivedCallback = new NewLeaderReceivedCallback() {\n<line51>\n<line52>        boolean processed = false;\n<line53>\n<line54>        @Override\n<line55>        public void process() throws IOException {\n<line56>            if (processed) {\n<line57>                return;\n<line58>            }\n<line59>            processed = true;\n<line60>            System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line61>            throw new IOException(\"read timedout\");\n<line62>        }\n<line63>    };\n<line64>    // 6. force snap sync once\n<line65>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line66>    // 7. start follower A\n<line67>    mt[followerA].start();\n<line68>    waitForOne(zk[followerA], States.CONNECTED);\n<line69>    for (int i = 0; i < index; i++) {\n<line70>        assertNotNull(zk[followerA].exists(nodePath + i, false));\n<line71>    }\n<line72>    // 8. issue another request which will be persisted on disk\n<line73>    zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line74>    // wait some time to let this get written to disk\n<line75>    Thread.sleep(500);\n<line76>    // 9. reload data from disk and make sure it's still consistent\n<line77>    mt[followerA].shutdown();\n<line78>    waitForOne(zk[followerA], States.CONNECTING);\n<line79>    mt[followerA].start();\n<line80>    waitForOne(zk[followerA], States.CONNECTED);\n<line81>    for (int i = 0; i < index; i++) {\n<line82>        assertNotNull(zk[followerA].exists(nodePath + i, false), \"node \" + i + \" should exist\");\n<line83>    }\n<line84>}","output":"<line1>{\n<line2>    // 1. start a quorum\n<line3>    final int[] clientPorts = new int[ENSEMBLE_SERVERS];\n<line4>    StringBuilder sb = new StringBuilder();\n<line5>    String server;\n<line6>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line7>        clientPorts[i] = PortAssignment.unique();\n<line8>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line9>        sb.append(server + \"\\n\");\n<line10>    }\n<line11>    String currentQuorumCfgSection = sb.toString();\n<line12>    // start servers\n<line13>    Context[] contexts = new Context[ENSEMBLE_SERVERS];\n<line14>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line15>        final Context context = new Context();\n<line16>        contexts[i] = context;\n<line17>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line18>\n<line19>            @Override\n<line20>            public TestQPMain getTestQPMain() {\n<line21>                return new CustomizedQPMain(context);\n<line22>            }\n<line23>        };\n<line24>        mt[i].start();\n<line25>        zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line26>    }\n<line27>    waitForAll(zk, States.CONNECTED);\n<line28>    LOG.info(\"all servers started\");\n<line29>    final String nodePath = \"/testDiffSyncAfterSnap\";\n<line30>    // 2. find leader and a follower\n<line31>    int leaderId = -1;\n<line32>    int followerA = -1;\n<line33>    for (int i = ENSEMBLE_SERVERS - 1; i >= 0; i--) {\n<line34>        if (mt[i].main.quorumPeer.leader != null) {\n<line35>            leaderId = i;\n<line36>        } else if (followerA == -1) {\n<line37>            followerA = i;\n<line38>        }\n<line39>    }\n<line40>    // 3. stop follower A\n<line41>    LOG.info(\"shutdown follower {}\", followerA);\n<line42>    mt[followerA].shutdown();\n<line43>    waitForOne(zk[followerA], States.CONNECTING);\n<line44>    // 4. issue some traffic\n<line45>    int index = 0;\n<line46>    int numOfRequests = 10;\n<line47>    for (int i = 0; i < numOfRequests; i++) {\n<line48>        zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line49>    }\n<line50>    CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;\n<line51>    // 5. inject fault to cause the follower exit when received NEWLEADER\n<line52>    contexts[followerA].newLeaderReceivedCallback = new NewLeaderReceivedCallback() {\n<line53>\n<line54>        boolean processed = false;\n<line55>\n<line56>        @Override\n<line57>        public void process() throws IOException {\n<line58>            if (processed) {\n<line59>                return;\n<line60>            }\n<line61>            processed = true;\n<line62>            System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"false\");\n<line63>            throw new IOException(\"read timedout\");\n<line64>        }\n<line65>    };\n<line66>    // 6. force snap sync once\n<line67>    LOG.info(\"force snapshot sync\");\n<line68>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line69>    // 7. start follower A\n<line70>    mt[followerA].start();\n<line71>    waitForOne(zk[followerA], States.CONNECTED);\n<line72>    LOG.info(\"verify the nodes are exist in memory\");\n<line73>    for (int i = 0; i < index; i++) {\n<line74>        assertNotNull(zk[followerA].exists(nodePath + i, false));\n<line75>    }\n<line76>    // 8. issue another request which will be persisted on disk\n<line77>    zk[leaderId].create(nodePath + index++, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line78>    // wait some time to let this get written to disk\n<line79>    Thread.sleep(500);\n<line80>    // 9. reload data from disk and make sure it's still consistent\n<line81>    LOG.info(\"restarting follower {}\", followerA);\n<line82>    mt[followerA].shutdown();\n<line83>    waitForOne(zk[followerA], States.CONNECTING);\n<line84>    mt[followerA].start();\n<line85>    waitForOne(zk[followerA], States.CONNECTED);\n<line86>    for (int i = 0; i < index; i++) {\n<line87>        assertNotNull(zk[followerA].exists(nodePath + i, false), \"node \" + i + \" should exist\");\n<line88>    }\n<line89>}"},{"input":"","instruction":"<line1>{\n<line2>    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {\n<line3>\n<line4>        @Override\n<line5>        void followLeader() throws InterruptedException {\n<line6>            if (context.quitFollowing) {\n<line7>                // reset the flag\n<line8>                context.quitFollowing = false;\n<line9>                return;\n<line10>            } else {\n<line11>                super.followLeader();\n<line12>            }\n<line13>        }\n<line14>\n<line15>        @Override\n<line16>        void writePacket(QuorumPacket pp, boolean flush) throws IOException {\n<line17>            if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {\n<line18>                if (context.newLeaderAckCallback != null) {\n<line19>                    context.newLeaderAckCallback.start();\n<line20>                }\n<line21>            }\n<line22>            super.writePacket(pp, flush);\n<line23>        }\n<line24>\n<line25>        @Override\n<line26>        void readPacket(QuorumPacket qp) throws IOException {\n<line27>            super.readPacket(qp);\n<line28>            if (qp.getType() == Leader.NEWLEADER && context.newLeaderReceivedCallback != null) {\n<line29>                context.newLeaderReceivedCallback.process();\n<line30>            }\n<line31>        }\n<line32>    };\n<line33>}","output":"<line1>{\n<line2>    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {\n<line3>\n<line4>        @Override\n<line5>        void followLeader() throws InterruptedException {\n<line6>            if (context.quitFollowing) {\n<line7>                // reset the flag\n<line8>                context.quitFollowing = false;\n<line9>                LOG.info(\"Quit following\");\n<line10>                return;\n<line11>            } else {\n<line12>                super.followLeader();\n<line13>            }\n<line14>        }\n<line15>\n<line16>        @Override\n<line17>        void writePacket(QuorumPacket pp, boolean flush) throws IOException {\n<line18>            if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {\n<line19>                if (context.newLeaderAckCallback != null) {\n<line20>                    context.newLeaderAckCallback.start();\n<line21>                }\n<line22>            }\n<line23>            super.writePacket(pp, flush);\n<line24>        }\n<line25>\n<line26>        @Override\n<line27>        void readPacket(QuorumPacket qp) throws IOException {\n<line28>            super.readPacket(qp);\n<line29>            if (qp.getType() == Leader.NEWLEADER && context.newLeaderReceivedCallback != null) {\n<line30>                context.newLeaderReceivedCallback.process();\n<line31>            }\n<line32>        }\n<line33>    };\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    if (context.quitFollowing) {\n<line3>        // reset the flag\n<line4>        context.quitFollowing = false;\n<line5>        return;\n<line6>    } else {\n<line7>        super.followLeader();\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (context.quitFollowing) {\n<line3>        // reset the flag\n<line4>        context.quitFollowing = false;\n<line5>        LOG.info(\"Quit following\");\n<line6>        return;\n<line7>    } else {\n<line8>        super.followLeader();\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    // reset the flag\n<line3>    context.quitFollowing = false;\n<line4>    return;\n<line5>}","output":"<line1>{\n<line2>    // reset the flag\n<line3>    context.quitFollowing = false;\n<line4>    LOG.info(\"Quit following\");\n<line5>    return;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (servers == null || servers.mt == null) {\n<line3>        return;\n<line4>    }\n<line5>    for (int i = 0; i < numServers; i++) {\n<line6>        if (i < servers.mt.length) {\n<line7>            servers.mt[i].shutdown();\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (servers == null || servers.mt == null) {\n<line3>        LOG.info(\"No servers to shutdown!\");\n<line4>        return;\n<line5>    }\n<line6>    for (int i = 0; i < numServers; i++) {\n<line7>        if (i < servers.mt.length) {\n<line8>            servers.mt[i].shutdown();\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"No servers to shutdown!\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    baseDir = ClientBase.createTmpDir();\n<line3>    this.myid = myid;\n<line4>    this.clientPort = clientPort;\n<line5>    this.quorumCfgSection = quorumCfgSection;\n<line6>    this.otherConfigs = otherConfigs;\n<line7>    confFile = new File(baseDir, \"zoo.cfg\");\n<line8>    FileWriter fwriter = new FileWriter(confFile);\n<line9>    fwriter.write(\"tickTime=\" + tickTime + \"\\n\");\n<line10>    fwriter.write(\"initLimit=10\\n\");\n<line11>    fwriter.write(\"syncLimit=5\\n\");\n<line12>    fwriter.write(\"connectToLearnerMasterLimit=5\\n\");\n<line13>    tmpDir = new File(baseDir, \"data\");\n<line14>    if (!tmpDir.mkdir()) {\n<line15>        throw new IOException(\"Unable to mkdir \" + tmpDir);\n<line16>    }\n<line17>    // Convert windows path to UNIX to avoid problems with \"\\\"\n<line18>    String dir = tmpDir.toString();\n<line19>    String osname = java.lang.System.getProperty(\"os.name\");\n<line20>    if (osname.toLowerCase().contains(\"windows\")) {\n<line21>        dir = dir.replace('\\\\', '/');\n<line22>    }\n<line23>    fwriter.write(\"dataDir=\" + dir + \"\\n\");\n<line24>    fwriter.write(\"clientPort=\" + clientPort + \"\\n\");\n<line25>    // write extra configurations\n<line26>    Set<Entry<String, String>> entrySet = otherConfigs.entrySet();\n<line27>    for (Entry<String, String> entry : entrySet) {\n<line28>        fwriter.write(entry.getKey() + \"=\" + entry.getValue() + \"\\n\");\n<line29>    }\n<line30>    fwriter.write(quorumCfgSection + \"\\n\");\n<line31>    fwriter.flush();\n<line32>    fwriter.close();\n<line33>    File myidFile = new File(tmpDir, \"myid\");\n<line34>    fwriter = new FileWriter(myidFile);\n<line35>    fwriter.write(Integer.toString(myid));\n<line36>    fwriter.flush();\n<line37>    fwriter.close();\n<line38>}","output":"<line1>{\n<line2>    baseDir = ClientBase.createTmpDir();\n<line3>    this.myid = myid;\n<line4>    this.clientPort = clientPort;\n<line5>    this.quorumCfgSection = quorumCfgSection;\n<line6>    this.otherConfigs = otherConfigs;\n<line7>    LOG.info(\"id = {} tmpDir = {} clientPort = {}\", myid, baseDir, clientPort);\n<line8>    confFile = new File(baseDir, \"zoo.cfg\");\n<line9>    FileWriter fwriter = new FileWriter(confFile);\n<line10>    fwriter.write(\"tickTime=\" + tickTime + \"\\n\");\n<line11>    fwriter.write(\"initLimit=10\\n\");\n<line12>    fwriter.write(\"syncLimit=5\\n\");\n<line13>    fwriter.write(\"connectToLearnerMasterLimit=5\\n\");\n<line14>    tmpDir = new File(baseDir, \"data\");\n<line15>    if (!tmpDir.mkdir()) {\n<line16>        throw new IOException(\"Unable to mkdir \" + tmpDir);\n<line17>    }\n<line18>    // Convert windows path to UNIX to avoid problems with \"\\\"\n<line19>    String dir = tmpDir.toString();\n<line20>    String osname = java.lang.System.getProperty(\"os.name\");\n<line21>    if (osname.toLowerCase().contains(\"windows\")) {\n<line22>        dir = dir.replace('\\\\', '/');\n<line23>    }\n<line24>    fwriter.write(\"dataDir=\" + dir + \"\\n\");\n<line25>    fwriter.write(\"clientPort=\" + clientPort + \"\\n\");\n<line26>    // write extra configurations\n<line27>    Set<Entry<String, String>> entrySet = otherConfigs.entrySet();\n<line28>    for (Entry<String, String> entry : entrySet) {\n<line29>        fwriter.write(entry.getKey() + \"=\" + entry.getValue() + \"\\n\");\n<line30>    }\n<line31>    fwriter.write(quorumCfgSection + \"\\n\");\n<line32>    fwriter.flush();\n<line33>    fwriter.close();\n<line34>    File myidFile = new File(tmpDir, \"myid\");\n<line35>    fwriter = new FileWriter(myidFile);\n<line36>    fwriter.write(Integer.toString(myid));\n<line37>    fwriter.flush();\n<line38>    fwriter.close();\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    tmpDir = ClientBase.createTmpDir();\n<line3>    File dataDir = new File(tmpDir, \"data\");\n<line4>    if (!dataDir.mkdir()) {\n<line5>        throw new IOException(\"Unable to mkdir \" + dataDir);\n<line6>    }\n<line7>    confFile = new File(tmpDir, \"zoo.cfg\");\n<line8>    FileWriter fwriter = new FileWriter(confFile);\n<line9>    fwriter.write(\"tickTime=4000\\n\");\n<line10>    fwriter.write(\"initLimit=10\\n\");\n<line11>    fwriter.write(\"syncLimit=5\\n\");\n<line12>    fwriter.write(\"connectToLearnerMasterLimit=5\\n\");\n<line13>    if (configs != null) {\n<line14>        fwriter.write(configs);\n<line15>    }\n<line16>    // Convert windows path to UNIX to avoid problems with \"\\\"\n<line17>    String dir = PathUtils.normalizeFileSystemPath(dataDir.toString());\n<line18>    fwriter.write(\"dataDir=\" + dir + \"\\n\");\n<line19>    fwriter.write(\"admin.serverPort=\" + adminServerPort + \"\\n\");\n<line20>    // For backward compatibility test, some tests create dynamic configuration\n<line21>    // without setting client port.\n<line22>    // This could happen both in static file or dynamic file.\n<line23>    if (clientPort != UNSET_STATIC_CLIENTPORT) {\n<line24>        fwriter.write(\"clientPort=\" + clientPort + \"\\n\");\n<line25>    }\n<line26>    if (secureClientPort != null) {\n<line27>        fwriter.write(\"secureClientPort=\" + secureClientPort + \"\\n\");\n<line28>    }\n<line29>    if (peerType != null) {\n<line30>        fwriter.write(\"peerType=\" + peerType + \"\\n\");\n<line31>    }\n<line32>    if (writeDynamicConfigFile) {\n<line33>        String dynamicConfigFilename = createDynamicFile(quorumCfgSection, version);\n<line34>        fwriter.write(\"dynamicConfigFile=\" + dynamicConfigFilename + \"\\n\");\n<line35>    } else {\n<line36>        fwriter.write(quorumCfgSection);\n<line37>    }\n<line38>    fwriter.flush();\n<line39>    fwriter.close();\n<line40>    File myidFile = new File(dataDir, \"myid\");\n<line41>    fwriter = new FileWriter(myidFile);\n<line42>    fwriter.write(Integer.toString(myid));\n<line43>    fwriter.flush();\n<line44>    fwriter.close();\n<line45>    ClientBase.createInitializeFile(dataDir);\n<line46>}","output":"<line1>{\n<line2>    tmpDir = ClientBase.createTmpDir();\n<line3>    LOG.info(\"id = {} tmpDir = {} clientPort = {} adminServerPort = {}\", myid, tmpDir, clientPort, adminServerPort);\n<line4>    File dataDir = new File(tmpDir, \"data\");\n<line5>    if (!dataDir.mkdir()) {\n<line6>        throw new IOException(\"Unable to mkdir \" + dataDir);\n<line7>    }\n<line8>    confFile = new File(tmpDir, \"zoo.cfg\");\n<line9>    FileWriter fwriter = new FileWriter(confFile);\n<line10>    fwriter.write(\"tickTime=4000\\n\");\n<line11>    fwriter.write(\"initLimit=10\\n\");\n<line12>    fwriter.write(\"syncLimit=5\\n\");\n<line13>    fwriter.write(\"connectToLearnerMasterLimit=5\\n\");\n<line14>    if (configs != null) {\n<line15>        fwriter.write(configs);\n<line16>    }\n<line17>    // Convert windows path to UNIX to avoid problems with \"\\\"\n<line18>    String dir = PathUtils.normalizeFileSystemPath(dataDir.toString());\n<line19>    fwriter.write(\"dataDir=\" + dir + \"\\n\");\n<line20>    fwriter.write(\"admin.serverPort=\" + adminServerPort + \"\\n\");\n<line21>    // For backward compatibility test, some tests create dynamic configuration\n<line22>    // without setting client port.\n<line23>    // This could happen both in static file or dynamic file.\n<line24>    if (clientPort != UNSET_STATIC_CLIENTPORT) {\n<line25>        fwriter.write(\"clientPort=\" + clientPort + \"\\n\");\n<line26>    }\n<line27>    if (secureClientPort != null) {\n<line28>        fwriter.write(\"secureClientPort=\" + secureClientPort + \"\\n\");\n<line29>    }\n<line30>    if (peerType != null) {\n<line31>        fwriter.write(\"peerType=\" + peerType + \"\\n\");\n<line32>    }\n<line33>    if (writeDynamicConfigFile) {\n<line34>        String dynamicConfigFilename = createDynamicFile(quorumCfgSection, version);\n<line35>        fwriter.write(\"dynamicConfigFile=\" + dynamicConfigFilename + \"\\n\");\n<line36>    } else {\n<line37>        fwriter.write(quorumCfgSection);\n<line38>    }\n<line39>    fwriter.flush();\n<line40>    fwriter.close();\n<line41>    File myidFile = new File(dataDir, \"myid\");\n<line42>    fwriter = new FileWriter(myidFile);\n<line43>    fwriter.write(Integer.toString(myid));\n<line44>    fwriter.flush();\n<line45>    fwriter.close();\n<line46>    ClientBase.createInitializeFile(dataDir);\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] args = new String[1];\n<line3>    args[0] = confFile.toString();\n<line4>    try {\n<line5>        main.initializeAndRun(args);\n<line6>    } catch (Exception e) {\n<line7>        // test will still fail even though we just log/ignore\n<line8>    } finally {\n<line9>        currentThread = null;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    String[] args = new String[1];\n<line3>    args[0] = confFile.toString();\n<line4>    try {\n<line5>        main.initializeAndRun(args);\n<line6>    } catch (Exception e) {\n<line7>        // test will still fail even though we just log/ignore\n<line8>        LOG.error(\"unexpected exception in run\", e);\n<line9>    } finally {\n<line10>        currentThread = null;\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // test will still fail even though we just log/ignore\n<line3>}","output":"<line1>{\n<line2>    // test will still fail even though we just log/ignore\n<line3>    LOG.error(\"unexpected exception in run\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < mt.length; i++) {\n<line3>        if (mt[i].main.quorumPeer.leader != null) {\n<line4>            return i;\n<line5>        }\n<line6>    }\n<line7>    return -1;\n<line8>}","output":"<line1>{\n<line2>    for (int i = 0; i < mt.length; i++) {\n<line3>        if (mt[i].main.quorumPeer.leader != null) {\n<line4>            LOG.info(\"Leader is {}\", i);\n<line5>            return i;\n<line6>        }\n<line7>    }\n<line8>    LOG.info(\"Cannot find Leader\");\n<line9>    return -1;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (mt[i].main.quorumPeer.leader != null) {\n<line3>        return i;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (mt[i].main.quorumPeer.leader != null) {\n<line3>        LOG.info(\"Leader is {}\", i);\n<line4>        return i;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    return i;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Leader is {}\", i);\n<line3>    return i;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < mt.length; i++) {\n<line3>        if (mt[i].main.quorumPeer.follower != null) {\n<line4>            return i;\n<line5>        }\n<line6>    }\n<line7>    return -1;\n<line8>}","output":"<line1>{\n<line2>    for (int i = 0; i < mt.length; i++) {\n<line3>        if (mt[i].main.quorumPeer.follower != null) {\n<line4>            LOG.info(\"Follower is {}\", i);\n<line5>            return i;\n<line6>        }\n<line7>    }\n<line8>    LOG.info(\"Cannot find any follower\");\n<line9>    return -1;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (mt[i].main.quorumPeer.follower != null) {\n<line3>        return i;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (mt[i].main.quorumPeer.follower != null) {\n<line3>        LOG.info(\"Follower is {}\", i);\n<line4>        return i;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    return i;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Follower is {}\", i);\n<line3>    return i;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < mt.length; i++) {\n<line3>        if (mt[i].main.quorumPeer.observer != null) {\n<line4>            return i;\n<line5>        }\n<line6>    }\n<line7>    return -1;\n<line8>}","output":"<line1>{\n<line2>    for (int i = 0; i < mt.length; i++) {\n<line3>        if (mt[i].main.quorumPeer.observer != null) {\n<line4>            LOG.info(\"Observer is {}\", i);\n<line5>            return i;\n<line6>        }\n<line7>    }\n<line8>    LOG.info(\"Cannot find any observer\");\n<line9>    return -1;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (mt[i].main.quorumPeer.observer != null) {\n<line3>        return i;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (mt[i].main.quorumPeer.observer != null) {\n<line3>        LOG.info(\"Observer is {}\", i);\n<line4>        return i;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    return i;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Observer is {}\", i);\n<line3>    return i;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    StringBuilder sbBuilder = new StringBuilder(\"Connection States: {\");\n<line3>    for (int i = 0; i < zks.length; i++) {\n<line4>        sbBuilder.append(i + \" : \" + zks[i].getState() + \", \");\n<line5>    }\n<line6>    sbBuilder.append('}');\n<line7>}","output":"<line1>{\n<line2>    StringBuilder sbBuilder = new StringBuilder(\"Connection States: {\");\n<line3>    for (int i = 0; i < zks.length; i++) {\n<line4>        sbBuilder.append(i + \" : \" + zks[i].getState() + \", \");\n<line5>    }\n<line6>    sbBuilder.append('}');\n<line7>    LOG.error(sbBuilder.toString());\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<String> paths = new ArrayList<>();\n<line3>    assertEquals(2, mt[2].getQuorumPeer().getLeaderId());\n<line4>    // create a ZK client to the leader (currentEpoch=1, lastLoggedZxid=<1, 1>)\n<line5>    createZKClient(2);\n<line6>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 2>)\n<line7>    paths.add(createNode(zkClients[2], PATH_PREFIX + \"0\"));\n<line8>    // shut down S0\n<line9>    mt[0].shutdown();\n<line10>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 3>), so S0 is 1 txn behind\n<line11>    paths.add(createNode(zkClients[2], PATH_PREFIX + \"1\"));\n<line12>    logEpochsAndLastLoggedTxnForAllServers();\n<line13>    // shut down S1\n<line14>    mt[1].shutdown();\n<line15>    // restart S0 and trigger a new leader election (currentEpoch=2)\n<line16>    // S0 starts with MockSyncRequestProcessor and MockCommitProcessor to simulate it writes the\n<line17>    // currentEpoch and sends NEWLEADER ACK but fails to persist and commit txns afterwards\n<line18>    // in DIFF sync\n<line19>    mt[0].start(new MockTestQPMain());\n<line20>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[0], CONNECTION_TIMEOUT), \"waiting for server 0 being up\");\n<line21>    logEpochsAndLastLoggedTxnForAllServers();\n<line22>    // validate S2 is still the leader\n<line23>    assertEquals(2, mt[2].getQuorumPeer().getLeaderId());\n<line24>    // shut down the leader (i.e. S2). This causes S0 disconnects from leader, performs partial\n<line25>    // shutdown, fast forwards its database to the latest persisted tnx (i.e. <1, 3>) and change\n<line26>    // its state to LOOKING\n<line27>    mt[2].shutdown();\n<line28>    // start S1 and trigger a leader election (currentEpoch=3)\n<line29>    mt[1].start();\n<line30>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[1], CONNECTION_TIMEOUT), \"waiting for server 1 being up\");\n<line31>    logEpochsAndLastLoggedTxnForAllServers();\n<line32>    // validate S0 is the new leader because of it has higher epoch\n<line33>    assertEquals(0, mt[0].getQuorumPeer().getLeaderId());\n<line34>    // connect to the new leader (i.e. S0) (currentEpoch=3, lastLoggedZxid=<3, 1>\n<line35>    createZKClient(0);\n<line36>    // create a znode (currentEpoch=3, lastLoggedZxid=<3, 2>)\n<line37>    paths.add(createNode(zkClients[0], PATH_PREFIX + \"3\"));\n<line38>    // start S2 which is the old leader\n<line39>    mt[2].start();\n<line40>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[2], CONNECTION_TIMEOUT), \"waiting for server \" + 2 + \" being up\");\n<line41>    logEpochsAndLastLoggedTxnForAllServers();\n<line42>    // validate all the znodes exist from all the clients\n<line43>    validateDataFromAllClients(paths);\n<line44>}","output":"<line1>{\n<line2>    final List<String> paths = new ArrayList<>();\n<line3>    assertEquals(2, mt[2].getQuorumPeer().getLeaderId());\n<line4>    // create a ZK client to the leader (currentEpoch=1, lastLoggedZxid=<1, 1>)\n<line5>    createZKClient(2);\n<line6>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 2>)\n<line7>    paths.add(createNode(zkClients[2], PATH_PREFIX + \"0\"));\n<line8>    // shut down S0\n<line9>    mt[0].shutdown();\n<line10>    LOG.info(\"S0 shutdown.\");\n<line11>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 3>), so S0 is 1 txn behind\n<line12>    paths.add(createNode(zkClients[2], PATH_PREFIX + \"1\"));\n<line13>    logEpochsAndLastLoggedTxnForAllServers();\n<line14>    // shut down S1\n<line15>    mt[1].shutdown();\n<line16>    LOG.info(\"S1 shutdown.\");\n<line17>    // restart S0 and trigger a new leader election (currentEpoch=2)\n<line18>    // S0 starts with MockSyncRequestProcessor and MockCommitProcessor to simulate it writes the\n<line19>    // currentEpoch and sends NEWLEADER ACK but fails to persist and commit txns afterwards\n<line20>    // in DIFF sync\n<line21>    mt[0].start(new MockTestQPMain());\n<line22>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[0], CONNECTION_TIMEOUT), \"waiting for server 0 being up\");\n<line23>    LOG.info(\"S0 restarted.\");\n<line24>    logEpochsAndLastLoggedTxnForAllServers();\n<line25>    // validate S2 is still the leader\n<line26>    assertEquals(2, mt[2].getQuorumPeer().getLeaderId());\n<line27>    // shut down the leader (i.e. S2). This causes S0 disconnects from leader, performs partial\n<line28>    // shutdown, fast forwards its database to the latest persisted tnx (i.e. <1, 3>) and change\n<line29>    // its state to LOOKING\n<line30>    mt[2].shutdown();\n<line31>    LOG.info(\"S2 shutdown.\");\n<line32>    // start S1 and trigger a leader election (currentEpoch=3)\n<line33>    mt[1].start();\n<line34>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[1], CONNECTION_TIMEOUT), \"waiting for server 1 being up\");\n<line35>    LOG.info(\"S1 restarted.\");\n<line36>    logEpochsAndLastLoggedTxnForAllServers();\n<line37>    // validate S0 is the new leader because of it has higher epoch\n<line38>    assertEquals(0, mt[0].getQuorumPeer().getLeaderId());\n<line39>    // connect to the new leader (i.e. S0) (currentEpoch=3, lastLoggedZxid=<3, 1>\n<line40>    createZKClient(0);\n<line41>    // create a znode (currentEpoch=3, lastLoggedZxid=<3, 2>)\n<line42>    paths.add(createNode(zkClients[0], PATH_PREFIX + \"3\"));\n<line43>    // start S2 which is the old leader\n<line44>    mt[2].start();\n<line45>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[2], CONNECTION_TIMEOUT), \"waiting for server \" + 2 + \" being up\");\n<line46>    LOG.info(\"S2 restarted.\");\n<line47>    logEpochsAndLastLoggedTxnForAllServers();\n<line48>    // validate all the znodes exist from all the clients\n<line49>    validateDataFromAllClients(paths);\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>    assertEquals(2, mt[2].getQuorumPeer().getLeaderId());\n<line3>    // create a ZK client to the leader (currentEpoch=1, lastLoggedZxid=<1, 1>)\n<line4>    createZKClient(2);\n<line5>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 2>)\n<line6>    createNode(zkClients[2], PATH_PREFIX + \"0\");\n<line7>    // shut down S0\n<line8>    mt[0].shutdown();\n<line9>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 3>), so S0 is 1 txn behind\n<line10>    createNode(zkClients[2], PATH_PREFIX + \"1\");\n<line11>    logEpochsAndLastLoggedTxnForAllServers();\n<line12>    // shut down S1\n<line13>    mt[1].shutdown();\n<line14>    // restart S0 and trigger a new leader election and DIFF sync (currentEpoch=2)\n<line15>    mt[0].start();\n<line16>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[0], CONNECTION_TIMEOUT), \"waiting for server 0 being up\");\n<line17>    // create a znode (currentEpoch=2, lastLoggedZxid=<2, 1>)\n<line18>    createNode(zkClients[2], PATH_PREFIX + \"2\");\n<line19>    // validate quorum is up without additional round of leader election\n<line20>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line21>        if (i != 1) {\n<line22>            final QuorumPeer qp = mt[i].getQuorumPeer();\n<line23>            assertNotNull(qp);\n<line24>            assertEquals(2, qp.getCurrentEpoch());\n<line25>            assertEquals(2, qp.getAcceptedEpoch());\n<line26>            assertEquals(\"200000001\", Long.toHexString(qp.getLastLoggedZxid()));\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    assertEquals(2, mt[2].getQuorumPeer().getLeaderId());\n<line3>    // create a ZK client to the leader (currentEpoch=1, lastLoggedZxid=<1, 1>)\n<line4>    createZKClient(2);\n<line5>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 2>)\n<line6>    createNode(zkClients[2], PATH_PREFIX + \"0\");\n<line7>    // shut down S0\n<line8>    mt[0].shutdown();\n<line9>    LOG.info(\"S0 shutdown.\");\n<line10>    // create a znode (currentEpoch=1, lastLoggedZxid=<1, 3>), so S0 is 1 txn behind\n<line11>    createNode(zkClients[2], PATH_PREFIX + \"1\");\n<line12>    logEpochsAndLastLoggedTxnForAllServers();\n<line13>    // shut down S1\n<line14>    mt[1].shutdown();\n<line15>    LOG.info(\"S1 shutdown.\");\n<line16>    // restart S0 and trigger a new leader election and DIFF sync (currentEpoch=2)\n<line17>    mt[0].start();\n<line18>    assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[0], CONNECTION_TIMEOUT), \"waiting for server 0 being up\");\n<line19>    LOG.info(\"S0 restarted.\");\n<line20>    // create a znode (currentEpoch=2, lastLoggedZxid=<2, 1>)\n<line21>    createNode(zkClients[2], PATH_PREFIX + \"2\");\n<line22>    // validate quorum is up without additional round of leader election\n<line23>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line24>        if (i != 1) {\n<line25>            final QuorumPeer qp = mt[i].getQuorumPeer();\n<line26>            assertNotNull(qp);\n<line27>            assertEquals(2, qp.getCurrentEpoch());\n<line28>            assertEquals(2, qp.getAcceptedEpoch());\n<line29>            assertEquals(\"200000001\", Long.toHexString(qp.getLastLoggedZxid()));\n<line30>        }\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Sync request for zxid {} is dropped\", Long.toHexString(request.getHdr().getZxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Commit request for zxid {} is dropped\", Long.toHexString(request.getHdr().getZxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line3>        final QuorumPeer qp = mt[i].getQuorumPeer();\n<line4>        if (qp != null) {\n<line5>        }\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line3>        final QuorumPeer qp = mt[i].getQuorumPeer();\n<line4>        if (qp != null) {\n<line5>            LOG.info(String.format(\"server id=%d, acceptedEpoch=%d, currentEpoch=%d, lastLoggedTxn=%s\", qp.getMyId(), qp.getAcceptedEpoch(), qp.getCurrentEpoch(), Long.toHexString(qp.getLastLoggedZxid())));\n<line6>        }\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    final QuorumPeer qp = mt[i].getQuorumPeer();\n<line3>    if (qp != null) {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    final QuorumPeer qp = mt[i].getQuorumPeer();\n<line3>    if (qp != null) {\n<line4>        LOG.info(String.format(\"server id=%d, acceptedEpoch=%d, currentEpoch=%d, lastLoggedTxn=%s\", qp.getMyId(), qp.getAcceptedEpoch(), qp.getCurrentEpoch(), Long.toHexString(qp.getLastLoggedZxid())));\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(String.format(\"server id=%d, acceptedEpoch=%d, currentEpoch=%d, lastLoggedTxn=%s\", qp.getMyId(), qp.getAcceptedEpoch(), qp.getCurrentEpoch(), Long.toHexString(qp.getLastLoggedZxid())));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final String path = \"/testAsMuchAsPossible\";\n<line3>    List<Request> shouldBeProcessed = new LinkedList<>();\n<line4>    Set<Request> shouldNotBeProcessed = new HashSet<>();\n<line5>    for (int sessionId = 1; sessionId <= 5; ++sessionId) {\n<line6>        for (int readReqId = 1; readReqId <= sessionId; ++readReqId) {\n<line7>            Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, readReqId);\n<line8>            shouldBeProcessed.add(readReq);\n<line9>            processor.queuedRequests.add(readReq);\n<line10>        }\n<line11>        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionId, sessionId + 1);\n<line12>        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, sessionId + 2);\n<line13>        processor.queuedRequests.add(writeReq);\n<line14>        processor.queuedWriteRequests.add(writeReq);\n<line15>        processor.queuedRequests.add(readReq);\n<line16>        shouldNotBeProcessed.add(writeReq);\n<line17>        shouldNotBeProcessed.add(readReq);\n<line18>    }\n<line19>    processor.initThreads(defaultSizeOfThreadPool);\n<line20>    processor.stoppedMainLoop = true;\n<line21>    processor.run();\n<line22>    Thread.sleep(1000);\n<line23>    shouldBeProcessed.removeAll(processedRequests);\n<line24>    for (Request r : shouldBeProcessed) {\n<line25>    }\n<line26>    assertTrue(shouldBeProcessed.isEmpty(), \"Not all requests were processed\");\n<line27>    assertFalse(shouldNotBeProcessed.removeAll(processedRequests), \"Processed a wrong request\");\n<line28>}","output":"<line1>{\n<line2>    final String path = \"/testAsMuchAsPossible\";\n<line3>    List<Request> shouldBeProcessed = new LinkedList<>();\n<line4>    Set<Request> shouldNotBeProcessed = new HashSet<>();\n<line5>    for (int sessionId = 1; sessionId <= 5; ++sessionId) {\n<line6>        for (int readReqId = 1; readReqId <= sessionId; ++readReqId) {\n<line7>            Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, readReqId);\n<line8>            shouldBeProcessed.add(readReq);\n<line9>            processor.queuedRequests.add(readReq);\n<line10>        }\n<line11>        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionId, sessionId + 1);\n<line12>        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, sessionId + 2);\n<line13>        processor.queuedRequests.add(writeReq);\n<line14>        processor.queuedWriteRequests.add(writeReq);\n<line15>        processor.queuedRequests.add(readReq);\n<line16>        shouldNotBeProcessed.add(writeReq);\n<line17>        shouldNotBeProcessed.add(readReq);\n<line18>    }\n<line19>    processor.initThreads(defaultSizeOfThreadPool);\n<line20>    processor.stoppedMainLoop = true;\n<line21>    processor.run();\n<line22>    Thread.sleep(1000);\n<line23>    shouldBeProcessed.removeAll(processedRequests);\n<line24>    for (Request r : shouldBeProcessed) {\n<line25>        LOG.error(\"Did not process {}\", r);\n<line26>    }\n<line27>    assertTrue(shouldBeProcessed.isEmpty(), \"Not all requests were processed\");\n<line28>    assertFalse(shouldNotBeProcessed.removeAll(processedRequests), \"Processed a wrong request\");\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Did not process {}\", r);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final String path = \"/testUncommittedFollowingCommited\";\n<line3>    Set<Request> shouldBeInPending = new HashSet<>();\n<line4>    Set<Request> shouldBeProcessedAfterPending = new HashSet<>();\n<line5>    Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);\n<line6>    processor.queuedRequests.add(writeReq);\n<line7>    processor.queuedWriteRequests.add(writeReq);\n<line8>    shouldBeInPending.add(writeReq);\n<line9>    for (int readReqId = 2; readReqId <= 5; ++readReqId) {\n<line10>        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);\n<line11>        processor.queuedRequests.add(readReq);\n<line12>        shouldBeInPending.add(readReq);\n<line13>        shouldBeProcessedAfterPending.add(readReq);\n<line14>    }\n<line15>    processor.initThreads(defaultSizeOfThreadPool);\n<line16>    processor.stoppedMainLoop = true;\n<line17>    processor.run();\n<line18>    assertTrue(processedRequests.isEmpty(), \"Processed without waiting for commit\");\n<line19>    assertTrue(processor.queuedRequests.isEmpty(), \"Did not handled all of queuedRequests' requests\");\n<line20>    assertTrue(!processor.queuedWriteRequests.isEmpty(), \"Removed from blockedQueuedRequests before commit\");\n<line21>    shouldBeInPending.removeAll(processor.pendingRequests.get(writeReq.sessionId));\n<line22>    for (Request r : shouldBeInPending) {\n<line23>    }\n<line24>    assertTrue(shouldBeInPending.isEmpty(), \"Not all requests moved to pending from queuedRequests\");\n<line25>    processor.committedRequests.add(writeReq);\n<line26>    processor.stoppedMainLoop = true;\n<line27>    processor.run();\n<line28>    processor.initThreads(defaultSizeOfThreadPool);\n<line29>    Thread.sleep(500);\n<line30>    assertTrue(processedRequests.peek() == writeReq, \"Did not process committed request\");\n<line31>    assertTrue(processedRequests.containsAll(shouldBeProcessedAfterPending), \"Did not process following read request\");\n<line32>    assertTrue(processor.committedRequests.isEmpty(), \"Did not process committed request\");\n<line33>    assertTrue(processor.pendingRequests.isEmpty(), \"Did not process committed request\");\n<line34>    assertTrue(processor.queuedWriteRequests.isEmpty(), \"Did not remove from blockedQueuedRequests\");\n<line35>}","output":"<line1>{\n<line2>    final String path = \"/testUncommittedFollowingCommited\";\n<line3>    Set<Request> shouldBeInPending = new HashSet<>();\n<line4>    Set<Request> shouldBeProcessedAfterPending = new HashSet<>();\n<line5>    Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);\n<line6>    processor.queuedRequests.add(writeReq);\n<line7>    processor.queuedWriteRequests.add(writeReq);\n<line8>    shouldBeInPending.add(writeReq);\n<line9>    for (int readReqId = 2; readReqId <= 5; ++readReqId) {\n<line10>        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);\n<line11>        processor.queuedRequests.add(readReq);\n<line12>        shouldBeInPending.add(readReq);\n<line13>        shouldBeProcessedAfterPending.add(readReq);\n<line14>    }\n<line15>    processor.initThreads(defaultSizeOfThreadPool);\n<line16>    processor.stoppedMainLoop = true;\n<line17>    processor.run();\n<line18>    assertTrue(processedRequests.isEmpty(), \"Processed without waiting for commit\");\n<line19>    assertTrue(processor.queuedRequests.isEmpty(), \"Did not handled all of queuedRequests' requests\");\n<line20>    assertTrue(!processor.queuedWriteRequests.isEmpty(), \"Removed from blockedQueuedRequests before commit\");\n<line21>    shouldBeInPending.removeAll(processor.pendingRequests.get(writeReq.sessionId));\n<line22>    for (Request r : shouldBeInPending) {\n<line23>        LOG.error(\"Should be in pending {}\", r);\n<line24>    }\n<line25>    assertTrue(shouldBeInPending.isEmpty(), \"Not all requests moved to pending from queuedRequests\");\n<line26>    processor.committedRequests.add(writeReq);\n<line27>    processor.stoppedMainLoop = true;\n<line28>    processor.run();\n<line29>    processor.initThreads(defaultSizeOfThreadPool);\n<line30>    Thread.sleep(500);\n<line31>    assertTrue(processedRequests.peek() == writeReq, \"Did not process committed request\");\n<line32>    assertTrue(processedRequests.containsAll(shouldBeProcessedAfterPending), \"Did not process following read request\");\n<line33>    assertTrue(processor.committedRequests.isEmpty(), \"Did not process committed request\");\n<line34>    assertTrue(processor.pendingRequests.isEmpty(), \"Did not process committed request\");\n<line35>    assertTrue(processor.queuedWriteRequests.isEmpty(), \"Did not remove from blockedQueuedRequests\");\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Should be in pending {}\", r);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    count = 3;\n<line3>    peers = new HashMap<>(count);\n<line4>    tmpdir = new File[count];\n<line5>    port = new int[count];\n<line6>    for (int i = 0; i < count; i++) {\n<line7>        int clientport = PortAssignment.unique();\n<line8>        peers.put((long) i, new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));\n<line9>        tmpdir[i] = ClientBase.createTmpDir();\n<line10>        port[i] = clientport;\n<line11>    }\n<line12>    /*\n<line13>         * Start server 0\n<line14>         */\n<line15>    peerRunningLeaderElection = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);\n<line16>    peerRunningLeaderElection.startLeaderElection();\n<line17>    leaderElectionThread = new FLETestUtils.LEThread(peerRunningLeaderElection, 0);\n<line18>    leaderElectionThread.start();\n<line19>}","output":"<line1>{\n<line2>    count = 3;\n<line3>    peers = new HashMap<>(count);\n<line4>    tmpdir = new File[count];\n<line5>    port = new int[count];\n<line6>    LOG.info(\"FLEMalformedNotificationMessageTest: {}, {}\", getTestName(), count);\n<line7>    for (int i = 0; i < count; i++) {\n<line8>        int clientport = PortAssignment.unique();\n<line9>        peers.put((long) i, new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));\n<line10>        tmpdir[i] = ClientBase.createTmpDir();\n<line11>        port[i] = clientport;\n<line12>    }\n<line13>    /*\n<line14>         * Start server 0\n<line15>         */\n<line16>    peerRunningLeaderElection = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);\n<line17>    peerRunningLeaderElection.startLeaderElection();\n<line18>    leaderElectionThread = new FLETestUtils.LEThread(peerRunningLeaderElection, 0);\n<line19>    leaderElectionThread.start();\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    NIOServerCnxnFactory serverCnxnFactory = mock(NIOServerCnxnFactory.class);\n<line3>    final SelectionKey sk = new FakeSK();\n<line4>    MockSelectorThread selectorThread = mock(MockSelectorThread.class);\n<line5>    when(selectorThread.addInterestOpsUpdateRequest(any(SelectionKey.class))).thenAnswer(new Answer<Boolean>() {\n<line6>\n<line7>        @Override\n<line8>        public Boolean answer(InvocationOnMock invocation) throws Throwable {\n<line9>            SelectionKey sk = (SelectionKey) invocation.getArguments()[0];\n<line10>            NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();\n<line11>            sk.interestOps(nioSrvCnx.getInterestOps());\n<line12>            return true;\n<line13>        }\n<line14>    });\n<line15>    ZKDatabase database = new ZKDatabase(null);\n<line16>    database.setlastProcessedZxid(2L);\n<line17>    QuorumPeer quorumPeer = mock(QuorumPeer.class);\n<line18>    FileTxnSnapLog logfactory = mock(FileTxnSnapLog.class);\n<line19>    // Directories are not used but we need it to avoid NPE\n<line20>    when(logfactory.getDataLogDir()).thenReturn(new File(\"\"));\n<line21>    when(logfactory.getSnapDir()).thenReturn(new File(\"\"));\n<line22>    FollowerZooKeeperServer fzks = null;\n<line23>    try {\n<line24>        // Create a new follower\n<line25>        fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);\n<line26>        fzks.startup();\n<line27>        fzks.setServerCnxnFactory(serverCnxnFactory);\n<line28>        quorumPeer.follower = new MyFollower(quorumPeer, fzks);\n<line29>        // Simulate a socket channel between a client and a follower\n<line30>        final SocketChannel socketChannel = createClientSocketChannel();\n<line31>        // Create the NIOServerCnxn that will handle the client requests\n<line32>        final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);\n<line33>        sk.attach(nioCnxn);\n<line34>        // Send the connection request as a client do\n<line35>        nioCnxn.doIO(sk);\n<line36>        // Send the valid or invalid session packet to the follower\n<line37>        QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);\n<line38>        quorumPeer.follower.processPacket(qp);\n<line39>        // OK, now the follower knows that the session is valid or invalid, let's try\n<line40>        // to send the watches\n<line41>        nioCnxn.doIO(sk);\n<line42>        // wait for the the request processor to do his job\n<line43>        Thread.sleep(1000L);\n<line44>        // If session has not been validated, there must be NO watches\n<line45>        int watchCount = database.getDataTree().getWatchCount();\n<line46>        if (sessionTimedout) {\n<line47>            // Session has not been re-validated !\n<line48>            assertEquals(0, watchCount, \"Session is not valid so there should be no watches\");\n<line49>        } else {\n<line50>            // Session has been re-validated\n<line51>            assertEquals(1, watchCount, \"Session is valid so the watch should be there\");\n<line52>        }\n<line53>    } finally {\n<line54>        if (fzks != null) {\n<line55>            fzks.shutdown();\n<line56>        }\n<line57>    }\n<line58>}","output":"<line1>{\n<line2>    NIOServerCnxnFactory serverCnxnFactory = mock(NIOServerCnxnFactory.class);\n<line3>    final SelectionKey sk = new FakeSK();\n<line4>    MockSelectorThread selectorThread = mock(MockSelectorThread.class);\n<line5>    when(selectorThread.addInterestOpsUpdateRequest(any(SelectionKey.class))).thenAnswer(new Answer<Boolean>() {\n<line6>\n<line7>        @Override\n<line8>        public Boolean answer(InvocationOnMock invocation) throws Throwable {\n<line9>            SelectionKey sk = (SelectionKey) invocation.getArguments()[0];\n<line10>            NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();\n<line11>            sk.interestOps(nioSrvCnx.getInterestOps());\n<line12>            return true;\n<line13>        }\n<line14>    });\n<line15>    ZKDatabase database = new ZKDatabase(null);\n<line16>    database.setlastProcessedZxid(2L);\n<line17>    QuorumPeer quorumPeer = mock(QuorumPeer.class);\n<line18>    FileTxnSnapLog logfactory = mock(FileTxnSnapLog.class);\n<line19>    // Directories are not used but we need it to avoid NPE\n<line20>    when(logfactory.getDataLogDir()).thenReturn(new File(\"\"));\n<line21>    when(logfactory.getSnapDir()).thenReturn(new File(\"\"));\n<line22>    FollowerZooKeeperServer fzks = null;\n<line23>    try {\n<line24>        // Create a new follower\n<line25>        fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);\n<line26>        fzks.startup();\n<line27>        fzks.setServerCnxnFactory(serverCnxnFactory);\n<line28>        quorumPeer.follower = new MyFollower(quorumPeer, fzks);\n<line29>        LOG.info(\"Follower created\");\n<line30>        // Simulate a socket channel between a client and a follower\n<line31>        final SocketChannel socketChannel = createClientSocketChannel();\n<line32>        // Create the NIOServerCnxn that will handle the client requests\n<line33>        final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);\n<line34>        sk.attach(nioCnxn);\n<line35>        // Send the connection request as a client do\n<line36>        nioCnxn.doIO(sk);\n<line37>        LOG.info(\"Client connection sent\");\n<line38>        // Send the valid or invalid session packet to the follower\n<line39>        QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);\n<line40>        quorumPeer.follower.processPacket(qp);\n<line41>        LOG.info(\"Session validation sent\");\n<line42>        // OK, now the follower knows that the session is valid or invalid, let's try\n<line43>        // to send the watches\n<line44>        nioCnxn.doIO(sk);\n<line45>        // wait for the the request processor to do his job\n<line46>        Thread.sleep(1000L);\n<line47>        LOG.info(\"Watches processed\");\n<line48>        // If session has not been validated, there must be NO watches\n<line49>        int watchCount = database.getDataTree().getWatchCount();\n<line50>        if (sessionTimedout) {\n<line51>            // Session has not been re-validated !\n<line52>            LOG.info(\"session is not valid, watches = {}\", watchCount);\n<line53>            assertEquals(0, watchCount, \"Session is not valid so there should be no watches\");\n<line54>        } else {\n<line55>            // Session has been re-validated\n<line56>            LOG.info(\"session is valid, watches = {}\", watchCount);\n<line57>            assertEquals(1, watchCount, \"Session is valid so the watch should be there\");\n<line58>        }\n<line59>    } finally {\n<line60>        if (fzks != null) {\n<line61>            fzks.shutdown();\n<line62>        }\n<line63>    }\n<line64>}"},{"input":"","instruction":"<line1>{\n<line2>    // Create a new follower\n<line3>    fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);\n<line4>    fzks.startup();\n<line5>    fzks.setServerCnxnFactory(serverCnxnFactory);\n<line6>    quorumPeer.follower = new MyFollower(quorumPeer, fzks);\n<line7>    // Simulate a socket channel between a client and a follower\n<line8>    final SocketChannel socketChannel = createClientSocketChannel();\n<line9>    // Create the NIOServerCnxn that will handle the client requests\n<line10>    final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);\n<line11>    sk.attach(nioCnxn);\n<line12>    // Send the connection request as a client do\n<line13>    nioCnxn.doIO(sk);\n<line14>    // Send the valid or invalid session packet to the follower\n<line15>    QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);\n<line16>    quorumPeer.follower.processPacket(qp);\n<line17>    // OK, now the follower knows that the session is valid or invalid, let's try\n<line18>    // to send the watches\n<line19>    nioCnxn.doIO(sk);\n<line20>    // wait for the the request processor to do his job\n<line21>    Thread.sleep(1000L);\n<line22>    // If session has not been validated, there must be NO watches\n<line23>    int watchCount = database.getDataTree().getWatchCount();\n<line24>    if (sessionTimedout) {\n<line25>        // Session has not been re-validated !\n<line26>        assertEquals(0, watchCount, \"Session is not valid so there should be no watches\");\n<line27>    } else {\n<line28>        // Session has been re-validated\n<line29>        assertEquals(1, watchCount, \"Session is valid so the watch should be there\");\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    // Create a new follower\n<line3>    fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);\n<line4>    fzks.startup();\n<line5>    fzks.setServerCnxnFactory(serverCnxnFactory);\n<line6>    quorumPeer.follower = new MyFollower(quorumPeer, fzks);\n<line7>    LOG.info(\"Follower created\");\n<line8>    // Simulate a socket channel between a client and a follower\n<line9>    final SocketChannel socketChannel = createClientSocketChannel();\n<line10>    // Create the NIOServerCnxn that will handle the client requests\n<line11>    final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);\n<line12>    sk.attach(nioCnxn);\n<line13>    // Send the connection request as a client do\n<line14>    nioCnxn.doIO(sk);\n<line15>    LOG.info(\"Client connection sent\");\n<line16>    // Send the valid or invalid session packet to the follower\n<line17>    QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);\n<line18>    quorumPeer.follower.processPacket(qp);\n<line19>    LOG.info(\"Session validation sent\");\n<line20>    // OK, now the follower knows that the session is valid or invalid, let's try\n<line21>    // to send the watches\n<line22>    nioCnxn.doIO(sk);\n<line23>    // wait for the the request processor to do his job\n<line24>    Thread.sleep(1000L);\n<line25>    LOG.info(\"Watches processed\");\n<line26>    // If session has not been validated, there must be NO watches\n<line27>    int watchCount = database.getDataTree().getWatchCount();\n<line28>    if (sessionTimedout) {\n<line29>        // Session has not been re-validated !\n<line30>        LOG.info(\"session is not valid, watches = {}\", watchCount);\n<line31>        assertEquals(0, watchCount, \"Session is not valid so there should be no watches\");\n<line32>    } else {\n<line33>        // Session has been re-validated\n<line34>        LOG.info(\"session is valid, watches = {}\", watchCount);\n<line35>        assertEquals(1, watchCount, \"Session is valid so the watch should be there\");\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    // Session has not been re-validated !\n<line3>    assertEquals(0, watchCount, \"Session is not valid so there should be no watches\");\n<line4>}","output":"<line1>{\n<line2>    // Session has not been re-validated !\n<line3>    LOG.info(\"session is not valid, watches = {}\", watchCount);\n<line4>    assertEquals(0, watchCount, \"Session is not valid so there should be no watches\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // Session has been re-validated\n<line3>    assertEquals(1, watchCount, \"Session is valid so the watch should be there\");\n<line4>}","output":"<line1>{\n<line2>    // Session has been re-validated\n<line3>    LOG.info(\"session is valid, watches = {}\", watchCount);\n<line4>    assertEquals(1, watchCount, \"Session is valid so the watch should be there\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean reading = (ops & OP_READ) != 0;\n<line3>    boolean writing = (ops & OP_WRITE) != 0;\n<line4>    if (reading && writing) {\n<line5>    } else if (reading) {\n<line6>    } else if (writing) {\n<line7>    }\n<line8>    return ops;\n<line9>}","output":"<line1>{\n<line2>    boolean reading = (ops & OP_READ) != 0;\n<line3>    boolean writing = (ops & OP_WRITE) != 0;\n<line4>    if (reading && writing) {\n<line5>        LOG.info(\"Channel is ready for reading and writing\");\n<line6>    } else if (reading) {\n<line7>        LOG.info(\"Channel is ready for reading only\");\n<line8>    } else if (writing) {\n<line9>        LOG.info(\"Channel is ready for writing only\");\n<line10>    }\n<line11>    return ops;\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Channel is ready for reading and writing\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Channel is ready for reading only\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Channel is ready for writing only\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    x509Util = new ClientX509Util();\n<line3>    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);\n<line4>    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), \"100\");\n<line5>    workerPool = Executors.newCachedThreadPool();\n<line6>    port = PortAssignment.unique();\n<line7>    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n<line8>    listeningSocket = new UnifiedServerSocket(x509Util, true);\n<line9>    listeningSocket.bind(localServerAddress);\n<line10>    Future<UnifiedServerSocket.UnifiedSocket> acceptFuture;\n<line11>    acceptFuture = workerPool.submit(new Callable<UnifiedServerSocket.UnifiedSocket>() {\n<line12>\n<line13>        @Override\n<line14>        public UnifiedServerSocket.UnifiedSocket call() throws Exception {\n<line15>            try {\n<line16>                return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();\n<line17>            } catch (IOException e) {\n<line18>                throw e;\n<line19>            }\n<line20>        }\n<line21>    });\n<line22>    if (useSecureClient) {\n<line23>        clientSocket = x509Util.createSSLSocket();\n<line24>        clientSocket.connect(localServerAddress);\n<line25>    } else {\n<line26>        clientSocket = new Socket();\n<line27>        clientSocket.connect(localServerAddress);\n<line28>        clientSocket.getOutputStream().write(new byte[] { 1, 2, 3, 4, 5 });\n<line29>    }\n<line30>    serverSideSocket = acceptFuture.get();\n<line31>}","output":"<line1>{\n<line2>    x509Util = new ClientX509Util();\n<line3>    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);\n<line4>    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), \"100\");\n<line5>    workerPool = Executors.newCachedThreadPool();\n<line6>    port = PortAssignment.unique();\n<line7>    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n<line8>    listeningSocket = new UnifiedServerSocket(x509Util, true);\n<line9>    listeningSocket.bind(localServerAddress);\n<line10>    Future<UnifiedServerSocket.UnifiedSocket> acceptFuture;\n<line11>    acceptFuture = workerPool.submit(new Callable<UnifiedServerSocket.UnifiedSocket>() {\n<line12>\n<line13>        @Override\n<line14>        public UnifiedServerSocket.UnifiedSocket call() throws Exception {\n<line15>            try {\n<line16>                return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();\n<line17>            } catch (IOException e) {\n<line18>                LOG.error(\"Error in accept()\", e);\n<line19>                throw e;\n<line20>            }\n<line21>        }\n<line22>    });\n<line23>    if (useSecureClient) {\n<line24>        clientSocket = x509Util.createSSLSocket();\n<line25>        clientSocket.connect(localServerAddress);\n<line26>    } else {\n<line27>        clientSocket = new Socket();\n<line28>        clientSocket.connect(localServerAddress);\n<line29>        clientSocket.getOutputStream().write(new byte[] { 1, 2, 3, 4, 5 });\n<line30>    }\n<line31>    serverSideSocket = acceptFuture.get();\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();\n<line4>    } catch (IOException e) {\n<line5>        throw e;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();\n<line4>    } catch (IOException e) {\n<line5>        LOG.error(\"Error in accept()\", e);\n<line6>        throw e;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error in accept()\", e);\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final int LEADER_TIMEOUT_MS = 10_000;\n<line3>    final int[] clientPorts = new int[SERVER_COUNT];\n<line4>    StringBuilder sb = new StringBuilder();\n<line5>    String server;\n<line6>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line7>        clientPorts[i] = PortAssignment.unique();\n<line8>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line9>        sb.append(server + \"\\n\");\n<line10>    }\n<line11>    String currentQuorumCfgSection = sb.toString();\n<line12>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line13>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line14>\n<line15>            @Override\n<line16>            public TestQPMain getTestQPMain() {\n<line17>                return new MockTestQPMain();\n<line18>            }\n<line19>        };\n<line20>        mt[i].start();\n<line21>    }\n<line22>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line23>        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n<line24>    }\n<line25>    int leader = findLeader(mt);\n<line26>    CountdownWatcher watch = new CountdownWatcher();\n<line27>    ZooKeeper zk = new ZooKeeper(\"127.0.0.1:\" + clientPorts[leader], ClientBase.CONNECTION_TIMEOUT, watch);\n<line28>    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line29>    Map<Long, Proposal> outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;\n<line30>    // Increase the tick time to delay the leader going to looking to allow us proposal a transaction while other\n<line31>    // followers are offline.\n<line32>    int previousTick = mt[leader].main.quorumPeer.tickTime;\n<line33>    mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;\n<line34>    // Let the previous tick on the leader exhaust itself so the new tick time takes effect\n<line35>    Thread.sleep(previousTick);\n<line36>    // Shutdown followers to make sure we don't accidentally send the proposal we are going to make to follower.\n<line37>    // In other words, we want to make sure the followers get the proposal later through DIFF sync.\n<line38>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line39>        if (i != leader) {\n<line40>            mt[i].shutdown();\n<line41>        }\n<line42>    }\n<line43>    // Send a create request to old leader and make sure it's synced to disk.\n<line44>    try {\n<line45>        zk.create(\"/zk\" + leader, \"zk\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line46>        fail(\"create /zk\" + leader + \" should have failed\");\n<line47>    } catch (KeeperException e) {\n<line48>    }\n<line49>    // Make sure that we actually did get it in process at the leader; there can be extra sessionClose proposals.\n<line50>    assertTrue(outstanding.size() > 0);\n<line51>    Proposal p = findProposalOfType(outstanding, OpCode.create);\n<line52>    assertNotNull(p, \"Old leader doesn't have 'create' proposal\");\n<line53>    // Make sure leader sync the proposal to disk.\n<line54>    int sleepTime = 0;\n<line55>    Long longLeader = (long) leader;\n<line56>    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {\n<line57>        if (sleepTime > 2000) {\n<line58>            fail(\"Transaction not synced to disk within 1 second \" + p.qvAcksetPairs.get(0).getAckset() + \" expected \" + leader);\n<line59>        }\n<line60>        Thread.sleep(100);\n<line61>        sleepTime += 100;\n<line62>    }\n<line63>    // Start controlled followers where we deliberately make the follower fail once follower receive the UPTODATE\n<line64>    // message from leader. Because followers only persist proposals from DIFF sync after UPTODATE, this can\n<line65>    // deterministically simulate the situation where followers ACK NEWLEADER (which makes leader think she has the\n<line66>    // quorum support, but actually not afterwards) but immediately fail afterwards without persisting the proposals\n<line67>    // from DIFF sync.\n<line68>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line69>        if (i == leader) {\n<line70>            continue;\n<line71>        }\n<line72>        mt[i].start();\n<line73>        int sleepCount = 0;\n<line74>        while (mt[i].getQuorumPeer() == null) {\n<line75>            ++sleepCount;\n<line76>            if (sleepCount > 100) {\n<line77>                fail(\"Can't start follower \" + i + \" !\");\n<line78>            }\n<line79>            Thread.sleep(100);\n<line80>        }\n<line81>        ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(true);\n<line82>    }\n<line83>    // Verify leader can see it. The fact that leader can see it implies that\n<line84>    // leader should, at this point in time, get a quorum of ACK of NEWLEADER\n<line85>    // from two followers so leader can start serving requests; this also implies\n<line86>    // that DIFF sync from leader to followers are finished at this point in time.\n<line87>    // We then verify later that followers should have the same view after we shutdown\n<line88>    // this leader, otherwise it's a violation of ZAB / sequential consistency.\n<line89>    int c = 0;\n<line90>    while (c < 100) {\n<line91>        ++c;\n<line92>        try {\n<line93>            Stat stat = zk.exists(\"/zk\" + leader, false);\n<line94>            assertNotNull(stat, \"server \" + leader + \" should have /zk\");\n<line95>            break;\n<line96>        } catch (KeeperException.ConnectionLossException e) {\n<line97>        }\n<line98>        Thread.sleep(100);\n<line99>    }\n<line100>    // Shutdown all servers\n<line101>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line102>        mt[i].shutdown();\n<line103>    }\n<line104>    waitForOne(zk, States.CONNECTING);\n<line105>    // Now restart all servers except the old leader. Only old leader has the transaction sync to disk.\n<line106>    // The old followers only had in memory view of the transaction, and they didn't have a chance\n<line107>    // to sync to disk because we made them fail at UPTODATE.\n<line108>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line109>        if (i == leader) {\n<line110>            continue;\n<line111>        }\n<line112>        mt[i].start();\n<line113>        int sleepCount = 0;\n<line114>        while (mt[i].getQuorumPeer() == null) {\n<line115>            ++sleepCount;\n<line116>            if (sleepCount > 100) {\n<line117>                fail(\"Can't start follower \" + i + \" !\");\n<line118>            }\n<line119>            Thread.sleep(100);\n<line120>        }\n<line121>        ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(false);\n<line122>    }\n<line123>    int newLeader = findLeader(mt);\n<line124>    assertNotEquals(newLeader, leader, \"new leader is still the old leader \" + leader + \" !!\");\n<line125>    // This simulates the case where clients connected to the old leader had a view of the data\n<line126>    // \"/zkX\", but clients connect to the new leader does not have the same view of data (missing \"/zkX\").\n<line127>    // This inconsistent view of the quorum exposed from leaders is a violation of ZAB.\n<line128>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line129>        if (i != newLeader) {\n<line130>            continue;\n<line131>        }\n<line132>        zk.close();\n<line133>        zk = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, watch);\n<line134>        watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line135>        Stat val = zk.exists(\"/zk\" + leader, false);\n<line136>        assertNotNull(val, \"Data inconsistency detected! \" + \"Server \" + i + \" should have a view of /zk\" + leader + \"!\");\n<line137>    }\n<line138>    zk.close();\n<line139>}","output":"<line1>{\n<line2>    final int LEADER_TIMEOUT_MS = 10_000;\n<line3>    final int[] clientPorts = new int[SERVER_COUNT];\n<line4>    StringBuilder sb = new StringBuilder();\n<line5>    String server;\n<line6>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line7>        clientPorts[i] = PortAssignment.unique();\n<line8>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line9>        sb.append(server + \"\\n\");\n<line10>    }\n<line11>    String currentQuorumCfgSection = sb.toString();\n<line12>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line13>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line14>\n<line15>            @Override\n<line16>            public TestQPMain getTestQPMain() {\n<line17>                return new MockTestQPMain();\n<line18>            }\n<line19>        };\n<line20>        mt[i].start();\n<line21>    }\n<line22>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line23>        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n<line24>    }\n<line25>    int leader = findLeader(mt);\n<line26>    CountdownWatcher watch = new CountdownWatcher();\n<line27>    ZooKeeper zk = new ZooKeeper(\"127.0.0.1:\" + clientPorts[leader], ClientBase.CONNECTION_TIMEOUT, watch);\n<line28>    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line29>    Map<Long, Proposal> outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;\n<line30>    // Increase the tick time to delay the leader going to looking to allow us proposal a transaction while other\n<line31>    // followers are offline.\n<line32>    int previousTick = mt[leader].main.quorumPeer.tickTime;\n<line33>    mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;\n<line34>    // Let the previous tick on the leader exhaust itself so the new tick time takes effect\n<line35>    Thread.sleep(previousTick);\n<line36>    LOG.info(\"LEADER ELECTED {}\", leader);\n<line37>    // Shutdown followers to make sure we don't accidentally send the proposal we are going to make to follower.\n<line38>    // In other words, we want to make sure the followers get the proposal later through DIFF sync.\n<line39>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line40>        if (i != leader) {\n<line41>            mt[i].shutdown();\n<line42>        }\n<line43>    }\n<line44>    // Send a create request to old leader and make sure it's synced to disk.\n<line45>    try {\n<line46>        zk.create(\"/zk\" + leader, \"zk\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line47>        fail(\"create /zk\" + leader + \" should have failed\");\n<line48>    } catch (KeeperException e) {\n<line49>    }\n<line50>    // Make sure that we actually did get it in process at the leader; there can be extra sessionClose proposals.\n<line51>    assertTrue(outstanding.size() > 0);\n<line52>    Proposal p = findProposalOfType(outstanding, OpCode.create);\n<line53>    LOG.info(\"Old leader id: {}. All proposals: {}\", leader, outstanding);\n<line54>    assertNotNull(p, \"Old leader doesn't have 'create' proposal\");\n<line55>    // Make sure leader sync the proposal to disk.\n<line56>    int sleepTime = 0;\n<line57>    Long longLeader = (long) leader;\n<line58>    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {\n<line59>        if (sleepTime > 2000) {\n<line60>            fail(\"Transaction not synced to disk within 1 second \" + p.qvAcksetPairs.get(0).getAckset() + \" expected \" + leader);\n<line61>        }\n<line62>        Thread.sleep(100);\n<line63>        sleepTime += 100;\n<line64>    }\n<line65>    // Start controlled followers where we deliberately make the follower fail once follower receive the UPTODATE\n<line66>    // message from leader. Because followers only persist proposals from DIFF sync after UPTODATE, this can\n<line67>    // deterministically simulate the situation where followers ACK NEWLEADER (which makes leader think she has the\n<line68>    // quorum support, but actually not afterwards) but immediately fail afterwards without persisting the proposals\n<line69>    // from DIFF sync.\n<line70>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line71>        if (i == leader) {\n<line72>            continue;\n<line73>        }\n<line74>        mt[i].start();\n<line75>        int sleepCount = 0;\n<line76>        while (mt[i].getQuorumPeer() == null) {\n<line77>            ++sleepCount;\n<line78>            if (sleepCount > 100) {\n<line79>                fail(\"Can't start follower \" + i + \" !\");\n<line80>            }\n<line81>            Thread.sleep(100);\n<line82>        }\n<line83>        ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(true);\n<line84>        LOG.info(\"Follower {} started.\", i);\n<line85>    }\n<line86>    // Verify leader can see it. The fact that leader can see it implies that\n<line87>    // leader should, at this point in time, get a quorum of ACK of NEWLEADER\n<line88>    // from two followers so leader can start serving requests; this also implies\n<line89>    // that DIFF sync from leader to followers are finished at this point in time.\n<line90>    // We then verify later that followers should have the same view after we shutdown\n<line91>    // this leader, otherwise it's a violation of ZAB / sequential consistency.\n<line92>    int c = 0;\n<line93>    while (c < 100) {\n<line94>        ++c;\n<line95>        try {\n<line96>            Stat stat = zk.exists(\"/zk\" + leader, false);\n<line97>            assertNotNull(stat, \"server \" + leader + \" should have /zk\");\n<line98>            break;\n<line99>        } catch (KeeperException.ConnectionLossException e) {\n<line100>        }\n<line101>        Thread.sleep(100);\n<line102>    }\n<line103>    // Shutdown all servers\n<line104>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line105>        mt[i].shutdown();\n<line106>    }\n<line107>    waitForOne(zk, States.CONNECTING);\n<line108>    // Now restart all servers except the old leader. Only old leader has the transaction sync to disk.\n<line109>    // The old followers only had in memory view of the transaction, and they didn't have a chance\n<line110>    // to sync to disk because we made them fail at UPTODATE.\n<line111>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line112>        if (i == leader) {\n<line113>            continue;\n<line114>        }\n<line115>        mt[i].start();\n<line116>        int sleepCount = 0;\n<line117>        while (mt[i].getQuorumPeer() == null) {\n<line118>            ++sleepCount;\n<line119>            if (sleepCount > 100) {\n<line120>                fail(\"Can't start follower \" + i + \" !\");\n<line121>            }\n<line122>            Thread.sleep(100);\n<line123>        }\n<line124>        ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(false);\n<line125>        LOG.info(\"Follower {} started again.\", i);\n<line126>    }\n<line127>    int newLeader = findLeader(mt);\n<line128>    assertNotEquals(newLeader, leader, \"new leader is still the old leader \" + leader + \" !!\");\n<line129>    // This simulates the case where clients connected to the old leader had a view of the data\n<line130>    // \"/zkX\", but clients connect to the new leader does not have the same view of data (missing \"/zkX\").\n<line131>    // This inconsistent view of the quorum exposed from leaders is a violation of ZAB.\n<line132>    for (int i = 0; i < SERVER_COUNT; i++) {\n<line133>        if (i != newLeader) {\n<line134>            continue;\n<line135>        }\n<line136>        zk.close();\n<line137>        zk = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, watch);\n<line138>        watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n<line139>        Stat val = zk.exists(\"/zk\" + leader, false);\n<line140>        assertNotNull(val, \"Data inconsistency detected! \" + \"Server \" + i + \" should have a view of /zk\" + leader + \"!\");\n<line141>    }\n<line142>    zk.close();\n<line143>}"},{"input":"","instruction":"<line1>{\n<line2>    if (i == leader) {\n<line3>        continue;\n<line4>    }\n<line5>    mt[i].start();\n<line6>    int sleepCount = 0;\n<line7>    while (mt[i].getQuorumPeer() == null) {\n<line8>        ++sleepCount;\n<line9>        if (sleepCount > 100) {\n<line10>            fail(\"Can't start follower \" + i + \" !\");\n<line11>        }\n<line12>        Thread.sleep(100);\n<line13>    }\n<line14>    ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(true);\n<line15>}","output":"<line1>{\n<line2>    if (i == leader) {\n<line3>        continue;\n<line4>    }\n<line5>    mt[i].start();\n<line6>    int sleepCount = 0;\n<line7>    while (mt[i].getQuorumPeer() == null) {\n<line8>        ++sleepCount;\n<line9>        if (sleepCount > 100) {\n<line10>            fail(\"Can't start follower \" + i + \" !\");\n<line11>        }\n<line12>        Thread.sleep(100);\n<line13>    }\n<line14>    ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(true);\n<line15>    LOG.info(\"Follower {} started.\", i);\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (i == leader) {\n<line3>        continue;\n<line4>    }\n<line5>    mt[i].start();\n<line6>    int sleepCount = 0;\n<line7>    while (mt[i].getQuorumPeer() == null) {\n<line8>        ++sleepCount;\n<line9>        if (sleepCount > 100) {\n<line10>            fail(\"Can't start follower \" + i + \" !\");\n<line11>        }\n<line12>        Thread.sleep(100);\n<line13>    }\n<line14>    ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(false);\n<line15>}","output":"<line1>{\n<line2>    if (i == leader) {\n<line3>        continue;\n<line4>    }\n<line5>    mt[i].start();\n<line6>    int sleepCount = 0;\n<line7>    while (mt[i].getQuorumPeer() == null) {\n<line8>        ++sleepCount;\n<line9>        if (sleepCount > 100) {\n<line10>            fail(\"Can't start follower \" + i + \" !\");\n<line11>        }\n<line12>        Thread.sleep(100);\n<line13>    }\n<line14>    ((CustomQuorumPeer) mt[i].getQuorumPeer()).setInjectError(false);\n<line15>    LOG.info(\"Follower {} started again.\", i);\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    numServers = builders.size();\n<line3>    servers = new Servers();\n<line4>    servers.clientPorts = new int[numServers];\n<line5>    servers.mt = new MainThread[numServers];\n<line6>    servers.zk = new ZooKeeper[numServers];\n<line7>    for (int i = 0; i < numServers; i++) {\n<line8>        QuorumServerConfigBuilder quorumServerConfigBuilder = builders.get(i);\n<line9>        String quorumCfgSection = quorumServerConfigBuilder.build();\n<line10>        servers.clientPorts[i] = quorumServerConfigBuilder.getClientPort(i);\n<line11>        servers.mt[i] = new MainThread(i, servers.clientPorts[i], quorumCfgSection);\n<line12>        servers.mt[i].start();\n<line13>        servers.restartClient(i, this);\n<line14>    }\n<line15>    waitForAll(servers, ZooKeeper.States.CONNECTED);\n<line16>    for (int i = 0; i < numServers; i++) {\n<line17>        servers.zk[i].close(5000);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    numServers = builders.size();\n<line3>    servers = new Servers();\n<line4>    servers.clientPorts = new int[numServers];\n<line5>    servers.mt = new MainThread[numServers];\n<line6>    servers.zk = new ZooKeeper[numServers];\n<line7>    for (int i = 0; i < numServers; i++) {\n<line8>        QuorumServerConfigBuilder quorumServerConfigBuilder = builders.get(i);\n<line9>        String quorumCfgSection = quorumServerConfigBuilder.build();\n<line10>        LOG.info(String.format(\"starting server %d with quorum config:\\n%s\", i, quorumCfgSection));\n<line11>        servers.clientPorts[i] = quorumServerConfigBuilder.getClientPort(i);\n<line12>        servers.mt[i] = new MainThread(i, servers.clientPorts[i], quorumCfgSection);\n<line13>        servers.mt[i].start();\n<line14>        servers.restartClient(i, this);\n<line15>    }\n<line16>    waitForAll(servers, ZooKeeper.States.CONNECTED);\n<line17>    for (int i = 0; i < numServers; i++) {\n<line18>        servers.zk[i].close(5000);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumServerConfigBuilder quorumServerConfigBuilder = builders.get(i);\n<line3>    String quorumCfgSection = quorumServerConfigBuilder.build();\n<line4>    servers.clientPorts[i] = quorumServerConfigBuilder.getClientPort(i);\n<line5>    servers.mt[i] = new MainThread(i, servers.clientPorts[i], quorumCfgSection);\n<line6>    servers.mt[i].start();\n<line7>    servers.restartClient(i, this);\n<line8>}","output":"<line1>{\n<line2>    QuorumServerConfigBuilder quorumServerConfigBuilder = builders.get(i);\n<line3>    String quorumCfgSection = quorumServerConfigBuilder.build();\n<line4>    LOG.info(String.format(\"starting server %d with quorum config:\\n%s\", i, quorumCfgSection));\n<line5>    servers.clientPorts[i] = quorumServerConfigBuilder.getClientPort(i);\n<line6>    servers.mt[i] = new MainThread(i, servers.clientPorts[i], quorumCfgSection);\n<line7>    servers.mt[i].start();\n<line8>    servers.restartClient(i, this);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    zNodeId += 1;\n<line3>    String zNodePath = \"/foo_\" + zNodeId;\n<line4>    ZooKeeper zk = connectToZkServer(builder, FIRST_SERVER);\n<line5>    zk.create(zNodePath, \"foobar1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    assertEquals(new String(zk.getData(zNodePath, null, null)), \"foobar1\");\n<line7>    zk.close(1000);\n<line8>    zk = connectToZkServer(builder, SECOND_SERVER);\n<line9>    assertEquals(new String(zk.getData(zNodePath, null, null)), \"foobar1\");\n<line10>    zk.close(1000);\n<line11>    zk = connectToZkServer(builder, THIRD_SERVER);\n<line12>    assertEquals(new String(zk.getData(zNodePath, null, null)), \"foobar1\");\n<line13>    zk.close(1000);\n<line14>}","output":"<line1>{\n<line2>    LOG.info(\"starting to verify if Quorum works\");\n<line3>    zNodeId += 1;\n<line4>    String zNodePath = \"/foo_\" + zNodeId;\n<line5>    ZooKeeper zk = connectToZkServer(builder, FIRST_SERVER);\n<line6>    zk.create(zNodePath, \"foobar1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>    assertEquals(new String(zk.getData(zNodePath, null, null)), \"foobar1\");\n<line8>    zk.close(1000);\n<line9>    zk = connectToZkServer(builder, SECOND_SERVER);\n<line10>    assertEquals(new String(zk.getData(zNodePath, null, null)), \"foobar1\");\n<line11>    zk.close(1000);\n<line12>    zk = connectToZkServer(builder, THIRD_SERVER);\n<line13>    assertEquals(new String(zk.getData(zNodePath, null, null)), \"foobar1\");\n<line14>    zk.close(1000);\n<line15>    LOG.info(\"Quorum verification finished successfully\");\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] responseBytes;\n<line3>    try {\n<line4>        String uri = httpExchange.getRequestURI().toString();\n<line5>        httpExchange.getRequestHeaders().entrySet().forEach((e) -> {\n<line6>        });\n<line7>        InputStream request = httpExchange.getRequestBody();\n<line8>        byte[] requestBytes = new byte[10000];\n<line9>        int len = request.read(requestBytes);\n<line10>        if (len < 0) {\n<line11>            String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n<line12>            requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n<line13>        }\n<line14>        OCSPReq ocspRequest = new OCSPReq(requestBytes);\n<line15>        Req[] requestList = ocspRequest.getRequestList();\n<line16>        DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);\n<line17>        BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);\n<line18>        for (Req req : requestList) {\n<line19>            CertificateID certId = req.getCertID();\n<line20>            CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());\n<line21>            CertificateStatus certificateStatus;\n<line22>            if (revokedCertId.equals(certId)) {\n<line23>                certificateStatus = new UnknownStatus();\n<line24>            } else {\n<line25>                certificateStatus = CertificateStatus.GOOD;\n<line26>            }\n<line27>            responseBuilder.addResponse(certId, certificateStatus, null);\n<line28>        }\n<line29>        X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };\n<line30>        ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\").setProvider(\"BC\").build(rootKeyPair.getPrivate());\n<line31>        BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());\n<line32>        responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();\n<line33>    } catch (OperatorException | CertificateEncodingException | OCSPException exception) {\n<line34>        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line35>    } catch (Throwable exception) {\n<line36>        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line37>    }\n<line38>    Headers rh = httpExchange.getResponseHeaders();\n<line39>    rh.set(\"Content-Type\", \"application/ocsp-response\");\n<line40>    httpExchange.sendResponseHeaders(200, responseBytes.length);\n<line41>    OutputStream os = httpExchange.getResponseBody();\n<line42>    os.write(responseBytes);\n<line43>    os.close();\n<line44>}","output":"<line1>{\n<line2>    byte[] responseBytes;\n<line3>    try {\n<line4>        String uri = httpExchange.getRequestURI().toString();\n<line5>        LOG.info(\"OCSP request: {} {}\", httpExchange.getRequestMethod(), uri);\n<line6>        httpExchange.getRequestHeaders().entrySet().forEach((e) -> {\n<line7>            LOG.info(\"OCSP request header: {} {}\", e.getKey(), e.getValue());\n<line8>        });\n<line9>        InputStream request = httpExchange.getRequestBody();\n<line10>        byte[] requestBytes = new byte[10000];\n<line11>        int len = request.read(requestBytes);\n<line12>        LOG.info(\"OCSP request size {}\", len);\n<line13>        if (len < 0) {\n<line14>            String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n<line15>            LOG.info(\"OCSP request from URI no encoding {}\", removedUriEncoding);\n<line16>            requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n<line17>        }\n<line18>        OCSPReq ocspRequest = new OCSPReq(requestBytes);\n<line19>        Req[] requestList = ocspRequest.getRequestList();\n<line20>        LOG.info(\"requestList {}\", Arrays.toString(requestList));\n<line21>        DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);\n<line22>        BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);\n<line23>        for (Req req : requestList) {\n<line24>            CertificateID certId = req.getCertID();\n<line25>            CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());\n<line26>            CertificateStatus certificateStatus;\n<line27>            if (revokedCertId.equals(certId)) {\n<line28>                certificateStatus = new UnknownStatus();\n<line29>            } else {\n<line30>                certificateStatus = CertificateStatus.GOOD;\n<line31>            }\n<line32>            LOG.info(\"addResponse {} {}\", certId, certificateStatus);\n<line33>            responseBuilder.addResponse(certId, certificateStatus, null);\n<line34>        }\n<line35>        X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };\n<line36>        ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\").setProvider(\"BC\").build(rootKeyPair.getPrivate());\n<line37>        BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());\n<line38>        LOG.info(\"response {}\", ocspResponse);\n<line39>        responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();\n<line40>        LOG.error(\"OCSP server response OK\");\n<line41>    } catch (OperatorException | CertificateEncodingException | OCSPException exception) {\n<line42>        LOG.error(\"Internal OCSP server error\", exception);\n<line43>        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line44>    } catch (Throwable exception) {\n<line45>        LOG.error(\"Internal OCSP server error\", exception);\n<line46>        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line47>    }\n<line48>    Headers rh = httpExchange.getResponseHeaders();\n<line49>    rh.set(\"Content-Type\", \"application/ocsp-response\");\n<line50>    httpExchange.sendResponseHeaders(200, responseBytes.length);\n<line51>    OutputStream os = httpExchange.getResponseBody();\n<line52>    os.write(responseBytes);\n<line53>    os.close();\n<line54>}"},{"input":"","instruction":"<line1>{\n<line2>    String uri = httpExchange.getRequestURI().toString();\n<line3>    httpExchange.getRequestHeaders().entrySet().forEach((e) -> {\n<line4>    });\n<line5>    InputStream request = httpExchange.getRequestBody();\n<line6>    byte[] requestBytes = new byte[10000];\n<line7>    int len = request.read(requestBytes);\n<line8>    if (len < 0) {\n<line9>        String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n<line10>        requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n<line11>    }\n<line12>    OCSPReq ocspRequest = new OCSPReq(requestBytes);\n<line13>    Req[] requestList = ocspRequest.getRequestList();\n<line14>    DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);\n<line15>    BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);\n<line16>    for (Req req : requestList) {\n<line17>        CertificateID certId = req.getCertID();\n<line18>        CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());\n<line19>        CertificateStatus certificateStatus;\n<line20>        if (revokedCertId.equals(certId)) {\n<line21>            certificateStatus = new UnknownStatus();\n<line22>        } else {\n<line23>            certificateStatus = CertificateStatus.GOOD;\n<line24>        }\n<line25>        responseBuilder.addResponse(certId, certificateStatus, null);\n<line26>    }\n<line27>    X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };\n<line28>    ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\").setProvider(\"BC\").build(rootKeyPair.getPrivate());\n<line29>    BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());\n<line30>    responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();\n<line31>}","output":"<line1>{\n<line2>    String uri = httpExchange.getRequestURI().toString();\n<line3>    LOG.info(\"OCSP request: {} {}\", httpExchange.getRequestMethod(), uri);\n<line4>    httpExchange.getRequestHeaders().entrySet().forEach((e) -> {\n<line5>        LOG.info(\"OCSP request header: {} {}\", e.getKey(), e.getValue());\n<line6>    });\n<line7>    InputStream request = httpExchange.getRequestBody();\n<line8>    byte[] requestBytes = new byte[10000];\n<line9>    int len = request.read(requestBytes);\n<line10>    LOG.info(\"OCSP request size {}\", len);\n<line11>    if (len < 0) {\n<line12>        String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n<line13>        LOG.info(\"OCSP request from URI no encoding {}\", removedUriEncoding);\n<line14>        requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n<line15>    }\n<line16>    OCSPReq ocspRequest = new OCSPReq(requestBytes);\n<line17>    Req[] requestList = ocspRequest.getRequestList();\n<line18>    LOG.info(\"requestList {}\", Arrays.toString(requestList));\n<line19>    DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);\n<line20>    BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);\n<line21>    for (Req req : requestList) {\n<line22>        CertificateID certId = req.getCertID();\n<line23>        CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());\n<line24>        CertificateStatus certificateStatus;\n<line25>        if (revokedCertId.equals(certId)) {\n<line26>            certificateStatus = new UnknownStatus();\n<line27>        } else {\n<line28>            certificateStatus = CertificateStatus.GOOD;\n<line29>        }\n<line30>        LOG.info(\"addResponse {} {}\", certId, certificateStatus);\n<line31>        responseBuilder.addResponse(certId, certificateStatus, null);\n<line32>    }\n<line33>    X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };\n<line34>    ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\").setProvider(\"BC\").build(rootKeyPair.getPrivate());\n<line35>    BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());\n<line36>    LOG.info(\"response {}\", ocspResponse);\n<line37>    responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();\n<line38>    LOG.error(\"OCSP server response OK\");\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"OCSP request header: {} {}\", e.getKey(), e.getValue());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n<line3>    requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n<line4>}","output":"<line1>{\n<line2>    String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n<line3>    LOG.info(\"OCSP request from URI no encoding {}\", removedUriEncoding);\n<line4>    requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    CertificateID certId = req.getCertID();\n<line3>    CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());\n<line4>    CertificateStatus certificateStatus;\n<line5>    if (revokedCertId.equals(certId)) {\n<line6>        certificateStatus = new UnknownStatus();\n<line7>    } else {\n<line8>        certificateStatus = CertificateStatus.GOOD;\n<line9>    }\n<line10>    responseBuilder.addResponse(certId, certificateStatus, null);\n<line11>}","output":"<line1>{\n<line2>    CertificateID certId = req.getCertID();\n<line3>    CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());\n<line4>    CertificateStatus certificateStatus;\n<line5>    if (revokedCertId.equals(certId)) {\n<line6>        certificateStatus = new UnknownStatus();\n<line7>    } else {\n<line8>        certificateStatus = CertificateStatus.GOOD;\n<line9>    }\n<line10>    LOG.info(\"addResponse {} {}\", certId, certificateStatus);\n<line11>    responseBuilder.addResponse(certId, certificateStatus, null);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Internal OCSP server error\", exception);\n<line3>    responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Internal OCSP server error\", exception);\n<line3>    responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperServer.setDigestEnabled(true);\n<line3>    final int ENSEMBLE_SERVERS = 3;\n<line4>    clientPorts = new int[ENSEMBLE_SERVERS];\n<line5>    StringBuilder sb = new StringBuilder();\n<line6>    String server;\n<line7>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line8>        clientPorts[i] = PortAssignment.unique();\n<line9>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line10>        sb.append(server + \"\\n\");\n<line11>    }\n<line12>    String currentQuorumCfgSection = sb.toString();\n<line13>    // start servers\n<line14>    mt = new MainThread[ENSEMBLE_SERVERS];\n<line15>    zk = new ZooKeeper[ENSEMBLE_SERVERS];\n<line16>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line17>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line18>\n<line19>            @Override\n<line20>            public TestQPMain getTestQPMain() {\n<line21>                return new CustomizedQPMain();\n<line22>            }\n<line23>        };\n<line24>        mt[i].start();\n<line25>        zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line26>    }\n<line27>    QuorumPeerMainTest.waitForAll(zk, States.CONNECTED);\n<line28>    leaderId = -1;\n<line29>    followerA = -1;\n<line30>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line31>        if (mt[i].main.quorumPeer.leader != null) {\n<line32>            leaderId = i;\n<line33>        } else if (followerA == -1) {\n<line34>            followerA = i;\n<line35>        }\n<line36>    }\n<line37>}","output":"<line1>{\n<line2>    ZooKeeperServer.setDigestEnabled(true);\n<line3>    LOG.info(\"Start up a 3 server quorum\");\n<line4>    final int ENSEMBLE_SERVERS = 3;\n<line5>    clientPorts = new int[ENSEMBLE_SERVERS];\n<line6>    StringBuilder sb = new StringBuilder();\n<line7>    String server;\n<line8>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line9>        clientPorts[i] = PortAssignment.unique();\n<line10>        server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique() + \":participant;127.0.0.1:\" + clientPorts[i];\n<line11>        sb.append(server + \"\\n\");\n<line12>    }\n<line13>    String currentQuorumCfgSection = sb.toString();\n<line14>    // start servers\n<line15>    mt = new MainThread[ENSEMBLE_SERVERS];\n<line16>    zk = new ZooKeeper[ENSEMBLE_SERVERS];\n<line17>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line18>        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {\n<line19>\n<line20>            @Override\n<line21>            public TestQPMain getTestQPMain() {\n<line22>                return new CustomizedQPMain();\n<line23>            }\n<line24>        };\n<line25>        mt[i].start();\n<line26>        zk[i] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n<line27>    }\n<line28>    QuorumPeerMainTest.waitForAll(zk, States.CONNECTED);\n<line29>    LOG.info(\"all servers started\");\n<line30>    leaderId = -1;\n<line31>    followerA = -1;\n<line32>    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {\n<line33>        if (mt[i].main.quorumPeer.leader != null) {\n<line34>            leaderId = i;\n<line35>        } else if (followerA == -1) {\n<line36>            followerA = i;\n<line37>        }\n<line38>    }\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    final String path = \"/testMultiOpConsistency\";\n<line3>    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);\n<line4>    CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();\n<line5>    final ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();\n<line6>    String node1 = path + \"/1\";\n<line7>    String node2 = path + \"/2\";\n<line8>    dt.addNodeCreateListener(node2, new NodeCreateListener() {\n<line9>\n<line10>        @Override\n<line11>        public void process(String path) {\n<line12>            try {\n<line13>                zkServer.takeSnapshot(true);\n<line14>            } catch (final IOException e) {\n<line15>                // ignored as it should never reach here because of System.exit() call\n<line16>            }\n<line17>        }\n<line18>    });\n<line19>    zk[followerA].multi(Arrays.asList(Op.create(node1, node1.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(node2, node2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));\n<line20>    mt[followerA].shutdown();\n<line21>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line22>    mt[followerA].start();\n<line23>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line24>    assertEquals(new String(zk[leaderId].getData(node2, null, null)), new String(zk[followerA].getData(node2, null, null)));\n<line25>}","output":"<line1>{\n<line2>    LOG.info(\"Create a parent node\");\n<line3>    final String path = \"/testMultiOpConsistency\";\n<line4>    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);\n<line5>    LOG.info(\"Hook to catch the 2nd sub create node txn in multi-op\");\n<line6>    CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();\n<line7>    final ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();\n<line8>    String node1 = path + \"/1\";\n<line9>    String node2 = path + \"/2\";\n<line10>    dt.addNodeCreateListener(node2, new NodeCreateListener() {\n<line11>\n<line12>        @Override\n<line13>        public void process(String path) {\n<line14>            LOG.info(\"Take a snapshot\");\n<line15>            try {\n<line16>                zkServer.takeSnapshot(true);\n<line17>            } catch (final IOException e) {\n<line18>                // ignored as it should never reach here because of System.exit() call\n<line19>            }\n<line20>        }\n<line21>    });\n<line22>    LOG.info(\"Issue a multi op to create 2 nodes\");\n<line23>    zk[followerA].multi(Arrays.asList(Op.create(node1, node1.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(node2, node2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));\n<line24>    LOG.info(\"Restart the server\");\n<line25>    mt[followerA].shutdown();\n<line26>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line27>    mt[followerA].start();\n<line28>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line29>    LOG.info(\"Make sure the node consistent with leader\");\n<line30>    assertEquals(new String(zk[leaderId].getData(node2, null, null)), new String(zk[followerA].getData(node2, null, null)));\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zkServer.takeSnapshot(true);\n<line4>    } catch (final IOException e) {\n<line5>        // ignored as it should never reach here because of System.exit() call\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"Take a snapshot\");\n<line3>    try {\n<line4>        zkServer.takeSnapshot(true);\n<line5>    } catch (final IOException e) {\n<line6>        // ignored as it should never reach here because of System.exit() call\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line3>    final String parent = \"/testPZxidUpdatedWhenDeletingNonExistNode\";\n<line4>    final String child = parent + \"/child\";\n<line5>    createEmptyNode(zk[leaderId], parent, CreateMode.PERSISTENT);\n<line6>    createEmptyNode(zk[leaderId], child, CreateMode.EPHEMERAL);\n<line7>    // create another child to test closeSession\n<line8>    createEmptyNode(zk[leaderId], child + \"1\", CreateMode.EPHEMERAL);\n<line9>    mt[followerA].shutdown();\n<line10>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line11>    addSerializeListener(leaderId, parent, child);\n<line12>    mt[followerA].start();\n<line13>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line14>    compareStat(parent, leaderId, followerA);\n<line15>}","output":"<line1>{\n<line2>    LOG.info(\"Enable force snapshot sync\");\n<line3>    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, \"true\");\n<line4>    final String parent = \"/testPZxidUpdatedWhenDeletingNonExistNode\";\n<line5>    final String child = parent + \"/child\";\n<line6>    createEmptyNode(zk[leaderId], parent, CreateMode.PERSISTENT);\n<line7>    createEmptyNode(zk[leaderId], child, CreateMode.EPHEMERAL);\n<line8>    // create another child to test closeSession\n<line9>    createEmptyNode(zk[leaderId], child + \"1\", CreateMode.EPHEMERAL);\n<line10>    LOG.info(\"shutdown follower {}\", followerA);\n<line11>    mt[followerA].shutdown();\n<line12>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line13>    LOG.info(\"Set up ZKDatabase to catch the node serializing in DataTree\");\n<line14>    addSerializeListener(leaderId, parent, child);\n<line15>    LOG.info(\"Restart follower A to trigger a SNAP sync with leader\");\n<line16>    mt[followerA].start();\n<line17>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line18>    LOG.info(\"Check and make sure the pzxid of the parent is the same on leader and follower A\");\n<line19>    compareStat(parent, leaderId, followerA);\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    final String parent = \"/testPZxidUpdatedDuringTakingSnapshot\";\n<line3>    final String child = parent + \"/child\";\n<line4>    createEmptyNode(zk[followerA], parent, CreateMode.PERSISTENT);\n<line5>    createEmptyNode(zk[followerA], child, CreateMode.EPHEMERAL);\n<line6>    // create another child to test closeSession\n<line7>    createEmptyNode(zk[leaderId], child + \"1\", CreateMode.EPHEMERAL);\n<line8>    addSerializeListener(followerA, parent, child);\n<line9>    ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();\n<line10>    zkServer.takeSnapshot(true);\n<line11>    mt[followerA].shutdown();\n<line12>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CLOSED);\n<line13>    mt[followerA].start();\n<line14>    // zk[followerA] will be closed in addSerializeListener, re-create it\n<line15>    zk[followerA] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line16>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line17>    compareStat(parent, leaderId, followerA);\n<line18>}","output":"<line1>{\n<line2>    final String parent = \"/testPZxidUpdatedDuringTakingSnapshot\";\n<line3>    final String child = parent + \"/child\";\n<line4>    createEmptyNode(zk[followerA], parent, CreateMode.PERSISTENT);\n<line5>    createEmptyNode(zk[followerA], child, CreateMode.EPHEMERAL);\n<line6>    // create another child to test closeSession\n<line7>    createEmptyNode(zk[leaderId], child + \"1\", CreateMode.EPHEMERAL);\n<line8>    LOG.info(\"Set up ZKDatabase to catch the node serializing in DataTree\");\n<line9>    addSerializeListener(followerA, parent, child);\n<line10>    LOG.info(\"Take snapshot on follower A\");\n<line11>    ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();\n<line12>    zkServer.takeSnapshot(true);\n<line13>    LOG.info(\"Restarting follower A to load snapshot\");\n<line14>    mt[followerA].shutdown();\n<line15>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CLOSED);\n<line16>    mt[followerA].start();\n<line17>    // zk[followerA] will be closed in addSerializeListener, re-create it\n<line18>    zk[followerA] = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line19>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line20>    LOG.info(\"Check and make sure the pzxid of the parent is the same on leader and follower A\");\n<line21>    compareStat(parent, leaderId, followerA);\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    final String path = \"/testMultiOpDigestConsistentDuringSnapshot\";\n<line4>    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);\n<line5>    CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();\n<line6>    final CountDownLatch setDataLatch = new CountDownLatch(1);\n<line7>    final CountDownLatch continueSetDataLatch = new CountDownLatch(1);\n<line8>    final ZooKeeper followerZk = zk[followerA];\n<line9>    dt.setDigestSerializeListener(new DigestSerializeListener() {\n<line10>\n<line11>        @Override\n<line12>        public void process() {\n<line13>            followerZk.multi(Arrays.asList(Op.create(\"/multi0\", \"/multi0\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(path, \"new data\".getBytes(), -1)), new MultiCallback() {\n<line14>\n<line15>                @Override\n<line16>                public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {\n<line17>                }\n<line18>            }, null);\n<line19>            try {\n<line20>                setDataLatch.await(3, TimeUnit.SECONDS);\n<line21>            } catch (Exception e) {\n<line22>            }\n<line23>        }\n<line24>\n<line25>        @Override\n<line26>        public void finished() {\n<line27>            continueSetDataLatch.countDown();\n<line28>        }\n<line29>    });\n<line30>    dt.setDataListener(new SetDataTxnListener() {\n<line31>\n<line32>        @Override\n<line33>        public void process() {\n<line34>            setDataLatch.countDown();\n<line35>            try {\n<line36>                continueSetDataLatch.await(3, TimeUnit.SECONDS);\n<line37>            } catch (Exception e) {\n<line38>            }\n<line39>        }\n<line40>    });\n<line41>    ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();\n<line42>    zkServer.takeSnapshot(true);\n<line43>    checkNoMismatchReported();\n<line44>    mt[followerA].shutdown();\n<line45>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line46>    mt[followerA].start();\n<line47>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line48>    checkNoMismatchReported();\n<line49>}","output":"<line1>{\n<line2>    ServerMetrics.getMetrics().resetAll();\n<line3>    LOG.info(\"Create some txns\");\n<line4>    final String path = \"/testMultiOpDigestConsistentDuringSnapshot\";\n<line5>    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);\n<line6>    CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();\n<line7>    final CountDownLatch setDataLatch = new CountDownLatch(1);\n<line8>    final CountDownLatch continueSetDataLatch = new CountDownLatch(1);\n<line9>    final ZooKeeper followerZk = zk[followerA];\n<line10>    dt.setDigestSerializeListener(new DigestSerializeListener() {\n<line11>\n<line12>        @Override\n<line13>        public void process() {\n<line14>            LOG.info(\"Trigger a multi op in async\");\n<line15>            followerZk.multi(Arrays.asList(Op.create(\"/multi0\", \"/multi0\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(path, \"new data\".getBytes(), -1)), new MultiCallback() {\n<line16>\n<line17>                @Override\n<line18>                public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {\n<line19>                }\n<line20>            }, null);\n<line21>            LOG.info(\"Wait for the signal to continue\");\n<line22>            try {\n<line23>                setDataLatch.await(3, TimeUnit.SECONDS);\n<line24>            } catch (Exception e) {\n<line25>                LOG.error(\"Error while waiting for set data txn, {}\", e);\n<line26>            }\n<line27>        }\n<line28>\n<line29>        @Override\n<line30>        public void finished() {\n<line31>            LOG.info(\"Finished writing digest out, continue\");\n<line32>            continueSetDataLatch.countDown();\n<line33>        }\n<line34>    });\n<line35>    dt.setDataListener(new SetDataTxnListener() {\n<line36>\n<line37>        @Override\n<line38>        public void process() {\n<line39>            setDataLatch.countDown();\n<line40>            try {\n<line41>                continueSetDataLatch.await(3, TimeUnit.SECONDS);\n<line42>            } catch (Exception e) {\n<line43>                LOG.error(\"Error while waiting for continue signal, {}\", e);\n<line44>            }\n<line45>        }\n<line46>    });\n<line47>    LOG.info(\"Trigger a snapshot\");\n<line48>    ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();\n<line49>    zkServer.takeSnapshot(true);\n<line50>    checkNoMismatchReported();\n<line51>    LOG.info(\"Restart the server to load the snapshot again\");\n<line52>    mt[followerA].shutdown();\n<line53>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line54>    mt[followerA].start();\n<line55>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line56>    LOG.info(\"Make sure there is nothing caught in the digest mismatch\");\n<line57>    checkNoMismatchReported();\n<line58>}"},{"input":"","instruction":"<line1>{\n<line2>    followerZk.multi(Arrays.asList(Op.create(\"/multi0\", \"/multi0\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(path, \"new data\".getBytes(), -1)), new MultiCallback() {\n<line3>\n<line4>        @Override\n<line5>        public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {\n<line6>        }\n<line7>    }, null);\n<line8>    try {\n<line9>        setDataLatch.await(3, TimeUnit.SECONDS);\n<line10>    } catch (Exception e) {\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Trigger a multi op in async\");\n<line3>    followerZk.multi(Arrays.asList(Op.create(\"/multi0\", \"/multi0\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData(path, \"new data\".getBytes(), -1)), new MultiCallback() {\n<line4>\n<line5>        @Override\n<line6>        public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {\n<line7>        }\n<line8>    }, null);\n<line9>    LOG.info(\"Wait for the signal to continue\");\n<line10>    try {\n<line11>        setDataLatch.await(3, TimeUnit.SECONDS);\n<line12>    } catch (Exception e) {\n<line13>        LOG.error(\"Error while waiting for set data txn, {}\", e);\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error while waiting for set data txn, {}\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    continueSetDataLatch.countDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Finished writing digest out, continue\");\n<line3>    continueSetDataLatch.countDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    setDataLatch.countDown();\n<line3>    try {\n<line4>        continueSetDataLatch.await(3, TimeUnit.SECONDS);\n<line5>    } catch (Exception e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    setDataLatch.countDown();\n<line3>    try {\n<line4>        continueSetDataLatch.await(3, TimeUnit.SECONDS);\n<line5>    } catch (Exception e) {\n<line6>        LOG.error(\"Error while waiting for continue signal, {}\", e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error while waiting for continue signal, {}\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final ZooKeeper zkClient = zk[sid];\n<line3>    CustomDataTree dt = (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();\n<line4>    dt.addListener(parent, new NodeSerializeListener() {\n<line5>\n<line6>        @Override\n<line7>        public void nodeSerialized(String path) {\n<line8>            try {\n<line9>                zkClient.delete(child, -1);\n<line10>                zkClient.close();\n<line11>            } catch (Exception e) {\n<line12>            }\n<line13>        }\n<line14>    });\n<line15>}","output":"<line1>{\n<line2>    final ZooKeeper zkClient = zk[sid];\n<line3>    CustomDataTree dt = (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();\n<line4>    dt.addListener(parent, new NodeSerializeListener() {\n<line5>\n<line6>        @Override\n<line7>        public void nodeSerialized(String path) {\n<line8>            try {\n<line9>                zkClient.delete(child, -1);\n<line10>                zkClient.close();\n<line11>                LOG.info(\"Deleted the child node after the parent is serialized\");\n<line12>            } catch (Exception e) {\n<line13>                LOG.error(\"Error when deleting node {}\", e);\n<line14>            }\n<line15>        }\n<line16>    });\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zkClient.delete(child, -1);\n<line4>        zkClient.close();\n<line5>    } catch (Exception e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        zkClient.delete(child, -1);\n<line4>        zkClient.close();\n<line5>        LOG.info(\"Deleted the child node after the parent is serialized\");\n<line6>    } catch (Exception e) {\n<line7>        LOG.error(\"Error when deleting node {}\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    zkClient.delete(child, -1);\n<line3>    zkClient.close();\n<line4>}","output":"<line1>{\n<line2>    zkClient.delete(child, -1);\n<line3>    zkClient.close();\n<line4>    LOG.info(\"Deleted the child node after the parent is serialized\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error when deleting node {}\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    CustomizedQPMain followerAMain = (CustomizedQPMain) mt[followerA].main;\n<line3>    final ZooKeeperServer zkServer = followerAMain.quorumPeer.getActiveServer();\n<line4>    // only take snapshot for the next global session we're going to create\n<line5>    final AtomicBoolean shouldTakeSnapshot = new AtomicBoolean(true);\n<line6>    followerAMain.setCommitSessionListener(new CommitSessionListener() {\n<line7>\n<line8>        @Override\n<line9>        public void process(long sessionId) {\n<line10>            if (shouldTakeSnapshot.getAndSet(false)) {\n<line11>                try {\n<line12>                    zkServer.takeSnapshot(true);\n<line13>                } catch (IOException e) {\n<line14>                    // ignored as it should never reach here because of System.exit() call\n<line15>                }\n<line16>            }\n<line17>        }\n<line18>    });\n<line19>    ZooKeeper globalClient = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line20>    QuorumPeerMainTest.waitForOne(globalClient, States.CONNECTED);\n<line21>    mt[followerA].shutdown();\n<line22>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line23>    mt[followerA].start();\n<line24>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line25>    Map<Long, Integer> globalSessionsOnLeader = mt[leaderId].main.quorumPeer.getZkDb().getSessionWithTimeOuts();\n<line26>    Map<Long, Integer> globalSessionsOnFollowerA = mt[followerA].main.quorumPeer.getZkDb().getSessionWithTimeOuts();\n<line27>    assertTrue(globalSessionsOnFollowerA.keySet().containsAll(globalSessionsOnLeader.keySet()));\n<line28>}","output":"<line1>{\n<line2>    LOG.info(\"Hook to catch the commitSession event on followerA\");\n<line3>    CustomizedQPMain followerAMain = (CustomizedQPMain) mt[followerA].main;\n<line4>    final ZooKeeperServer zkServer = followerAMain.quorumPeer.getActiveServer();\n<line5>    // only take snapshot for the next global session we're going to create\n<line6>    final AtomicBoolean shouldTakeSnapshot = new AtomicBoolean(true);\n<line7>    followerAMain.setCommitSessionListener(new CommitSessionListener() {\n<line8>\n<line9>        @Override\n<line10>        public void process(long sessionId) {\n<line11>            LOG.info(\"Take snapshot\");\n<line12>            if (shouldTakeSnapshot.getAndSet(false)) {\n<line13>                try {\n<line14>                    zkServer.takeSnapshot(true);\n<line15>                } catch (IOException e) {\n<line16>                    // ignored as it should never reach here because of System.exit() call\n<line17>                }\n<line18>            }\n<line19>        }\n<line20>    });\n<line21>    LOG.info(\"Create a global session\");\n<line22>    ZooKeeper globalClient = new ZooKeeper(\"127.0.0.1:\" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);\n<line23>    QuorumPeerMainTest.waitForOne(globalClient, States.CONNECTED);\n<line24>    LOG.info(\"Restart followerA to load the data from disk\");\n<line25>    mt[followerA].shutdown();\n<line26>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);\n<line27>    mt[followerA].start();\n<line28>    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);\n<line29>    LOG.info(\"Make sure the global sessions are consistent with leader\");\n<line30>    Map<Long, Integer> globalSessionsOnLeader = mt[leaderId].main.quorumPeer.getZkDb().getSessionWithTimeOuts();\n<line31>    Map<Long, Integer> globalSessionsOnFollowerA = mt[followerA].main.quorumPeer.getZkDb().getSessionWithTimeOuts();\n<line32>    LOG.info(\"sessions are {}, {}\", globalSessionsOnLeader.keySet(), globalSessionsOnFollowerA.keySet());\n<line33>    assertTrue(globalSessionsOnFollowerA.keySet().containsAll(globalSessionsOnLeader.keySet()));\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    if (shouldTakeSnapshot.getAndSet(false)) {\n<line3>        try {\n<line4>            zkServer.takeSnapshot(true);\n<line5>        } catch (IOException e) {\n<line6>            // ignored as it should never reach here because of System.exit() call\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Take snapshot\");\n<line3>    if (shouldTakeSnapshot.getAndSet(false)) {\n<line4>        try {\n<line5>            zkServer.takeSnapshot(true);\n<line6>        } catch (IOException e) {\n<line7>            // ignored as it should never reach here because of System.exit() call\n<line8>        }\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = 0; i < zkClients.length; i++) {\n<line3>        zkClients[i].close();\n<line4>    }\n<line5>    qu.shutdownAll();\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"tearDown starting\");\n<line3>    for (int i = 0; i < zkClients.length; i++) {\n<line4>        zkClients[i].close();\n<line5>    }\n<line6>    qu.shutdownAll();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    int j = 0;\n<line3>    try {\n<line4>        for (int i = start; i < start + count; i++) {\n<line5>            zk.create(\"/foo\" + i, new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line6>            j++;\n<line7>        }\n<line8>    } catch (ConnectionLossException e) {\n<line9>        // this is ok - the leader has dropped leadership\n<line10>        waitForClientsConnected();\n<line11>    }\n<line12>    return j;\n<line13>}","output":"<line1>{\n<line2>    LOG.info(\"Creating nodes {} thru {}\", start, (start + count));\n<line3>    int j = 0;\n<line4>    try {\n<line5>        for (int i = start; i < start + count; i++) {\n<line6>            zk.create(\"/foo\" + i, new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.EPHEMERAL);\n<line7>            j++;\n<line8>        }\n<line9>    } catch (ConnectionLossException e) {\n<line10>        // this is ok - the leader has dropped leadership\n<line11>        waitForClientsConnected();\n<line12>    }\n<line13>    return j;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    for (int i = start; i < start + count; i++) {\n<line3>        assertNotNull(zk.exists(\"/foo\" + i, false));\n<line4>    }\n<line5>    assertNull(zk.exists(\"/foo\" + (start + count), false));\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Validating nodes {} thru {}\", start, (start + count));\n<line3>    for (int i = start; i < start + count; i++) {\n<line4>        assertNotNull(zk.exists(\"/foo\" + i, false));\n<line5>        LOG.error(\"Exists zxid:{}\", Long.toHexString(zk.exists(\"/foo\" + i, false).getCzxid()));\n<line6>    }\n<line7>    assertNull(zk.exists(\"/foo\" + (start + count), false));\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    assertNotNull(zk.exists(\"/foo\" + i, false));\n<line3>}","output":"<line1>{\n<line2>    assertNotNull(zk.exists(\"/foo\" + i, false));\n<line3>    LOG.error(\"Exists zxid:{}\", Long.toHexString(zk.exists(\"/foo\" + i, false).getCzxid()));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.ChildWatchRemoved);\n<line4>    expectedEvents.add(EventType.DataWatchRemoved);\n<line5>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 2);\n<line6>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>    zk.create(\"/testnode2\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    zk.getChildren(\"/testnode1\", myWatcher);\n<line9>    zk.getChildren(\"/testnode2\", myWatcher);\n<line10>    zk.getData(\"/testnode1\", myWatcher, null);\n<line11>    zk.getData(\"/testnode2\", myWatcher, null);\n<line12>    String cmdstring = \"removewatches /testnode1\";\n<line13>    zkMain.cl.parseCommand(cmdstring);\n<line14>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child watches\");\n<line15>    myWatcher.matches();\n<line16>    // verifying that other path child watches are not affected\n<line17>    assertTrue(zk.getChildWatches().contains(\"/testnode2\"), \"Failed to find child watches for the path testnode2\");\n<line18>    assertTrue(zk.getDataWatches().contains(\"/testnode2\"), \"Failed to find data watches for the path testnode2\");\n<line19>}","output":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.ChildWatchRemoved);\n<line4>    expectedEvents.add(EventType.DataWatchRemoved);\n<line5>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 2);\n<line6>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>    zk.create(\"/testnode2\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    LOG.info(\"Adding childwatcher to /testnode1 and /testnode2\");\n<line9>    zk.getChildren(\"/testnode1\", myWatcher);\n<line10>    zk.getChildren(\"/testnode2\", myWatcher);\n<line11>    LOG.info(\"Adding datawatcher to /testnode1 and /testnode2\");\n<line12>    zk.getData(\"/testnode1\", myWatcher, null);\n<line13>    zk.getData(\"/testnode2\", myWatcher, null);\n<line14>    String cmdstring = \"removewatches /testnode1\";\n<line15>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring);\n<line16>    zkMain.cl.parseCommand(cmdstring);\n<line17>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child watches\");\n<line18>    LOG.info(\"Waiting for the DataWatchRemoved event\");\n<line19>    myWatcher.matches();\n<line20>    // verifying that other path child watches are not affected\n<line21>    assertTrue(zk.getChildWatches().contains(\"/testnode2\"), \"Failed to find child watches for the path testnode2\");\n<line22>    assertTrue(zk.getDataWatches().contains(\"/testnode2\"), \"Failed to find data watches for the path testnode2\");\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.DataWatchRemoved);\n<line4>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line5>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    zk.getData(\"/testnode1\", myWatcher, null);\n<line7>    String cmdstring = \"removewatches /testnode1 -d\";\n<line8>    zkMain.cl.parseCommand(cmdstring);\n<line9>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove data watches\");\n<line10>    myWatcher.matches();\n<line11>    // verifying that other path data watches are removed\n<line12>    assertEquals(0, zk.getDataWatches().size(), \"Data watches are not removed : \" + zk.getDataWatches());\n<line13>}","output":"<line1>{\n<line2>    LOG.info(\"Adding data watcher using getData()\");\n<line3>    List<EventType> expectedEvents = new ArrayList<>();\n<line4>    expectedEvents.add(EventType.DataWatchRemoved);\n<line5>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line6>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>    zk.getData(\"/testnode1\", myWatcher, null);\n<line8>    String cmdstring = \"removewatches /testnode1 -d\";\n<line9>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring);\n<line10>    zkMain.cl.parseCommand(cmdstring);\n<line11>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove data watches\");\n<line12>    LOG.info(\"Waiting for the DataWatchRemoved event\");\n<line13>    myWatcher.matches();\n<line14>    // verifying that other path data watches are removed\n<line15>    assertEquals(0, zk.getDataWatches().size(), \"Data watches are not removed : \" + zk.getDataWatches());\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.DataWatchRemoved);\n<line4>    MyWatcher myWatcher1 = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line5>    MyWatcher myWatcher2 = new MyWatcher(\"/testnode1/testnode2\", expectedEvents, 1);\n<line6>    // Adding pre-created watcher\n<line7>    zk.exists(\"/testnode1\", myWatcher1);\n<line8>    zk.exists(\"/testnode1/testnode2\", myWatcher2);\n<line9>    String cmdstring1 = \"removewatches /testnode1 -d\";\n<line10>    zkMain.cl.parseCommand(cmdstring1);\n<line11>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove pre-create watches\");\n<line12>    myWatcher1.matches();\n<line13>    assertEquals(1, zk.getExistWatches().size(), \"Failed to remove pre-create watches :\" + zk.getExistWatches());\n<line14>    assertTrue(zk.getExistWatches().contains(\"/testnode1/testnode2\"), \"Failed to remove pre-create watches :\" + zk.getExistWatches());\n<line15>    String cmdstring2 = \"removewatches /testnode1/testnode2 -d\";\n<line16>    zkMain.cl.parseCommand(cmdstring2);\n<line17>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove data watches\");\n<line18>    myWatcher2.matches();\n<line19>    assertEquals(0, zk.getExistWatches().size(), \"Failed to remove pre-create watches : \" + zk.getExistWatches());\n<line20>}","output":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.DataWatchRemoved);\n<line4>    MyWatcher myWatcher1 = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line5>    MyWatcher myWatcher2 = new MyWatcher(\"/testnode1/testnode2\", expectedEvents, 1);\n<line6>    // Adding pre-created watcher\n<line7>    LOG.info(\"Adding NodeCreated watcher\");\n<line8>    zk.exists(\"/testnode1\", myWatcher1);\n<line9>    zk.exists(\"/testnode1/testnode2\", myWatcher2);\n<line10>    String cmdstring1 = \"removewatches /testnode1 -d\";\n<line11>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring1);\n<line12>    zkMain.cl.parseCommand(cmdstring1);\n<line13>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove pre-create watches\");\n<line14>    myWatcher1.matches();\n<line15>    assertEquals(1, zk.getExistWatches().size(), \"Failed to remove pre-create watches :\" + zk.getExistWatches());\n<line16>    assertTrue(zk.getExistWatches().contains(\"/testnode1/testnode2\"), \"Failed to remove pre-create watches :\" + zk.getExistWatches());\n<line17>    String cmdstring2 = \"removewatches /testnode1/testnode2 -d\";\n<line18>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring2);\n<line19>    zkMain.cl.parseCommand(cmdstring2);\n<line20>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove data watches\");\n<line21>    myWatcher2.matches();\n<line22>    assertEquals(0, zk.getExistWatches().size(), \"Failed to remove pre-create watches : \" + zk.getExistWatches());\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.ChildWatchRemoved);\n<line4>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line5>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    zk.getChildren(\"/testnode1\", myWatcher);\n<line7>    String cmdstring = \"removewatches /testnode1 -c\";\n<line8>    zkMain.cl.parseCommand(cmdstring);\n<line9>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child watches\");\n<line10>    myWatcher.matches();\n<line11>    assertEquals(0, zk.getChildWatches().size(), \"Failed to remove child watches : \" + zk.getChildWatches());\n<line12>}","output":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.ChildWatchRemoved);\n<line4>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line5>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line6>    LOG.info(\"Adding child changed watcher\");\n<line7>    zk.getChildren(\"/testnode1\", myWatcher);\n<line8>    String cmdstring = \"removewatches /testnode1 -c\";\n<line9>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring);\n<line10>    zkMain.cl.parseCommand(cmdstring);\n<line11>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child watches\");\n<line12>    myWatcher.matches();\n<line13>    assertEquals(0, zk.getChildWatches().size(), \"Failed to remove child watches : \" + zk.getChildWatches());\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    List<EventType> expectedEvents = new ArrayList<>();\n<line3>    expectedEvents.add(EventType.ChildWatchRemoved);\n<line4>    expectedEvents.add(EventType.NodeDeleted);\n<line5>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line6>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line7>    zk.create(\"/testnode1/testnode2\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    zk.getChildren(\"/testnode1/testnode2\", myWatcher);\n<line9>    zk.getChildren(\"/testnode1\", myWatcher);\n<line10>    String cmdstring = \"removewatches /testnode1 -c\";\n<line11>    zkMain.cl.parseCommand(cmdstring);\n<line12>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child watches\");\n<line13>    myWatcher.matches();\n<line14>    assertEquals(1, zk.getChildWatches().size(), \"Failed to remove child watches : \" + zk.getChildWatches());\n<line15>    assertTrue(zk.getChildWatches().contains(\"/testnode1/testnode2\"), \"Failed to remove child watches :\" + zk.getChildWatches());\n<line16>    // verify node delete watcher\n<line17>    zk.delete(\"/testnode1/testnode2\", -1);\n<line18>    myWatcher.matches();\n<line19>}","output":"<line1>{\n<line2>    LOG.info(\"Adding NodeDeleted watcher\");\n<line3>    List<EventType> expectedEvents = new ArrayList<>();\n<line4>    expectedEvents.add(EventType.ChildWatchRemoved);\n<line5>    expectedEvents.add(EventType.NodeDeleted);\n<line6>    MyWatcher myWatcher = new MyWatcher(\"/testnode1\", expectedEvents, 1);\n<line7>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line8>    zk.create(\"/testnode1/testnode2\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>    zk.getChildren(\"/testnode1/testnode2\", myWatcher);\n<line10>    zk.getChildren(\"/testnode1\", myWatcher);\n<line11>    String cmdstring = \"removewatches /testnode1 -c\";\n<line12>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring);\n<line13>    zkMain.cl.parseCommand(cmdstring);\n<line14>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child watches\");\n<line15>    LOG.info(\"Waiting for the ChildWatchRemoved event\");\n<line16>    myWatcher.matches();\n<line17>    assertEquals(1, zk.getChildWatches().size(), \"Failed to remove child watches : \" + zk.getChildWatches());\n<line18>    assertTrue(zk.getChildWatches().contains(\"/testnode1/testnode2\"), \"Failed to remove child watches :\" + zk.getChildWatches());\n<line19>    // verify node delete watcher\n<line20>    zk.delete(\"/testnode1/testnode2\", -1);\n<line21>    myWatcher.matches();\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    final Map<String, List<EventType>> pathVsEvent = new HashMap<>();\n<line3>    final CountDownLatch watcherLatch = new CountDownLatch(2);\n<line4>    Watcher watcher = new Watcher() {\n<line5>\n<line6>        @Override\n<line7>        public void process(WatchedEvent event) {\n<line8>            switch(event.getType()) {\n<line9>                case ChildWatchRemoved:\n<line10>                case DataWatchRemoved:\n<line11>                    addWatchNotifications(pathVsEvent, event);\n<line12>                    watcherLatch.countDown();\n<line13>                    break;\n<line14>                case NodeChildrenChanged:\n<line15>                case NodeDataChanged:\n<line16>                    addWatchNotifications(pathVsEvent, event);\n<line17>                    break;\n<line18>            }\n<line19>        }\n<line20>\n<line21>        private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event) {\n<line22>            pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());\n<line23>        }\n<line24>    };\n<line25>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line26>    zk.getChildren(\"/testnode1\", watcher);\n<line27>    zk.getData(\"/testnode1\", watcher, null);\n<line28>    String cmdstring = \"removewatches /testnode1 -a\";\n<line29>    if (local) {\n<line30>        stopServer();\n<line31>        cmdstring = \"removewatches /testnode1 -a -l\";\n<line32>    }\n<line33>    zkMain.cl.parseCommand(cmdstring);\n<line34>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child/data watches\");\n<line35>    watcherLatch.await(10, TimeUnit.SECONDS);\n<line36>    assertEquals(1, pathVsEvent.size(), \"Didn't receives WatchRemoved events!\");\n<line37>    assertTrue(pathVsEvent.get(\"/testnode1\").contains(EventType.DataWatchRemoved), \"Didn't receives DataWatchRemoved!\");\n<line38>    assertTrue(pathVsEvent.get(\"/testnode1\").contains(EventType.ChildWatchRemoved), \"Didn't receives ChildWatchRemoved!\");\n<line39>}","output":"<line1>{\n<line2>    final Map<String, List<EventType>> pathVsEvent = new HashMap<>();\n<line3>    LOG.info(\"Adding NodeChildrenChanged, NodeDataChanged watchers\");\n<line4>    final CountDownLatch watcherLatch = new CountDownLatch(2);\n<line5>    Watcher watcher = new Watcher() {\n<line6>\n<line7>        @Override\n<line8>        public void process(WatchedEvent event) {\n<line9>            switch(event.getType()) {\n<line10>                case ChildWatchRemoved:\n<line11>                case DataWatchRemoved:\n<line12>                    addWatchNotifications(pathVsEvent, event);\n<line13>                    watcherLatch.countDown();\n<line14>                    break;\n<line15>                case NodeChildrenChanged:\n<line16>                case NodeDataChanged:\n<line17>                    addWatchNotifications(pathVsEvent, event);\n<line18>                    break;\n<line19>            }\n<line20>        }\n<line21>\n<line22>        private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event) {\n<line23>            pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());\n<line24>        }\n<line25>    };\n<line26>    zk.create(\"/testnode1\", \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line27>    zk.getChildren(\"/testnode1\", watcher);\n<line28>    zk.getData(\"/testnode1\", watcher, null);\n<line29>    String cmdstring = \"removewatches /testnode1 -a\";\n<line30>    if (local) {\n<line31>        LOG.info(\"Stopping ZK server to verify deletion of watches locally\");\n<line32>        stopServer();\n<line33>        cmdstring = \"removewatches /testnode1 -a -l\";\n<line34>    }\n<line35>    LOG.info(\"Remove watchers using shell command : {}\", cmdstring);\n<line36>    zkMain.cl.parseCommand(cmdstring);\n<line37>    assertTrue(zkMain.processZKCmd(zkMain.cl), \"Removewatches cmd fails to remove child/data watches\");\n<line38>    LOG.info(\"Waiting for the WatchRemoved events\");\n<line39>    watcherLatch.await(10, TimeUnit.SECONDS);\n<line40>    assertEquals(1, pathVsEvent.size(), \"Didn't receives WatchRemoved events!\");\n<line41>    assertTrue(pathVsEvent.get(\"/testnode1\").contains(EventType.DataWatchRemoved), \"Didn't receives DataWatchRemoved!\");\n<line42>    assertTrue(pathVsEvent.get(\"/testnode1\").contains(EventType.ChildWatchRemoved), \"Didn't receives ChildWatchRemoved!\");\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    stopServer();\n<line3>    cmdstring = \"removewatches /testnode1 -a -l\";\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Stopping ZK server to verify deletion of watches locally\");\n<line3>    stopServer();\n<line4>    cmdstring = \"removewatches /testnode1 -a -l\";\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    this.eventPath = event.getPath();\n<line3>    if (expectedEvents.contains(event.getType())) {\n<line4>        latch.countDown();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.debug(\"Event path : {}, eventPath : {}\", path, event.getPath());\n<line3>    this.eventPath = event.getPath();\n<line4>    if (expectedEvents.contains(event.getType())) {\n<line5>        latch.countDown();\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!latch.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS)) {\n<line3>        return false;\n<line4>    }\n<line5>    return path.equals(eventPath);\n<line6>}","output":"<line1>{\n<line2>    if (!latch.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS)) {\n<line3>        LOG.error(\"Failed to get watch notifications!\");\n<line4>        return false;\n<line5>    }\n<line6>    LOG.debug(\"Client path : {} eventPath : {}\", path, eventPath);\n<line7>    return path.equals(eventPath);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to get watch notifications!\");\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    hosts.add(host);\n<line3>    super.verify(host, cert);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"verifyWithX509Certificate {} {}\", host, cert);\n<line3>    hosts.add(host);\n<line4>    super.verify(host, cert);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            // Filter out the extra ENTRY_CREATE events that are\n<line7>            // sometimes seen at the start. Even though we create the watcher\n<line8>            // after the file exists, sometimes we still get a create event.\n<line9>            if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line10>                return;\n<line11>            }\n<line12>            synchronized (events) {\n<line13>                events.add(event);\n<line14>                events.notifyAll();\n<line15>            }\n<line16>        });\n<line17>        watcher.start();\n<line18>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line19>        // TODO hack\n<line20>        Thread.sleep(1000L);\n<line21>        for (int i = 0; i < 3; i++) {\n<line22>            FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n<line23>            synchronized (events) {\n<line24>                if (events.size() < i + 1) {\n<line25>                    events.wait(FS_TIMEOUT);\n<line26>                }\n<line27>                assertEquals(i + 1, events.size(), \"Wrong number of events\");\n<line28>                WatchEvent<?> event = events.get(i);\n<line29>                assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line30>                assertEquals(tempFile.getName(), event.context().toString());\n<line31>            }\n<line32>        }\n<line33>    } finally {\n<line34>        if (watcher != null) {\n<line35>            watcher.stop();\n<line36>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line37>        }\n<line38>    }\n<line39>}","output":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line7>            // Filter out the extra ENTRY_CREATE events that are\n<line8>            // sometimes seen at the start. Even though we create the watcher\n<line9>            // after the file exists, sometimes we still get a create event.\n<line10>            if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line11>                return;\n<line12>            }\n<line13>            synchronized (events) {\n<line14>                events.add(event);\n<line15>                events.notifyAll();\n<line16>            }\n<line17>        });\n<line18>        watcher.start();\n<line19>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line20>        // TODO hack\n<line21>        Thread.sleep(1000L);\n<line22>        for (int i = 0; i < 3; i++) {\n<line23>            LOG.info(\"Modifying file, attempt {}\", (i + 1));\n<line24>            FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n<line25>            synchronized (events) {\n<line26>                if (events.size() < i + 1) {\n<line27>                    events.wait(FS_TIMEOUT);\n<line28>                }\n<line29>                assertEquals(i + 1, events.size(), \"Wrong number of events\");\n<line30>                WatchEvent<?> event = events.get(i);\n<line31>                assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line32>                assertEquals(tempFile.getName(), event.context().toString());\n<line33>            }\n<line34>        }\n<line35>    } finally {\n<line36>        if (watcher != null) {\n<line37>            watcher.stop();\n<line38>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line39>        }\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        // Filter out the extra ENTRY_CREATE events that are\n<line5>        // sometimes seen at the start. Even though we create the watcher\n<line6>        // after the file exists, sometimes we still get a create event.\n<line7>        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line8>            return;\n<line9>        }\n<line10>        synchronized (events) {\n<line11>            events.add(event);\n<line12>            events.notifyAll();\n<line13>        }\n<line14>    });\n<line15>    watcher.start();\n<line16>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line17>    // TODO hack\n<line18>    Thread.sleep(1000L);\n<line19>    for (int i = 0; i < 3; i++) {\n<line20>        FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n<line21>        synchronized (events) {\n<line22>            if (events.size() < i + 1) {\n<line23>                events.wait(FS_TIMEOUT);\n<line24>            }\n<line25>            assertEquals(i + 1, events.size(), \"Wrong number of events\");\n<line26>            WatchEvent<?> event = events.get(i);\n<line27>            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line28>            assertEquals(tempFile.getName(), event.context().toString());\n<line29>        }\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line5>        // Filter out the extra ENTRY_CREATE events that are\n<line6>        // sometimes seen at the start. Even though we create the watcher\n<line7>        // after the file exists, sometimes we still get a create event.\n<line8>        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line9>            return;\n<line10>        }\n<line11>        synchronized (events) {\n<line12>            events.add(event);\n<line13>            events.notifyAll();\n<line14>        }\n<line15>    });\n<line16>    watcher.start();\n<line17>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line18>    // TODO hack\n<line19>    Thread.sleep(1000L);\n<line20>    for (int i = 0; i < 3; i++) {\n<line21>        LOG.info(\"Modifying file, attempt {}\", (i + 1));\n<line22>        FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n<line23>        synchronized (events) {\n<line24>            if (events.size() < i + 1) {\n<line25>                events.wait(FS_TIMEOUT);\n<line26>            }\n<line27>            assertEquals(i + 1, events.size(), \"Wrong number of events\");\n<line28>            WatchEvent<?> event = events.get(i);\n<line29>            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line30>            assertEquals(tempFile.getName(), event.context().toString());\n<line31>        }\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    // Filter out the extra ENTRY_CREATE events that are\n<line3>    // sometimes seen at the start. Even though we create the watcher\n<line4>    // after the file exists, sometimes we still get a create event.\n<line5>    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line6>        return;\n<line7>    }\n<line8>    synchronized (events) {\n<line9>        events.add(event);\n<line10>        events.notifyAll();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line3>    // Filter out the extra ENTRY_CREATE events that are\n<line4>    // sometimes seen at the start. Even though we create the watcher\n<line5>    // after the file exists, sometimes we still get a create event.\n<line6>    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line7>        return;\n<line8>    }\n<line9>    synchronized (events) {\n<line10>        events.add(event);\n<line11>        events.notifyAll();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n<line3>    synchronized (events) {\n<line4>        if (events.size() < i + 1) {\n<line5>            events.wait(FS_TIMEOUT);\n<line6>        }\n<line7>        assertEquals(i + 1, events.size(), \"Wrong number of events\");\n<line8>        WatchEvent<?> event = events.get(i);\n<line9>        assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line10>        assertEquals(tempFile.getName(), event.context().toString());\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Modifying file, attempt {}\", (i + 1));\n<line3>    FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n<line4>    synchronized (events) {\n<line5>        if (events.size() < i + 1) {\n<line6>            events.wait(FS_TIMEOUT);\n<line7>        }\n<line8>        assertEquals(i + 1, events.size(), \"Wrong number of events\");\n<line9>        WatchEvent<?> event = events.get(i);\n<line10>        assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line11>        assertEquals(tempFile.getName(), event.context().toString());\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            // Filter out the extra ENTRY_CREATE events that are\n<line7>            // sometimes seen at the start. Even though we create the watcher\n<line8>            // after the file exists, sometimes we still get a create event.\n<line9>            if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line10>                return;\n<line11>            }\n<line12>            synchronized (events) {\n<line13>                events.add(event);\n<line14>                events.notifyAll();\n<line15>            }\n<line16>        });\n<line17>        watcher.start();\n<line18>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line19>        // TODO hack\n<line20>        Thread.sleep(1000L);\n<line21>        FileUtils.touch(tempFile);\n<line22>        synchronized (events) {\n<line23>            if (events.isEmpty()) {\n<line24>                events.wait(FS_TIMEOUT);\n<line25>            }\n<line26>            assertFalse(events.isEmpty());\n<line27>            WatchEvent<?> event = events.get(0);\n<line28>            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line29>            assertEquals(tempFile.getName(), event.context().toString());\n<line30>        }\n<line31>    } finally {\n<line32>        if (watcher != null) {\n<line33>            watcher.stop();\n<line34>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line35>        }\n<line36>    }\n<line37>}","output":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line7>            // Filter out the extra ENTRY_CREATE events that are\n<line8>            // sometimes seen at the start. Even though we create the watcher\n<line9>            // after the file exists, sometimes we still get a create event.\n<line10>            if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line11>                return;\n<line12>            }\n<line13>            synchronized (events) {\n<line14>                events.add(event);\n<line15>                events.notifyAll();\n<line16>            }\n<line17>        });\n<line18>        watcher.start();\n<line19>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line20>        // TODO hack\n<line21>        Thread.sleep(1000L);\n<line22>        LOG.info(\"Touching file\");\n<line23>        FileUtils.touch(tempFile);\n<line24>        synchronized (events) {\n<line25>            if (events.isEmpty()) {\n<line26>                events.wait(FS_TIMEOUT);\n<line27>            }\n<line28>            assertFalse(events.isEmpty());\n<line29>            WatchEvent<?> event = events.get(0);\n<line30>            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line31>            assertEquals(tempFile.getName(), event.context().toString());\n<line32>        }\n<line33>    } finally {\n<line34>        if (watcher != null) {\n<line35>            watcher.stop();\n<line36>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line37>        }\n<line38>    }\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        // Filter out the extra ENTRY_CREATE events that are\n<line5>        // sometimes seen at the start. Even though we create the watcher\n<line6>        // after the file exists, sometimes we still get a create event.\n<line7>        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line8>            return;\n<line9>        }\n<line10>        synchronized (events) {\n<line11>            events.add(event);\n<line12>            events.notifyAll();\n<line13>        }\n<line14>    });\n<line15>    watcher.start();\n<line16>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line17>    // TODO hack\n<line18>    Thread.sleep(1000L);\n<line19>    FileUtils.touch(tempFile);\n<line20>    synchronized (events) {\n<line21>        if (events.isEmpty()) {\n<line22>            events.wait(FS_TIMEOUT);\n<line23>        }\n<line24>        assertFalse(events.isEmpty());\n<line25>        WatchEvent<?> event = events.get(0);\n<line26>        assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line27>        assertEquals(tempFile.getName(), event.context().toString());\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line5>        // Filter out the extra ENTRY_CREATE events that are\n<line6>        // sometimes seen at the start. Even though we create the watcher\n<line7>        // after the file exists, sometimes we still get a create event.\n<line8>        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line9>            return;\n<line10>        }\n<line11>        synchronized (events) {\n<line12>            events.add(event);\n<line13>            events.notifyAll();\n<line14>        }\n<line15>    });\n<line16>    watcher.start();\n<line17>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line18>    // TODO hack\n<line19>    Thread.sleep(1000L);\n<line20>    LOG.info(\"Touching file\");\n<line21>    FileUtils.touch(tempFile);\n<line22>    synchronized (events) {\n<line23>        if (events.isEmpty()) {\n<line24>            events.wait(FS_TIMEOUT);\n<line25>        }\n<line26>        assertFalse(events.isEmpty());\n<line27>        WatchEvent<?> event = events.get(0);\n<line28>        assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n<line29>        assertEquals(tempFile.getName(), event.context().toString());\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    // Filter out the extra ENTRY_CREATE events that are\n<line3>    // sometimes seen at the start. Even though we create the watcher\n<line4>    // after the file exists, sometimes we still get a create event.\n<line5>    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line6>        return;\n<line7>    }\n<line8>    synchronized (events) {\n<line9>        events.add(event);\n<line10>        events.notifyAll();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line3>    // Filter out the extra ENTRY_CREATE events that are\n<line4>    // sometimes seen at the start. Even though we create the watcher\n<line5>    // after the file exists, sometimes we still get a create event.\n<line6>    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line7>        return;\n<line8>    }\n<line9>    synchronized (events) {\n<line10>        events.add(event);\n<line11>        events.notifyAll();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            synchronized (events) {\n<line7>                events.add(event);\n<line8>                events.notifyAll();\n<line9>            }\n<line10>        });\n<line11>        watcher.start();\n<line12>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line13>        // TODO hack\n<line14>        Thread.sleep(1000L);\n<line15>        File tempFile2 = File.createTempFile(\"zk_test_\", \"\", tempDir);\n<line16>        tempFile2.deleteOnExit();\n<line17>        synchronized (events) {\n<line18>            if (events.isEmpty()) {\n<line19>                events.wait(FS_TIMEOUT);\n<line20>            }\n<line21>            assertFalse(events.isEmpty());\n<line22>            WatchEvent<?> event = events.get(0);\n<line23>            assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());\n<line24>            assertEquals(tempFile2.getName(), event.context().toString());\n<line25>        }\n<line26>    } finally {\n<line27>        if (watcher != null) {\n<line28>            watcher.stop();\n<line29>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line30>        }\n<line31>    }\n<line32>}","output":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line7>            synchronized (events) {\n<line8>                events.add(event);\n<line9>                events.notifyAll();\n<line10>            }\n<line11>        });\n<line12>        watcher.start();\n<line13>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line14>        // TODO hack\n<line15>        Thread.sleep(1000L);\n<line16>        File tempFile2 = File.createTempFile(\"zk_test_\", \"\", tempDir);\n<line17>        tempFile2.deleteOnExit();\n<line18>        synchronized (events) {\n<line19>            if (events.isEmpty()) {\n<line20>                events.wait(FS_TIMEOUT);\n<line21>            }\n<line22>            assertFalse(events.isEmpty());\n<line23>            WatchEvent<?> event = events.get(0);\n<line24>            assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());\n<line25>            assertEquals(tempFile2.getName(), event.context().toString());\n<line26>        }\n<line27>    } finally {\n<line28>        if (watcher != null) {\n<line29>            watcher.stop();\n<line30>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line31>        }\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        synchronized (events) {\n<line5>            events.add(event);\n<line6>            events.notifyAll();\n<line7>        }\n<line8>    });\n<line9>    watcher.start();\n<line10>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line11>    // TODO hack\n<line12>    Thread.sleep(1000L);\n<line13>    File tempFile2 = File.createTempFile(\"zk_test_\", \"\", tempDir);\n<line14>    tempFile2.deleteOnExit();\n<line15>    synchronized (events) {\n<line16>        if (events.isEmpty()) {\n<line17>            events.wait(FS_TIMEOUT);\n<line18>        }\n<line19>        assertFalse(events.isEmpty());\n<line20>        WatchEvent<?> event = events.get(0);\n<line21>        assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());\n<line22>        assertEquals(tempFile2.getName(), event.context().toString());\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line5>        synchronized (events) {\n<line6>            events.add(event);\n<line7>            events.notifyAll();\n<line8>        }\n<line9>    });\n<line10>    watcher.start();\n<line11>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line12>    // TODO hack\n<line13>    Thread.sleep(1000L);\n<line14>    File tempFile2 = File.createTempFile(\"zk_test_\", \"\", tempDir);\n<line15>    tempFile2.deleteOnExit();\n<line16>    synchronized (events) {\n<line17>        if (events.isEmpty()) {\n<line18>            events.wait(FS_TIMEOUT);\n<line19>        }\n<line20>        assertFalse(events.isEmpty());\n<line21>        WatchEvent<?> event = events.get(0);\n<line22>        assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());\n<line23>        assertEquals(tempFile2.getName(), event.context().toString());\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (events) {\n<line3>        events.add(event);\n<line4>        events.notifyAll();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line3>    synchronized (events) {\n<line4>        events.add(event);\n<line5>        events.notifyAll();\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            // Filter out the extra ENTRY_CREATE events that are\n<line7>            // sometimes seen at the start. Even though we create the watcher\n<line8>            // after the file exists, sometimes we still get a create event.\n<line9>            if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line10>                return;\n<line11>            }\n<line12>            synchronized (events) {\n<line13>                events.add(event);\n<line14>                events.notifyAll();\n<line15>            }\n<line16>        });\n<line17>        watcher.start();\n<line18>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line19>        // TODO hack\n<line20>        Thread.sleep(1000L);\n<line21>        tempFile.delete();\n<line22>        synchronized (events) {\n<line23>            if (events.isEmpty()) {\n<line24>                events.wait(FS_TIMEOUT);\n<line25>            }\n<line26>            assertFalse(events.isEmpty());\n<line27>            WatchEvent<?> event = events.get(0);\n<line28>            assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());\n<line29>            assertEquals(tempFile.getName(), event.context().toString());\n<line30>        }\n<line31>    } finally {\n<line32>        if (watcher != null) {\n<line33>            watcher.stop();\n<line34>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line35>        }\n<line36>    }\n<line37>}","output":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final List<WatchEvent<?>> events = new ArrayList<>();\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line7>            // Filter out the extra ENTRY_CREATE events that are\n<line8>            // sometimes seen at the start. Even though we create the watcher\n<line9>            // after the file exists, sometimes we still get a create event.\n<line10>            if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line11>                return;\n<line12>            }\n<line13>            synchronized (events) {\n<line14>                events.add(event);\n<line15>                events.notifyAll();\n<line16>            }\n<line17>        });\n<line18>        watcher.start();\n<line19>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line20>        // TODO hack\n<line21>        Thread.sleep(1000L);\n<line22>        tempFile.delete();\n<line23>        synchronized (events) {\n<line24>            if (events.isEmpty()) {\n<line25>                events.wait(FS_TIMEOUT);\n<line26>            }\n<line27>            assertFalse(events.isEmpty());\n<line28>            WatchEvent<?> event = events.get(0);\n<line29>            assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());\n<line30>            assertEquals(tempFile.getName(), event.context().toString());\n<line31>        }\n<line32>    } finally {\n<line33>        if (watcher != null) {\n<line34>            watcher.stop();\n<line35>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line36>        }\n<line37>    }\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        // Filter out the extra ENTRY_CREATE events that are\n<line5>        // sometimes seen at the start. Even though we create the watcher\n<line6>        // after the file exists, sometimes we still get a create event.\n<line7>        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line8>            return;\n<line9>        }\n<line10>        synchronized (events) {\n<line11>            events.add(event);\n<line12>            events.notifyAll();\n<line13>        }\n<line14>    });\n<line15>    watcher.start();\n<line16>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line17>    // TODO hack\n<line18>    Thread.sleep(1000L);\n<line19>    tempFile.delete();\n<line20>    synchronized (events) {\n<line21>        if (events.isEmpty()) {\n<line22>            events.wait(FS_TIMEOUT);\n<line23>        }\n<line24>        assertFalse(events.isEmpty());\n<line25>        WatchEvent<?> event = events.get(0);\n<line26>        assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());\n<line27>        assertEquals(tempFile.getName(), event.context().toString());\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    final List<WatchEvent<?>> events = new ArrayList<>();\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line5>        // Filter out the extra ENTRY_CREATE events that are\n<line6>        // sometimes seen at the start. Even though we create the watcher\n<line7>        // after the file exists, sometimes we still get a create event.\n<line8>        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line9>            return;\n<line10>        }\n<line11>        synchronized (events) {\n<line12>            events.add(event);\n<line13>            events.notifyAll();\n<line14>        }\n<line15>    });\n<line16>    watcher.start();\n<line17>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line18>    // TODO hack\n<line19>    Thread.sleep(1000L);\n<line20>    tempFile.delete();\n<line21>    synchronized (events) {\n<line22>        if (events.isEmpty()) {\n<line23>            events.wait(FS_TIMEOUT);\n<line24>        }\n<line25>        assertFalse(events.isEmpty());\n<line26>        WatchEvent<?> event = events.get(0);\n<line27>        assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());\n<line28>        assertEquals(tempFile.getName(), event.context().toString());\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    // Filter out the extra ENTRY_CREATE events that are\n<line3>    // sometimes seen at the start. Even though we create the watcher\n<line4>    // after the file exists, sometimes we still get a create event.\n<line5>    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line6>        return;\n<line7>    }\n<line8>    synchronized (events) {\n<line9>        events.add(event);\n<line10>        events.notifyAll();\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line3>    // Filter out the extra ENTRY_CREATE events that are\n<line4>    // sometimes seen at the start. Even though we create the watcher\n<line5>    // after the file exists, sometimes we still get a create event.\n<line6>    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n<line7>        return;\n<line8>    }\n<line9>    synchronized (events) {\n<line10>        events.add(event);\n<line11>        events.notifyAll();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final AtomicInteger callCount = new AtomicInteger(0);\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            int oldValue;\n<line7>            synchronized (callCount) {\n<line8>                oldValue = callCount.getAndIncrement();\n<line9>                callCount.notifyAll();\n<line10>            }\n<line11>            if (oldValue == 0) {\n<line12>                throw new RuntimeException(\"This error should not crash the watcher thread\");\n<line13>            }\n<line14>        });\n<line15>        watcher.start();\n<line16>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line17>        // TODO hack\n<line18>        Thread.sleep(1000L);\n<line19>        FileUtils.writeStringToFile(tempFile, \"Hello world\\n\", StandardCharsets.UTF_8, true);\n<line20>        synchronized (callCount) {\n<line21>            while (callCount.get() == 0) {\n<line22>                callCount.wait(FS_TIMEOUT);\n<line23>            }\n<line24>        }\n<line25>        FileUtils.writeStringToFile(tempFile, \"Hello world again\\n\", StandardCharsets.UTF_8, true);\n<line26>        synchronized (callCount) {\n<line27>            if (callCount.get() == 1) {\n<line28>                callCount.wait(FS_TIMEOUT);\n<line29>            }\n<line30>        }\n<line31>        // The value of callCount can exceed 1 only if the callback thread\n<line32>        // survives the exception thrown by the first callback.\n<line33>        assertTrue(callCount.get() > 1);\n<line34>    } finally {\n<line35>        if (watcher != null) {\n<line36>            watcher.stop();\n<line37>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line38>        }\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    FileChangeWatcher watcher = null;\n<line3>    try {\n<line4>        final AtomicInteger callCount = new AtomicInteger(0);\n<line5>        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line6>            LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line7>            int oldValue;\n<line8>            synchronized (callCount) {\n<line9>                oldValue = callCount.getAndIncrement();\n<line10>                callCount.notifyAll();\n<line11>            }\n<line12>            if (oldValue == 0) {\n<line13>                throw new RuntimeException(\"This error should not crash the watcher thread\");\n<line14>            }\n<line15>        });\n<line16>        watcher.start();\n<line17>        watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line18>        // TODO hack\n<line19>        Thread.sleep(1000L);\n<line20>        LOG.info(\"Modifying file\");\n<line21>        FileUtils.writeStringToFile(tempFile, \"Hello world\\n\", StandardCharsets.UTF_8, true);\n<line22>        synchronized (callCount) {\n<line23>            while (callCount.get() == 0) {\n<line24>                callCount.wait(FS_TIMEOUT);\n<line25>            }\n<line26>        }\n<line27>        LOG.info(\"Modifying file again\");\n<line28>        FileUtils.writeStringToFile(tempFile, \"Hello world again\\n\", StandardCharsets.UTF_8, true);\n<line29>        synchronized (callCount) {\n<line30>            if (callCount.get() == 1) {\n<line31>                callCount.wait(FS_TIMEOUT);\n<line32>            }\n<line33>        }\n<line34>        // The value of callCount can exceed 1 only if the callback thread\n<line35>        // survives the exception thrown by the first callback.\n<line36>        assertTrue(callCount.get() > 1);\n<line37>    } finally {\n<line38>        if (watcher != null) {\n<line39>            watcher.stop();\n<line40>            watcher.waitForState(FileChangeWatcher.State.STOPPED);\n<line41>        }\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    final AtomicInteger callCount = new AtomicInteger(0);\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        int oldValue;\n<line5>        synchronized (callCount) {\n<line6>            oldValue = callCount.getAndIncrement();\n<line7>            callCount.notifyAll();\n<line8>        }\n<line9>        if (oldValue == 0) {\n<line10>            throw new RuntimeException(\"This error should not crash the watcher thread\");\n<line11>        }\n<line12>    });\n<line13>    watcher.start();\n<line14>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line15>    // TODO hack\n<line16>    Thread.sleep(1000L);\n<line17>    FileUtils.writeStringToFile(tempFile, \"Hello world\\n\", StandardCharsets.UTF_8, true);\n<line18>    synchronized (callCount) {\n<line19>        while (callCount.get() == 0) {\n<line20>            callCount.wait(FS_TIMEOUT);\n<line21>        }\n<line22>    }\n<line23>    FileUtils.writeStringToFile(tempFile, \"Hello world again\\n\", StandardCharsets.UTF_8, true);\n<line24>    synchronized (callCount) {\n<line25>        if (callCount.get() == 1) {\n<line26>            callCount.wait(FS_TIMEOUT);\n<line27>        }\n<line28>    }\n<line29>    // The value of callCount can exceed 1 only if the callback thread\n<line30>    // survives the exception thrown by the first callback.\n<line31>    assertTrue(callCount.get() > 1);\n<line32>}","output":"<line1>{\n<line2>    final AtomicInteger callCount = new AtomicInteger(0);\n<line3>    watcher = new FileChangeWatcher(tempDir.toPath(), event -> {\n<line4>        LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line5>        int oldValue;\n<line6>        synchronized (callCount) {\n<line7>            oldValue = callCount.getAndIncrement();\n<line8>            callCount.notifyAll();\n<line9>        }\n<line10>        if (oldValue == 0) {\n<line11>            throw new RuntimeException(\"This error should not crash the watcher thread\");\n<line12>        }\n<line13>    });\n<line14>    watcher.start();\n<line15>    watcher.waitForState(FileChangeWatcher.State.RUNNING);\n<line16>    // TODO hack\n<line17>    Thread.sleep(1000L);\n<line18>    LOG.info(\"Modifying file\");\n<line19>    FileUtils.writeStringToFile(tempFile, \"Hello world\\n\", StandardCharsets.UTF_8, true);\n<line20>    synchronized (callCount) {\n<line21>        while (callCount.get() == 0) {\n<line22>            callCount.wait(FS_TIMEOUT);\n<line23>        }\n<line24>    }\n<line25>    LOG.info(\"Modifying file again\");\n<line26>    FileUtils.writeStringToFile(tempFile, \"Hello world again\\n\", StandardCharsets.UTF_8, true);\n<line27>    synchronized (callCount) {\n<line28>        if (callCount.get() == 1) {\n<line29>            callCount.wait(FS_TIMEOUT);\n<line30>        }\n<line31>    }\n<line32>    // The value of callCount can exceed 1 only if the callback thread\n<line33>    // survives the exception thrown by the first callback.\n<line34>    assertTrue(callCount.get() > 1);\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    int oldValue;\n<line3>    synchronized (callCount) {\n<line4>        oldValue = callCount.getAndIncrement();\n<line5>        callCount.notifyAll();\n<line6>    }\n<line7>    if (oldValue == 0) {\n<line8>        throw new RuntimeException(\"This error should not crash the watcher thread\");\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.info(\"Got an update: {} {}\", event.kind(), event.context());\n<line3>    int oldValue;\n<line4>    synchronized (callCount) {\n<line5>        oldValue = callCount.getAndIncrement();\n<line6>        callCount.notifyAll();\n<line7>    }\n<line8>    if (oldValue == 0) {\n<line9>        throw new RuntimeException(\"This error should not crash the watcher thread\");\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (args.length != 3) {\n<line3>        System.err.println(\"USAGE: ZKAuditLoggerPerformance connectionString parentPath numberOfRecords\");\n<line4>        System.exit(1);\n<line5>    }\n<line6>    String cxnString = args[0];\n<line7>    CountdownWatcher watcher = new CountdownWatcher();\n<line8>    ZooKeeper zkClient = null;\n<line9>    try {\n<line10>        zkClient = new ZooKeeper(cxnString, 60000, watcher);\n<line11>        watcher.waitForConnected(30000);\n<line12>    } catch (InterruptedException | TimeoutException | IOException e) {\n<line13>        String msg = \"ZooKeeper client can not connect to \" + cxnString;\n<line14>        logErrorAndExit(e, msg);\n<line15>    }\n<line16>    String parentPath = args[1];\n<line17>    try {\n<line18>        Stat exists = zkClient.exists(parentPath, false);\n<line19>        if (exists == null) {\n<line20>            System.err.println(\"Parent path '\" + parentPath + \"' must exist.\");\n<line21>            System.exit(1);\n<line22>        }\n<line23>    } catch (KeeperException | InterruptedException e1) {\n<line24>        String msg = \"Error while checking the existence of parent path\";\n<line25>        logErrorAndExit(e1, msg);\n<line26>    }\n<line27>    int recordCount = 0;\n<line28>    try {\n<line29>        recordCount = Integer.parseInt(args[2]);\n<line30>    } catch (NumberFormatException e) {\n<line31>        String msg = \"Failed to parse '\" + args[2] + \"' to integer\";\n<line32>        System.err.println(msg);\n<line33>        System.exit(1);\n<line34>    }\n<line35>    ZKAuditLoggerPerformance auditLoggingPerf = new ZKAuditLoggerPerformance(zkClient, parentPath, recordCount);\n<line36>    AuditLogPerfReading doOperations = null;\n<line37>    try {\n<line38>        doOperations = auditLoggingPerf.doOperations();\n<line39>    } catch (Exception e) {\n<line40>        String msg = \"Error while doing operations.\";\n<line41>        System.err.println(msg);\n<line42>        System.exit(1);\n<line43>    }\n<line44>    System.out.println(\"Time taken for \" + recordCount + \" operations are:\");\n<line45>    System.out.println(doOperations.report());\n<line46>    System.exit(0);\n<line47>}","output":"<line1>{\n<line2>    if (args.length != 3) {\n<line3>        System.err.println(\"USAGE: ZKAuditLoggerPerformance connectionString parentPath numberOfRecords\");\n<line4>        System.exit(1);\n<line5>    }\n<line6>    String cxnString = args[0];\n<line7>    CountdownWatcher watcher = new CountdownWatcher();\n<line8>    ZooKeeper zkClient = null;\n<line9>    try {\n<line10>        zkClient = new ZooKeeper(cxnString, 60000, watcher);\n<line11>        watcher.waitForConnected(30000);\n<line12>    } catch (InterruptedException | TimeoutException | IOException e) {\n<line13>        String msg = \"ZooKeeper client can not connect to \" + cxnString;\n<line14>        logErrorAndExit(e, msg);\n<line15>    }\n<line16>    String parentPath = args[1];\n<line17>    try {\n<line18>        Stat exists = zkClient.exists(parentPath, false);\n<line19>        if (exists == null) {\n<line20>            System.err.println(\"Parent path '\" + parentPath + \"' must exist.\");\n<line21>            System.exit(1);\n<line22>        }\n<line23>    } catch (KeeperException | InterruptedException e1) {\n<line24>        String msg = \"Error while checking the existence of parent path\";\n<line25>        logErrorAndExit(e1, msg);\n<line26>    }\n<line27>    int recordCount = 0;\n<line28>    try {\n<line29>        recordCount = Integer.parseInt(args[2]);\n<line30>    } catch (NumberFormatException e) {\n<line31>        String msg = \"Failed to parse '\" + args[2] + \"' to integer\";\n<line32>        LOG.error(msg, e);\n<line33>        System.err.println(msg);\n<line34>        System.exit(1);\n<line35>    }\n<line36>    ZKAuditLoggerPerformance auditLoggingPerf = new ZKAuditLoggerPerformance(zkClient, parentPath, recordCount);\n<line37>    AuditLogPerfReading doOperations = null;\n<line38>    try {\n<line39>        doOperations = auditLoggingPerf.doOperations();\n<line40>    } catch (Exception e) {\n<line41>        String msg = \"Error while doing operations.\";\n<line42>        LOG.error(msg, e);\n<line43>        System.err.println(msg);\n<line44>        System.exit(1);\n<line45>    }\n<line46>    System.out.println(\"Time taken for \" + recordCount + \" operations are:\");\n<line47>    System.out.println(doOperations.report());\n<line48>    System.exit(0);\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Failed to parse '\" + args[2] + \"' to integer\";\n<line3>    System.err.println(msg);\n<line4>    System.exit(1);\n<line5>}","output":"<line1>{\n<line2>    String msg = \"Failed to parse '\" + args[2] + \"' to integer\";\n<line3>    LOG.error(msg, e);\n<line4>    System.err.println(msg);\n<line5>    System.exit(1);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Error while doing operations.\";\n<line3>    System.err.println(msg);\n<line4>    System.exit(1);\n<line5>}","output":"<line1>{\n<line2>    String msg = \"Error while doing operations.\";\n<line3>    LOG.error(msg, e);\n<line4>    System.err.println(msg);\n<line5>    System.exit(1);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(msg + \", error=\" + e.getMessage());\n<line3>    System.exit(1);\n<line4>}","output":"<line1>{\n<line2>    LOG.error(msg, e);\n<line3>    System.err.println(msg + \", error=\" + e.getMessage());\n<line4>    System.exit(1);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    AuditEvent logEvent = ZKAuditProvider.createLogEvent(user, operation, znode, acl, createMode, session, ip, result);\n<line3>    String auditLog = logEvent.toString();\n<line4>    return auditLog;\n<line5>}","output":"<line1>{\n<line2>    AuditEvent logEvent = ZKAuditProvider.createLogEvent(user, operation, znode, acl, createMode, session, ip, result);\n<line3>    String auditLog = logEvent.toString();\n<line4>    LOG.info(\"expected audit log for operation '\" + operation + \"' is '\" + auditLog + \"'\");\n<line5>    return auditLog;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    Executors.newSingleThreadExecutor().submit(() -> {\n<line3>        try {\n<line4>            zk.close();\n<line5>        } catch (InterruptedException e) {\n<line6>        }\n<line7>    });\n<line8>}","output":"<line1>{\n<line2>    Executors.newSingleThreadExecutor().submit(() -> {\n<line3>        try {\n<line4>            LOG.info(\"closeZookeeper is fired\");\n<line5>            zk.close();\n<line6>        } catch (InterruptedException e) {\n<line7>        }\n<line8>    });\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zk.close();\n<line4>    } catch (InterruptedException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"closeZookeeper is fired\");\n<line4>        zk.close();\n<line5>    } catch (InterruptedException e) {\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.close();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"closeZookeeper is fired\");\n<line3>    zk.close();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    while (alive) {\n<line3>        try {\n<line4>            zk.getData(path, false, new Stat());\n<line5>            // sleep for a while to avoid exhausting CPU\n<line6>            TimeUnit.MILLISECONDS.sleep(500);\n<line7>        } catch (Exception e) {\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    while (alive) {\n<line3>        try {\n<line4>            zk.getData(path, false, new Stat());\n<line5>            // sleep for a while to avoid exhausting CPU\n<line6>            TimeUnit.MILLISECONDS.sleep(500);\n<line7>        } catch (Exception e) {\n<line8>            LOG.info(\"zookeeper getData failed on path {}\", path);\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zk.getData(path, false, new Stat());\n<line4>        // sleep for a while to avoid exhausting CPU\n<line5>        TimeUnit.MILLISECONDS.sleep(500);\n<line6>    } catch (Exception e) {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        zk.getData(path, false, new Stat());\n<line4>        // sleep for a while to avoid exhausting CPU\n<line5>        TimeUnit.MILLISECONDS.sleep(500);\n<line6>    } catch (Exception e) {\n<line7>        LOG.info(\"zookeeper getData failed on path {}\", path);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"zookeeper getData failed on path {}\", path);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!mute) {\n<line3>        mute = true;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (!mute) {\n<line3>        LOG.info(\"Fire socket mute\");\n<line4>        mute = true;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    mute = true;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Fire socket mute\");\n<line3>    mute = true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (mute) {\n<line3>        mute = false;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (mute) {\n<line3>        LOG.info(\"Fire socket unmute\");\n<line4>        mute = false;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    mute = false;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Fire socket unmute\");\n<line3>    mute = false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event.getState() == KeeperState.Expired) {\n<line3>        sessionExpired = true;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Watcher got {}\", event);\n<line3>    if (event.getState() == KeeperState.Expired) {\n<line4>        sessionExpired = true;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (closing) {\n<line3>        syncLatch.countDown();\n<line4>        try {\n<line5>            syncLatch.await();\n<line6>        } catch (InterruptedException e) {\n<line7>            throw new RuntimeException(e);\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.info(\"Attempt to sync with {}\", closing);\n<line3>    if (closing) {\n<line4>        syncLatch.countDown();\n<line5>        try {\n<line6>            syncLatch.await();\n<line7>        } catch (InterruptedException e) {\n<line8>            throw new RuntimeException(e);\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (closing) {\n<line3>        ///////// Unsafe Region ////////\n<line4>        // Slow down and zoom out the unsafe point to make risk\n<line5>        // The unsafe point is that startConnect happens after sendThread.close\n<line6>        hitUnsafeRegion = true;\n<line7>        unsafeCoordinator.sync(closing);\n<line8>        ////////////////////////////////\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (closing) {\n<line3>        LOG.info(\"Attempt to connnecting {} {} {}\", addr, closing, state);\n<line4>        ///////// Unsafe Region ////////\n<line5>        // Slow down and zoom out the unsafe point to make risk\n<line6>        // The unsafe point is that startConnect happens after sendThread.close\n<line7>        hitUnsafeRegion = true;\n<line8>        unsafeCoordinator.sync(closing);\n<line9>        ////////////////////////////////\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    ///////// Unsafe Region ////////\n<line3>    // Slow down and zoom out the unsafe point to make risk\n<line4>    // The unsafe point is that startConnect happens after sendThread.close\n<line5>    hitUnsafeRegion = true;\n<line6>    unsafeCoordinator.sync(closing);\n<line7>    ////////////////////////////////\n<line8>}","output":"<line1>{\n<line2>    LOG.info(\"Attempt to connnecting {} {} {}\", addr, closing, state);\n<line3>    ///////// Unsafe Region ////////\n<line4>    // Slow down and zoom out the unsafe point to make risk\n<line5>    // The unsafe point is that startConnect happens after sendThread.close\n<line6>    hitUnsafeRegion = true;\n<line7>    unsafeCoordinator.sync(closing);\n<line8>    ////////////////////////////////\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    assertTrue(closing);\n<line3>    sendThread.close();\n<line4>    ///////// Unsafe Region ////////\n<line5>    unsafeCoordinator.sync(closing);\n<line6>    ////////////////////////////////\n<line7>    try {\n<line8>        sendThread.join();\n<line9>    } catch (InterruptedException ex) {\n<line10>    }\n<line11>    eventThread.queueEventOfDeath();\n<line12>}","output":"<line1>{\n<line2>    assertTrue(closing);\n<line3>    LOG.info(\"Attempt to disconnecting client for session: 0x{} {} {}\", Long.toHexString(getSessionId()), closing, state);\n<line4>    sendThread.close();\n<line5>    ///////// Unsafe Region ////////\n<line6>    unsafeCoordinator.sync(closing);\n<line7>    ////////////////////////////////\n<line8>    try {\n<line9>        sendThread.join();\n<line10>    } catch (InterruptedException ex) {\n<line11>        LOG.warn(\"Got interrupted while waiting for the sender thread to close\", ex);\n<line12>    }\n<line13>    eventThread.queueEventOfDeath();\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (portRange == null) {\n<line3>        Integer threadId = Integer.getInteger(\"zookeeper.junit.threadid\");\n<line4>        portRange = setupPortRange(System.getProperty(\"test.junit.threads\"), threadId != null ? \"threadid=\" + threadId : System.getProperty(\"sun.java.command\"));\n<line5>        nextPort = portRange.getMinimum();\n<line6>    }\n<line7>    int candidatePort = nextPort;\n<line8>    for (; ; ) {\n<line9>        ++candidatePort;\n<line10>        if (candidatePort > portRange.getMaximum()) {\n<line11>            candidatePort = portRange.getMinimum();\n<line12>        }\n<line13>        if (candidatePort == nextPort) {\n<line14>            throw new IllegalStateException(String.format(\"Could not assign port from range %s.  The entire range has been exhausted.\", portRange));\n<line15>        }\n<line16>        try {\n<line17>            ServerSocket s = new ServerSocket(candidatePort);\n<line18>            s.close();\n<line19>            nextPort = candidatePort;\n<line20>            return nextPort;\n<line21>        } catch (IOException e) {\n<line22>        }\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    if (portRange == null) {\n<line3>        Integer threadId = Integer.getInteger(\"zookeeper.junit.threadid\");\n<line4>        portRange = setupPortRange(System.getProperty(\"test.junit.threads\"), threadId != null ? \"threadid=\" + threadId : System.getProperty(\"sun.java.command\"));\n<line5>        nextPort = portRange.getMinimum();\n<line6>    }\n<line7>    int candidatePort = nextPort;\n<line8>    for (; ; ) {\n<line9>        ++candidatePort;\n<line10>        if (candidatePort > portRange.getMaximum()) {\n<line11>            candidatePort = portRange.getMinimum();\n<line12>        }\n<line13>        if (candidatePort == nextPort) {\n<line14>            throw new IllegalStateException(String.format(\"Could not assign port from range %s.  The entire range has been exhausted.\", portRange));\n<line15>        }\n<line16>        try {\n<line17>            ServerSocket s = new ServerSocket(candidatePort);\n<line18>            s.close();\n<line19>            nextPort = candidatePort;\n<line20>            LOG.info(\"Assigned port {} from range {}.\", nextPort, portRange);\n<line21>            return nextPort;\n<line22>        } catch (IOException e) {\n<line23>            LOG.debug(\"Could not bind to port {} from range {}.  Attempting next port.\", candidatePort, portRange, e);\n<line24>        }\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    ++candidatePort;\n<line3>    if (candidatePort > portRange.getMaximum()) {\n<line4>        candidatePort = portRange.getMinimum();\n<line5>    }\n<line6>    if (candidatePort == nextPort) {\n<line7>        throw new IllegalStateException(String.format(\"Could not assign port from range %s.  The entire range has been exhausted.\", portRange));\n<line8>    }\n<line9>    try {\n<line10>        ServerSocket s = new ServerSocket(candidatePort);\n<line11>        s.close();\n<line12>        nextPort = candidatePort;\n<line13>        return nextPort;\n<line14>    } catch (IOException e) {\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    ++candidatePort;\n<line3>    if (candidatePort > portRange.getMaximum()) {\n<line4>        candidatePort = portRange.getMinimum();\n<line5>    }\n<line6>    if (candidatePort == nextPort) {\n<line7>        throw new IllegalStateException(String.format(\"Could not assign port from range %s.  The entire range has been exhausted.\", portRange));\n<line8>    }\n<line9>    try {\n<line10>        ServerSocket s = new ServerSocket(candidatePort);\n<line11>        s.close();\n<line12>        nextPort = candidatePort;\n<line13>        LOG.info(\"Assigned port {} from range {}.\", nextPort, portRange);\n<line14>        return nextPort;\n<line15>    } catch (IOException e) {\n<line16>        LOG.debug(\"Could not bind to port {} from range {}.  Attempting next port.\", candidatePort, portRange, e);\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerSocket s = new ServerSocket(candidatePort);\n<line3>    s.close();\n<line4>    nextPort = candidatePort;\n<line5>    return nextPort;\n<line6>}","output":"<line1>{\n<line2>    ServerSocket s = new ServerSocket(candidatePort);\n<line3>    s.close();\n<line4>    nextPort = candidatePort;\n<line5>    LOG.info(\"Assigned port {} from range {}.\", nextPort, portRange);\n<line6>    return nextPort;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Could not bind to port {} from range {}.  Attempting next port.\", candidatePort, portRange, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Integer processCount = null;\n<line3>    if (strProcessCount != null && !strProcessCount.isEmpty()) {\n<line4>        try {\n<line5>            processCount = Integer.valueOf(strProcessCount);\n<line6>        } catch (NumberFormatException e) {\n<line7>        }\n<line8>    }\n<line9>    Integer threadId = null;\n<line10>    if (processCount != null) {\n<line11>        if (cmdLine != null && !cmdLine.isEmpty()) {\n<line12>            Matcher m = Pattern.compile(\"threadid=(\\\\d+)\").matcher(cmdLine);\n<line13>            if (m.find()) {\n<line14>                try {\n<line15>                    threadId = Integer.valueOf(m.group(1));\n<line16>                } catch (NumberFormatException e) {\n<line17>                }\n<line18>            }\n<line19>        }\n<line20>    }\n<line21>    final PortRange newPortRange;\n<line22>    if (processCount != null && processCount > 1 && threadId != null) {\n<line23>        // We know the total JUnit process count and this test process's ID.\n<line24>        // Use these values to calculate the valid range for port assignments\n<line25>        // within this test process.  We lose a few possible ports to the\n<line26>        // remainder, but that's acceptable.\n<line27>        int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;\n<line28>        int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);\n<line29>        int maxPort = minPort + portRangeSize - 1;\n<line30>        newPortRange = new PortRange(minPort, maxPort);\n<line31>    } else {\n<line32>        // If running outside the context of Ant or Ant is using a single\n<line33>        // test process, then use all valid ports.\n<line34>        newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);\n<line35>    }\n<line36>    return newPortRange;\n<line37>}","output":"<line1>{\n<line2>    Integer processCount = null;\n<line3>    if (strProcessCount != null && !strProcessCount.isEmpty()) {\n<line4>        try {\n<line5>            processCount = Integer.valueOf(strProcessCount);\n<line6>        } catch (NumberFormatException e) {\n<line7>            LOG.warn(\"Error parsing test.junit.threads = {}.\", strProcessCount, e);\n<line8>        }\n<line9>    }\n<line10>    Integer threadId = null;\n<line11>    if (processCount != null) {\n<line12>        if (cmdLine != null && !cmdLine.isEmpty()) {\n<line13>            Matcher m = Pattern.compile(\"threadid=(\\\\d+)\").matcher(cmdLine);\n<line14>            if (m.find()) {\n<line15>                try {\n<line16>                    threadId = Integer.valueOf(m.group(1));\n<line17>                } catch (NumberFormatException e) {\n<line18>                    LOG.warn(\"Error parsing threadid from {}.\", cmdLine, e);\n<line19>                }\n<line20>            }\n<line21>        }\n<line22>    }\n<line23>    final PortRange newPortRange;\n<line24>    if (processCount != null && processCount > 1 && threadId != null) {\n<line25>        // We know the total JUnit process count and this test process's ID.\n<line26>        // Use these values to calculate the valid range for port assignments\n<line27>        // within this test process.  We lose a few possible ports to the\n<line28>        // remainder, but that's acceptable.\n<line29>        int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;\n<line30>        int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);\n<line31>        int maxPort = minPort + portRangeSize - 1;\n<line32>        newPortRange = new PortRange(minPort, maxPort);\n<line33>        LOG.info(\"Test process {}/{} using ports from {}.\", threadId, processCount, newPortRange);\n<line34>    } else {\n<line35>        // If running outside the context of Ant or Ant is using a single\n<line36>        // test process, then use all valid ports.\n<line37>        newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);\n<line38>        LOG.info(\"Single test process using ports from {}.\", newPortRange);\n<line39>    }\n<line40>    return newPortRange;\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    // We know the total JUnit process count and this test process's ID.\n<line3>    // Use these values to calculate the valid range for port assignments\n<line4>    // within this test process.  We lose a few possible ports to the\n<line5>    // remainder, but that's acceptable.\n<line6>    int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;\n<line7>    int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);\n<line8>    int maxPort = minPort + portRangeSize - 1;\n<line9>    newPortRange = new PortRange(minPort, maxPort);\n<line10>}","output":"<line1>{\n<line2>    // We know the total JUnit process count and this test process's ID.\n<line3>    // Use these values to calculate the valid range for port assignments\n<line4>    // within this test process.  We lose a few possible ports to the\n<line5>    // remainder, but that's acceptable.\n<line6>    int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;\n<line7>    int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);\n<line8>    int maxPort = minPort + portRangeSize - 1;\n<line9>    newPortRange = new PortRange(minPort, maxPort);\n<line10>    LOG.info(\"Test process {}/{} using ports from {}.\", threadId, processCount, newPortRange);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // If running outside the context of Ant or Ant is using a single\n<line3>    // test process, then use all valid ports.\n<line4>    newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);\n<line5>}","output":"<line1>{\n<line2>    // If running outside the context of Ant or Ant is using a single\n<line3>    // test process, then use all valid ports.\n<line4>    newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);\n<line5>    LOG.info(\"Single test process using ports from {}.\", newPortRange);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Class<?> clazz = Class.forName(metricsProviderClassName, true, Thread.currentThread().getContextClassLoader());\n<line4>        MetricsProvider metricsProvider = (MetricsProvider) clazz.getConstructor().newInstance();\n<line5>        metricsProvider.configure(configuration);\n<line6>        metricsProvider.start();\n<line7>        return metricsProvider;\n<line8>    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException error) {\n<line9>        throw new MetricsProviderLifeCycleException(\"Cannot boot MetricsProvider \" + metricsProviderClassName, error);\n<line10>    } catch (MetricsProviderLifeCycleException error) {\n<line11>        throw error;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    try {\n<line3>        Class<?> clazz = Class.forName(metricsProviderClassName, true, Thread.currentThread().getContextClassLoader());\n<line4>        MetricsProvider metricsProvider = (MetricsProvider) clazz.getConstructor().newInstance();\n<line5>        metricsProvider.configure(configuration);\n<line6>        metricsProvider.start();\n<line7>        return metricsProvider;\n<line8>    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException error) {\n<line9>        LOG.error(\"Cannot boot MetricsProvider {}\", metricsProviderClassName, error);\n<line10>        throw new MetricsProviderLifeCycleException(\"Cannot boot MetricsProvider \" + metricsProviderClassName, error);\n<line11>    } catch (MetricsProviderLifeCycleException error) {\n<line12>        LOG.error(\"Cannot boot MetricsProvider {}\", metricsProviderClassName, error);\n<line13>        throw error;\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new MetricsProviderLifeCycleException(\"Cannot boot MetricsProvider \" + metricsProviderClassName, error);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Cannot boot MetricsProvider {}\", metricsProviderClassName, error);\n<line3>    throw new MetricsProviderLifeCycleException(\"Cannot boot MetricsProvider \" + metricsProviderClassName, error);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throw error;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Cannot boot MetricsProvider {}\", metricsProviderClassName, error);\n<line3>    throw error;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    List<Entry> env = Environment.list();\n<line3>    for (Entry e : env) {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    List<Entry> env = Environment.list();\n<line3>    for (Entry e : env) {\n<line4>        log.info(msg + e.toString());\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    log.info(msg + e.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Exiting JVM with code {}\";\n<line3>    if (code == 0) {\n<line4>        // JVM exits normally\n<line5>    } else {\n<line6>        // JVM exits with error\n<line7>    }\n<line8>    System.exit(code);\n<line9>}","output":"<line1>{\n<line2>    String msg = \"Exiting JVM with code {}\";\n<line3>    if (code == 0) {\n<line4>        // JVM exits normally\n<line5>        LOG.info(msg, code);\n<line6>    } else {\n<line7>        // JVM exits with error\n<line8>        LOG.error(msg, code);\n<line9>    }\n<line10>    System.exit(code);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // JVM exits normally\n<line3>}","output":"<line1>{\n<line2>    // JVM exits normally\n<line3>    LOG.info(msg, code);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // JVM exits with error\n<line3>}","output":"<line1>{\n<line2>    // JVM exits with error\n<line3>    LOG.error(msg, code);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (code != 0) {\n<line3>    } else {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (code != 0) {\n<line3>        LOG.error(\"Fatal error, JVM should exit with code {}. \" + \"Actually System.exit is disabled\", code);\n<line4>    } else {\n<line5>        LOG.info(\"JVM should exit with code {}. Actually System.exit is disabled\", code);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Fatal error, JVM should exit with code {}. \" + \"Actually System.exit is disabled\", code);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"JVM should exit with code {}. Actually System.exit is disabled\", code);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    SaslClient saslClient;\n<line3>    // Use subject.getPrincipals().isEmpty() as an indication of which SASL\n<line4>    // mechanism to use: if empty, use DIGEST-MD5; otherwise, use GSSAPI.\n<line5>    if (subject.getPrincipals().isEmpty()) {\n<line6>        // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism\n<line7>        // instead.\n<line8>        String[] mechs = { \"DIGEST-MD5\" };\n<line9>        String username = (String) (subject.getPublicCredentials().toArray()[0]);\n<line10>        String password = (String) (subject.getPrivateCredentials().toArray()[0]);\n<line11>        // 'domain' parameter is hard-wired between the server and client\n<line12>        saslClient = Sasl.createSaslClient(mechs, username, protocol, serverName, null, new SaslClientCallbackHandler(password, entity));\n<line13>        return saslClient;\n<line14>    } else {\n<line15>        // GSSAPI.\n<line16>        final Object[] principals = subject.getPrincipals().toArray();\n<line17>        // determine client principal from subject.\n<line18>        final Principal clientPrincipal = (Principal) principals[0];\n<line19>        boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line20>        if (usingNativeJgss) {\n<line21>            // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line22>            // \"\"\"\n<line23>            // In addition, when performing operations as a particular\n<line24>            // Subject, e.g. Subject.doAs(...) or\n<line25>            // Subject.doAsPrivileged(...),\n<line26>            // the to-be-used GSSCredential should be added to Subject's\n<line27>            // private credential set. Otherwise, the GSS operations will\n<line28>            // fail since no credential is found.\n<line29>            // \"\"\"\n<line30>            try {\n<line31>                GSSManager manager = GSSManager.getInstance();\n<line32>                Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line33>                GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line34>                subject.getPrivateCredentials().add(cred);\n<line35>            } catch (GSSException ex) {\n<line36>            }\n<line37>        }\n<line38>        final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n<line39>        // assume that server and client are in the same realm (by default;\n<line40>        // unless the system property\n<line41>        // \"zookeeper.server.realm\" is set).\n<line42>        String serverRealm = System.getProperty(\"zookeeper.server.realm\", clientKerberosName.getRealm());\n<line43>        String modifiedServerPrincipal = servicePrincipal;\n<line44>        // If service principal does not contain realm, then add it\n<line45>        if (!modifiedServerPrincipal.contains(\"@\")) {\n<line46>            modifiedServerPrincipal = modifiedServerPrincipal + \"@\" + serverRealm;\n<line47>        }\n<line48>        KerberosName serviceKerberosName = new KerberosName(modifiedServerPrincipal);\n<line49>        final String serviceName = serviceKerberosName.getServiceName();\n<line50>        final String serviceHostname = serviceKerberosName.getHostName();\n<line51>        final String clientPrincipalName = clientKerberosName.toString();\n<line52>        try {\n<line53>            saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {\n<line54>\n<line55>                public SaslClient run() throws SaslException {\n<line56>                    String[] mechs = { \"GSSAPI\" };\n<line57>                    SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line58>                    return saslClient;\n<line59>                }\n<line60>            });\n<line61>            return saslClient;\n<line62>        } catch (Exception e) {\n<line63>            return null;\n<line64>        }\n<line65>    }\n<line66>}","output":"<line1>{\n<line2>    SaslClient saslClient;\n<line3>    // Use subject.getPrincipals().isEmpty() as an indication of which SASL\n<line4>    // mechanism to use: if empty, use DIGEST-MD5; otherwise, use GSSAPI.\n<line5>    if (subject.getPrincipals().isEmpty()) {\n<line6>        // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism\n<line7>        // instead.\n<line8>        LOG.info(\"{} will use DIGEST-MD5 as SASL mechanism.\", entity);\n<line9>        String[] mechs = { \"DIGEST-MD5\" };\n<line10>        String username = (String) (subject.getPublicCredentials().toArray()[0]);\n<line11>        String password = (String) (subject.getPrivateCredentials().toArray()[0]);\n<line12>        // 'domain' parameter is hard-wired between the server and client\n<line13>        saslClient = Sasl.createSaslClient(mechs, username, protocol, serverName, null, new SaslClientCallbackHandler(password, entity));\n<line14>        return saslClient;\n<line15>    } else {\n<line16>        // GSSAPI.\n<line17>        final Object[] principals = subject.getPrincipals().toArray();\n<line18>        // determine client principal from subject.\n<line19>        final Principal clientPrincipal = (Principal) principals[0];\n<line20>        boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line21>        if (usingNativeJgss) {\n<line22>            // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line23>            // \"\"\"\n<line24>            // In addition, when performing operations as a particular\n<line25>            // Subject, e.g. Subject.doAs(...) or\n<line26>            // Subject.doAsPrivileged(...),\n<line27>            // the to-be-used GSSCredential should be added to Subject's\n<line28>            // private credential set. Otherwise, the GSS operations will\n<line29>            // fail since no credential is found.\n<line30>            // \"\"\"\n<line31>            try {\n<line32>                GSSManager manager = GSSManager.getInstance();\n<line33>                Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line34>                GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line35>                subject.getPrivateCredentials().add(cred);\n<line36>                LOG.debug(\"Added private credential to {} principal name: '{}'\", entity, clientPrincipal);\n<line37>            } catch (GSSException ex) {\n<line38>                LOG.warn(\"Cannot add private credential to subject; authentication at the server may fail\", ex);\n<line39>            }\n<line40>        }\n<line41>        final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n<line42>        // assume that server and client are in the same realm (by default;\n<line43>        // unless the system property\n<line44>        // \"zookeeper.server.realm\" is set).\n<line45>        String serverRealm = System.getProperty(\"zookeeper.server.realm\", clientKerberosName.getRealm());\n<line46>        String modifiedServerPrincipal = servicePrincipal;\n<line47>        // If service principal does not contain realm, then add it\n<line48>        if (!modifiedServerPrincipal.contains(\"@\")) {\n<line49>            modifiedServerPrincipal = modifiedServerPrincipal + \"@\" + serverRealm;\n<line50>        }\n<line51>        KerberosName serviceKerberosName = new KerberosName(modifiedServerPrincipal);\n<line52>        final String serviceName = serviceKerberosName.getServiceName();\n<line53>        final String serviceHostname = serviceKerberosName.getHostName();\n<line54>        final String clientPrincipalName = clientKerberosName.toString();\n<line55>        try {\n<line56>            saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {\n<line57>\n<line58>                public SaslClient run() throws SaslException {\n<line59>                    LOG.info(\"{} will use GSSAPI as SASL mechanism.\", entity);\n<line60>                    String[] mechs = { \"GSSAPI\" };\n<line61>                    LOG.debug(\"creating sasl client: {}={};service={};serviceHostname={}\", entity, clientPrincipalName, serviceName, serviceHostname);\n<line62>                    SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line63>                    return saslClient;\n<line64>                }\n<line65>            });\n<line66>            return saslClient;\n<line67>        } catch (Exception e) {\n<line68>            LOG.error(\"Exception while trying to create SASL client\", e);\n<line69>            return null;\n<line70>        }\n<line71>    }\n<line72>}"},{"input":"","instruction":"<line1>{\n<line2>    // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism\n<line3>    // instead.\n<line4>    String[] mechs = { \"DIGEST-MD5\" };\n<line5>    String username = (String) (subject.getPublicCredentials().toArray()[0]);\n<line6>    String password = (String) (subject.getPrivateCredentials().toArray()[0]);\n<line7>    // 'domain' parameter is hard-wired between the server and client\n<line8>    saslClient = Sasl.createSaslClient(mechs, username, protocol, serverName, null, new SaslClientCallbackHandler(password, entity));\n<line9>    return saslClient;\n<line10>}","output":"<line1>{\n<line2>    // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism\n<line3>    // instead.\n<line4>    LOG.info(\"{} will use DIGEST-MD5 as SASL mechanism.\", entity);\n<line5>    String[] mechs = { \"DIGEST-MD5\" };\n<line6>    String username = (String) (subject.getPublicCredentials().toArray()[0]);\n<line7>    String password = (String) (subject.getPrivateCredentials().toArray()[0]);\n<line8>    // 'domain' parameter is hard-wired between the server and client\n<line9>    saslClient = Sasl.createSaslClient(mechs, username, protocol, serverName, null, new SaslClientCallbackHandler(password, entity));\n<line10>    return saslClient;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // GSSAPI.\n<line3>    final Object[] principals = subject.getPrincipals().toArray();\n<line4>    // determine client principal from subject.\n<line5>    final Principal clientPrincipal = (Principal) principals[0];\n<line6>    boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line7>    if (usingNativeJgss) {\n<line8>        // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line9>        // \"\"\"\n<line10>        // In addition, when performing operations as a particular\n<line11>        // Subject, e.g. Subject.doAs(...) or\n<line12>        // Subject.doAsPrivileged(...),\n<line13>        // the to-be-used GSSCredential should be added to Subject's\n<line14>        // private credential set. Otherwise, the GSS operations will\n<line15>        // fail since no credential is found.\n<line16>        // \"\"\"\n<line17>        try {\n<line18>            GSSManager manager = GSSManager.getInstance();\n<line19>            Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line20>            GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line21>            subject.getPrivateCredentials().add(cred);\n<line22>        } catch (GSSException ex) {\n<line23>        }\n<line24>    }\n<line25>    final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n<line26>    // assume that server and client are in the same realm (by default;\n<line27>    // unless the system property\n<line28>    // \"zookeeper.server.realm\" is set).\n<line29>    String serverRealm = System.getProperty(\"zookeeper.server.realm\", clientKerberosName.getRealm());\n<line30>    String modifiedServerPrincipal = servicePrincipal;\n<line31>    // If service principal does not contain realm, then add it\n<line32>    if (!modifiedServerPrincipal.contains(\"@\")) {\n<line33>        modifiedServerPrincipal = modifiedServerPrincipal + \"@\" + serverRealm;\n<line34>    }\n<line35>    KerberosName serviceKerberosName = new KerberosName(modifiedServerPrincipal);\n<line36>    final String serviceName = serviceKerberosName.getServiceName();\n<line37>    final String serviceHostname = serviceKerberosName.getHostName();\n<line38>    final String clientPrincipalName = clientKerberosName.toString();\n<line39>    try {\n<line40>        saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {\n<line41>\n<line42>            public SaslClient run() throws SaslException {\n<line43>                String[] mechs = { \"GSSAPI\" };\n<line44>                SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line45>                return saslClient;\n<line46>            }\n<line47>        });\n<line48>        return saslClient;\n<line49>    } catch (Exception e) {\n<line50>        return null;\n<line51>    }\n<line52>}","output":"<line1>{\n<line2>    // GSSAPI.\n<line3>    final Object[] principals = subject.getPrincipals().toArray();\n<line4>    // determine client principal from subject.\n<line5>    final Principal clientPrincipal = (Principal) principals[0];\n<line6>    boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line7>    if (usingNativeJgss) {\n<line8>        // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line9>        // \"\"\"\n<line10>        // In addition, when performing operations as a particular\n<line11>        // Subject, e.g. Subject.doAs(...) or\n<line12>        // Subject.doAsPrivileged(...),\n<line13>        // the to-be-used GSSCredential should be added to Subject's\n<line14>        // private credential set. Otherwise, the GSS operations will\n<line15>        // fail since no credential is found.\n<line16>        // \"\"\"\n<line17>        try {\n<line18>            GSSManager manager = GSSManager.getInstance();\n<line19>            Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line20>            GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line21>            subject.getPrivateCredentials().add(cred);\n<line22>            LOG.debug(\"Added private credential to {} principal name: '{}'\", entity, clientPrincipal);\n<line23>        } catch (GSSException ex) {\n<line24>            LOG.warn(\"Cannot add private credential to subject; authentication at the server may fail\", ex);\n<line25>        }\n<line26>    }\n<line27>    final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n<line28>    // assume that server and client are in the same realm (by default;\n<line29>    // unless the system property\n<line30>    // \"zookeeper.server.realm\" is set).\n<line31>    String serverRealm = System.getProperty(\"zookeeper.server.realm\", clientKerberosName.getRealm());\n<line32>    String modifiedServerPrincipal = servicePrincipal;\n<line33>    // If service principal does not contain realm, then add it\n<line34>    if (!modifiedServerPrincipal.contains(\"@\")) {\n<line35>        modifiedServerPrincipal = modifiedServerPrincipal + \"@\" + serverRealm;\n<line36>    }\n<line37>    KerberosName serviceKerberosName = new KerberosName(modifiedServerPrincipal);\n<line38>    final String serviceName = serviceKerberosName.getServiceName();\n<line39>    final String serviceHostname = serviceKerberosName.getHostName();\n<line40>    final String clientPrincipalName = clientKerberosName.toString();\n<line41>    try {\n<line42>        saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {\n<line43>\n<line44>            public SaslClient run() throws SaslException {\n<line45>                LOG.info(\"{} will use GSSAPI as SASL mechanism.\", entity);\n<line46>                String[] mechs = { \"GSSAPI\" };\n<line47>                LOG.debug(\"creating sasl client: {}={};service={};serviceHostname={}\", entity, clientPrincipalName, serviceName, serviceHostname);\n<line48>                SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line49>                return saslClient;\n<line50>            }\n<line51>        });\n<line52>        return saslClient;\n<line53>    } catch (Exception e) {\n<line54>        LOG.error(\"Exception while trying to create SASL client\", e);\n<line55>        return null;\n<line56>    }\n<line57>}"},{"input":"","instruction":"<line1>{\n<line2>    // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line3>    // \"\"\"\n<line4>    // In addition, when performing operations as a particular\n<line5>    // Subject, e.g. Subject.doAs(...) or\n<line6>    // Subject.doAsPrivileged(...),\n<line7>    // the to-be-used GSSCredential should be added to Subject's\n<line8>    // private credential set. Otherwise, the GSS operations will\n<line9>    // fail since no credential is found.\n<line10>    // \"\"\"\n<line11>    try {\n<line12>        GSSManager manager = GSSManager.getInstance();\n<line13>        Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line14>        GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line15>        subject.getPrivateCredentials().add(cred);\n<line16>    } catch (GSSException ex) {\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line3>    // \"\"\"\n<line4>    // In addition, when performing operations as a particular\n<line5>    // Subject, e.g. Subject.doAs(...) or\n<line6>    // Subject.doAsPrivileged(...),\n<line7>    // the to-be-used GSSCredential should be added to Subject's\n<line8>    // private credential set. Otherwise, the GSS operations will\n<line9>    // fail since no credential is found.\n<line10>    // \"\"\"\n<line11>    try {\n<line12>        GSSManager manager = GSSManager.getInstance();\n<line13>        Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line14>        GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line15>        subject.getPrivateCredentials().add(cred);\n<line16>        LOG.debug(\"Added private credential to {} principal name: '{}'\", entity, clientPrincipal);\n<line17>    } catch (GSSException ex) {\n<line18>        LOG.warn(\"Cannot add private credential to subject; authentication at the server may fail\", ex);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    GSSManager manager = GSSManager.getInstance();\n<line3>    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line4>    GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line5>    subject.getPrivateCredentials().add(cred);\n<line6>}","output":"<line1>{\n<line2>    GSSManager manager = GSSManager.getInstance();\n<line3>    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line4>    GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);\n<line5>    subject.getPrivateCredentials().add(cred);\n<line6>    LOG.debug(\"Added private credential to {} principal name: '{}'\", entity, clientPrincipal);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {\n<line3>\n<line4>        public SaslClient run() throws SaslException {\n<line5>            String[] mechs = { \"GSSAPI\" };\n<line6>            SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line7>            return saslClient;\n<line8>        }\n<line9>    });\n<line10>    return saslClient;\n<line11>}","output":"<line1>{\n<line2>    saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {\n<line3>\n<line4>        public SaslClient run() throws SaslException {\n<line5>            LOG.info(\"{} will use GSSAPI as SASL mechanism.\", entity);\n<line6>            String[] mechs = { \"GSSAPI\" };\n<line7>            LOG.debug(\"creating sasl client: {}={};service={};serviceHostname={}\", entity, clientPrincipalName, serviceName, serviceHostname);\n<line8>            SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line9>            return saslClient;\n<line10>        }\n<line11>    });\n<line12>    return saslClient;\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] mechs = { \"GSSAPI\" };\n<line3>    SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line4>    return saslClient;\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"{} will use GSSAPI as SASL mechanism.\", entity);\n<line3>    String[] mechs = { \"GSSAPI\" };\n<line4>    LOG.debug(\"creating sasl client: {}={};service={};serviceHostname={}\", entity, clientPrincipalName, serviceName, serviceHostname);\n<line5>    SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));\n<line6>    return saslClient;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while trying to create SASL client\", e);\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (subject != null) {\n<line3>        // server is using a JAAS-authenticated subject: determine service\n<line4>        // principal name and hostname from zk server's subject.\n<line5>        if (subject.getPrincipals().size() > 0) {\n<line6>            try {\n<line7>                final Object[] principals = subject.getPrincipals().toArray();\n<line8>                final Principal servicePrincipal = (Principal) principals[0];\n<line9>                // e.g. servicePrincipalNameAndHostname :=\n<line10>                // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line11>                final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line12>                int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line13>                // e.g. servicePrincipalName := \"zookeeper\"\n<line14>                final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line15>                // e.g. serviceHostnameAndKerbDomain :=\n<line16>                // \"myhost.foo.com@FOO.COM\"\n<line17>                final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line18>                indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line19>                // e.g. serviceHostname := \"myhost.foo.com\"\n<line20>                final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line21>                // TODO: should depend on zoo.cfg specified mechs, but if\n<line22>                // subject is non-null, it can be assumed to be GSSAPI.\n<line23>                final String mech = \"GSSAPI\";\n<line24>                boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line25>                if (usingNativeJgss) {\n<line26>                    // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line27>                    // \"\"\"\n<line28>                    // In addition, when performing operations as a\n<line29>                    // particular\n<line30>                    // Subject, e.g. Subject.doAs(...) or\n<line31>                    // Subject.doAsPrivileged(...), the to-be-used\n<line32>                    // GSSCredential should be added to Subject's\n<line33>                    // private credential set. Otherwise, the GSS operations\n<line34>                    // will fail since no credential is found.\n<line35>                    // \"\"\"\n<line36>                    try {\n<line37>                        GSSManager manager = GSSManager.getInstance();\n<line38>                        Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line39>                        GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line40>                        GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line41>                        subject.getPrivateCredentials().add(cred);\n<line42>                    } catch (GSSException ex) {\n<line43>                    }\n<line44>                }\n<line45>                try {\n<line46>                    return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line47>\n<line48>                        public SaslServer run() {\n<line49>                            try {\n<line50>                                SaslServer saslServer;\n<line51>                                saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line52>                                return saslServer;\n<line53>                            } catch (SaslException e) {\n<line54>                                return null;\n<line55>                            }\n<line56>                        }\n<line57>                    });\n<line58>                } catch (PrivilegedActionException e) {\n<line59>                    // TODO: exit server at this point(?)\n<line60>                }\n<line61>            } catch (IndexOutOfBoundsException e) {\n<line62>            }\n<line63>        } else {\n<line64>            // JAAS non-GSSAPI authentication: assuming and supporting only\n<line65>            // DIGEST-MD5 mechanism for now.\n<line66>            // TODO: use 'authMech=' value in zoo.cfg.\n<line67>            try {\n<line68>                SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\", protocol, serverName, null, callbackHandler);\n<line69>                return saslServer;\n<line70>            } catch (SaslException e) {\n<line71>            }\n<line72>        }\n<line73>    }\n<line74>    return null;\n<line75>}","output":"<line1>{\n<line2>    if (subject != null) {\n<line3>        // server is using a JAAS-authenticated subject: determine service\n<line4>        // principal name and hostname from zk server's subject.\n<line5>        if (subject.getPrincipals().size() > 0) {\n<line6>            try {\n<line7>                final Object[] principals = subject.getPrincipals().toArray();\n<line8>                final Principal servicePrincipal = (Principal) principals[0];\n<line9>                // e.g. servicePrincipalNameAndHostname :=\n<line10>                // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line11>                final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line12>                int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line13>                // e.g. servicePrincipalName := \"zookeeper\"\n<line14>                final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line15>                // e.g. serviceHostnameAndKerbDomain :=\n<line16>                // \"myhost.foo.com@FOO.COM\"\n<line17>                final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line18>                indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line19>                // e.g. serviceHostname := \"myhost.foo.com\"\n<line20>                final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line21>                // TODO: should depend on zoo.cfg specified mechs, but if\n<line22>                // subject is non-null, it can be assumed to be GSSAPI.\n<line23>                final String mech = \"GSSAPI\";\n<line24>                LOG.debug(\"serviceHostname is '{}'\", serviceHostname);\n<line25>                LOG.debug(\"servicePrincipalName is '{}'\", servicePrincipalName);\n<line26>                LOG.debug(\"SASL mechanism(mech) is '{}'\", mech);\n<line27>                boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line28>                if (usingNativeJgss) {\n<line29>                    // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line30>                    // \"\"\"\n<line31>                    // In addition, when performing operations as a\n<line32>                    // particular\n<line33>                    // Subject, e.g. Subject.doAs(...) or\n<line34>                    // Subject.doAsPrivileged(...), the to-be-used\n<line35>                    // GSSCredential should be added to Subject's\n<line36>                    // private credential set. Otherwise, the GSS operations\n<line37>                    // will fail since no credential is found.\n<line38>                    // \"\"\"\n<line39>                    try {\n<line40>                        GSSManager manager = GSSManager.getInstance();\n<line41>                        Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line42>                        GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line43>                        GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line44>                        subject.getPrivateCredentials().add(cred);\n<line45>                        LOG.debug(\"Added private credential to service principal name: '{}', GSSCredential name: {}\", servicePrincipalName, cred.getName());\n<line46>                    } catch (GSSException ex) {\n<line47>                        LOG.warn(\"Cannot add private credential to subject; clients authentication may fail\", ex);\n<line48>                    }\n<line49>                }\n<line50>                try {\n<line51>                    return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line52>\n<line53>                        public SaslServer run() {\n<line54>                            try {\n<line55>                                SaslServer saslServer;\n<line56>                                saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line57>                                return saslServer;\n<line58>                            } catch (SaslException e) {\n<line59>                                LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line60>                                return null;\n<line61>                            }\n<line62>                        }\n<line63>                    });\n<line64>                } catch (PrivilegedActionException e) {\n<line65>                    // TODO: exit server at this point(?)\n<line66>                    LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context\", e);\n<line67>                }\n<line68>            } catch (IndexOutOfBoundsException e) {\n<line69>                LOG.error(\"server principal name/hostname determination error\", e);\n<line70>            }\n<line71>        } else {\n<line72>            // JAAS non-GSSAPI authentication: assuming and supporting only\n<line73>            // DIGEST-MD5 mechanism for now.\n<line74>            // TODO: use 'authMech=' value in zoo.cfg.\n<line75>            try {\n<line76>                SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\", protocol, serverName, null, callbackHandler);\n<line77>                return saslServer;\n<line78>            } catch (SaslException e) {\n<line79>                LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n<line80>            }\n<line81>        }\n<line82>    }\n<line83>    return null;\n<line84>}"},{"input":"","instruction":"<line1>{\n<line2>    // server is using a JAAS-authenticated subject: determine service\n<line3>    // principal name and hostname from zk server's subject.\n<line4>    if (subject.getPrincipals().size() > 0) {\n<line5>        try {\n<line6>            final Object[] principals = subject.getPrincipals().toArray();\n<line7>            final Principal servicePrincipal = (Principal) principals[0];\n<line8>            // e.g. servicePrincipalNameAndHostname :=\n<line9>            // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line10>            final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line11>            int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line12>            // e.g. servicePrincipalName := \"zookeeper\"\n<line13>            final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line14>            // e.g. serviceHostnameAndKerbDomain :=\n<line15>            // \"myhost.foo.com@FOO.COM\"\n<line16>            final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line17>            indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line18>            // e.g. serviceHostname := \"myhost.foo.com\"\n<line19>            final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line20>            // TODO: should depend on zoo.cfg specified mechs, but if\n<line21>            // subject is non-null, it can be assumed to be GSSAPI.\n<line22>            final String mech = \"GSSAPI\";\n<line23>            boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line24>            if (usingNativeJgss) {\n<line25>                // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line26>                // \"\"\"\n<line27>                // In addition, when performing operations as a\n<line28>                // particular\n<line29>                // Subject, e.g. Subject.doAs(...) or\n<line30>                // Subject.doAsPrivileged(...), the to-be-used\n<line31>                // GSSCredential should be added to Subject's\n<line32>                // private credential set. Otherwise, the GSS operations\n<line33>                // will fail since no credential is found.\n<line34>                // \"\"\"\n<line35>                try {\n<line36>                    GSSManager manager = GSSManager.getInstance();\n<line37>                    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line38>                    GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line39>                    GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line40>                    subject.getPrivateCredentials().add(cred);\n<line41>                } catch (GSSException ex) {\n<line42>                }\n<line43>            }\n<line44>            try {\n<line45>                return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line46>\n<line47>                    public SaslServer run() {\n<line48>                        try {\n<line49>                            SaslServer saslServer;\n<line50>                            saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line51>                            return saslServer;\n<line52>                        } catch (SaslException e) {\n<line53>                            return null;\n<line54>                        }\n<line55>                    }\n<line56>                });\n<line57>            } catch (PrivilegedActionException e) {\n<line58>                // TODO: exit server at this point(?)\n<line59>            }\n<line60>        } catch (IndexOutOfBoundsException e) {\n<line61>        }\n<line62>    } else {\n<line63>        // JAAS non-GSSAPI authentication: assuming and supporting only\n<line64>        // DIGEST-MD5 mechanism for now.\n<line65>        // TODO: use 'authMech=' value in zoo.cfg.\n<line66>        try {\n<line67>            SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\", protocol, serverName, null, callbackHandler);\n<line68>            return saslServer;\n<line69>        } catch (SaslException e) {\n<line70>        }\n<line71>    }\n<line72>}","output":"<line1>{\n<line2>    // server is using a JAAS-authenticated subject: determine service\n<line3>    // principal name and hostname from zk server's subject.\n<line4>    if (subject.getPrincipals().size() > 0) {\n<line5>        try {\n<line6>            final Object[] principals = subject.getPrincipals().toArray();\n<line7>            final Principal servicePrincipal = (Principal) principals[0];\n<line8>            // e.g. servicePrincipalNameAndHostname :=\n<line9>            // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line10>            final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line11>            int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line12>            // e.g. servicePrincipalName := \"zookeeper\"\n<line13>            final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line14>            // e.g. serviceHostnameAndKerbDomain :=\n<line15>            // \"myhost.foo.com@FOO.COM\"\n<line16>            final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line17>            indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line18>            // e.g. serviceHostname := \"myhost.foo.com\"\n<line19>            final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line20>            // TODO: should depend on zoo.cfg specified mechs, but if\n<line21>            // subject is non-null, it can be assumed to be GSSAPI.\n<line22>            final String mech = \"GSSAPI\";\n<line23>            LOG.debug(\"serviceHostname is '{}'\", serviceHostname);\n<line24>            LOG.debug(\"servicePrincipalName is '{}'\", servicePrincipalName);\n<line25>            LOG.debug(\"SASL mechanism(mech) is '{}'\", mech);\n<line26>            boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line27>            if (usingNativeJgss) {\n<line28>                // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line29>                // \"\"\"\n<line30>                // In addition, when performing operations as a\n<line31>                // particular\n<line32>                // Subject, e.g. Subject.doAs(...) or\n<line33>                // Subject.doAsPrivileged(...), the to-be-used\n<line34>                // GSSCredential should be added to Subject's\n<line35>                // private credential set. Otherwise, the GSS operations\n<line36>                // will fail since no credential is found.\n<line37>                // \"\"\"\n<line38>                try {\n<line39>                    GSSManager manager = GSSManager.getInstance();\n<line40>                    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line41>                    GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line42>                    GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line43>                    subject.getPrivateCredentials().add(cred);\n<line44>                    LOG.debug(\"Added private credential to service principal name: '{}', GSSCredential name: {}\", servicePrincipalName, cred.getName());\n<line45>                } catch (GSSException ex) {\n<line46>                    LOG.warn(\"Cannot add private credential to subject; clients authentication may fail\", ex);\n<line47>                }\n<line48>            }\n<line49>            try {\n<line50>                return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line51>\n<line52>                    public SaslServer run() {\n<line53>                        try {\n<line54>                            SaslServer saslServer;\n<line55>                            saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line56>                            return saslServer;\n<line57>                        } catch (SaslException e) {\n<line58>                            LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line59>                            return null;\n<line60>                        }\n<line61>                    }\n<line62>                });\n<line63>            } catch (PrivilegedActionException e) {\n<line64>                // TODO: exit server at this point(?)\n<line65>                LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context\", e);\n<line66>            }\n<line67>        } catch (IndexOutOfBoundsException e) {\n<line68>            LOG.error(\"server principal name/hostname determination error\", e);\n<line69>        }\n<line70>    } else {\n<line71>        // JAAS non-GSSAPI authentication: assuming and supporting only\n<line72>        // DIGEST-MD5 mechanism for now.\n<line73>        // TODO: use 'authMech=' value in zoo.cfg.\n<line74>        try {\n<line75>            SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\", protocol, serverName, null, callbackHandler);\n<line76>            return saslServer;\n<line77>        } catch (SaslException e) {\n<line78>            LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n<line79>        }\n<line80>    }\n<line81>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        final Object[] principals = subject.getPrincipals().toArray();\n<line4>        final Principal servicePrincipal = (Principal) principals[0];\n<line5>        // e.g. servicePrincipalNameAndHostname :=\n<line6>        // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line7>        final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line8>        int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line9>        // e.g. servicePrincipalName := \"zookeeper\"\n<line10>        final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line11>        // e.g. serviceHostnameAndKerbDomain :=\n<line12>        // \"myhost.foo.com@FOO.COM\"\n<line13>        final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line14>        indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line15>        // e.g. serviceHostname := \"myhost.foo.com\"\n<line16>        final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line17>        // TODO: should depend on zoo.cfg specified mechs, but if\n<line18>        // subject is non-null, it can be assumed to be GSSAPI.\n<line19>        final String mech = \"GSSAPI\";\n<line20>        boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line21>        if (usingNativeJgss) {\n<line22>            // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line23>            // \"\"\"\n<line24>            // In addition, when performing operations as a\n<line25>            // particular\n<line26>            // Subject, e.g. Subject.doAs(...) or\n<line27>            // Subject.doAsPrivileged(...), the to-be-used\n<line28>            // GSSCredential should be added to Subject's\n<line29>            // private credential set. Otherwise, the GSS operations\n<line30>            // will fail since no credential is found.\n<line31>            // \"\"\"\n<line32>            try {\n<line33>                GSSManager manager = GSSManager.getInstance();\n<line34>                Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line35>                GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line36>                GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line37>                subject.getPrivateCredentials().add(cred);\n<line38>            } catch (GSSException ex) {\n<line39>            }\n<line40>        }\n<line41>        try {\n<line42>            return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line43>\n<line44>                public SaslServer run() {\n<line45>                    try {\n<line46>                        SaslServer saslServer;\n<line47>                        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line48>                        return saslServer;\n<line49>                    } catch (SaslException e) {\n<line50>                        return null;\n<line51>                    }\n<line52>                }\n<line53>            });\n<line54>        } catch (PrivilegedActionException e) {\n<line55>            // TODO: exit server at this point(?)\n<line56>        }\n<line57>    } catch (IndexOutOfBoundsException e) {\n<line58>    }\n<line59>}","output":"<line1>{\n<line2>    try {\n<line3>        final Object[] principals = subject.getPrincipals().toArray();\n<line4>        final Principal servicePrincipal = (Principal) principals[0];\n<line5>        // e.g. servicePrincipalNameAndHostname :=\n<line6>        // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line7>        final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line8>        int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line9>        // e.g. servicePrincipalName := \"zookeeper\"\n<line10>        final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line11>        // e.g. serviceHostnameAndKerbDomain :=\n<line12>        // \"myhost.foo.com@FOO.COM\"\n<line13>        final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line14>        indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line15>        // e.g. serviceHostname := \"myhost.foo.com\"\n<line16>        final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line17>        // TODO: should depend on zoo.cfg specified mechs, but if\n<line18>        // subject is non-null, it can be assumed to be GSSAPI.\n<line19>        final String mech = \"GSSAPI\";\n<line20>        LOG.debug(\"serviceHostname is '{}'\", serviceHostname);\n<line21>        LOG.debug(\"servicePrincipalName is '{}'\", servicePrincipalName);\n<line22>        LOG.debug(\"SASL mechanism(mech) is '{}'\", mech);\n<line23>        boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line24>        if (usingNativeJgss) {\n<line25>            // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line26>            // \"\"\"\n<line27>            // In addition, when performing operations as a\n<line28>            // particular\n<line29>            // Subject, e.g. Subject.doAs(...) or\n<line30>            // Subject.doAsPrivileged(...), the to-be-used\n<line31>            // GSSCredential should be added to Subject's\n<line32>            // private credential set. Otherwise, the GSS operations\n<line33>            // will fail since no credential is found.\n<line34>            // \"\"\"\n<line35>            try {\n<line36>                GSSManager manager = GSSManager.getInstance();\n<line37>                Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line38>                GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line39>                GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line40>                subject.getPrivateCredentials().add(cred);\n<line41>                LOG.debug(\"Added private credential to service principal name: '{}', GSSCredential name: {}\", servicePrincipalName, cred.getName());\n<line42>            } catch (GSSException ex) {\n<line43>                LOG.warn(\"Cannot add private credential to subject; clients authentication may fail\", ex);\n<line44>            }\n<line45>        }\n<line46>        try {\n<line47>            return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line48>\n<line49>                public SaslServer run() {\n<line50>                    try {\n<line51>                        SaslServer saslServer;\n<line52>                        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line53>                        return saslServer;\n<line54>                    } catch (SaslException e) {\n<line55>                        LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line56>                        return null;\n<line57>                    }\n<line58>                }\n<line59>            });\n<line60>        } catch (PrivilegedActionException e) {\n<line61>            // TODO: exit server at this point(?)\n<line62>            LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context\", e);\n<line63>        }\n<line64>    } catch (IndexOutOfBoundsException e) {\n<line65>        LOG.error(\"server principal name/hostname determination error\", e);\n<line66>    }\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    final Object[] principals = subject.getPrincipals().toArray();\n<line3>    final Principal servicePrincipal = (Principal) principals[0];\n<line4>    // e.g. servicePrincipalNameAndHostname :=\n<line5>    // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line6>    final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line7>    int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line8>    // e.g. servicePrincipalName := \"zookeeper\"\n<line9>    final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line10>    // e.g. serviceHostnameAndKerbDomain :=\n<line11>    // \"myhost.foo.com@FOO.COM\"\n<line12>    final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line13>    indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line14>    // e.g. serviceHostname := \"myhost.foo.com\"\n<line15>    final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line16>    // TODO: should depend on zoo.cfg specified mechs, but if\n<line17>    // subject is non-null, it can be assumed to be GSSAPI.\n<line18>    final String mech = \"GSSAPI\";\n<line19>    boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line20>    if (usingNativeJgss) {\n<line21>        // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line22>        // \"\"\"\n<line23>        // In addition, when performing operations as a\n<line24>        // particular\n<line25>        // Subject, e.g. Subject.doAs(...) or\n<line26>        // Subject.doAsPrivileged(...), the to-be-used\n<line27>        // GSSCredential should be added to Subject's\n<line28>        // private credential set. Otherwise, the GSS operations\n<line29>        // will fail since no credential is found.\n<line30>        // \"\"\"\n<line31>        try {\n<line32>            GSSManager manager = GSSManager.getInstance();\n<line33>            Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line34>            GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line35>            GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line36>            subject.getPrivateCredentials().add(cred);\n<line37>        } catch (GSSException ex) {\n<line38>        }\n<line39>    }\n<line40>    try {\n<line41>        return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line42>\n<line43>            public SaslServer run() {\n<line44>                try {\n<line45>                    SaslServer saslServer;\n<line46>                    saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line47>                    return saslServer;\n<line48>                } catch (SaslException e) {\n<line49>                    return null;\n<line50>                }\n<line51>            }\n<line52>        });\n<line53>    } catch (PrivilegedActionException e) {\n<line54>        // TODO: exit server at this point(?)\n<line55>    }\n<line56>}","output":"<line1>{\n<line2>    final Object[] principals = subject.getPrincipals().toArray();\n<line3>    final Principal servicePrincipal = (Principal) principals[0];\n<line4>    // e.g. servicePrincipalNameAndHostname :=\n<line5>    // \"zookeeper/myhost.foo.com@FOO.COM\"\n<line6>    final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n<line7>    int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n<line8>    // e.g. servicePrincipalName := \"zookeeper\"\n<line9>    final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n<line10>    // e.g. serviceHostnameAndKerbDomain :=\n<line11>    // \"myhost.foo.com@FOO.COM\"\n<line12>    final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);\n<line13>    indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n<line14>    // e.g. serviceHostname := \"myhost.foo.com\"\n<line15>    final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);\n<line16>    // TODO: should depend on zoo.cfg specified mechs, but if\n<line17>    // subject is non-null, it can be assumed to be GSSAPI.\n<line18>    final String mech = \"GSSAPI\";\n<line19>    LOG.debug(\"serviceHostname is '{}'\", serviceHostname);\n<line20>    LOG.debug(\"servicePrincipalName is '{}'\", servicePrincipalName);\n<line21>    LOG.debug(\"SASL mechanism(mech) is '{}'\", mech);\n<line22>    boolean usingNativeJgss = Boolean.getBoolean(\"sun.security.jgss.native\");\n<line23>    if (usingNativeJgss) {\n<line24>        // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line25>        // \"\"\"\n<line26>        // In addition, when performing operations as a\n<line27>        // particular\n<line28>        // Subject, e.g. Subject.doAs(...) or\n<line29>        // Subject.doAsPrivileged(...), the to-be-used\n<line30>        // GSSCredential should be added to Subject's\n<line31>        // private credential set. Otherwise, the GSS operations\n<line32>        // will fail since no credential is found.\n<line33>        // \"\"\"\n<line34>        try {\n<line35>            GSSManager manager = GSSManager.getInstance();\n<line36>            Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line37>            GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line38>            GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line39>            subject.getPrivateCredentials().add(cred);\n<line40>            LOG.debug(\"Added private credential to service principal name: '{}', GSSCredential name: {}\", servicePrincipalName, cred.getName());\n<line41>        } catch (GSSException ex) {\n<line42>            LOG.warn(\"Cannot add private credential to subject; clients authentication may fail\", ex);\n<line43>        }\n<line44>    }\n<line45>    try {\n<line46>        return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line47>\n<line48>            public SaslServer run() {\n<line49>                try {\n<line50>                    SaslServer saslServer;\n<line51>                    saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line52>                    return saslServer;\n<line53>                } catch (SaslException e) {\n<line54>                    LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line55>                    return null;\n<line56>                }\n<line57>            }\n<line58>        });\n<line59>    } catch (PrivilegedActionException e) {\n<line60>        // TODO: exit server at this point(?)\n<line61>        LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context\", e);\n<line62>    }\n<line63>}"},{"input":"","instruction":"<line1>{\n<line2>    // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line3>    // \"\"\"\n<line4>    // In addition, when performing operations as a\n<line5>    // particular\n<line6>    // Subject, e.g. Subject.doAs(...) or\n<line7>    // Subject.doAsPrivileged(...), the to-be-used\n<line8>    // GSSCredential should be added to Subject's\n<line9>    // private credential set. Otherwise, the GSS operations\n<line10>    // will fail since no credential is found.\n<line11>    // \"\"\"\n<line12>    try {\n<line13>        GSSManager manager = GSSManager.getInstance();\n<line14>        Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line15>        GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line16>        GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line17>        subject.getPrivateCredentials().add(cred);\n<line18>    } catch (GSSException ex) {\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n<line3>    // \"\"\"\n<line4>    // In addition, when performing operations as a\n<line5>    // particular\n<line6>    // Subject, e.g. Subject.doAs(...) or\n<line7>    // Subject.doAsPrivileged(...), the to-be-used\n<line8>    // GSSCredential should be added to Subject's\n<line9>    // private credential set. Otherwise, the GSS operations\n<line10>    // will fail since no credential is found.\n<line11>    // \"\"\"\n<line12>    try {\n<line13>        GSSManager manager = GSSManager.getInstance();\n<line14>        Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line15>        GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line16>        GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line17>        subject.getPrivateCredentials().add(cred);\n<line18>        LOG.debug(\"Added private credential to service principal name: '{}', GSSCredential name: {}\", servicePrincipalName, cred.getName());\n<line19>    } catch (GSSException ex) {\n<line20>        LOG.warn(\"Cannot add private credential to subject; clients authentication may fail\", ex);\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    GSSManager manager = GSSManager.getInstance();\n<line3>    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line4>    GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line5>    GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line6>    subject.getPrivateCredentials().add(cred);\n<line7>}","output":"<line1>{\n<line2>    GSSManager manager = GSSManager.getInstance();\n<line3>    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n<line4>    GSSName gssName = manager.createName(servicePrincipalName + \"@\" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);\n<line5>    GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n<line6>    subject.getPrivateCredentials().add(cred);\n<line7>    LOG.debug(\"Added private credential to service principal name: '{}', GSSCredential name: {}\", servicePrincipalName, cred.getName());\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line3>\n<line4>        public SaslServer run() {\n<line5>            try {\n<line6>                SaslServer saslServer;\n<line7>                saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line8>                return saslServer;\n<line9>            } catch (SaslException e) {\n<line10>                return null;\n<line11>            }\n<line12>        }\n<line13>    });\n<line14>}","output":"<line1>{\n<line2>    return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n<line3>\n<line4>        public SaslServer run() {\n<line5>            try {\n<line6>                SaslServer saslServer;\n<line7>                saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line8>                return saslServer;\n<line9>            } catch (SaslException e) {\n<line10>                LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line11>                return null;\n<line12>            }\n<line13>        }\n<line14>    });\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        SaslServer saslServer;\n<line4>        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line5>        return saslServer;\n<line6>    } catch (SaslException e) {\n<line7>        return null;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        SaslServer saslServer;\n<line4>        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);\n<line5>        return saslServer;\n<line6>    } catch (SaslException e) {\n<line7>        LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line8>        return null;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation\", e);\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // TODO: exit server at this point(?)\n<line3>}","output":"<line1>{\n<line2>    // TODO: exit server at this point(?)\n<line3>    LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"server principal name/hostname determination error\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // JAAS non-GSSAPI authentication: assuming and supporting only\n<line3>    // DIGEST-MD5 mechanism for now.\n<line4>    // TODO: use 'authMech=' value in zoo.cfg.\n<line5>    try {\n<line6>        SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\", protocol, serverName, null, callbackHandler);\n<line7>        return saslServer;\n<line8>    } catch (SaslException e) {\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    // JAAS non-GSSAPI authentication: assuming and supporting only\n<line3>    // DIGEST-MD5 mechanism for now.\n<line4>    // TODO: use 'authMech=' value in zoo.cfg.\n<line5>    try {\n<line6>        SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\", protocol, serverName, null, callbackHandler);\n<line7>        return saslServer;\n<line8>    } catch (SaslException e) {\n<line9>        LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Objects.requireNonNull(e);\n<line3>    final ReentrantLock lock = this.lock;\n<line4>    lock.lock();\n<line5>    try {\n<line6>        if (this.queue.size() == this.maxSize) {\n<line7>            final E discard = this.queue.remove();\n<line8>            this.droppedCount++;\n<line9>        }\n<line10>        this.queue.add(e);\n<line11>        this.notEmpty.signal();\n<line12>    } finally {\n<line13>        lock.unlock();\n<line14>    }\n<line15>    return true;\n<line16>}","output":"<line1>{\n<line2>    Objects.requireNonNull(e);\n<line3>    final ReentrantLock lock = this.lock;\n<line4>    lock.lock();\n<line5>    try {\n<line6>        if (this.queue.size() == this.maxSize) {\n<line7>            final E discard = this.queue.remove();\n<line8>            this.droppedCount++;\n<line9>            LOG.debug(\"Queue is full. Discarding oldest element [count={}]: {}\", this.droppedCount, discard);\n<line10>        }\n<line11>        this.queue.add(e);\n<line12>        this.notEmpty.signal();\n<line13>    } finally {\n<line14>        lock.unlock();\n<line15>    }\n<line16>    return true;\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    if (this.queue.size() == this.maxSize) {\n<line3>        final E discard = this.queue.remove();\n<line4>        this.droppedCount++;\n<line5>    }\n<line6>    this.queue.add(e);\n<line7>    this.notEmpty.signal();\n<line8>}","output":"<line1>{\n<line2>    if (this.queue.size() == this.maxSize) {\n<line3>        final E discard = this.queue.remove();\n<line4>        this.droppedCount++;\n<line5>        LOG.debug(\"Queue is full. Discarding oldest element [count={}]: {}\", this.droppedCount, discard);\n<line6>    }\n<line7>    this.queue.add(e);\n<line8>    this.notEmpty.signal();\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    final E discard = this.queue.remove();\n<line3>    this.droppedCount++;\n<line4>}","output":"<line1>{\n<line2>    final E discard = this.queue.remove();\n<line3>    this.droppedCount++;\n<line4>    LOG.debug(\"Queue is full. Discarding oldest element [count={}]: {}\", this.droppedCount, discard);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (outgoingQueue.isEmpty()) {\n<line3>        return null;\n<line4>    }\n<line5>    // If we've already starting sending the first packet, we better finish\n<line6>    if (outgoingQueue.getFirst().bb != null || !tunneledAuthInProgres) {\n<line7>        return outgoingQueue.getFirst();\n<line8>    }\n<line9>    // Since client's authentication with server is in progress,\n<line10>    // send only the null-header packet queued by primeConnection().\n<line11>    // This packet must be sent so that the SASL authentication process\n<line12>    // can proceed, but all other packets should wait until\n<line13>    // SASL authentication completes.\n<line14>    Iterator<Packet> iter = outgoingQueue.iterator();\n<line15>    while (iter.hasNext()) {\n<line16>        Packet p = iter.next();\n<line17>        if (p.requestHeader == null) {\n<line18>            // We've found the priming-packet. Move it to the beginning of the queue.\n<line19>            iter.remove();\n<line20>            outgoingQueue.addFirst(p);\n<line21>            return p;\n<line22>        } else {\n<line23>            // Non-priming packet: defer it until later, leaving it in the queue\n<line24>            // until authentication completes.\n<line25>        }\n<line26>    }\n<line27>    return null;\n<line28>}","output":"<line1>{\n<line2>    if (outgoingQueue.isEmpty()) {\n<line3>        return null;\n<line4>    }\n<line5>    // If we've already starting sending the first packet, we better finish\n<line6>    if (outgoingQueue.getFirst().bb != null || !tunneledAuthInProgres) {\n<line7>        return outgoingQueue.getFirst();\n<line8>    }\n<line9>    // Since client's authentication with server is in progress,\n<line10>    // send only the null-header packet queued by primeConnection().\n<line11>    // This packet must be sent so that the SASL authentication process\n<line12>    // can proceed, but all other packets should wait until\n<line13>    // SASL authentication completes.\n<line14>    Iterator<Packet> iter = outgoingQueue.iterator();\n<line15>    while (iter.hasNext()) {\n<line16>        Packet p = iter.next();\n<line17>        if (p.requestHeader == null) {\n<line18>            // We've found the priming-packet. Move it to the beginning of the queue.\n<line19>            iter.remove();\n<line20>            outgoingQueue.addFirst(p);\n<line21>            return p;\n<line22>        } else {\n<line23>            // Non-priming packet: defer it until later, leaving it in the queue\n<line24>            // until authentication completes.\n<line25>            LOG.debug(\"Deferring non-priming packet {} until SASL authentication completes.\", p);\n<line26>        }\n<line27>    }\n<line28>    return null;\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    Packet p = iter.next();\n<line3>    if (p.requestHeader == null) {\n<line4>        // We've found the priming-packet. Move it to the beginning of the queue.\n<line5>        iter.remove();\n<line6>        outgoingQueue.addFirst(p);\n<line7>        return p;\n<line8>    } else {\n<line9>        // Non-priming packet: defer it until later, leaving it in the queue\n<line10>        // until authentication completes.\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    Packet p = iter.next();\n<line3>    if (p.requestHeader == null) {\n<line4>        // We've found the priming-packet. Move it to the beginning of the queue.\n<line5>        iter.remove();\n<line6>        outgoingQueue.addFirst(p);\n<line7>        return p;\n<line8>    } else {\n<line9>        // Non-priming packet: defer it until later, leaving it in the queue\n<line10>        // until authentication completes.\n<line11>        LOG.debug(\"Deferring non-priming packet {} until SASL authentication completes.\", p);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    // Non-priming packet: defer it until later, leaving it in the queue\n<line3>    // until authentication completes.\n<line4>}","output":"<line1>{\n<line2>    // Non-priming packet: defer it until later, leaving it in the queue\n<line3>    // until authentication completes.\n<line4>    LOG.debug(\"Deferring non-priming packet {} until SASL authentication completes.\", p);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sockKey != null) {\n<line3>        SocketChannel sock = (SocketChannel) sockKey.channel();\n<line4>        sockKey.cancel();\n<line5>        try {\n<line6>            sock.socket().shutdownInput();\n<line7>        } catch (IOException e) {\n<line8>        }\n<line9>        try {\n<line10>            sock.socket().shutdownOutput();\n<line11>        } catch (IOException e) {\n<line12>        }\n<line13>        try {\n<line14>            sock.socket().close();\n<line15>        } catch (IOException e) {\n<line16>        }\n<line17>        try {\n<line18>            sock.close();\n<line19>        } catch (IOException e) {\n<line20>        }\n<line21>    }\n<line22>    try {\n<line23>        Thread.sleep(100);\n<line24>    } catch (InterruptedException e) {\n<line25>    }\n<line26>    sockKey = null;\n<line27>}","output":"<line1>{\n<line2>    if (sockKey != null) {\n<line3>        SocketChannel sock = (SocketChannel) sockKey.channel();\n<line4>        sockKey.cancel();\n<line5>        try {\n<line6>            sock.socket().shutdownInput();\n<line7>        } catch (IOException e) {\n<line8>            LOG.debug(\"Ignoring exception during shutdown input\", e);\n<line9>        }\n<line10>        try {\n<line11>            sock.socket().shutdownOutput();\n<line12>        } catch (IOException e) {\n<line13>            LOG.debug(\"Ignoring exception during shutdown output\", e);\n<line14>        }\n<line15>        try {\n<line16>            sock.socket().close();\n<line17>        } catch (IOException e) {\n<line18>            LOG.debug(\"Ignoring exception during socket close\", e);\n<line19>        }\n<line20>        try {\n<line21>            sock.close();\n<line22>        } catch (IOException e) {\n<line23>            LOG.debug(\"Ignoring exception during channel close\", e);\n<line24>        }\n<line25>    }\n<line26>    try {\n<line27>        Thread.sleep(100);\n<line28>    } catch (InterruptedException e) {\n<line29>        LOG.debug(\"SendThread interrupted during sleep, ignoring\");\n<line30>    }\n<line31>    sockKey = null;\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    SocketChannel sock = (SocketChannel) sockKey.channel();\n<line3>    sockKey.cancel();\n<line4>    try {\n<line5>        sock.socket().shutdownInput();\n<line6>    } catch (IOException e) {\n<line7>    }\n<line8>    try {\n<line9>        sock.socket().shutdownOutput();\n<line10>    } catch (IOException e) {\n<line11>    }\n<line12>    try {\n<line13>        sock.socket().close();\n<line14>    } catch (IOException e) {\n<line15>    }\n<line16>    try {\n<line17>        sock.close();\n<line18>    } catch (IOException e) {\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    SocketChannel sock = (SocketChannel) sockKey.channel();\n<line3>    sockKey.cancel();\n<line4>    try {\n<line5>        sock.socket().shutdownInput();\n<line6>    } catch (IOException e) {\n<line7>        LOG.debug(\"Ignoring exception during shutdown input\", e);\n<line8>    }\n<line9>    try {\n<line10>        sock.socket().shutdownOutput();\n<line11>    } catch (IOException e) {\n<line12>        LOG.debug(\"Ignoring exception during shutdown output\", e);\n<line13>    }\n<line14>    try {\n<line15>        sock.socket().close();\n<line16>    } catch (IOException e) {\n<line17>        LOG.debug(\"Ignoring exception during socket close\", e);\n<line18>    }\n<line19>    try {\n<line20>        sock.close();\n<line21>    } catch (IOException e) {\n<line22>        LOG.debug(\"Ignoring exception during channel close\", e);\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring exception during shutdown input\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring exception during shutdown output\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring exception during socket close\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring exception during channel close\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"SendThread interrupted during sleep, ignoring\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    SocketChannel sock = createSock();\n<line3>    try {\n<line4>        registerAndConnect(sock, addr);\n<line5>    } catch (UnresolvedAddressException | UnsupportedAddressTypeException | SecurityException | IOException e) {\n<line6>        sock.close();\n<line7>        throw e;\n<line8>    }\n<line9>    initialized = false;\n<line10>    /*\n<line11>         * Reset incomingBuffer\n<line12>         */\n<line13>    lenBuffer.clear();\n<line14>    incomingBuffer = lenBuffer;\n<line15>}","output":"<line1>{\n<line2>    SocketChannel sock = createSock();\n<line3>    try {\n<line4>        registerAndConnect(sock, addr);\n<line5>    } catch (UnresolvedAddressException | UnsupportedAddressTypeException | SecurityException | IOException e) {\n<line6>        LOG.error(\"Unable to open socket to {}\", addr);\n<line7>        sock.close();\n<line8>        throw e;\n<line9>    }\n<line10>    initialized = false;\n<line11>    /*\n<line12>         * Reset incomingBuffer\n<line13>         */\n<line14>    lenBuffer.clear();\n<line15>    incomingBuffer = lenBuffer;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    sock.close();\n<line3>    throw e;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to open socket to {}\", addr);\n<line3>    sock.close();\n<line4>    throw e;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // sockKey may be concurrently accessed by multiple\n<line3>    // threads. We use tmp here to avoid a race condition\n<line4>    SelectionKey tmp = sockKey;\n<line5>    if (tmp != null) {\n<line6>        ((SocketChannel) tmp.channel()).socket().close();\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.info(\"testableCloseSocket() called\");\n<line3>    // sockKey may be concurrently accessed by multiple\n<line4>    // threads. We use tmp here to avoid a race condition\n<line5>    SelectionKey tmp = sockKey;\n<line6>    if (tmp != null) {\n<line7>        ((SocketChannel) tmp.channel()).socket().close();\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    switch(flag) {\n<line3>        case 0:\n<line4>            return CreateMode.PERSISTENT;\n<line5>        case 1:\n<line6>            return CreateMode.EPHEMERAL;\n<line7>        case 2:\n<line8>            return CreateMode.PERSISTENT_SEQUENTIAL;\n<line9>        case 3:\n<line10>            return CreateMode.EPHEMERAL_SEQUENTIAL;\n<line11>        case 4:\n<line12>            return CreateMode.CONTAINER;\n<line13>        case 5:\n<line14>            return CreateMode.PERSISTENT_WITH_TTL;\n<line15>        case 6:\n<line16>            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;\n<line17>        default:\n<line18>            String errMsg = \"Received an invalid flag value: \" + flag + \" to convert to a CreateMode\";\n<line19>            throw new KeeperException.BadArgumentsException(errMsg);\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    switch(flag) {\n<line3>        case 0:\n<line4>            return CreateMode.PERSISTENT;\n<line5>        case 1:\n<line6>            return CreateMode.EPHEMERAL;\n<line7>        case 2:\n<line8>            return CreateMode.PERSISTENT_SEQUENTIAL;\n<line9>        case 3:\n<line10>            return CreateMode.EPHEMERAL_SEQUENTIAL;\n<line11>        case 4:\n<line12>            return CreateMode.CONTAINER;\n<line13>        case 5:\n<line14>            return CreateMode.PERSISTENT_WITH_TTL;\n<line15>        case 6:\n<line16>            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;\n<line17>        default:\n<line18>            String errMsg = \"Received an invalid flag value: \" + flag + \" to convert to a CreateMode\";\n<line19>            LOG.error(errMsg);\n<line20>            throw new KeeperException.BadArgumentsException(errMsg);\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    if (path == null) {\n<line3>        return;\n<line4>    }\n<line5>    if (!bean.isHidden()) {\n<line6>        final ObjectName objName = makeObjectName(path, bean);\n<line7>        synchronized (LOCK) {\n<line8>            mBeanServer.unregisterMBean(objName);\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    if (path == null) {\n<line3>        return;\n<line4>    }\n<line5>    if (!bean.isHidden()) {\n<line6>        final ObjectName objName = makeObjectName(path, bean);\n<line7>        LOG.debug(\"Unregister MBean [{}]\", objName);\n<line8>        synchronized (LOCK) {\n<line9>            mBeanServer.unregisterMBean(objName);\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    final ObjectName objName = makeObjectName(path, bean);\n<line3>    synchronized (LOCK) {\n<line4>        mBeanServer.unregisterMBean(objName);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    final ObjectName objName = makeObjectName(path, bean);\n<line3>    LOG.debug(\"Unregister MBean [{}]\", objName);\n<line4>    synchronized (LOCK) {\n<line5>        mBeanServer.unregisterMBean(objName);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bean == null) {\n<line3>        return;\n<line4>    }\n<line5>    String path = mapBean2Path.remove(bean);\n<line6>    try {\n<line7>        unregister(path, bean);\n<line8>    } catch (JMException e) {\n<line9>    } catch (Throwable t) {\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    if (bean == null) {\n<line3>        return;\n<line4>    }\n<line5>    String path = mapBean2Path.remove(bean);\n<line6>    try {\n<line7>        unregister(path, bean);\n<line8>    } catch (JMException e) {\n<line9>        LOG.warn(\"Error during unregister of [{}]\", bean.getName(), e);\n<line10>    } catch (Throwable t) {\n<line11>        LOG.error(\"Unexpected exception during unregister of [{}]. It should be reviewed and fixed.\", bean.getName(), t);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception during unregister of [{}]. It should be reviewed and fixed.\", bean.getName(), t);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean enabled = false;\n<line3>    if (Boolean.getBoolean(\"zookeeper.jmx.log4j.disable\")) {\n<line4>    } else {\n<line5>        try {\n<line6>            Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\");\n<line7>            enabled = true;\n<line8>        } catch (ClassNotFoundException e) {\n<line9>        }\n<line10>    }\n<line11>    return enabled;\n<line12>}","output":"<line1>{\n<line2>    boolean enabled = false;\n<line3>    if (Boolean.getBoolean(\"zookeeper.jmx.log4j.disable\")) {\n<line4>        LOG.info(\"Log4j 1.2 jmx support is disabled by property.\");\n<line5>    } else {\n<line6>        try {\n<line7>            Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\");\n<line8>            enabled = true;\n<line9>            LOG.info(\"Log4j 1.2 jmx support found and enabled.\");\n<line10>        } catch (ClassNotFoundException e) {\n<line11>            LOG.info(\"Log4j 1.2 jmx support not found; jmx disabled.\");\n<line12>        }\n<line13>    }\n<line14>    return enabled;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Log4j 1.2 jmx support is disabled by property.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\");\n<line4>        enabled = true;\n<line5>    } catch (ClassNotFoundException e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\");\n<line4>        enabled = true;\n<line5>        LOG.info(\"Log4j 1.2 jmx support found and enabled.\");\n<line6>    } catch (ClassNotFoundException e) {\n<line7>        LOG.info(\"Log4j 1.2 jmx support not found; jmx disabled.\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\");\n<line3>    enabled = true;\n<line4>}","output":"<line1>{\n<line2>    Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\");\n<line3>    enabled = true;\n<line4>    LOG.info(\"Log4j 1.2 jmx support found and enabled.\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Log4j 1.2 jmx support not found; jmx disabled.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (isLog4jJmxEnabled()) {\n<line3>        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n<line4>        try {\n<line5>            // Create and Register the top level Log4J MBean\n<line6>            // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();\n<line7>            Object hdm = Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\").getConstructor().newInstance();\n<line8>            String mbean = System.getProperty(\"zookeeper.jmx.log4j.mbean\", \"log4j:hierarchy=default\");\n<line9>            ObjectName mbo = new ObjectName(mbean);\n<line10>            mbs.registerMBean(hdm, mbo);\n<line11>            // Add the root logger to the Hierarchy MBean\n<line12>            // org.apache.log4j.Logger rootLogger =\n<line13>            // org.apache.log4j.Logger.getRootLogger();\n<line14>            Object rootLogger = Class.forName(\"org.apache.log4j.Logger\").getMethod(\"getRootLogger\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line15>            // hdm.addLoggerMBean(rootLogger.getName());\n<line16>            Object rootLoggerName = rootLogger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);\n<line17>            hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, rootLoggerName);\n<line18>            // Get each logger from the Log4J Repository and add it to the\n<line19>            // Hierarchy MBean created above.\n<line20>            // org.apache.log4j.spi.LoggerRepository r =\n<line21>            // org.apache.log4j.LogManager.getLoggerRepository();\n<line22>            Object r = Class.forName(\"org.apache.log4j.LogManager\").getMethod(\"getLoggerRepository\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line23>            // Enumeration enumer = r.getCurrentLoggers();\n<line24>            Enumeration enumer = (Enumeration) r.getClass().getMethod(\"getCurrentLoggers\", (Class<?>[]) null).invoke(r, (Object[]) null);\n<line25>            while (enumer.hasMoreElements()) {\n<line26>                Object logger = enumer.nextElement();\n<line27>                // hdm.addLoggerMBean(logger.getName());\n<line28>                Object loggerName = logger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(logger, (Object[]) null);\n<line29>                hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, loggerName);\n<line30>            }\n<line31>        } catch (Exception e) {\n<line32>            throw new JMException(e.toString());\n<line33>        }\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    if (isLog4jJmxEnabled()) {\n<line3>        LOG.debug(\"registerLog4jMBeans()\");\n<line4>        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n<line5>        try {\n<line6>            // Create and Register the top level Log4J MBean\n<line7>            // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();\n<line8>            Object hdm = Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\").getConstructor().newInstance();\n<line9>            String mbean = System.getProperty(\"zookeeper.jmx.log4j.mbean\", \"log4j:hierarchy=default\");\n<line10>            ObjectName mbo = new ObjectName(mbean);\n<line11>            mbs.registerMBean(hdm, mbo);\n<line12>            // Add the root logger to the Hierarchy MBean\n<line13>            // org.apache.log4j.Logger rootLogger =\n<line14>            // org.apache.log4j.Logger.getRootLogger();\n<line15>            Object rootLogger = Class.forName(\"org.apache.log4j.Logger\").getMethod(\"getRootLogger\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line16>            // hdm.addLoggerMBean(rootLogger.getName());\n<line17>            Object rootLoggerName = rootLogger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);\n<line18>            hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, rootLoggerName);\n<line19>            // Get each logger from the Log4J Repository and add it to the\n<line20>            // Hierarchy MBean created above.\n<line21>            // org.apache.log4j.spi.LoggerRepository r =\n<line22>            // org.apache.log4j.LogManager.getLoggerRepository();\n<line23>            Object r = Class.forName(\"org.apache.log4j.LogManager\").getMethod(\"getLoggerRepository\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line24>            // Enumeration enumer = r.getCurrentLoggers();\n<line25>            Enumeration enumer = (Enumeration) r.getClass().getMethod(\"getCurrentLoggers\", (Class<?>[]) null).invoke(r, (Object[]) null);\n<line26>            while (enumer.hasMoreElements()) {\n<line27>                Object logger = enumer.nextElement();\n<line28>                // hdm.addLoggerMBean(logger.getName());\n<line29>                Object loggerName = logger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(logger, (Object[]) null);\n<line30>                hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, loggerName);\n<line31>            }\n<line32>        } catch (Exception e) {\n<line33>            LOG.error(\"Problems while registering log4j 1.2 jmx beans!\", e);\n<line34>            throw new JMException(e.toString());\n<line35>        }\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n<line3>    try {\n<line4>        // Create and Register the top level Log4J MBean\n<line5>        // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();\n<line6>        Object hdm = Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\").getConstructor().newInstance();\n<line7>        String mbean = System.getProperty(\"zookeeper.jmx.log4j.mbean\", \"log4j:hierarchy=default\");\n<line8>        ObjectName mbo = new ObjectName(mbean);\n<line9>        mbs.registerMBean(hdm, mbo);\n<line10>        // Add the root logger to the Hierarchy MBean\n<line11>        // org.apache.log4j.Logger rootLogger =\n<line12>        // org.apache.log4j.Logger.getRootLogger();\n<line13>        Object rootLogger = Class.forName(\"org.apache.log4j.Logger\").getMethod(\"getRootLogger\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line14>        // hdm.addLoggerMBean(rootLogger.getName());\n<line15>        Object rootLoggerName = rootLogger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);\n<line16>        hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, rootLoggerName);\n<line17>        // Get each logger from the Log4J Repository and add it to the\n<line18>        // Hierarchy MBean created above.\n<line19>        // org.apache.log4j.spi.LoggerRepository r =\n<line20>        // org.apache.log4j.LogManager.getLoggerRepository();\n<line21>        Object r = Class.forName(\"org.apache.log4j.LogManager\").getMethod(\"getLoggerRepository\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line22>        // Enumeration enumer = r.getCurrentLoggers();\n<line23>        Enumeration enumer = (Enumeration) r.getClass().getMethod(\"getCurrentLoggers\", (Class<?>[]) null).invoke(r, (Object[]) null);\n<line24>        while (enumer.hasMoreElements()) {\n<line25>            Object logger = enumer.nextElement();\n<line26>            // hdm.addLoggerMBean(logger.getName());\n<line27>            Object loggerName = logger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(logger, (Object[]) null);\n<line28>            hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, loggerName);\n<line29>        }\n<line30>    } catch (Exception e) {\n<line31>        throw new JMException(e.toString());\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    LOG.debug(\"registerLog4jMBeans()\");\n<line3>    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();\n<line4>    try {\n<line5>        // Create and Register the top level Log4J MBean\n<line6>        // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();\n<line7>        Object hdm = Class.forName(\"org.apache.log4j.jmx.HierarchyDynamicMBean\").getConstructor().newInstance();\n<line8>        String mbean = System.getProperty(\"zookeeper.jmx.log4j.mbean\", \"log4j:hierarchy=default\");\n<line9>        ObjectName mbo = new ObjectName(mbean);\n<line10>        mbs.registerMBean(hdm, mbo);\n<line11>        // Add the root logger to the Hierarchy MBean\n<line12>        // org.apache.log4j.Logger rootLogger =\n<line13>        // org.apache.log4j.Logger.getRootLogger();\n<line14>        Object rootLogger = Class.forName(\"org.apache.log4j.Logger\").getMethod(\"getRootLogger\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line15>        // hdm.addLoggerMBean(rootLogger.getName());\n<line16>        Object rootLoggerName = rootLogger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);\n<line17>        hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, rootLoggerName);\n<line18>        // Get each logger from the Log4J Repository and add it to the\n<line19>        // Hierarchy MBean created above.\n<line20>        // org.apache.log4j.spi.LoggerRepository r =\n<line21>        // org.apache.log4j.LogManager.getLoggerRepository();\n<line22>        Object r = Class.forName(\"org.apache.log4j.LogManager\").getMethod(\"getLoggerRepository\", (Class<?>[]) null).invoke(null, (Object[]) null);\n<line23>        // Enumeration enumer = r.getCurrentLoggers();\n<line24>        Enumeration enumer = (Enumeration) r.getClass().getMethod(\"getCurrentLoggers\", (Class<?>[]) null).invoke(r, (Object[]) null);\n<line25>        while (enumer.hasMoreElements()) {\n<line26>            Object logger = enumer.nextElement();\n<line27>            // hdm.addLoggerMBean(logger.getName());\n<line28>            Object loggerName = logger.getClass().getMethod(\"getName\", (Class<?>[]) null).invoke(logger, (Object[]) null);\n<line29>            hdm.getClass().getMethod(\"addLoggerMBean\", String.class).invoke(hdm, loggerName);\n<line30>        }\n<line31>    } catch (Exception e) {\n<line32>        LOG.error(\"Problems while registering log4j 1.2 jmx beans!\", e);\n<line33>        throw new JMException(e.toString());\n<line34>    }\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new JMException(e.toString());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Problems while registering log4j 1.2 jmx beans!\", e);\n<line3>    throw new JMException(e.toString());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (cl.getCommand() == null) {\n<line3>        System.out.println(\"Welcome to ZooKeeper!\");\n<line4>        boolean jlinemissing = false;\n<line5>        // only use jline if it's in the classpath\n<line6>        try {\n<line7>            Class<?> consoleC = Class.forName(\"jline.console.ConsoleReader\");\n<line8>            Class<?> completorC = Class.forName(\"org.apache.zookeeper.JLineZNodeCompleter\");\n<line9>            System.out.println(\"JLine support is enabled\");\n<line10>            Object console = consoleC.getConstructor().newInstance();\n<line11>            Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);\n<line12>            Method addCompletor = consoleC.getMethod(\"addCompleter\", Class.forName(\"jline.console.completer.Completer\"));\n<line13>            addCompletor.invoke(console, completor);\n<line14>            String line;\n<line15>            Method readLine = consoleC.getMethod(\"readLine\", String.class);\n<line16>            while ((line = (String) readLine.invoke(console, getPrompt())) != null) {\n<line17>                executeLine(line);\n<line18>            }\n<line19>        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) {\n<line20>            jlinemissing = true;\n<line21>        }\n<line22>        if (jlinemissing) {\n<line23>            System.out.println(\"JLine support is disabled\");\n<line24>            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n<line25>            String line;\n<line26>            while ((line = br.readLine()) != null) {\n<line27>                executeLine(line);\n<line28>            }\n<line29>        }\n<line30>    } else {\n<line31>        // Command line args non-null.  Run what was passed.\n<line32>        processCmd(cl);\n<line33>    }\n<line34>    ServiceUtils.requestSystemExit(exitCode);\n<line35>}","output":"<line1>{\n<line2>    if (cl.getCommand() == null) {\n<line3>        System.out.println(\"Welcome to ZooKeeper!\");\n<line4>        boolean jlinemissing = false;\n<line5>        // only use jline if it's in the classpath\n<line6>        try {\n<line7>            Class<?> consoleC = Class.forName(\"jline.console.ConsoleReader\");\n<line8>            Class<?> completorC = Class.forName(\"org.apache.zookeeper.JLineZNodeCompleter\");\n<line9>            System.out.println(\"JLine support is enabled\");\n<line10>            Object console = consoleC.getConstructor().newInstance();\n<line11>            Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);\n<line12>            Method addCompletor = consoleC.getMethod(\"addCompleter\", Class.forName(\"jline.console.completer.Completer\"));\n<line13>            addCompletor.invoke(console, completor);\n<line14>            String line;\n<line15>            Method readLine = consoleC.getMethod(\"readLine\", String.class);\n<line16>            while ((line = (String) readLine.invoke(console, getPrompt())) != null) {\n<line17>                executeLine(line);\n<line18>            }\n<line19>        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) {\n<line20>            LOG.debug(\"Unable to start jline\", e);\n<line21>            jlinemissing = true;\n<line22>        }\n<line23>        if (jlinemissing) {\n<line24>            System.out.println(\"JLine support is disabled\");\n<line25>            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n<line26>            String line;\n<line27>            while ((line = br.readLine()) != null) {\n<line28>                executeLine(line);\n<line29>            }\n<line30>        }\n<line31>    } else {\n<line32>        // Command line args non-null.  Run what was passed.\n<line33>        processCmd(cl);\n<line34>    }\n<line35>    ServiceUtils.requestSystemExit(exitCode);\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    System.out.println(\"Welcome to ZooKeeper!\");\n<line3>    boolean jlinemissing = false;\n<line4>    // only use jline if it's in the classpath\n<line5>    try {\n<line6>        Class<?> consoleC = Class.forName(\"jline.console.ConsoleReader\");\n<line7>        Class<?> completorC = Class.forName(\"org.apache.zookeeper.JLineZNodeCompleter\");\n<line8>        System.out.println(\"JLine support is enabled\");\n<line9>        Object console = consoleC.getConstructor().newInstance();\n<line10>        Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);\n<line11>        Method addCompletor = consoleC.getMethod(\"addCompleter\", Class.forName(\"jline.console.completer.Completer\"));\n<line12>        addCompletor.invoke(console, completor);\n<line13>        String line;\n<line14>        Method readLine = consoleC.getMethod(\"readLine\", String.class);\n<line15>        while ((line = (String) readLine.invoke(console, getPrompt())) != null) {\n<line16>            executeLine(line);\n<line17>        }\n<line18>    } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) {\n<line19>        jlinemissing = true;\n<line20>    }\n<line21>    if (jlinemissing) {\n<line22>        System.out.println(\"JLine support is disabled\");\n<line23>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n<line24>        String line;\n<line25>        while ((line = br.readLine()) != null) {\n<line26>            executeLine(line);\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    System.out.println(\"Welcome to ZooKeeper!\");\n<line3>    boolean jlinemissing = false;\n<line4>    // only use jline if it's in the classpath\n<line5>    try {\n<line6>        Class<?> consoleC = Class.forName(\"jline.console.ConsoleReader\");\n<line7>        Class<?> completorC = Class.forName(\"org.apache.zookeeper.JLineZNodeCompleter\");\n<line8>        System.out.println(\"JLine support is enabled\");\n<line9>        Object console = consoleC.getConstructor().newInstance();\n<line10>        Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);\n<line11>        Method addCompletor = consoleC.getMethod(\"addCompleter\", Class.forName(\"jline.console.completer.Completer\"));\n<line12>        addCompletor.invoke(console, completor);\n<line13>        String line;\n<line14>        Method readLine = consoleC.getMethod(\"readLine\", String.class);\n<line15>        while ((line = (String) readLine.invoke(console, getPrompt())) != null) {\n<line16>            executeLine(line);\n<line17>        }\n<line18>    } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) {\n<line19>        LOG.debug(\"Unable to start jline\", e);\n<line20>        jlinemissing = true;\n<line21>    }\n<line22>    if (jlinemissing) {\n<line23>        System.out.println(\"JLine support is disabled\");\n<line24>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n<line25>        String line;\n<line26>        while ((line = br.readLine()) != null) {\n<line27>            executeLine(line);\n<line28>        }\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    jlinemissing = true;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Unable to start jline\", e);\n<line3>    jlinemissing = true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] args = co.getArgArray();\n<line3>    String cmd = co.getCommand();\n<line4>    if (args.length < 1) {\n<line5>        usage();\n<line6>        throw new MalformedCommandException(\"No command entered\");\n<line7>    }\n<line8>    if (!commandMap.containsKey(cmd)) {\n<line9>        usage();\n<line10>        throw new CommandNotFoundException(\"Command not found \" + cmd);\n<line11>    }\n<line12>    boolean watch = false;\n<line13>    if (cmd.equals(\"quit\")) {\n<line14>        zk.close();\n<line15>        ServiceUtils.requestSystemExit(exitCode);\n<line16>    } else if (cmd.equals(\"redo\") && args.length >= 2) {\n<line17>        Integer i = Integer.decode(args[1]);\n<line18>        if (commandCount <= i || i < 0) {\n<line19>            // don't allow redoing this redo\n<line20>            throw new MalformedCommandException(\"Command index out of range\");\n<line21>        }\n<line22>        cl.parseCommand(history.get(i));\n<line23>        if (cl.getCommand().equals(\"redo\")) {\n<line24>            throw new MalformedCommandException(\"No redoing redos\");\n<line25>        }\n<line26>        history.put(commandCount, history.get(i));\n<line27>        processCmd(cl);\n<line28>    } else if (cmd.equals(\"history\")) {\n<line29>        for (int i = commandCount - 10; i <= commandCount; ++i) {\n<line30>            if (i < 0) {\n<line31>                continue;\n<line32>            }\n<line33>            System.out.println(i + \" - \" + history.get(i));\n<line34>        }\n<line35>    } else if (cmd.equals(\"printwatches\")) {\n<line36>        if (args.length == 1) {\n<line37>            System.out.println(\"printwatches is \" + (printWatches ? \"on\" : \"off\"));\n<line38>        } else {\n<line39>            printWatches = args[1].equals(\"on\");\n<line40>        }\n<line41>    } else if (cmd.equals(\"connect\")) {\n<line42>        if (args.length >= 2) {\n<line43>            connectToZK(args[1]);\n<line44>        } else {\n<line45>            connectToZK(host);\n<line46>        }\n<line47>    }\n<line48>    // Below commands all need a live connection\n<line49>    if (zk == null || !zk.getState().isAlive()) {\n<line50>        System.out.println(\"Not connected\");\n<line51>        return false;\n<line52>    }\n<line53>    // execute from commandMap\n<line54>    CliCommand cliCmd = commandMapCli.get(cmd);\n<line55>    if (cliCmd != null) {\n<line56>        cliCmd.setZk(zk);\n<line57>        watch = cliCmd.parse(args).exec();\n<line58>    } else if (!commandMap.containsKey(cmd)) {\n<line59>        usage();\n<line60>    }\n<line61>    return watch;\n<line62>}","output":"<line1>{\n<line2>    String[] args = co.getArgArray();\n<line3>    String cmd = co.getCommand();\n<line4>    if (args.length < 1) {\n<line5>        usage();\n<line6>        throw new MalformedCommandException(\"No command entered\");\n<line7>    }\n<line8>    if (!commandMap.containsKey(cmd)) {\n<line9>        usage();\n<line10>        throw new CommandNotFoundException(\"Command not found \" + cmd);\n<line11>    }\n<line12>    boolean watch = false;\n<line13>    LOG.debug(\"Processing {}\", cmd);\n<line14>    if (cmd.equals(\"quit\")) {\n<line15>        zk.close();\n<line16>        ServiceUtils.requestSystemExit(exitCode);\n<line17>    } else if (cmd.equals(\"redo\") && args.length >= 2) {\n<line18>        Integer i = Integer.decode(args[1]);\n<line19>        if (commandCount <= i || i < 0) {\n<line20>            // don't allow redoing this redo\n<line21>            throw new MalformedCommandException(\"Command index out of range\");\n<line22>        }\n<line23>        cl.parseCommand(history.get(i));\n<line24>        if (cl.getCommand().equals(\"redo\")) {\n<line25>            throw new MalformedCommandException(\"No redoing redos\");\n<line26>        }\n<line27>        history.put(commandCount, history.get(i));\n<line28>        processCmd(cl);\n<line29>    } else if (cmd.equals(\"history\")) {\n<line30>        for (int i = commandCount - 10; i <= commandCount; ++i) {\n<line31>            if (i < 0) {\n<line32>                continue;\n<line33>            }\n<line34>            System.out.println(i + \" - \" + history.get(i));\n<line35>        }\n<line36>    } else if (cmd.equals(\"printwatches\")) {\n<line37>        if (args.length == 1) {\n<line38>            System.out.println(\"printwatches is \" + (printWatches ? \"on\" : \"off\"));\n<line39>        } else {\n<line40>            printWatches = args[1].equals(\"on\");\n<line41>        }\n<line42>    } else if (cmd.equals(\"connect\")) {\n<line43>        if (args.length >= 2) {\n<line44>            connectToZK(args[1]);\n<line45>        } else {\n<line46>            connectToZK(host);\n<line47>        }\n<line48>    }\n<line49>    // Below commands all need a live connection\n<line50>    if (zk == null || !zk.getState().isAlive()) {\n<line51>        System.out.println(\"Not connected\");\n<line52>        return false;\n<line53>    }\n<line54>    // execute from commandMap\n<line55>    CliCommand cliCmd = commandMapCli.get(cmd);\n<line56>    if (cliCmd != null) {\n<line57>        cliCmd.setZk(zk);\n<line58>        watch = cliCmd.parse(args).exec();\n<line59>    } else if (!commandMap.containsKey(cmd)) {\n<line60>        usage();\n<line61>    }\n<line62>    return watch;\n<line63>}"},{"input":"","instruction":"<line1>{\n<line2>    this.zkConfig = zkConfig;\n<line3>    this.callbackHandler = callbackHandler;\n<line4>    login = login(loginContextName);\n<line5>    this.loginContextName = loginContextName;\n<line6>    subject = login.getSubject();\n<line7>    isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();\n<line8>    AppConfigurationEntry[] entries = Configuration.getConfiguration().getAppConfigurationEntry(loginContextName);\n<line9>    for (AppConfigurationEntry entry : entries) {\n<line10>        // there will only be a single entry, so this for() loop will only be iterated through once.\n<line11>        if (entry.getOptions().get(\"useTicketCache\") != null) {\n<line12>            String val = (String) entry.getOptions().get(\"useTicketCache\");\n<line13>            if (val.equals(\"true\")) {\n<line14>                isUsingTicketCache = true;\n<line15>            }\n<line16>        }\n<line17>        if (entry.getOptions().get(\"principal\") != null) {\n<line18>            principal = (String) entry.getOptions().get(\"principal\");\n<line19>        }\n<line20>        break;\n<line21>    }\n<line22>    if (!isKrbTicket) {\n<line23>        // if no TGT, do not bother with ticket management.\n<line24>        return;\n<line25>    }\n<line26>    // Refresh the Ticket Granting Ticket (TGT) periodically. How often to refresh is determined by the\n<line27>    // TGT's existing expiry date and the configured MIN_TIME_BEFORE_RELOGIN. For testing and development,\n<line28>    // you can decrease the interval of expiration of tickets (for example, to 3 minutes) by running :\n<line29>    //  \"modprinc -maxlife 3mins <principal>\" in kadmin.\n<line30>    t = new Thread(new Runnable() {\n<line31>\n<line32>        public void run() {\n<line33>            while (true) {\n<line34>                // renewal thread's main loop. if it exits from here, thread will exit.\n<line35>                KerberosTicket tgt = getTGT();\n<line36>                long now = Time.currentWallTime();\n<line37>                long nextRefresh;\n<line38>                Date nextRefreshDate;\n<line39>                if (tgt == null) {\n<line40>                    nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n<line41>                    nextRefreshDate = new Date(nextRefresh);\n<line42>                } else {\n<line43>                    nextRefresh = getRefreshTime(tgt);\n<line44>                    long expiry = tgt.getEndTime().getTime();\n<line45>                    Date expiryDate = new Date(expiry);\n<line46>                    if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line47>                        return;\n<line48>                    }\n<line49>                    // determine how long to sleep from looking at ticket's expiry.\n<line50>                    // We should not allow the ticket to expire, but we should take into consideration\n<line51>                    // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line52>                    // would cause ticket expiration.\n<line53>                    if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line54>                        // expiry is before next scheduled refresh).\n<line55>                        nextRefresh = now;\n<line56>                    } else {\n<line57>                        if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line58>                            // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line59>                            Date until = new Date(nextRefresh);\n<line60>                            Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line61>                        }\n<line62>                        nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line63>                    }\n<line64>                    nextRefreshDate = new Date(nextRefresh);\n<line65>                    if (nextRefresh > expiry) {\n<line66>                        return;\n<line67>                    }\n<line68>                }\n<line69>                if (now == nextRefresh) {\n<line70>                } else if (now < nextRefresh) {\n<line71>                    Date until = new Date(nextRefresh);\n<line72>                    try {\n<line73>                        Thread.sleep(nextRefresh - now);\n<line74>                    } catch (InterruptedException ie) {\n<line75>                        break;\n<line76>                    }\n<line77>                } else {\n<line78>                    break;\n<line79>                }\n<line80>                if (isUsingTicketCache) {\n<line81>                    String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line82>                    String kinitArgs = \"-R\";\n<line83>                    int retry = 1;\n<line84>                    while (retry >= 0) {\n<line85>                        try {\n<line86>                            Shell.execCommand(cmd, kinitArgs);\n<line87>                            break;\n<line88>                        } catch (Exception e) {\n<line89>                            if (retry > 0) {\n<line90>                                --retry;\n<line91>                                // sleep for 10 seconds\n<line92>                                try {\n<line93>                                    sleepBeforeRetryFailedRefresh();\n<line94>                                } catch (InterruptedException ie) {\n<line95>                                    return;\n<line96>                                }\n<line97>                            } else {\n<line98>                                return;\n<line99>                            }\n<line100>                        }\n<line101>                    }\n<line102>                }\n<line103>                try {\n<line104>                    int retry = 1;\n<line105>                    while (retry >= 0) {\n<line106>                        try {\n<line107>                            reLogin();\n<line108>                            break;\n<line109>                        } catch (LoginException le) {\n<line110>                            if (retry > 0) {\n<line111>                                --retry;\n<line112>                                // sleep for 10 seconds.\n<line113>                                try {\n<line114>                                    sleepBeforeRetryFailedRefresh();\n<line115>                                } catch (InterruptedException e) {\n<line116>                                    throw le;\n<line117>                                }\n<line118>                            } else {\n<line119>                            }\n<line120>                        }\n<line121>                    }\n<line122>                } catch (LoginException le) {\n<line123>                    break;\n<line124>                }\n<line125>            }\n<line126>        }\n<line127>    });\n<line128>    t.setDaemon(true);\n<line129>}","output":"<line1>{\n<line2>    this.zkConfig = zkConfig;\n<line3>    this.callbackHandler = callbackHandler;\n<line4>    login = login(loginContextName);\n<line5>    this.loginContextName = loginContextName;\n<line6>    subject = login.getSubject();\n<line7>    isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();\n<line8>    AppConfigurationEntry[] entries = Configuration.getConfiguration().getAppConfigurationEntry(loginContextName);\n<line9>    for (AppConfigurationEntry entry : entries) {\n<line10>        // there will only be a single entry, so this for() loop will only be iterated through once.\n<line11>        if (entry.getOptions().get(\"useTicketCache\") != null) {\n<line12>            String val = (String) entry.getOptions().get(\"useTicketCache\");\n<line13>            if (val.equals(\"true\")) {\n<line14>                isUsingTicketCache = true;\n<line15>            }\n<line16>        }\n<line17>        if (entry.getOptions().get(\"principal\") != null) {\n<line18>            principal = (String) entry.getOptions().get(\"principal\");\n<line19>        }\n<line20>        break;\n<line21>    }\n<line22>    if (!isKrbTicket) {\n<line23>        // if no TGT, do not bother with ticket management.\n<line24>        return;\n<line25>    }\n<line26>    // Refresh the Ticket Granting Ticket (TGT) periodically. How often to refresh is determined by the\n<line27>    // TGT's existing expiry date and the configured MIN_TIME_BEFORE_RELOGIN. For testing and development,\n<line28>    // you can decrease the interval of expiration of tickets (for example, to 3 minutes) by running :\n<line29>    //  \"modprinc -maxlife 3mins <principal>\" in kadmin.\n<line30>    t = new Thread(new Runnable() {\n<line31>\n<line32>        public void run() {\n<line33>            LOG.info(\"TGT refresh thread started.\");\n<line34>            while (true) {\n<line35>                // renewal thread's main loop. if it exits from here, thread will exit.\n<line36>                KerberosTicket tgt = getTGT();\n<line37>                long now = Time.currentWallTime();\n<line38>                long nextRefresh;\n<line39>                Date nextRefreshDate;\n<line40>                if (tgt == null) {\n<line41>                    nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n<line42>                    nextRefreshDate = new Date(nextRefresh);\n<line43>                    LOG.warn(\"No TGT found: will try again at {}\", nextRefreshDate);\n<line44>                } else {\n<line45>                    nextRefresh = getRefreshTime(tgt);\n<line46>                    long expiry = tgt.getEndTime().getTime();\n<line47>                    Date expiryDate = new Date(expiry);\n<line48>                    if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line49>                        LOG.error(\"The TGT cannot be renewed beyond the next expiry date: {}.\" + \"This process will not be able to authenticate new SASL connections after that \" + \"time (for example, it will not be authenticate a new connection with a Zookeeper \" + \"Quorum member).  Ask your system administrator to either increase the \" + \"'renew until' time by doing : 'modprinc -maxrenewlife {}' within \" + \"kadmin, or instead, to generate a keytab for {}. Because the TGT's \" + \"expiry cannot be further extended by refreshing, exiting refresh thread now.\", expiryDate, principal, principal);\n<line50>                        return;\n<line51>                    }\n<line52>                    // determine how long to sleep from looking at ticket's expiry.\n<line53>                    // We should not allow the ticket to expire, but we should take into consideration\n<line54>                    // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line55>                    // would cause ticket expiration.\n<line56>                    if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line57>                        // expiry is before next scheduled refresh).\n<line58>                        nextRefresh = now;\n<line59>                    } else {\n<line60>                        if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line61>                            // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line62>                            Date until = new Date(nextRefresh);\n<line63>                            Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line64>                            LOG.warn(\"TGT refresh thread time adjusted from : {} to : {} since \" + \"the former is sooner than the minimum refresh interval (\" + \"{} seconds) from now.\", until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000));\n<line65>                        }\n<line66>                        nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line67>                    }\n<line68>                    nextRefreshDate = new Date(nextRefresh);\n<line69>                    if (nextRefresh > expiry) {\n<line70>                        LOG.error(\"next refresh: {} is later than expiry {}.\" + \" This may indicate a clock skew problem.\" + \" Check that this host and the KDC's \" + \"hosts' clocks are in sync. Exiting refresh thread.\", nextRefreshDate, expiryDate);\n<line71>                        return;\n<line72>                    }\n<line73>                }\n<line74>                if (now == nextRefresh) {\n<line75>                    LOG.info(\"refreshing now because expiry is before next scheduled refresh time.\");\n<line76>                } else if (now < nextRefresh) {\n<line77>                    Date until = new Date(nextRefresh);\n<line78>                    LOG.info(\"TGT refresh sleeping until: {}\", until.toString());\n<line79>                    try {\n<line80>                        Thread.sleep(nextRefresh - now);\n<line81>                    } catch (InterruptedException ie) {\n<line82>                        LOG.warn(\"TGT renewal thread has been interrupted and will exit.\");\n<line83>                        break;\n<line84>                    }\n<line85>                } else {\n<line86>                    LOG.error(\"nextRefresh:{} is in the past: exiting refresh thread. Check\" + \" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).\" + \" Manual intervention will be required for this client to successfully authenticate.\" + \" Exiting refresh thread.\", nextRefreshDate);\n<line87>                    break;\n<line88>                }\n<line89>                if (isUsingTicketCache) {\n<line90>                    String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line91>                    String kinitArgs = \"-R\";\n<line92>                    int retry = 1;\n<line93>                    while (retry >= 0) {\n<line94>                        try {\n<line95>                            LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n<line96>                            Shell.execCommand(cmd, kinitArgs);\n<line97>                            break;\n<line98>                        } catch (Exception e) {\n<line99>                            if (retry > 0) {\n<line100>                                --retry;\n<line101>                                // sleep for 10 seconds\n<line102>                                try {\n<line103>                                    sleepBeforeRetryFailedRefresh();\n<line104>                                } catch (InterruptedException ie) {\n<line105>                                    LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line106>                                    return;\n<line107>                                }\n<line108>                            } else {\n<line109>                                LOG.warn(\"Could not renew TGT due to problem running shell command: '{} {}'.\" + \" Exiting refresh thread.\", cmd, kinitArgs, e);\n<line110>                                return;\n<line111>                            }\n<line112>                        }\n<line113>                    }\n<line114>                }\n<line115>                try {\n<line116>                    int retry = 1;\n<line117>                    while (retry >= 0) {\n<line118>                        try {\n<line119>                            reLogin();\n<line120>                            break;\n<line121>                        } catch (LoginException le) {\n<line122>                            if (retry > 0) {\n<line123>                                --retry;\n<line124>                                // sleep for 10 seconds.\n<line125>                                try {\n<line126>                                    sleepBeforeRetryFailedRefresh();\n<line127>                                } catch (InterruptedException e) {\n<line128>                                    LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line129>                                    throw le;\n<line130>                                }\n<line131>                            } else {\n<line132>                                LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line133>                            }\n<line134>                        }\n<line135>                    }\n<line136>                } catch (LoginException le) {\n<line137>                    LOG.error(\"Failed to refresh TGT: refresh thread exiting now.\", le);\n<line138>                    break;\n<line139>                }\n<line140>            }\n<line141>        }\n<line142>    });\n<line143>    t.setDaemon(true);\n<line144>}"},{"input":"","instruction":"<line1>{\n<line2>    while (true) {\n<line3>        // renewal thread's main loop. if it exits from here, thread will exit.\n<line4>        KerberosTicket tgt = getTGT();\n<line5>        long now = Time.currentWallTime();\n<line6>        long nextRefresh;\n<line7>        Date nextRefreshDate;\n<line8>        if (tgt == null) {\n<line9>            nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n<line10>            nextRefreshDate = new Date(nextRefresh);\n<line11>        } else {\n<line12>            nextRefresh = getRefreshTime(tgt);\n<line13>            long expiry = tgt.getEndTime().getTime();\n<line14>            Date expiryDate = new Date(expiry);\n<line15>            if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line16>                return;\n<line17>            }\n<line18>            // determine how long to sleep from looking at ticket's expiry.\n<line19>            // We should not allow the ticket to expire, but we should take into consideration\n<line20>            // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line21>            // would cause ticket expiration.\n<line22>            if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line23>                // expiry is before next scheduled refresh).\n<line24>                nextRefresh = now;\n<line25>            } else {\n<line26>                if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line27>                    // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line28>                    Date until = new Date(nextRefresh);\n<line29>                    Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line30>                }\n<line31>                nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line32>            }\n<line33>            nextRefreshDate = new Date(nextRefresh);\n<line34>            if (nextRefresh > expiry) {\n<line35>                return;\n<line36>            }\n<line37>        }\n<line38>        if (now == nextRefresh) {\n<line39>        } else if (now < nextRefresh) {\n<line40>            Date until = new Date(nextRefresh);\n<line41>            try {\n<line42>                Thread.sleep(nextRefresh - now);\n<line43>            } catch (InterruptedException ie) {\n<line44>                break;\n<line45>            }\n<line46>        } else {\n<line47>            break;\n<line48>        }\n<line49>        if (isUsingTicketCache) {\n<line50>            String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line51>            String kinitArgs = \"-R\";\n<line52>            int retry = 1;\n<line53>            while (retry >= 0) {\n<line54>                try {\n<line55>                    Shell.execCommand(cmd, kinitArgs);\n<line56>                    break;\n<line57>                } catch (Exception e) {\n<line58>                    if (retry > 0) {\n<line59>                        --retry;\n<line60>                        // sleep for 10 seconds\n<line61>                        try {\n<line62>                            sleepBeforeRetryFailedRefresh();\n<line63>                        } catch (InterruptedException ie) {\n<line64>                            return;\n<line65>                        }\n<line66>                    } else {\n<line67>                        return;\n<line68>                    }\n<line69>                }\n<line70>            }\n<line71>        }\n<line72>        try {\n<line73>            int retry = 1;\n<line74>            while (retry >= 0) {\n<line75>                try {\n<line76>                    reLogin();\n<line77>                    break;\n<line78>                } catch (LoginException le) {\n<line79>                    if (retry > 0) {\n<line80>                        --retry;\n<line81>                        // sleep for 10 seconds.\n<line82>                        try {\n<line83>                            sleepBeforeRetryFailedRefresh();\n<line84>                        } catch (InterruptedException e) {\n<line85>                            throw le;\n<line86>                        }\n<line87>                    } else {\n<line88>                    }\n<line89>                }\n<line90>            }\n<line91>        } catch (LoginException le) {\n<line92>            break;\n<line93>        }\n<line94>    }\n<line95>}","output":"<line1>{\n<line2>    LOG.info(\"TGT refresh thread started.\");\n<line3>    while (true) {\n<line4>        // renewal thread's main loop. if it exits from here, thread will exit.\n<line5>        KerberosTicket tgt = getTGT();\n<line6>        long now = Time.currentWallTime();\n<line7>        long nextRefresh;\n<line8>        Date nextRefreshDate;\n<line9>        if (tgt == null) {\n<line10>            nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n<line11>            nextRefreshDate = new Date(nextRefresh);\n<line12>            LOG.warn(\"No TGT found: will try again at {}\", nextRefreshDate);\n<line13>        } else {\n<line14>            nextRefresh = getRefreshTime(tgt);\n<line15>            long expiry = tgt.getEndTime().getTime();\n<line16>            Date expiryDate = new Date(expiry);\n<line17>            if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line18>                LOG.error(\"The TGT cannot be renewed beyond the next expiry date: {}.\" + \"This process will not be able to authenticate new SASL connections after that \" + \"time (for example, it will not be authenticate a new connection with a Zookeeper \" + \"Quorum member).  Ask your system administrator to either increase the \" + \"'renew until' time by doing : 'modprinc -maxrenewlife {}' within \" + \"kadmin, or instead, to generate a keytab for {}. Because the TGT's \" + \"expiry cannot be further extended by refreshing, exiting refresh thread now.\", expiryDate, principal, principal);\n<line19>                return;\n<line20>            }\n<line21>            // determine how long to sleep from looking at ticket's expiry.\n<line22>            // We should not allow the ticket to expire, but we should take into consideration\n<line23>            // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line24>            // would cause ticket expiration.\n<line25>            if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line26>                // expiry is before next scheduled refresh).\n<line27>                nextRefresh = now;\n<line28>            } else {\n<line29>                if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line30>                    // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line31>                    Date until = new Date(nextRefresh);\n<line32>                    Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line33>                    LOG.warn(\"TGT refresh thread time adjusted from : {} to : {} since \" + \"the former is sooner than the minimum refresh interval (\" + \"{} seconds) from now.\", until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000));\n<line34>                }\n<line35>                nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line36>            }\n<line37>            nextRefreshDate = new Date(nextRefresh);\n<line38>            if (nextRefresh > expiry) {\n<line39>                LOG.error(\"next refresh: {} is later than expiry {}.\" + \" This may indicate a clock skew problem.\" + \" Check that this host and the KDC's \" + \"hosts' clocks are in sync. Exiting refresh thread.\", nextRefreshDate, expiryDate);\n<line40>                return;\n<line41>            }\n<line42>        }\n<line43>        if (now == nextRefresh) {\n<line44>            LOG.info(\"refreshing now because expiry is before next scheduled refresh time.\");\n<line45>        } else if (now < nextRefresh) {\n<line46>            Date until = new Date(nextRefresh);\n<line47>            LOG.info(\"TGT refresh sleeping until: {}\", until.toString());\n<line48>            try {\n<line49>                Thread.sleep(nextRefresh - now);\n<line50>            } catch (InterruptedException ie) {\n<line51>                LOG.warn(\"TGT renewal thread has been interrupted and will exit.\");\n<line52>                break;\n<line53>            }\n<line54>        } else {\n<line55>            LOG.error(\"nextRefresh:{} is in the past: exiting refresh thread. Check\" + \" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).\" + \" Manual intervention will be required for this client to successfully authenticate.\" + \" Exiting refresh thread.\", nextRefreshDate);\n<line56>            break;\n<line57>        }\n<line58>        if (isUsingTicketCache) {\n<line59>            String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line60>            String kinitArgs = \"-R\";\n<line61>            int retry = 1;\n<line62>            while (retry >= 0) {\n<line63>                try {\n<line64>                    LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n<line65>                    Shell.execCommand(cmd, kinitArgs);\n<line66>                    break;\n<line67>                } catch (Exception e) {\n<line68>                    if (retry > 0) {\n<line69>                        --retry;\n<line70>                        // sleep for 10 seconds\n<line71>                        try {\n<line72>                            sleepBeforeRetryFailedRefresh();\n<line73>                        } catch (InterruptedException ie) {\n<line74>                            LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line75>                            return;\n<line76>                        }\n<line77>                    } else {\n<line78>                        LOG.warn(\"Could not renew TGT due to problem running shell command: '{} {}'.\" + \" Exiting refresh thread.\", cmd, kinitArgs, e);\n<line79>                        return;\n<line80>                    }\n<line81>                }\n<line82>            }\n<line83>        }\n<line84>        try {\n<line85>            int retry = 1;\n<line86>            while (retry >= 0) {\n<line87>                try {\n<line88>                    reLogin();\n<line89>                    break;\n<line90>                } catch (LoginException le) {\n<line91>                    if (retry > 0) {\n<line92>                        --retry;\n<line93>                        // sleep for 10 seconds.\n<line94>                        try {\n<line95>                            sleepBeforeRetryFailedRefresh();\n<line96>                        } catch (InterruptedException e) {\n<line97>                            LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line98>                            throw le;\n<line99>                        }\n<line100>                    } else {\n<line101>                        LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line102>                    }\n<line103>                }\n<line104>            }\n<line105>        } catch (LoginException le) {\n<line106>            LOG.error(\"Failed to refresh TGT: refresh thread exiting now.\", le);\n<line107>            break;\n<line108>        }\n<line109>    }\n<line110>}"},{"input":"","instruction":"<line1>{\n<line2>    // renewal thread's main loop. if it exits from here, thread will exit.\n<line3>    KerberosTicket tgt = getTGT();\n<line4>    long now = Time.currentWallTime();\n<line5>    long nextRefresh;\n<line6>    Date nextRefreshDate;\n<line7>    if (tgt == null) {\n<line8>        nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n<line9>        nextRefreshDate = new Date(nextRefresh);\n<line10>    } else {\n<line11>        nextRefresh = getRefreshTime(tgt);\n<line12>        long expiry = tgt.getEndTime().getTime();\n<line13>        Date expiryDate = new Date(expiry);\n<line14>        if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line15>            return;\n<line16>        }\n<line17>        // determine how long to sleep from looking at ticket's expiry.\n<line18>        // We should not allow the ticket to expire, but we should take into consideration\n<line19>        // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line20>        // would cause ticket expiration.\n<line21>        if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line22>            // expiry is before next scheduled refresh).\n<line23>            nextRefresh = now;\n<line24>        } else {\n<line25>            if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line26>                // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line27>                Date until = new Date(nextRefresh);\n<line28>                Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line29>            }\n<line30>            nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line31>        }\n<line32>        nextRefreshDate = new Date(nextRefresh);\n<line33>        if (nextRefresh > expiry) {\n<line34>            return;\n<line35>        }\n<line36>    }\n<line37>    if (now == nextRefresh) {\n<line38>    } else if (now < nextRefresh) {\n<line39>        Date until = new Date(nextRefresh);\n<line40>        try {\n<line41>            Thread.sleep(nextRefresh - now);\n<line42>        } catch (InterruptedException ie) {\n<line43>            break;\n<line44>        }\n<line45>    } else {\n<line46>        break;\n<line47>    }\n<line48>    if (isUsingTicketCache) {\n<line49>        String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line50>        String kinitArgs = \"-R\";\n<line51>        int retry = 1;\n<line52>        while (retry >= 0) {\n<line53>            try {\n<line54>                Shell.execCommand(cmd, kinitArgs);\n<line55>                break;\n<line56>            } catch (Exception e) {\n<line57>                if (retry > 0) {\n<line58>                    --retry;\n<line59>                    // sleep for 10 seconds\n<line60>                    try {\n<line61>                        sleepBeforeRetryFailedRefresh();\n<line62>                    } catch (InterruptedException ie) {\n<line63>                        return;\n<line64>                    }\n<line65>                } else {\n<line66>                    return;\n<line67>                }\n<line68>            }\n<line69>        }\n<line70>    }\n<line71>    try {\n<line72>        int retry = 1;\n<line73>        while (retry >= 0) {\n<line74>            try {\n<line75>                reLogin();\n<line76>                break;\n<line77>            } catch (LoginException le) {\n<line78>                if (retry > 0) {\n<line79>                    --retry;\n<line80>                    // sleep for 10 seconds.\n<line81>                    try {\n<line82>                        sleepBeforeRetryFailedRefresh();\n<line83>                    } catch (InterruptedException e) {\n<line84>                        throw le;\n<line85>                    }\n<line86>                } else {\n<line87>                }\n<line88>            }\n<line89>        }\n<line90>    } catch (LoginException le) {\n<line91>        break;\n<line92>    }\n<line93>}","output":"<line1>{\n<line2>    // renewal thread's main loop. if it exits from here, thread will exit.\n<line3>    KerberosTicket tgt = getTGT();\n<line4>    long now = Time.currentWallTime();\n<line5>    long nextRefresh;\n<line6>    Date nextRefreshDate;\n<line7>    if (tgt == null) {\n<line8>        nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n<line9>        nextRefreshDate = new Date(nextRefresh);\n<line10>        LOG.warn(\"No TGT found: will try again at {}\", nextRefreshDate);\n<line11>    } else {\n<line12>        nextRefresh = getRefreshTime(tgt);\n<line13>        long expiry = tgt.getEndTime().getTime();\n<line14>        Date expiryDate = new Date(expiry);\n<line15>        if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line16>            LOG.error(\"The TGT cannot be renewed beyond the next expiry date: {}.\" + \"This process will not be able to authenticate new SASL connections after that \" + \"time (for example, it will not be authenticate a new connection with a Zookeeper \" + \"Quorum member).  Ask your system administrator to either increase the \" + \"'renew until' time by doing : 'modprinc -maxrenewlife {}' within \" + \"kadmin, or instead, to generate a keytab for {}. Because the TGT's \" + \"expiry cannot be further extended by refreshing, exiting refresh thread now.\", expiryDate, principal, principal);\n<line17>            return;\n<line18>        }\n<line19>        // determine how long to sleep from looking at ticket's expiry.\n<line20>        // We should not allow the ticket to expire, but we should take into consideration\n<line21>        // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line22>        // would cause ticket expiration.\n<line23>        if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line24>            // expiry is before next scheduled refresh).\n<line25>            nextRefresh = now;\n<line26>        } else {\n<line27>            if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line28>                // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line29>                Date until = new Date(nextRefresh);\n<line30>                Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line31>                LOG.warn(\"TGT refresh thread time adjusted from : {} to : {} since \" + \"the former is sooner than the minimum refresh interval (\" + \"{} seconds) from now.\", until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000));\n<line32>            }\n<line33>            nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line34>        }\n<line35>        nextRefreshDate = new Date(nextRefresh);\n<line36>        if (nextRefresh > expiry) {\n<line37>            LOG.error(\"next refresh: {} is later than expiry {}.\" + \" This may indicate a clock skew problem.\" + \" Check that this host and the KDC's \" + \"hosts' clocks are in sync. Exiting refresh thread.\", nextRefreshDate, expiryDate);\n<line38>            return;\n<line39>        }\n<line40>    }\n<line41>    if (now == nextRefresh) {\n<line42>        LOG.info(\"refreshing now because expiry is before next scheduled refresh time.\");\n<line43>    } else if (now < nextRefresh) {\n<line44>        Date until = new Date(nextRefresh);\n<line45>        LOG.info(\"TGT refresh sleeping until: {}\", until.toString());\n<line46>        try {\n<line47>            Thread.sleep(nextRefresh - now);\n<line48>        } catch (InterruptedException ie) {\n<line49>            LOG.warn(\"TGT renewal thread has been interrupted and will exit.\");\n<line50>            break;\n<line51>        }\n<line52>    } else {\n<line53>        LOG.error(\"nextRefresh:{} is in the past: exiting refresh thread. Check\" + \" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).\" + \" Manual intervention will be required for this client to successfully authenticate.\" + \" Exiting refresh thread.\", nextRefreshDate);\n<line54>        break;\n<line55>    }\n<line56>    if (isUsingTicketCache) {\n<line57>        String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line58>        String kinitArgs = \"-R\";\n<line59>        int retry = 1;\n<line60>        while (retry >= 0) {\n<line61>            try {\n<line62>                LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n<line63>                Shell.execCommand(cmd, kinitArgs);\n<line64>                break;\n<line65>            } catch (Exception e) {\n<line66>                if (retry > 0) {\n<line67>                    --retry;\n<line68>                    // sleep for 10 seconds\n<line69>                    try {\n<line70>                        sleepBeforeRetryFailedRefresh();\n<line71>                    } catch (InterruptedException ie) {\n<line72>                        LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line73>                        return;\n<line74>                    }\n<line75>                } else {\n<line76>                    LOG.warn(\"Could not renew TGT due to problem running shell command: '{} {}'.\" + \" Exiting refresh thread.\", cmd, kinitArgs, e);\n<line77>                    return;\n<line78>                }\n<line79>            }\n<line80>        }\n<line81>    }\n<line82>    try {\n<line83>        int retry = 1;\n<line84>        while (retry >= 0) {\n<line85>            try {\n<line86>                reLogin();\n<line87>                break;\n<line88>            } catch (LoginException le) {\n<line89>                if (retry > 0) {\n<line90>                    --retry;\n<line91>                    // sleep for 10 seconds.\n<line92>                    try {\n<line93>                        sleepBeforeRetryFailedRefresh();\n<line94>                    } catch (InterruptedException e) {\n<line95>                        LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line96>                        throw le;\n<line97>                    }\n<line98>                } else {\n<line99>                    LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line100>                }\n<line101>            }\n<line102>        }\n<line103>    } catch (LoginException le) {\n<line104>        LOG.error(\"Failed to refresh TGT: refresh thread exiting now.\", le);\n<line105>        break;\n<line106>    }\n<line107>}"},{"input":"","instruction":"<line1>{\n<line2>    nextRefresh = getRefreshTime(tgt);\n<line3>    long expiry = tgt.getEndTime().getTime();\n<line4>    Date expiryDate = new Date(expiry);\n<line5>    if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line6>        return;\n<line7>    }\n<line8>    // determine how long to sleep from looking at ticket's expiry.\n<line9>    // We should not allow the ticket to expire, but we should take into consideration\n<line10>    // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line11>    // would cause ticket expiration.\n<line12>    if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line13>        // expiry is before next scheduled refresh).\n<line14>        nextRefresh = now;\n<line15>    } else {\n<line16>        if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line17>            // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line18>            Date until = new Date(nextRefresh);\n<line19>            Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line20>        }\n<line21>        nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line22>    }\n<line23>    nextRefreshDate = new Date(nextRefresh);\n<line24>    if (nextRefresh > expiry) {\n<line25>        return;\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    nextRefresh = getRefreshTime(tgt);\n<line3>    long expiry = tgt.getEndTime().getTime();\n<line4>    Date expiryDate = new Date(expiry);\n<line5>    if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n<line6>        LOG.error(\"The TGT cannot be renewed beyond the next expiry date: {}.\" + \"This process will not be able to authenticate new SASL connections after that \" + \"time (for example, it will not be authenticate a new connection with a Zookeeper \" + \"Quorum member).  Ask your system administrator to either increase the \" + \"'renew until' time by doing : 'modprinc -maxrenewlife {}' within \" + \"kadmin, or instead, to generate a keytab for {}. Because the TGT's \" + \"expiry cannot be further extended by refreshing, exiting refresh thread now.\", expiryDate, principal, principal);\n<line7>        return;\n<line8>    }\n<line9>    // determine how long to sleep from looking at ticket's expiry.\n<line10>    // We should not allow the ticket to expire, but we should take into consideration\n<line11>    // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n<line12>    // would cause ticket expiration.\n<line13>    if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n<line14>        // expiry is before next scheduled refresh).\n<line15>        nextRefresh = now;\n<line16>    } else {\n<line17>        if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n<line18>            // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n<line19>            Date until = new Date(nextRefresh);\n<line20>            Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n<line21>            LOG.warn(\"TGT refresh thread time adjusted from : {} to : {} since \" + \"the former is sooner than the minimum refresh interval (\" + \"{} seconds) from now.\", until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000));\n<line22>        }\n<line23>        nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n<line24>    }\n<line25>    nextRefreshDate = new Date(nextRefresh);\n<line26>    if (nextRefresh > expiry) {\n<line27>        LOG.error(\"next refresh: {} is later than expiry {}.\" + \" This may indicate a clock skew problem.\" + \" Check that this host and the KDC's \" + \"hosts' clocks are in sync. Exiting refresh thread.\", nextRefreshDate, expiryDate);\n<line28>        return;\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"The TGT cannot be renewed beyond the next expiry date: {}.\" + \"This process will not be able to authenticate new SASL connections after that \" + \"time (for example, it will not be authenticate a new connection with a Zookeeper \" + \"Quorum member).  Ask your system administrator to either increase the \" + \"'renew until' time by doing : 'modprinc -maxrenewlife {}' within \" + \"kadmin, or instead, to generate a keytab for {}. Because the TGT's \" + \"expiry cannot be further extended by refreshing, exiting refresh thread now.\", expiryDate, principal, principal);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"next refresh: {} is later than expiry {}.\" + \" This may indicate a clock skew problem.\" + \" Check that this host and the KDC's \" + \"hosts' clocks are in sync. Exiting refresh thread.\", nextRefreshDate, expiryDate);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"refreshing now because expiry is before next scheduled refresh time.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Date until = new Date(nextRefresh);\n<line3>    try {\n<line4>        Thread.sleep(nextRefresh - now);\n<line5>    } catch (InterruptedException ie) {\n<line6>        break;\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    Date until = new Date(nextRefresh);\n<line3>    LOG.info(\"TGT refresh sleeping until: {}\", until.toString());\n<line4>    try {\n<line5>        Thread.sleep(nextRefresh - now);\n<line6>    } catch (InterruptedException ie) {\n<line7>        LOG.warn(\"TGT renewal thread has been interrupted and will exit.\");\n<line8>        break;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"nextRefresh:{} is in the past: exiting refresh thread. Check\" + \" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).\" + \" Manual intervention will be required for this client to successfully authenticate.\" + \" Exiting refresh thread.\", nextRefreshDate);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line3>    String kinitArgs = \"-R\";\n<line4>    int retry = 1;\n<line5>    while (retry >= 0) {\n<line6>        try {\n<line7>            Shell.execCommand(cmd, kinitArgs);\n<line8>            break;\n<line9>        } catch (Exception e) {\n<line10>            if (retry > 0) {\n<line11>                --retry;\n<line12>                // sleep for 10 seconds\n<line13>                try {\n<line14>                    sleepBeforeRetryFailedRefresh();\n<line15>                } catch (InterruptedException ie) {\n<line16>                    return;\n<line17>                }\n<line18>            } else {\n<line19>                return;\n<line20>            }\n<line21>        }\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);\n<line3>    String kinitArgs = \"-R\";\n<line4>    int retry = 1;\n<line5>    while (retry >= 0) {\n<line6>        try {\n<line7>            LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n<line8>            Shell.execCommand(cmd, kinitArgs);\n<line9>            break;\n<line10>        } catch (Exception e) {\n<line11>            if (retry > 0) {\n<line12>                --retry;\n<line13>                // sleep for 10 seconds\n<line14>                try {\n<line15>                    sleepBeforeRetryFailedRefresh();\n<line16>                } catch (InterruptedException ie) {\n<line17>                    LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line18>                    return;\n<line19>                }\n<line20>            } else {\n<line21>                LOG.warn(\"Could not renew TGT due to problem running shell command: '{} {}'.\" + \" Exiting refresh thread.\", cmd, kinitArgs, e);\n<line22>                return;\n<line23>            }\n<line24>        }\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Shell.execCommand(cmd, kinitArgs);\n<line4>        break;\n<line5>    } catch (Exception e) {\n<line6>        if (retry > 0) {\n<line7>            --retry;\n<line8>            // sleep for 10 seconds\n<line9>            try {\n<line10>                sleepBeforeRetryFailedRefresh();\n<line11>            } catch (InterruptedException ie) {\n<line12>                return;\n<line13>            }\n<line14>        } else {\n<line15>            return;\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n<line4>        Shell.execCommand(cmd, kinitArgs);\n<line5>        break;\n<line6>    } catch (Exception e) {\n<line7>        if (retry > 0) {\n<line8>            --retry;\n<line9>            // sleep for 10 seconds\n<line10>            try {\n<line11>                sleepBeforeRetryFailedRefresh();\n<line12>            } catch (InterruptedException ie) {\n<line13>                LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line14>                return;\n<line15>            }\n<line16>        } else {\n<line17>            LOG.warn(\"Could not renew TGT due to problem running shell command: '{} {}'.\" + \" Exiting refresh thread.\", cmd, kinitArgs, e);\n<line18>            return;\n<line19>        }\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    Shell.execCommand(cmd, kinitArgs);\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n<line3>    Shell.execCommand(cmd, kinitArgs);\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (retry > 0) {\n<line3>        --retry;\n<line4>        // sleep for 10 seconds\n<line5>        try {\n<line6>            sleepBeforeRetryFailedRefresh();\n<line7>        } catch (InterruptedException ie) {\n<line8>            return;\n<line9>        }\n<line10>    } else {\n<line11>        return;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    if (retry > 0) {\n<line3>        --retry;\n<line4>        // sleep for 10 seconds\n<line5>        try {\n<line6>            sleepBeforeRetryFailedRefresh();\n<line7>        } catch (InterruptedException ie) {\n<line8>            LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line9>            return;\n<line10>        }\n<line11>    } else {\n<line12>        LOG.warn(\"Could not renew TGT due to problem running shell command: '{} {}'.\" + \" Exiting refresh thread.\", cmd, kinitArgs, e);\n<line13>        return;\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    --retry;\n<line3>    // sleep for 10 seconds\n<line4>    try {\n<line5>        sleepBeforeRetryFailedRefresh();\n<line6>    } catch (InterruptedException ie) {\n<line7>        return;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    --retry;\n<line3>    // sleep for 10 seconds\n<line4>    try {\n<line5>        sleepBeforeRetryFailedRefresh();\n<line6>    } catch (InterruptedException ie) {\n<line7>        LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line8>        return;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int retry = 1;\n<line3>    while (retry >= 0) {\n<line4>        try {\n<line5>            reLogin();\n<line6>            break;\n<line7>        } catch (LoginException le) {\n<line8>            if (retry > 0) {\n<line9>                --retry;\n<line10>                // sleep for 10 seconds.\n<line11>                try {\n<line12>                    sleepBeforeRetryFailedRefresh();\n<line13>                } catch (InterruptedException e) {\n<line14>                    throw le;\n<line15>                }\n<line16>            } else {\n<line17>            }\n<line18>        }\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    int retry = 1;\n<line3>    while (retry >= 0) {\n<line4>        try {\n<line5>            reLogin();\n<line6>            break;\n<line7>        } catch (LoginException le) {\n<line8>            if (retry > 0) {\n<line9>                --retry;\n<line10>                // sleep for 10 seconds.\n<line11>                try {\n<line12>                    sleepBeforeRetryFailedRefresh();\n<line13>                } catch (InterruptedException e) {\n<line14>                    LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line15>                    throw le;\n<line16>                }\n<line17>            } else {\n<line18>                LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line19>            }\n<line20>        }\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        reLogin();\n<line4>        break;\n<line5>    } catch (LoginException le) {\n<line6>        if (retry > 0) {\n<line7>            --retry;\n<line8>            // sleep for 10 seconds.\n<line9>            try {\n<line10>                sleepBeforeRetryFailedRefresh();\n<line11>            } catch (InterruptedException e) {\n<line12>                throw le;\n<line13>            }\n<line14>        } else {\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    try {\n<line3>        reLogin();\n<line4>        break;\n<line5>    } catch (LoginException le) {\n<line6>        if (retry > 0) {\n<line7>            --retry;\n<line8>            // sleep for 10 seconds.\n<line9>            try {\n<line10>                sleepBeforeRetryFailedRefresh();\n<line11>            } catch (InterruptedException e) {\n<line12>                LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line13>                throw le;\n<line14>            }\n<line15>        } else {\n<line16>            LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (retry > 0) {\n<line3>        --retry;\n<line4>        // sleep for 10 seconds.\n<line5>        try {\n<line6>            sleepBeforeRetryFailedRefresh();\n<line7>        } catch (InterruptedException e) {\n<line8>            throw le;\n<line9>        }\n<line10>    } else {\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (retry > 0) {\n<line3>        --retry;\n<line4>        // sleep for 10 seconds.\n<line5>        try {\n<line6>            sleepBeforeRetryFailedRefresh();\n<line7>        } catch (InterruptedException e) {\n<line8>            LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line9>            throw le;\n<line10>        }\n<line11>    } else {\n<line12>        LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    --retry;\n<line3>    // sleep for 10 seconds.\n<line4>    try {\n<line5>        sleepBeforeRetryFailedRefresh();\n<line6>    } catch (InterruptedException e) {\n<line7>        throw le;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    --retry;\n<line3>    // sleep for 10 seconds.\n<line4>    try {\n<line5>        sleepBeforeRetryFailedRefresh();\n<line6>    } catch (InterruptedException e) {\n<line7>        LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line8>        throw le;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    throw le;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted during login retry after LoginException:\", le);\n<line3>    throw le;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Could not refresh TGT for principal: {}.\", principal, le);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to refresh TGT: refresh thread exiting now.\", le);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (loginContextName == null) {\n<line3>        throw new LoginException(\"loginContext name (JAAS file section header) was null. \" + \"Please check your java.security.login.auth.config (=\" + System.getProperty(\"java.security.login.auth.config\") + \") and your \" + getLoginContextMessage());\n<line4>    }\n<line5>    LoginContext loginContext = new LoginContext(loginContextName, callbackHandler);\n<line6>    loginContext.login();\n<line7>    return loginContext;\n<line8>}","output":"<line1>{\n<line2>    if (loginContextName == null) {\n<line3>        throw new LoginException(\"loginContext name (JAAS file section header) was null. \" + \"Please check your java.security.login.auth.config (=\" + System.getProperty(\"java.security.login.auth.config\") + \") and your \" + getLoginContextMessage());\n<line4>    }\n<line5>    LoginContext loginContext = new LoginContext(loginContextName, callbackHandler);\n<line6>    loginContext.login();\n<line7>    LOG.info(\"{} successfully logged in.\", loginContextName);\n<line8>    return loginContext;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    long start = tgt.getStartTime().getTime();\n<line3>    long expires = tgt.getEndTime().getTime();\n<line4>    long proposedRefresh = start + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * ThreadLocalRandom.current().nextDouble())));\n<line5>    if (proposedRefresh > expires) {\n<line6>        // proposedRefresh is too far in the future: it's after ticket expires: simply return now.\n<line7>        return Time.currentWallTime();\n<line8>    } else {\n<line9>        return proposedRefresh;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    long start = tgt.getStartTime().getTime();\n<line3>    long expires = tgt.getEndTime().getTime();\n<line4>    LOG.info(\"TGT valid starting at:        {}\", tgt.getStartTime().toString());\n<line5>    LOG.info(\"TGT expires:                  {}\", tgt.getEndTime().toString());\n<line6>    long proposedRefresh = start + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * ThreadLocalRandom.current().nextDouble())));\n<line7>    if (proposedRefresh > expires) {\n<line8>        // proposedRefresh is too far in the future: it's after ticket expires: simply return now.\n<line9>        return Time.currentWallTime();\n<line10>    } else {\n<line11>        return proposedRefresh;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<KerberosTicket> tickets = subject.getPrivateCredentials(KerberosTicket.class);\n<line3>    for (KerberosTicket ticket : tickets) {\n<line4>        KerberosPrincipal server = ticket.getServer();\n<line5>        if (server.getName().equals(\"krbtgt/\" + server.getRealm() + \"@\" + server.getRealm())) {\n<line6>            return ticket;\n<line7>        }\n<line8>    }\n<line9>    return null;\n<line10>}","output":"<line1>{\n<line2>    Set<KerberosTicket> tickets = subject.getPrivateCredentials(KerberosTicket.class);\n<line3>    for (KerberosTicket ticket : tickets) {\n<line4>        KerberosPrincipal server = ticket.getServer();\n<line5>        if (server.getName().equals(\"krbtgt/\" + server.getRealm() + \"@\" + server.getRealm())) {\n<line6>            LOG.debug(\"Client principal is \\\"{}\\\".\", ticket.getClient().getName());\n<line7>            LOG.debug(\"Server principal is \\\"{}\\\".\", ticket.getServer().getName());\n<line8>            return ticket;\n<line9>        }\n<line10>    }\n<line11>    return null;\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    KerberosPrincipal server = ticket.getServer();\n<line3>    if (server.getName().equals(\"krbtgt/\" + server.getRealm() + \"@\" + server.getRealm())) {\n<line4>        return ticket;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    KerberosPrincipal server = ticket.getServer();\n<line3>    if (server.getName().equals(\"krbtgt/\" + server.getRealm() + \"@\" + server.getRealm())) {\n<line4>        LOG.debug(\"Client principal is \\\"{}\\\".\", ticket.getClient().getName());\n<line5>        LOG.debug(\"Server principal is \\\"{}\\\".\", ticket.getServer().getName());\n<line6>        return ticket;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return ticket;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Client principal is \\\"{}\\\".\", ticket.getClient().getName());\n<line3>    LOG.debug(\"Server principal is \\\"{}\\\".\", ticket.getServer().getName());\n<line4>    return ticket;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!isKrbTicket) {\n<line3>        return;\n<line4>    }\n<line5>    LoginContext login = getLogin();\n<line6>    if (login == null) {\n<line7>        throw new LoginException(\"login must be done first\");\n<line8>    }\n<line9>    if (!hasSufficientTimeElapsed()) {\n<line10>        return;\n<line11>    }\n<line12>    synchronized (Login.class) {\n<line13>        //clear up the kerberos state. But the tokens are not cleared! As per\n<line14>        //the Java kerberos login module code, only the kerberos credentials\n<line15>        //are cleared\n<line16>        logout();\n<line17>        //login and also update the subject field of this instance to\n<line18>        //have the new credentials (pass it to the LoginContext constructor)\n<line19>        login = new LoginContext(loginContextName, getSubject());\n<line20>        login.login();\n<line21>        setLogin(login);\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    if (!isKrbTicket) {\n<line3>        return;\n<line4>    }\n<line5>    LoginContext login = getLogin();\n<line6>    if (login == null) {\n<line7>        throw new LoginException(\"login must be done first\");\n<line8>    }\n<line9>    if (!hasSufficientTimeElapsed()) {\n<line10>        return;\n<line11>    }\n<line12>    LOG.info(\"Initiating logout for {}\", principal);\n<line13>    synchronized (Login.class) {\n<line14>        //clear up the kerberos state. But the tokens are not cleared! As per\n<line15>        //the Java kerberos login module code, only the kerberos credentials\n<line16>        //are cleared\n<line17>        logout();\n<line18>        //login and also update the subject field of this instance to\n<line19>        //have the new credentials (pass it to the LoginContext constructor)\n<line20>        login = new LoginContext(loginContextName, getSubject());\n<line21>        LOG.info(\"Initiating re-login for {}\", principal);\n<line22>        login.login();\n<line23>        setLogin(login);\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    //clear up the kerberos state. But the tokens are not cleared! As per\n<line3>    //the Java kerberos login module code, only the kerberos credentials\n<line4>    //are cleared\n<line5>    logout();\n<line6>    //login and also update the subject field of this instance to\n<line7>    //have the new credentials (pass it to the LoginContext constructor)\n<line8>    login = new LoginContext(loginContextName, getSubject());\n<line9>    login.login();\n<line10>    setLogin(login);\n<line11>}","output":"<line1>{\n<line2>    //clear up the kerberos state. But the tokens are not cleared! As per\n<line3>    //the Java kerberos login module code, only the kerberos credentials\n<line4>    //are cleared\n<line5>    logout();\n<line6>    //login and also update the subject field of this instance to\n<line7>    //have the new credentials (pass it to the LoginContext constructor)\n<line8>    login = new LoginContext(loginContextName, getSubject());\n<line9>    LOG.info(\"Initiating re-login for {}\", principal);\n<line10>    login.login();\n<line11>    setLogin(login);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    CURRENT = new ServerMetrics(metricsProvider);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"ServerMetrics initialized with provider {}\", metricsProvider);\n<line3>    CURRENT = new ServerMetrics(metricsProvider);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    /**\n<line3>     * Value of 0 disables use of direct buffers and instead uses\n<line4>     * gathered write call.\n<line5>     *\n<line6>     * Default to using 64k direct buffers.\n<line7>     */\n<line8>    directBufferBytes = Integer.getInteger(ZOOKEEPER_NIO_DIRECT_BUFFER_BYTES, 64 * 1024);\n<line9>}","output":"<line1>{\n<line2>    Thread.setDefaultUncaughtExceptionHandler((t, e) -> LOG.error(\"Thread {} died\", t, e));\n<line3>    /**\n<line4>     * Value of 0 disables use of direct buffers and instead uses\n<line5>     * gathered write call.\n<line6>     *\n<line7>     * Default to using 64k direct buffers.\n<line8>     */\n<line9>    directBufferBytes = Integer.getInteger(ZOOKEEPER_NIO_DIRECT_BUFFER_BYTES, 64 * 1024);\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (key != null) {\n<line3>        try {\n<line4>            key.cancel();\n<line5>        } catch (Exception ex) {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    if (key != null) {\n<line3>        try {\n<line4>            key.cancel();\n<line5>        } catch (Exception ex) {\n<line6>            LOG.debug(\"ignoring exception during selectionkey cancel\", ex);\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        key.cancel();\n<line4>    } catch (Exception ex) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        key.cancel();\n<line4>    } catch (Exception ex) {\n<line5>        LOG.debug(\"ignoring exception during selectionkey cancel\", ex);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ignoring exception during selectionkey cancel\", ex);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!stopped && !acceptSocket.socket().isClosed()) {\n<line4>            try {\n<line5>                select();\n<line6>            } catch (RuntimeException e) {\n<line7>            } catch (Exception e) {\n<line8>            }\n<line9>        }\n<line10>    } finally {\n<line11>        closeSelector();\n<line12>        // This will wake up the selector threads, and tell the\n<line13>        // worker thread pool to begin shutdown.\n<line14>        if (!reconfiguring) {\n<line15>            NIOServerCnxnFactory.this.stop();\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!stopped && !acceptSocket.socket().isClosed()) {\n<line4>            try {\n<line5>                select();\n<line6>            } catch (RuntimeException e) {\n<line7>                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n<line8>            } catch (Exception e) {\n<line9>                LOG.warn(\"Ignoring unexpected exception\", e);\n<line10>            }\n<line11>        }\n<line12>    } finally {\n<line13>        closeSelector();\n<line14>        // This will wake up the selector threads, and tell the\n<line15>        // worker thread pool to begin shutdown.\n<line16>        if (!reconfiguring) {\n<line17>            NIOServerCnxnFactory.this.stop();\n<line18>        }\n<line19>        LOG.info(\"accept thread exitted run method\");\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSelector();\n<line3>    // This will wake up the selector threads, and tell the\n<line4>    // worker thread pool to begin shutdown.\n<line5>    if (!reconfiguring) {\n<line6>        NIOServerCnxnFactory.this.stop();\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    closeSelector();\n<line3>    // This will wake up the selector threads, and tell the\n<line4>    // worker thread pool to begin shutdown.\n<line5>    if (!reconfiguring) {\n<line6>        NIOServerCnxnFactory.this.stop();\n<line7>    }\n<line8>    LOG.info(\"accept thread exitted run method\");\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean accepted = false;\n<line3>    SocketChannel sc = null;\n<line4>    try {\n<line5>        sc = acceptSocket.accept();\n<line6>        accepted = true;\n<line7>        if (limitTotalNumberOfCnxns()) {\n<line8>            throw new IOException(\"Too many connections max allowed is \" + maxCnxns);\n<line9>        }\n<line10>        InetAddress ia = sc.socket().getInetAddress();\n<line11>        int cnxncount = getClientCnxnCount(ia);\n<line12>        if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {\n<line13>            throw new IOException(\"Too many connections from \" + ia + \" - max is \" + maxClientCnxns);\n<line14>        }\n<line15>        sc.configureBlocking(false);\n<line16>        // Round-robin assign this connection to a selector thread\n<line17>        if (!selectorIterator.hasNext()) {\n<line18>            selectorIterator = selectorThreads.iterator();\n<line19>        }\n<line20>        SelectorThread selectorThread = selectorIterator.next();\n<line21>        if (!selectorThread.addAcceptedConnection(sc)) {\n<line22>            throw new IOException(\"Unable to add connection to selector queue\" + (stopped ? \" (shutdown in progress)\" : \"\"));\n<line23>        }\n<line24>        acceptErrorLogger.flush();\n<line25>    } catch (IOException e) {\n<line26>        // accept, maxClientCnxns, configureBlocking\n<line27>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line28>        acceptErrorLogger.rateLimitLog(\"Error accepting new connection: \" + e.getMessage());\n<line29>        fastCloseSock(sc);\n<line30>    }\n<line31>    return accepted;\n<line32>}","output":"<line1>{\n<line2>    boolean accepted = false;\n<line3>    SocketChannel sc = null;\n<line4>    try {\n<line5>        sc = acceptSocket.accept();\n<line6>        accepted = true;\n<line7>        if (limitTotalNumberOfCnxns()) {\n<line8>            throw new IOException(\"Too many connections max allowed is \" + maxCnxns);\n<line9>        }\n<line10>        InetAddress ia = sc.socket().getInetAddress();\n<line11>        int cnxncount = getClientCnxnCount(ia);\n<line12>        if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {\n<line13>            throw new IOException(\"Too many connections from \" + ia + \" - max is \" + maxClientCnxns);\n<line14>        }\n<line15>        LOG.debug(\"Accepted socket connection from {}\", sc.socket().getRemoteSocketAddress());\n<line16>        sc.configureBlocking(false);\n<line17>        // Round-robin assign this connection to a selector thread\n<line18>        if (!selectorIterator.hasNext()) {\n<line19>            selectorIterator = selectorThreads.iterator();\n<line20>        }\n<line21>        SelectorThread selectorThread = selectorIterator.next();\n<line22>        if (!selectorThread.addAcceptedConnection(sc)) {\n<line23>            throw new IOException(\"Unable to add connection to selector queue\" + (stopped ? \" (shutdown in progress)\" : \"\"));\n<line24>        }\n<line25>        acceptErrorLogger.flush();\n<line26>    } catch (IOException e) {\n<line27>        // accept, maxClientCnxns, configureBlocking\n<line28>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line29>        acceptErrorLogger.rateLimitLog(\"Error accepting new connection: \" + e.getMessage());\n<line30>        fastCloseSock(sc);\n<line31>    }\n<line32>    return accepted;\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    sc = acceptSocket.accept();\n<line3>    accepted = true;\n<line4>    if (limitTotalNumberOfCnxns()) {\n<line5>        throw new IOException(\"Too many connections max allowed is \" + maxCnxns);\n<line6>    }\n<line7>    InetAddress ia = sc.socket().getInetAddress();\n<line8>    int cnxncount = getClientCnxnCount(ia);\n<line9>    if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {\n<line10>        throw new IOException(\"Too many connections from \" + ia + \" - max is \" + maxClientCnxns);\n<line11>    }\n<line12>    sc.configureBlocking(false);\n<line13>    // Round-robin assign this connection to a selector thread\n<line14>    if (!selectorIterator.hasNext()) {\n<line15>        selectorIterator = selectorThreads.iterator();\n<line16>    }\n<line17>    SelectorThread selectorThread = selectorIterator.next();\n<line18>    if (!selectorThread.addAcceptedConnection(sc)) {\n<line19>        throw new IOException(\"Unable to add connection to selector queue\" + (stopped ? \" (shutdown in progress)\" : \"\"));\n<line20>    }\n<line21>    acceptErrorLogger.flush();\n<line22>}","output":"<line1>{\n<line2>    sc = acceptSocket.accept();\n<line3>    accepted = true;\n<line4>    if (limitTotalNumberOfCnxns()) {\n<line5>        throw new IOException(\"Too many connections max allowed is \" + maxCnxns);\n<line6>    }\n<line7>    InetAddress ia = sc.socket().getInetAddress();\n<line8>    int cnxncount = getClientCnxnCount(ia);\n<line9>    if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {\n<line10>        throw new IOException(\"Too many connections from \" + ia + \" - max is \" + maxClientCnxns);\n<line11>    }\n<line12>    LOG.debug(\"Accepted socket connection from {}\", sc.socket().getRemoteSocketAddress());\n<line13>    sc.configureBlocking(false);\n<line14>    // Round-robin assign this connection to a selector thread\n<line15>    if (!selectorIterator.hasNext()) {\n<line16>        selectorIterator = selectorThreads.iterator();\n<line17>    }\n<line18>    SelectorThread selectorThread = selectorIterator.next();\n<line19>    if (!selectorThread.addAcceptedConnection(sc)) {\n<line20>        throw new IOException(\"Unable to add connection to selector queue\" + (stopped ? \" (shutdown in progress)\" : \"\"));\n<line21>    }\n<line22>    acceptErrorLogger.flush();\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!stopped) {\n<line4>            try {\n<line5>                select();\n<line6>                processAcceptedConnections();\n<line7>                processInterestOpsUpdateRequests();\n<line8>            } catch (RuntimeException e) {\n<line9>            } catch (Exception e) {\n<line10>            }\n<line11>        }\n<line12>        // Close connections still pending on the selector. Any others\n<line13>        // with in-flight work, let drain out of the work queue.\n<line14>        for (SelectionKey key : selector.keys()) {\n<line15>            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n<line16>            if (cnxn.isSelectable()) {\n<line17>                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n<line18>            }\n<line19>            cleanupSelectionKey(key);\n<line20>        }\n<line21>        SocketChannel accepted;\n<line22>        while ((accepted = acceptedQueue.poll()) != null) {\n<line23>            fastCloseSock(accepted);\n<line24>        }\n<line25>        updateQueue.clear();\n<line26>    } finally {\n<line27>        closeSelector();\n<line28>        // This will wake up the accept thread and the other selector\n<line29>        // threads, and tell the worker thread pool to begin shutdown.\n<line30>        NIOServerCnxnFactory.this.stop();\n<line31>    }\n<line32>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!stopped) {\n<line4>            try {\n<line5>                select();\n<line6>                processAcceptedConnections();\n<line7>                processInterestOpsUpdateRequests();\n<line8>            } catch (RuntimeException e) {\n<line9>                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n<line10>            } catch (Exception e) {\n<line11>                LOG.warn(\"Ignoring unexpected exception\", e);\n<line12>            }\n<line13>        }\n<line14>        // Close connections still pending on the selector. Any others\n<line15>        // with in-flight work, let drain out of the work queue.\n<line16>        for (SelectionKey key : selector.keys()) {\n<line17>            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n<line18>            if (cnxn.isSelectable()) {\n<line19>                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n<line20>            }\n<line21>            cleanupSelectionKey(key);\n<line22>        }\n<line23>        SocketChannel accepted;\n<line24>        while ((accepted = acceptedQueue.poll()) != null) {\n<line25>            fastCloseSock(accepted);\n<line26>        }\n<line27>        updateQueue.clear();\n<line28>    } finally {\n<line29>        closeSelector();\n<line30>        // This will wake up the accept thread and the other selector\n<line31>        // threads, and tell the worker thread pool to begin shutdown.\n<line32>        NIOServerCnxnFactory.this.stop();\n<line33>        LOG.info(\"selector thread exitted run method\");\n<line34>    }\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSelector();\n<line3>    // This will wake up the accept thread and the other selector\n<line4>    // threads, and tell the worker thread pool to begin shutdown.\n<line5>    NIOServerCnxnFactory.this.stop();\n<line6>}","output":"<line1>{\n<line2>    closeSelector();\n<line3>    // This will wake up the accept thread and the other selector\n<line4>    // threads, and tell the worker thread pool to begin shutdown.\n<line5>    NIOServerCnxnFactory.this.stop();\n<line6>    LOG.info(\"selector thread exitted run method\");\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!stopped) {\n<line4>            long waitTime = cnxnExpiryQueue.getWaitTime();\n<line5>            if (waitTime > 0) {\n<line6>                Thread.sleep(waitTime);\n<line7>                continue;\n<line8>            }\n<line9>            for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {\n<line10>                ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(1);\n<line11>                conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);\n<line12>            }\n<line13>        }\n<line14>    } catch (InterruptedException e) {\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!stopped) {\n<line4>            long waitTime = cnxnExpiryQueue.getWaitTime();\n<line5>            if (waitTime > 0) {\n<line6>                Thread.sleep(waitTime);\n<line7>                continue;\n<line8>            }\n<line9>            for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {\n<line10>                ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(1);\n<line11>                conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);\n<line12>            }\n<line13>        }\n<line14>    } catch (InterruptedException e) {\n<line15>        LOG.info(\"ConnnectionExpirerThread interrupted\");\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"ConnnectionExpirerThread interrupted\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (secure) {\n<line3>        throw new UnsupportedOperationException(\"SSL isn't supported in NIOServerCnxn\");\n<line4>    }\n<line5>    configureSaslLogin();\n<line6>    maxClientCnxns = maxcc;\n<line7>    initMaxCnxns();\n<line8>    sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);\n<line9>    // We also use the sessionlessCnxnTimeout as expiring interval for\n<line10>    // cnxnExpiryQueue. These don't need to be the same, but the expiring\n<line11>    // interval passed into the ExpiryQueue() constructor below should be\n<line12>    // less than or equal to the timeout.\n<line13>    cnxnExpiryQueue = new ExpiryQueue<>(sessionlessCnxnTimeout);\n<line14>    expirerThread = new ConnectionExpirerThread();\n<line15>    int numCores = Runtime.getRuntime().availableProcessors();\n<line16>    // 32 cores sweet spot seems to be 4 selector threads\n<line17>    numSelectorThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_SELECTOR_THREADS, Math.max((int) Math.sqrt((float) numCores / 2), 1));\n<line18>    if (numSelectorThreads < 1) {\n<line19>        throw new IOException(\"numSelectorThreads must be at least 1\");\n<line20>    }\n<line21>    numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);\n<line22>    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);\n<line23>    String logMsg = \"Configuring NIO connection handler with \" + (sessionlessCnxnTimeout / 1000) + \"s sessionless connection timeout, \" + numSelectorThreads + \" selector thread(s), \" + (numWorkerThreads > 0 ? numWorkerThreads : \"no\") + \" worker threads, and \" + (directBufferBytes == 0 ? \"gathered writes.\" : (\"\" + (directBufferBytes / 1024) + \" kB direct buffers.\"));\n<line24>    for (int i = 0; i < numSelectorThreads; ++i) {\n<line25>        selectorThreads.add(new SelectorThread(i));\n<line26>    }\n<line27>    listenBacklog = backlog;\n<line28>    this.ss = ServerSocketChannel.open();\n<line29>    ss.socket().setReuseAddress(true);\n<line30>    if (listenBacklog == -1) {\n<line31>        ss.socket().bind(addr);\n<line32>    } else {\n<line33>        ss.socket().bind(addr, listenBacklog);\n<line34>    }\n<line35>    if (addr.getPort() == 0) {\n<line36>        // We're likely bound to a different port than was requested, so log that too\n<line37>    }\n<line38>    ss.configureBlocking(false);\n<line39>    acceptThread = new AcceptThread(ss, addr, selectorThreads);\n<line40>}","output":"<line1>{\n<line2>    if (secure) {\n<line3>        throw new UnsupportedOperationException(\"SSL isn't supported in NIOServerCnxn\");\n<line4>    }\n<line5>    configureSaslLogin();\n<line6>    maxClientCnxns = maxcc;\n<line7>    initMaxCnxns();\n<line8>    sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);\n<line9>    // We also use the sessionlessCnxnTimeout as expiring interval for\n<line10>    // cnxnExpiryQueue. These don't need to be the same, but the expiring\n<line11>    // interval passed into the ExpiryQueue() constructor below should be\n<line12>    // less than or equal to the timeout.\n<line13>    cnxnExpiryQueue = new ExpiryQueue<>(sessionlessCnxnTimeout);\n<line14>    expirerThread = new ConnectionExpirerThread();\n<line15>    int numCores = Runtime.getRuntime().availableProcessors();\n<line16>    // 32 cores sweet spot seems to be 4 selector threads\n<line17>    numSelectorThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_SELECTOR_THREADS, Math.max((int) Math.sqrt((float) numCores / 2), 1));\n<line18>    if (numSelectorThreads < 1) {\n<line19>        throw new IOException(\"numSelectorThreads must be at least 1\");\n<line20>    }\n<line21>    numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);\n<line22>    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);\n<line23>    String logMsg = \"Configuring NIO connection handler with \" + (sessionlessCnxnTimeout / 1000) + \"s sessionless connection timeout, \" + numSelectorThreads + \" selector thread(s), \" + (numWorkerThreads > 0 ? numWorkerThreads : \"no\") + \" worker threads, and \" + (directBufferBytes == 0 ? \"gathered writes.\" : (\"\" + (directBufferBytes / 1024) + \" kB direct buffers.\"));\n<line24>    LOG.info(logMsg);\n<line25>    for (int i = 0; i < numSelectorThreads; ++i) {\n<line26>        selectorThreads.add(new SelectorThread(i));\n<line27>    }\n<line28>    listenBacklog = backlog;\n<line29>    this.ss = ServerSocketChannel.open();\n<line30>    ss.socket().setReuseAddress(true);\n<line31>    LOG.info(\"binding to port {}\", addr);\n<line32>    if (listenBacklog == -1) {\n<line33>        ss.socket().bind(addr);\n<line34>    } else {\n<line35>        ss.socket().bind(addr, listenBacklog);\n<line36>    }\n<line37>    if (addr.getPort() == 0) {\n<line38>        // We're likely bound to a different port than was requested, so log that too\n<line39>        LOG.info(\"bound to port {}\", ss.getLocalAddress());\n<line40>    }\n<line41>    ss.configureBlocking(false);\n<line42>    acceptThread = new AcceptThread(ss, addr, selectorThreads);\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    // We're likely bound to a different port than was requested, so log that too\n<line3>}","output":"<line1>{\n<line2>    // We're likely bound to a different port than was requested, so log that too\n<line3>    LOG.info(\"bound to port {}\", ss.getLocalAddress());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        s.close();\n<line4>    } catch (IOException sse) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        s.close();\n<line4>    } catch (IOException sse) {\n<line5>        LOG.error(\"Error while closing server socket.\", sse);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error while closing server socket.\", sse);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerSocketChannel oldSS = ss;\n<line3>    try {\n<line4>        acceptThread.setReconfiguring();\n<line5>        tryClose(oldSS);\n<line6>        acceptThread.wakeupSelector();\n<line7>        try {\n<line8>            acceptThread.join();\n<line9>        } catch (InterruptedException e) {\n<line10>            Thread.currentThread().interrupt();\n<line11>        }\n<line12>        this.ss = ServerSocketChannel.open();\n<line13>        ss.socket().setReuseAddress(true);\n<line14>        ss.socket().bind(addr);\n<line15>        ss.configureBlocking(false);\n<line16>        acceptThread = new AcceptThread(ss, addr, selectorThreads);\n<line17>        acceptThread.start();\n<line18>    } catch (IOException e) {\n<line19>        tryClose(oldSS);\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    ServerSocketChannel oldSS = ss;\n<line3>    try {\n<line4>        acceptThread.setReconfiguring();\n<line5>        tryClose(oldSS);\n<line6>        acceptThread.wakeupSelector();\n<line7>        try {\n<line8>            acceptThread.join();\n<line9>        } catch (InterruptedException e) {\n<line10>            LOG.error(\"Error joining old acceptThread when reconfiguring client port.\", e);\n<line11>            Thread.currentThread().interrupt();\n<line12>        }\n<line13>        this.ss = ServerSocketChannel.open();\n<line14>        ss.socket().setReuseAddress(true);\n<line15>        LOG.info(\"binding to port {}\", addr);\n<line16>        ss.socket().bind(addr);\n<line17>        ss.configureBlocking(false);\n<line18>        acceptThread = new AcceptThread(ss, addr, selectorThreads);\n<line19>        acceptThread.start();\n<line20>    } catch (IOException e) {\n<line21>        LOG.error(\"Error reconfiguring client port to {}\", addr, e);\n<line22>        tryClose(oldSS);\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    acceptThread.setReconfiguring();\n<line3>    tryClose(oldSS);\n<line4>    acceptThread.wakeupSelector();\n<line5>    try {\n<line6>        acceptThread.join();\n<line7>    } catch (InterruptedException e) {\n<line8>        Thread.currentThread().interrupt();\n<line9>    }\n<line10>    this.ss = ServerSocketChannel.open();\n<line11>    ss.socket().setReuseAddress(true);\n<line12>    ss.socket().bind(addr);\n<line13>    ss.configureBlocking(false);\n<line14>    acceptThread = new AcceptThread(ss, addr, selectorThreads);\n<line15>    acceptThread.start();\n<line16>}","output":"<line1>{\n<line2>    acceptThread.setReconfiguring();\n<line3>    tryClose(oldSS);\n<line4>    acceptThread.wakeupSelector();\n<line5>    try {\n<line6>        acceptThread.join();\n<line7>    } catch (InterruptedException e) {\n<line8>        LOG.error(\"Error joining old acceptThread when reconfiguring client port.\", e);\n<line9>        Thread.currentThread().interrupt();\n<line10>    }\n<line11>    this.ss = ServerSocketChannel.open();\n<line12>    ss.socket().setReuseAddress(true);\n<line13>    LOG.info(\"binding to port {}\", addr);\n<line14>    ss.socket().bind(addr);\n<line15>    ss.configureBlocking(false);\n<line16>    acceptThread = new AcceptThread(ss, addr, selectorThreads);\n<line17>    acceptThread.start();\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread.currentThread().interrupt();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error joining old acceptThread when reconfiguring client port.\", e);\n<line3>    Thread.currentThread().interrupt();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    tryClose(oldSS);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error reconfiguring client port to {}\", addr, e);\n<line3>    tryClose(oldSS);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (pwriter != null) {\n<line4>            pwriter.flush();\n<line5>            pwriter.close();\n<line6>        }\n<line7>    } catch (Exception e) {\n<line8>    } finally {\n<line9>        try {\n<line10>            close(DisconnectReason.CLOSE_CONNECTION_COMMAND);\n<line11>        } catch (Exception e) {\n<line12>        }\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    try {\n<line3>        if (pwriter != null) {\n<line4>            pwriter.flush();\n<line5>            pwriter.close();\n<line6>        }\n<line7>    } catch (Exception e) {\n<line8>        LOG.info(\"Error closing PrintWriter \", e);\n<line9>    } finally {\n<line10>        try {\n<line11>            close(DisconnectReason.CLOSE_CONNECTION_COMMAND);\n<line12>        } catch (Exception e) {\n<line13>            LOG.error(\"Error closing a command socket \", e);\n<line14>        }\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Error closing PrintWriter \", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        close(DisconnectReason.CLOSE_CONNECTION_COMMAND);\n<line4>    } catch (Exception e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        close(DisconnectReason.CLOSE_CONNECTION_COMMAND);\n<line4>    } catch (Exception e) {\n<line5>        LOG.error(\"Error closing a command socket \", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error closing a command socket \", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final Map<String, PathStatsQueue> requestsMap = new HashMap<>();\n<line3>    this.accurateMode = accurateMode;\n<line4>    REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);\n<line5>    REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);\n<line6>    REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);\n<line7>    REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);\n<line8>    REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(System.getProperty(PATH_STATS_SAMPLE_RATE, \"0.1\"));\n<line9>    COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);\n<line10>    COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);\n<line11>    enabled = Boolean.getBoolean(PATH_STATS_ENABLED);\n<line12>    this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n<line13>    scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n<line14>    scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n<line15>    requestsMap.put(Request.op2String(create), new PathStatsQueue(create));\n<line16>    requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));\n<line17>    requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));\n<line18>    requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));\n<line19>    requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));\n<line20>    requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));\n<line21>    requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));\n<line22>    requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));\n<line23>    requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));\n<line24>    requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));\n<line25>    requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));\n<line26>    requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));\n<line27>    requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));\n<line28>    requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));\n<line29>    requestsMap.put(Request.op2String(setWatches2), new PathStatsQueue(setWatches2));\n<line30>    requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));\n<line31>    this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);\n<line32>}","output":"<line1>{\n<line2>    final Map<String, PathStatsQueue> requestsMap = new HashMap<>();\n<line3>    this.accurateMode = accurateMode;\n<line4>    REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);\n<line5>    REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);\n<line6>    REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);\n<line7>    REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);\n<line8>    REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(System.getProperty(PATH_STATS_SAMPLE_RATE, \"0.1\"));\n<line9>    COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);\n<line10>    COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);\n<line11>    enabled = Boolean.getBoolean(PATH_STATS_ENABLED);\n<line12>    LOG.info(\"{} = {}\", PATH_STATS_SLOT_CAPACITY, REQUEST_STATS_SLOT_CAPACITY);\n<line13>    LOG.info(\"{} = {}\", PATH_STATS_SLOT_DURATION, REQUEST_STATS_SLOT_DURATION);\n<line14>    LOG.info(\"{} = {}\", PATH_STATS_MAX_DEPTH, REQUEST_PREPROCESS_PATH_DEPTH);\n<line15>    LOG.info(\"{} = {}\", PATH_STATS_COLLECTOR_INITIAL_DELAY, COLLECTOR_INITIAL_DELAY);\n<line16>    LOG.info(\"{} = {}\", PATH_STATS_COLLECTOR_DELAY, COLLECTOR_DELAY);\n<line17>    LOG.info(\"{} = {}\", PATH_STATS_ENABLED, enabled);\n<line18>    this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n<line19>    scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n<line20>    scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n<line21>    requestsMap.put(Request.op2String(create), new PathStatsQueue(create));\n<line22>    requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));\n<line23>    requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));\n<line24>    requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));\n<line25>    requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));\n<line26>    requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));\n<line27>    requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));\n<line28>    requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));\n<line29>    requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));\n<line30>    requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));\n<line31>    requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));\n<line32>    requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));\n<line33>    requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));\n<line34>    requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));\n<line35>    requestsMap.put(Request.op2String(setWatches2), new PathStatsQueue(setWatches2));\n<line36>    requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));\n<line37>    this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    scheduledExecutor.shutdownNow();\n<line6>}","output":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    LOG.info(\"shutdown scheduledExecutor\");\n<line6>    scheduledExecutor.shutdownNow();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    immutableRequestsMap.forEach((opType, pathStatsQueue) -> pathStatsQueue.start());\n<line6>    // Schedule to log the top used read/write paths every 5 mins\n<line7>    scheduledExecutor.scheduleWithFixedDelay(() -> {\n<line8>    }, COLLECTOR_INITIAL_DELAY, COLLECTOR_DELAY, TimeUnit.MINUTES);\n<line9>}","output":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    LOG.info(\"Start the RequestPath collector\");\n<line6>    immutableRequestsMap.forEach((opType, pathStatsQueue) -> pathStatsQueue.start());\n<line7>    // Schedule to log the top used read/write paths every 5 mins\n<line8>    scheduledExecutor.scheduleWithFixedDelay(() -> {\n<line9>        LOG.info(\"%nHere are the top Read paths:\");\n<line10>        logTopPaths(aggregatePaths(4, queue -> !queue.isWriteOperation()), entry -> LOG.info(\"{} : {}\", entry.getKey(), entry.getValue()));\n<line11>        LOG.info(\"%nHere are the top Write paths:\");\n<line12>        logTopPaths(aggregatePaths(4, queue -> queue.isWriteOperation()), entry -> LOG.info(\"{} : {}\", entry.getKey(), entry.getValue()));\n<line13>    }, COLLECTOR_INITIAL_DELAY, COLLECTOR_DELAY, TimeUnit.MINUTES);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"%nHere are the top Read paths:\");\n<line3>    logTopPaths(aggregatePaths(4, queue -> !queue.isWriteOperation()), entry -> LOG.info(\"{} : {}\", entry.getKey(), entry.getValue()));\n<line4>    LOG.info(\"%nHere are the top Write paths:\");\n<line5>    logTopPaths(aggregatePaths(4, queue -> queue.isWriteOperation()), entry -> LOG.info(\"{} : {}\", entry.getKey(), entry.getValue()));\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    if (ThreadLocalRandom.current().nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {\n<line6>        PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));\n<line7>        if (pathStatsQueue != null) {\n<line8>            pathStatsQueue.registerRequest(path);\n<line9>        } else {\n<line10>        }\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    if (ThreadLocalRandom.current().nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {\n<line6>        PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));\n<line7>        if (pathStatsQueue != null) {\n<line8>            pathStatsQueue.registerRequest(path);\n<line9>        } else {\n<line10>            LOG.error(\"We should not handle {}\", type);\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));\n<line3>    if (pathStatsQueue != null) {\n<line4>        pathStatsQueue.registerRequest(path);\n<line5>    } else {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));\n<line3>    if (pathStatsQueue != null) {\n<line4>        pathStatsQueue.registerRequest(path);\n<line5>    } else {\n<line6>        LOG.error(\"We should not handle {}\", type);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"We should not handle {}\", type);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    // Staggered start and then run every 15 seconds no matter what\n<line6>    int delay = ThreadLocalRandom.current().nextInt(REQUEST_STATS_SLOT_DURATION);\n<line7>    // We need to use fixed Delay as the fixed rate will start the next one right\n<line8>    // after the previous one finishes if it runs overtime instead of overlapping it.\n<line9>    scheduledExecutor.scheduleWithFixedDelay(() -> {\n<line10>        // Generate new slot so new requests will go here.\n<line11>        ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());\n<line12>        try {\n<line13>            // pre process the last slot and queue it up, only one thread scheduled modified\n<line14>            // this but we can mess up the collect part so we put a lock in the test.\n<line15>            Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);\n<line16>            synchronized (accurateMode ? requestPathStats : new Object()) {\n<line17>                if (requestPathStats.remainingCapacity() <= 0) {\n<line18>                    requestPathStats.poll();\n<line19>                }\n<line20>                if (!requestPathStats.offer(latestSlot)) {\n<line21>                }\n<line22>            }\n<line23>        } catch (Exception e) {\n<line24>        }\n<line25>    }, delay, REQUEST_STATS_SLOT_DURATION, TimeUnit.SECONDS);\n<line26>}","output":"<line1>{\n<line2>    if (!enabled) {\n<line3>        return;\n<line4>    }\n<line5>    // Staggered start and then run every 15 seconds no matter what\n<line6>    int delay = ThreadLocalRandom.current().nextInt(REQUEST_STATS_SLOT_DURATION);\n<line7>    // We need to use fixed Delay as the fixed rate will start the next one right\n<line8>    // after the previous one finishes if it runs overtime instead of overlapping it.\n<line9>    scheduledExecutor.scheduleWithFixedDelay(() -> {\n<line10>        // Generate new slot so new requests will go here.\n<line11>        ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());\n<line12>        try {\n<line13>            // pre process the last slot and queue it up, only one thread scheduled modified\n<line14>            // this but we can mess up the collect part so we put a lock in the test.\n<line15>            Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);\n<line16>            synchronized (accurateMode ? requestPathStats : new Object()) {\n<line17>                if (requestPathStats.remainingCapacity() <= 0) {\n<line18>                    requestPathStats.poll();\n<line19>                }\n<line20>                if (!requestPathStats.offer(latestSlot)) {\n<line21>                    LOG.error(\"Failed to insert the new request path stats for {}\", requestTypeName);\n<line22>                }\n<line23>            }\n<line24>        } catch (Exception e) {\n<line25>            LOG.error(\"Failed to insert the new request path stats for {} with exception {}\", requestTypeName, e);\n<line26>        }\n<line27>    }, delay, REQUEST_STATS_SLOT_DURATION, TimeUnit.SECONDS);\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    // Generate new slot so new requests will go here.\n<line3>    ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());\n<line4>    try {\n<line5>        // pre process the last slot and queue it up, only one thread scheduled modified\n<line6>        // this but we can mess up the collect part so we put a lock in the test.\n<line7>        Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);\n<line8>        synchronized (accurateMode ? requestPathStats : new Object()) {\n<line9>            if (requestPathStats.remainingCapacity() <= 0) {\n<line10>                requestPathStats.poll();\n<line11>            }\n<line12>            if (!requestPathStats.offer(latestSlot)) {\n<line13>            }\n<line14>        }\n<line15>    } catch (Exception e) {\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    // Generate new slot so new requests will go here.\n<line3>    ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());\n<line4>    try {\n<line5>        // pre process the last slot and queue it up, only one thread scheduled modified\n<line6>        // this but we can mess up the collect part so we put a lock in the test.\n<line7>        Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);\n<line8>        synchronized (accurateMode ? requestPathStats : new Object()) {\n<line9>            if (requestPathStats.remainingCapacity() <= 0) {\n<line10>                requestPathStats.poll();\n<line11>            }\n<line12>            if (!requestPathStats.offer(latestSlot)) {\n<line13>                LOG.error(\"Failed to insert the new request path stats for {}\", requestTypeName);\n<line14>            }\n<line15>        }\n<line16>    } catch (Exception e) {\n<line17>        LOG.error(\"Failed to insert the new request path stats for {} with exception {}\", requestTypeName, e);\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    // pre process the last slot and queue it up, only one thread scheduled modified\n<line3>    // this but we can mess up the collect part so we put a lock in the test.\n<line4>    Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);\n<line5>    synchronized (accurateMode ? requestPathStats : new Object()) {\n<line6>        if (requestPathStats.remainingCapacity() <= 0) {\n<line7>            requestPathStats.poll();\n<line8>        }\n<line9>        if (!requestPathStats.offer(latestSlot)) {\n<line10>        }\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    // pre process the last slot and queue it up, only one thread scheduled modified\n<line3>    // this but we can mess up the collect part so we put a lock in the test.\n<line4>    Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);\n<line5>    synchronized (accurateMode ? requestPathStats : new Object()) {\n<line6>        if (requestPathStats.remainingCapacity() <= 0) {\n<line7>            requestPathStats.poll();\n<line8>        }\n<line9>        if (!requestPathStats.offer(latestSlot)) {\n<line10>            LOG.error(\"Failed to insert the new request path stats for {}\", requestTypeName);\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (requestPathStats.remainingCapacity() <= 0) {\n<line3>        requestPathStats.poll();\n<line4>    }\n<line5>    if (!requestPathStats.offer(latestSlot)) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (requestPathStats.remainingCapacity() <= 0) {\n<line3>        requestPathStats.poll();\n<line4>    }\n<line5>    if (!requestPathStats.offer(latestSlot)) {\n<line6>        LOG.error(\"Failed to insert the new request path stats for {}\", requestTypeName);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to insert the new request path stats for {}\", requestTypeName);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to insert the new request path stats for {} with exception {}\", requestTypeName, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String sentOrReceivedText = direction == Direction.SENT ? \"sentBuffer to\" : \"receivedBuffer from\";\n<line3>    if (messages.isEmpty()) {\n<line4>    } else {\n<line5>        while (!messages.isEmpty()) {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    String sentOrReceivedText = direction == Direction.SENT ? \"sentBuffer to\" : \"receivedBuffer from\";\n<line3>    if (messages.isEmpty()) {\n<line4>        LOG.info(\"No buffered timestamps for messages {} {}\", sentOrReceivedText, serverAddr);\n<line5>    } else {\n<line6>        LOG.warn(\"Last {} timestamps for messages {} {}:\", messages.size(), sentOrReceivedText, serverAddr);\n<line7>        while (!messages.isEmpty()) {\n<line8>            LOG.warn(\"{} {}  {}\", sentOrReceivedText, serverAddr, messages.take().toString());\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"No buffered timestamps for messages {} {}\", sentOrReceivedText, serverAddr);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Map<String, GcTimes> gcTimesBeforeSleep = getGcTimes();\n<line3>    while (shouldRun) {\n<line4>        long startTime = Instant.now().toEpochMilli();\n<line5>        try {\n<line6>            Thread.sleep(sleepTimeMs);\n<line7>        } catch (InterruptedException ie) {\n<line8>            return;\n<line9>        }\n<line10>        long endTime = Instant.now().toEpochMilli();\n<line11>        long extraSleepTime = (endTime - startTime) - sleepTimeMs;\n<line12>        if (extraSleepTime >= 0) {\n<line13>            ServerMetrics.getMetrics().JVM_PAUSE_TIME.add(extraSleepTime);\n<line14>        }\n<line15>        Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();\n<line16>        if (extraSleepTime > warnThresholdMs) {\n<line17>            ++numGcWarnThresholdExceeded;\n<line18>        } else if (extraSleepTime > infoThresholdMs) {\n<line19>            ++numGcInfoThresholdExceeded;\n<line20>        }\n<line21>        totalGcExtraSleepTime += extraSleepTime;\n<line22>        gcTimesBeforeSleep = gcTimesAfterSleep;\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    Map<String, GcTimes> gcTimesBeforeSleep = getGcTimes();\n<line3>    LOG.info(\"Starting JVM Pause Monitor with infoThresholdMs:{} warnThresholdMs:{} and sleepTimeMs:{}\", infoThresholdMs, warnThresholdMs, sleepTimeMs);\n<line4>    while (shouldRun) {\n<line5>        long startTime = Instant.now().toEpochMilli();\n<line6>        try {\n<line7>            Thread.sleep(sleepTimeMs);\n<line8>        } catch (InterruptedException ie) {\n<line9>            return;\n<line10>        }\n<line11>        long endTime = Instant.now().toEpochMilli();\n<line12>        long extraSleepTime = (endTime - startTime) - sleepTimeMs;\n<line13>        if (extraSleepTime >= 0) {\n<line14>            ServerMetrics.getMetrics().JVM_PAUSE_TIME.add(extraSleepTime);\n<line15>        }\n<line16>        Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();\n<line17>        if (extraSleepTime > warnThresholdMs) {\n<line18>            ++numGcWarnThresholdExceeded;\n<line19>            LOG.warn(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));\n<line20>        } else if (extraSleepTime > infoThresholdMs) {\n<line21>            ++numGcInfoThresholdExceeded;\n<line22>            LOG.info(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));\n<line23>        }\n<line24>        totalGcExtraSleepTime += extraSleepTime;\n<line25>        gcTimesBeforeSleep = gcTimesAfterSleep;\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    long startTime = Instant.now().toEpochMilli();\n<line3>    try {\n<line4>        Thread.sleep(sleepTimeMs);\n<line5>    } catch (InterruptedException ie) {\n<line6>        return;\n<line7>    }\n<line8>    long endTime = Instant.now().toEpochMilli();\n<line9>    long extraSleepTime = (endTime - startTime) - sleepTimeMs;\n<line10>    if (extraSleepTime >= 0) {\n<line11>        ServerMetrics.getMetrics().JVM_PAUSE_TIME.add(extraSleepTime);\n<line12>    }\n<line13>    Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();\n<line14>    if (extraSleepTime > warnThresholdMs) {\n<line15>        ++numGcWarnThresholdExceeded;\n<line16>    } else if (extraSleepTime > infoThresholdMs) {\n<line17>        ++numGcInfoThresholdExceeded;\n<line18>    }\n<line19>    totalGcExtraSleepTime += extraSleepTime;\n<line20>    gcTimesBeforeSleep = gcTimesAfterSleep;\n<line21>}","output":"<line1>{\n<line2>    long startTime = Instant.now().toEpochMilli();\n<line3>    try {\n<line4>        Thread.sleep(sleepTimeMs);\n<line5>    } catch (InterruptedException ie) {\n<line6>        return;\n<line7>    }\n<line8>    long endTime = Instant.now().toEpochMilli();\n<line9>    long extraSleepTime = (endTime - startTime) - sleepTimeMs;\n<line10>    if (extraSleepTime >= 0) {\n<line11>        ServerMetrics.getMetrics().JVM_PAUSE_TIME.add(extraSleepTime);\n<line12>    }\n<line13>    Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();\n<line14>    if (extraSleepTime > warnThresholdMs) {\n<line15>        ++numGcWarnThresholdExceeded;\n<line16>        LOG.warn(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));\n<line17>    } else if (extraSleepTime > infoThresholdMs) {\n<line18>        ++numGcInfoThresholdExceeded;\n<line19>        LOG.info(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));\n<line20>    }\n<line21>    totalGcExtraSleepTime += extraSleepTime;\n<line22>    gcTimesBeforeSleep = gcTimesAfterSleep;\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    ++numGcInfoThresholdExceeded;\n<line3>}","output":"<line1>{\n<line2>    ++numGcInfoThresholdExceeded;\n<line3>    LOG.info(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    zkServer.setState(State.ERROR);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Thread {} exits, error code {}\", threadName, exitCode);\n<line3>    zkServer.setState(State.ERROR);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (Boolean.parseBoolean(System.getProperty(SESSION_REQUIRE_CLIENT_SASL_AUTH, \"false\"))) {\n<line3>        enforceAuthEnabled = true;\n<line4>        enforceAuthSchemes.add(SASL_AUTH_SCHEME);\n<line5>    } else {\n<line6>        enforceAuthEnabled = Boolean.parseBoolean(System.getProperty(ENFORCE_AUTH_ENABLED, \"false\"));\n<line7>        String enforceAuthSchemesProp = System.getProperty(ENFORCE_AUTH_SCHEMES);\n<line8>        if (enforceAuthSchemesProp != null) {\n<line9>            Arrays.stream(enforceAuthSchemesProp.split(\",\")).forEach(s -> {\n<line10>                enforceAuthSchemes.add(s.trim());\n<line11>            });\n<line12>        }\n<line13>    }\n<line14>    validateConfiguredProperties();\n<line15>    saslAuthRequired = enforceAuthEnabled && enforceAuthSchemes.contains(SASL_AUTH_SCHEME);\n<line16>}","output":"<line1>{\n<line2>    if (Boolean.parseBoolean(System.getProperty(SESSION_REQUIRE_CLIENT_SASL_AUTH, \"false\"))) {\n<line3>        enforceAuthEnabled = true;\n<line4>        enforceAuthSchemes.add(SASL_AUTH_SCHEME);\n<line5>    } else {\n<line6>        enforceAuthEnabled = Boolean.parseBoolean(System.getProperty(ENFORCE_AUTH_ENABLED, \"false\"));\n<line7>        String enforceAuthSchemesProp = System.getProperty(ENFORCE_AUTH_SCHEMES);\n<line8>        if (enforceAuthSchemesProp != null) {\n<line9>            Arrays.stream(enforceAuthSchemesProp.split(\",\")).forEach(s -> {\n<line10>                enforceAuthSchemes.add(s.trim());\n<line11>            });\n<line12>        }\n<line13>    }\n<line14>    LOG.info(\"{} = {}\", ENFORCE_AUTH_ENABLED, enforceAuthEnabled);\n<line15>    LOG.info(\"{} = {}\", ENFORCE_AUTH_SCHEMES, enforceAuthSchemes);\n<line16>    validateConfiguredProperties();\n<line17>    saslAuthRequired = enforceAuthEnabled && enforceAuthSchemes.contains(SASL_AUTH_SCHEME);\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    if (enforceAuthEnabled) {\n<line3>        if (enforceAuthSchemes.isEmpty()) {\n<line4>            String msg = ENFORCE_AUTH_ENABLED + \" is true \" + ENFORCE_AUTH_SCHEMES + \" must be  \" + \"configured.\";\n<line5>            throw new IllegalArgumentException(msg);\n<line6>        }\n<line7>        enforceAuthSchemes.forEach(scheme -> {\n<line8>            if (ProviderRegistry.getProvider(scheme) == null) {\n<line9>                String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line10>                throw new IllegalArgumentException(msg);\n<line11>            }\n<line12>        });\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    if (enforceAuthEnabled) {\n<line3>        if (enforceAuthSchemes.isEmpty()) {\n<line4>            String msg = ENFORCE_AUTH_ENABLED + \" is true \" + ENFORCE_AUTH_SCHEMES + \" must be  \" + \"configured.\";\n<line5>            LOG.error(msg);\n<line6>            throw new IllegalArgumentException(msg);\n<line7>        }\n<line8>        enforceAuthSchemes.forEach(scheme -> {\n<line9>            if (ProviderRegistry.getProvider(scheme) == null) {\n<line10>                String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line11>                LOG.error(msg);\n<line12>                throw new IllegalArgumentException(msg);\n<line13>            }\n<line14>        });\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (enforceAuthSchemes.isEmpty()) {\n<line3>        String msg = ENFORCE_AUTH_ENABLED + \" is true \" + ENFORCE_AUTH_SCHEMES + \" must be  \" + \"configured.\";\n<line4>        throw new IllegalArgumentException(msg);\n<line5>    }\n<line6>    enforceAuthSchemes.forEach(scheme -> {\n<line7>        if (ProviderRegistry.getProvider(scheme) == null) {\n<line8>            String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line9>            throw new IllegalArgumentException(msg);\n<line10>        }\n<line11>    });\n<line12>}","output":"<line1>{\n<line2>    if (enforceAuthSchemes.isEmpty()) {\n<line3>        String msg = ENFORCE_AUTH_ENABLED + \" is true \" + ENFORCE_AUTH_SCHEMES + \" must be  \" + \"configured.\";\n<line4>        LOG.error(msg);\n<line5>        throw new IllegalArgumentException(msg);\n<line6>    }\n<line7>    enforceAuthSchemes.forEach(scheme -> {\n<line8>        if (ProviderRegistry.getProvider(scheme) == null) {\n<line9>            String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line10>            LOG.error(msg);\n<line11>            throw new IllegalArgumentException(msg);\n<line12>        }\n<line13>    });\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = ENFORCE_AUTH_ENABLED + \" is true \" + ENFORCE_AUTH_SCHEMES + \" must be  \" + \"configured.\";\n<line3>    throw new IllegalArgumentException(msg);\n<line4>}","output":"<line1>{\n<line2>    String msg = ENFORCE_AUTH_ENABLED + \" is true \" + ENFORCE_AUTH_SCHEMES + \" must be  \" + \"configured.\";\n<line3>    LOG.error(msg);\n<line4>    throw new IllegalArgumentException(msg);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (ProviderRegistry.getProvider(scheme) == null) {\n<line3>        String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line4>        throw new IllegalArgumentException(msg);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (ProviderRegistry.getProvider(scheme) == null) {\n<line3>        String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line4>        LOG.error(msg);\n<line5>        throw new IllegalArgumentException(msg);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line3>    throw new IllegalArgumentException(msg);\n<line4>}","output":"<line1>{\n<line2>    String msg = \"Authentication scheme \" + scheme + \" is not available.\";\n<line3>    LOG.error(msg);\n<line4>    throw new IllegalArgumentException(msg);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (isEnforceAuthEnabled() && !isCnxnAuthenticated(connection)) {\n<line3>        //Un authenticated connection, lets inform user with response and then close the session\n<line4>        ReplyHeader replyHeader = new ReplyHeader(xid, 0, KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());\n<line5>        connection.sendResponse(replyHeader, null, \"response\");\n<line6>        connection.sendCloseSession();\n<line7>        connection.disableRecv();\n<line8>        return false;\n<line9>    }\n<line10>    return true;\n<line11>}","output":"<line1>{\n<line2>    if (isEnforceAuthEnabled() && !isCnxnAuthenticated(connection)) {\n<line3>        //Un authenticated connection, lets inform user with response and then close the session\n<line4>        LOG.error(\"Client authentication scheme(s) {} does not match with any of the expected \" + \"authentication scheme {}, closing session.\", getAuthSchemes(connection), enforceAuthSchemes);\n<line5>        ReplyHeader replyHeader = new ReplyHeader(xid, 0, KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());\n<line6>        connection.sendResponse(replyHeader, null, \"response\");\n<line7>        connection.sendCloseSession();\n<line8>        connection.disableRecv();\n<line9>        return false;\n<line10>    }\n<line11>    return true;\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    //Un authenticated connection, lets inform user with response and then close the session\n<line3>    ReplyHeader replyHeader = new ReplyHeader(xid, 0, KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());\n<line4>    connection.sendResponse(replyHeader, null, \"response\");\n<line5>    connection.sendCloseSession();\n<line6>    connection.disableRecv();\n<line7>    return false;\n<line8>}","output":"<line1>{\n<line2>    //Un authenticated connection, lets inform user with response and then close the session\n<line3>    LOG.error(\"Client authentication scheme(s) {} does not match with any of the expected \" + \"authentication scheme {}, closing session.\", getAuthSchemes(connection), enforceAuthSchemes);\n<line4>    ReplyHeader replyHeader = new ReplyHeader(xid, 0, KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());\n<line5>    connection.sendResponse(replyHeader, null, \"response\");\n<line6>    connection.sendCloseSession();\n<line7>    connection.disableRecv();\n<line8>    return false;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    shutdownTimeout = Integer.getInteger(SHUTDOWN_TIMEOUT, 10000);\n<line3>}","output":"<line1>{\n<line2>    shutdownTimeout = Integer.getInteger(SHUTDOWN_TIMEOUT, 10000);\n<line3>    LOG.info(\"{} = {} ms\", SHUTDOWN_TIMEOUT, shutdownTimeout);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (true) {\n<line4>            if (killed) {\n<line5>                break;\n<line6>            }\n<line7>            Request request = submittedRequests.take();\n<line8>            if (Request.requestOfDeath == request) {\n<line9>                break;\n<line10>            }\n<line11>            if (request.mustDrop()) {\n<line12>                continue;\n<line13>            }\n<line14>            // Throttling is disabled when maxRequests = 0\n<line15>            if (maxRequests > 0) {\n<line16>                while (!killed) {\n<line17>                    if (dropStaleRequests && request.isStale()) {\n<line18>                        // Note: this will close the connection\n<line19>                        dropRequest(request);\n<line20>                        ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);\n<line21>                        request = null;\n<line22>                        break;\n<line23>                    }\n<line24>                    if (zks.getInProcess() < maxRequests) {\n<line25>                        break;\n<line26>                    }\n<line27>                    throttleSleep(stallTime);\n<line28>                }\n<line29>            }\n<line30>            if (killed) {\n<line31>                break;\n<line32>            }\n<line33>            // A dropped stale request will be null\n<line34>            if (request != null) {\n<line35>                if (request.isStale()) {\n<line36>                    ServerMetrics.getMetrics().STALE_REQUESTS.add(1);\n<line37>                }\n<line38>                final long elapsedTime = Time.currentElapsedTime() - request.requestThrottleQueueTime;\n<line39>                ServerMetrics.getMetrics().REQUEST_THROTTLE_QUEUE_TIME.add(elapsedTime);\n<line40>                if (shouldThrottleOp(request, elapsedTime)) {\n<line41>                    request.setIsThrottled(true);\n<line42>                    ServerMetrics.getMetrics().THROTTLED_OPS.add(1);\n<line43>                }\n<line44>                zks.submitRequestNow(request);\n<line45>            }\n<line46>        }\n<line47>    } catch (InterruptedException e) {\n<line48>    }\n<line49>    int dropped = drainQueue();\n<line50>}","output":"<line1>{\n<line2>    try {\n<line3>        while (true) {\n<line4>            if (killed) {\n<line5>                break;\n<line6>            }\n<line7>            Request request = submittedRequests.take();\n<line8>            if (Request.requestOfDeath == request) {\n<line9>                break;\n<line10>            }\n<line11>            if (request.mustDrop()) {\n<line12>                continue;\n<line13>            }\n<line14>            // Throttling is disabled when maxRequests = 0\n<line15>            if (maxRequests > 0) {\n<line16>                while (!killed) {\n<line17>                    if (dropStaleRequests && request.isStale()) {\n<line18>                        // Note: this will close the connection\n<line19>                        dropRequest(request);\n<line20>                        ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);\n<line21>                        request = null;\n<line22>                        break;\n<line23>                    }\n<line24>                    if (zks.getInProcess() < maxRequests) {\n<line25>                        break;\n<line26>                    }\n<line27>                    throttleSleep(stallTime);\n<line28>                }\n<line29>            }\n<line30>            if (killed) {\n<line31>                break;\n<line32>            }\n<line33>            // A dropped stale request will be null\n<line34>            if (request != null) {\n<line35>                if (request.isStale()) {\n<line36>                    ServerMetrics.getMetrics().STALE_REQUESTS.add(1);\n<line37>                }\n<line38>                final long elapsedTime = Time.currentElapsedTime() - request.requestThrottleQueueTime;\n<line39>                ServerMetrics.getMetrics().REQUEST_THROTTLE_QUEUE_TIME.add(elapsedTime);\n<line40>                if (shouldThrottleOp(request, elapsedTime)) {\n<line41>                    request.setIsThrottled(true);\n<line42>                    ServerMetrics.getMetrics().THROTTLED_OPS.add(1);\n<line43>                }\n<line44>                zks.submitRequestNow(request);\n<line45>            }\n<line46>        }\n<line47>    } catch (InterruptedException e) {\n<line48>        LOG.error(\"Unexpected interruption\", e);\n<line49>    }\n<line50>    int dropped = drainQueue();\n<line51>    LOG.info(\"RequestThrottler shutdown. Dropped {} requests\", dropped);\n<line52>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected interruption\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // If the throttler shutdown gracefully, the queue will be empty.\n<line3>    // However, if the shutdown time limit was reached and the throttler\n<line4>    // was killed, we have no other option than to drop all remaining\n<line5>    // requests on the floor.\n<line6>    int dropped = 0;\n<line7>    Request request;\n<line8>    while ((request = submittedRequests.poll()) != null) {\n<line9>        dropped += 1;\n<line10>        dropRequest(request);\n<line11>    }\n<line12>    return dropped;\n<line13>}","output":"<line1>{\n<line2>    // If the throttler shutdown gracefully, the queue will be empty.\n<line3>    // However, if the shutdown time limit was reached and the throttler\n<line4>    // was killed, we have no other option than to drop all remaining\n<line5>    // requests on the floor.\n<line6>    int dropped = 0;\n<line7>    Request request;\n<line8>    LOG.info(\"Draining request throttler queue\");\n<line9>    while ((request = submittedRequests.poll()) != null) {\n<line10>        dropped += 1;\n<line11>        dropRequest(request);\n<line12>    }\n<line13>    return dropped;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (stopping) {\n<line3>        dropRequest(request);\n<line4>    } else {\n<line5>        request.requestThrottleQueueTime = Time.currentElapsedTime();\n<line6>        submittedRequests.add(request);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    if (stopping) {\n<line3>        LOG.debug(\"Shutdown in progress. Request cannot be processed\");\n<line4>        dropRequest(request);\n<line5>    } else {\n<line6>        request.requestThrottleQueueTime = Time.currentElapsedTime();\n<line7>        submittedRequests.add(request);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    dropRequest(request);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Shutdown in progress. Request cannot be processed\");\n<line3>    dropRequest(request);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Try to shutdown gracefully\n<line3>    stopping = true;\n<line4>    submittedRequests.add(Request.requestOfDeath);\n<line5>    try {\n<line6>        this.join(shutdownTimeout);\n<line7>    } catch (InterruptedException e) {\n<line8>    }\n<line9>    // Forcibly shutdown if necessary in order to ensure request\n<line10>    // queue is drained.\n<line11>    killed = true;\n<line12>    try {\n<line13>        this.join();\n<line14>    } catch (InterruptedException e) {\n<line15>        //TODO apply ZOOKEEPER-575 and remove this line.\n<line16>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    // Try to shutdown gracefully\n<line3>    LOG.info(\"Shutting down\");\n<line4>    stopping = true;\n<line5>    submittedRequests.add(Request.requestOfDeath);\n<line6>    try {\n<line7>        this.join(shutdownTimeout);\n<line8>    } catch (InterruptedException e) {\n<line9>        LOG.warn(\"Interrupted while waiting for {} to finish\", this);\n<line10>    }\n<line11>    // Forcibly shutdown if necessary in order to ensure request\n<line12>    // queue is drained.\n<line13>    killed = true;\n<line14>    try {\n<line15>        this.join();\n<line16>    } catch (InterruptedException e) {\n<line17>        LOG.warn(\"Interrupted while waiting for {} to finish\", this);\n<line18>        //TODO apply ZOOKEEPER-575 and remove this line.\n<line19>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    ZKDatabase db = zks.getZKDatabase();\n<line3>    if (db != null) {\n<line4>        try {\n<line5>            Stat stat = new Stat();\n<line6>            return db.getData(\"/key\", stat, null);\n<line7>        } catch (NoNodeException e) {\n<line8>        }\n<line9>    }\n<line10>    return null;\n<line11>}","output":"<line1>{\n<line2>    ZKDatabase db = zks.getZKDatabase();\n<line3>    if (db != null) {\n<line4>        try {\n<line5>            Stat stat = new Stat();\n<line6>            return db.getData(\"/key\", stat, null);\n<line7>        } catch (NoNodeException e) {\n<line8>            LOG.error(\"getData failed\", e);\n<line9>        }\n<line10>    }\n<line11>    return null;\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Stat stat = new Stat();\n<line4>        return db.getData(\"/key\", stat, null);\n<line5>    } catch (NoNodeException e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        Stat stat = new Stat();\n<line4>        return db.getData(\"/key\", stat, null);\n<line5>    } catch (NoNodeException e) {\n<line6>        LOG.error(\"getData failed\", e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"getData failed\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // perform arbitrary function (auth is a multiple of key)\n<line3>    try {\n<line4>        String keyStr = new String(key, UTF_8);\n<line5>        String authStr = new String(auth, UTF_8);\n<line6>        int keyVal = Integer.parseInt(keyStr);\n<line7>        int authVal = Integer.parseInt(authStr);\n<line8>        if (keyVal != 0 && ((authVal % keyVal) != 0)) {\n<line9>            return false;\n<line10>        }\n<line11>    } catch (NumberFormatException nfe) {\n<line12>        return false;\n<line13>    }\n<line14>    return true;\n<line15>}","output":"<line1>{\n<line2>    // perform arbitrary function (auth is a multiple of key)\n<line3>    try {\n<line4>        String keyStr = new String(key, UTF_8);\n<line5>        String authStr = new String(auth, UTF_8);\n<line6>        int keyVal = Integer.parseInt(keyStr);\n<line7>        int authVal = Integer.parseInt(authStr);\n<line8>        if (keyVal != 0 && ((authVal % keyVal) != 0)) {\n<line9>            return false;\n<line10>        }\n<line11>    } catch (NumberFormatException nfe) {\n<line12>        LOG.error(\"bad formatting\", nfe);\n<line13>        return false;\n<line14>    }\n<line15>    return true;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"bad formatting\", nfe);\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] key = getKey(serverObjs.getZks());\n<line3>    String authStr = new String(authData, UTF_8);\n<line4>    String keyStr = \"\";\n<line5>    if (key != null) {\n<line6>        if (!validate(key, authData)) {\n<line7>            keyStr = new String(key, UTF_8);\n<line8>            return KeeperException.Code.AUTHFAILED;\n<line9>        }\n<line10>    }\n<line11>    // default to allow, so the key can be initially written\n<line12>    // NOTE: keyStr in addAuthInfo() sticks with the created node ACLs.\n<line13>    //   For transient keys or certificates, this presents a problem.\n<line14>    //   In that case, replace it with something non-ephemeral (or punt with null).\n<line15>    //\n<line16>    // BOTH addAuthInfo and an OK return-code are needed for authentication.\n<line17>    serverObjs.getCnxn().addAuthInfo(new Id(getScheme(), keyStr));\n<line18>    return KeeperException.Code.OK;\n<line19>}","output":"<line1>{\n<line2>    byte[] key = getKey(serverObjs.getZks());\n<line3>    String authStr = new String(authData, UTF_8);\n<line4>    String keyStr = \"\";\n<line5>    if (key != null) {\n<line6>        if (!validate(key, authData)) {\n<line7>            keyStr = new String(key, UTF_8);\n<line8>            LOG.debug(\"KeyAuthenticationProvider handleAuthentication ({}, {}) -> FAIL.\\n\", keyStr, authStr);\n<line9>            return KeeperException.Code.AUTHFAILED;\n<line10>        }\n<line11>    }\n<line12>    // default to allow, so the key can be initially written\n<line13>    LOG.debug(\"KeyAuthenticationProvider handleAuthentication -> OK.\\n\");\n<line14>    // NOTE: keyStr in addAuthInfo() sticks with the created node ACLs.\n<line15>    //   For transient keys or certificates, this presents a problem.\n<line16>    //   In that case, replace it with something non-ephemeral (or punt with null).\n<line17>    //\n<line18>    // BOTH addAuthInfo and an OK return-code are needed for authentication.\n<line19>    serverObjs.getCnxn().addAuthInfo(new Id(getScheme(), keyStr));\n<line20>    return KeeperException.Code.OK;\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!validate(key, authData)) {\n<line3>        keyStr = new String(key, UTF_8);\n<line4>        return KeeperException.Code.AUTHFAILED;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (!validate(key, authData)) {\n<line3>        keyStr = new String(key, UTF_8);\n<line4>        LOG.debug(\"KeyAuthenticationProvider handleAuthentication ({}, {}) -> FAIL.\\n\", keyStr, authStr);\n<line5>        return KeeperException.Code.AUTHFAILED;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    keyStr = new String(key, UTF_8);\n<line3>    return KeeperException.Code.AUTHFAILED;\n<line4>}","output":"<line1>{\n<line2>    keyStr = new String(key, UTF_8);\n<line3>    LOG.debug(\"KeyAuthenticationProvider handleAuthentication ({}, {}) -> FAIL.\\n\", keyStr, authStr);\n<line4>    return KeeperException.Code.AUTHFAILED;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n<line3>    AppConfigurationEntry[] configurationEntries = configuration.getAppConfigurationEntry(serverSection);\n<line4>    if (configurationEntries == null) {\n<line5>        String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line6>        throw new IOException(errorMessage);\n<line7>    }\n<line8>    credentials.clear();\n<line9>    for (AppConfigurationEntry entry : configurationEntries) {\n<line10>        Map<String, ?> options = entry.getOptions();\n<line11>        // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"Server\" section.\n<line12>        // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n<line13>        for (Map.Entry<String, ?> pair : options.entrySet()) {\n<line14>            String key = pair.getKey();\n<line15>            if (key.startsWith(USER_PREFIX)) {\n<line16>                String userName = key.substring(USER_PREFIX.length());\n<line17>                credentials.put(userName, (String) pair.getValue());\n<line18>            }\n<line19>        }\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n<line3>    AppConfigurationEntry[] configurationEntries = configuration.getAppConfigurationEntry(serverSection);\n<line4>    if (configurationEntries == null) {\n<line5>        String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line6>        LOG.error(errorMessage);\n<line7>        throw new IOException(errorMessage);\n<line8>    }\n<line9>    credentials.clear();\n<line10>    for (AppConfigurationEntry entry : configurationEntries) {\n<line11>        Map<String, ?> options = entry.getOptions();\n<line12>        // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"Server\" section.\n<line13>        // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n<line14>        for (Map.Entry<String, ?> pair : options.entrySet()) {\n<line15>            String key = pair.getKey();\n<line16>            if (key.startsWith(USER_PREFIX)) {\n<line17>                String userName = key.substring(USER_PREFIX.length());\n<line18>                credentials.put(userName, (String) pair.getValue());\n<line19>            }\n<line20>        }\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line3>    throw new IOException(errorMessage);\n<line4>}","output":"<line1>{\n<line2>    String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line3>    LOG.error(errorMessage);\n<line4>    throw new IOException(errorMessage);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    rc.setText(rc.getDefaultText());\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"client supplied realm: {}\", rc.getDefaultText());\n<line3>    rc.setText(rc.getDefaultText());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String authenticationID = ac.getAuthenticationID();\n<line3>    String authorizationID = ac.getAuthorizationID();\n<line4>    ac.setAuthorized(true);\n<line5>    // canonicalize authorization id according to system properties:\n<line6>    // zookeeper.kerberos.removeRealmFromPrincipal(={true,false})\n<line7>    // zookeeper.kerberos.removeHostFromPrincipal(={true,false})\n<line8>    KerberosName kerberosName = new KerberosName(authenticationID);\n<line9>    try {\n<line10>        StringBuilder userNameBuilder = new StringBuilder(kerberosName.getShortName());\n<line11>        if (shouldAppendHost(kerberosName)) {\n<line12>            userNameBuilder.append(\"/\").append(kerberosName.getHostName());\n<line13>        }\n<line14>        if (shouldAppendRealm(kerberosName)) {\n<line15>            userNameBuilder.append(\"@\").append(kerberosName.getRealm());\n<line16>        }\n<line17>        ac.setAuthorizedID(userNameBuilder.toString());\n<line18>    } catch (IOException e) {\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    String authenticationID = ac.getAuthenticationID();\n<line3>    String authorizationID = ac.getAuthorizationID();\n<line4>    LOG.info(\"Successfully authenticated client: authenticationID={};  authorizationID={}.\", authenticationID, authorizationID);\n<line5>    ac.setAuthorized(true);\n<line6>    // canonicalize authorization id according to system properties:\n<line7>    // zookeeper.kerberos.removeRealmFromPrincipal(={true,false})\n<line8>    // zookeeper.kerberos.removeHostFromPrincipal(={true,false})\n<line9>    KerberosName kerberosName = new KerberosName(authenticationID);\n<line10>    try {\n<line11>        StringBuilder userNameBuilder = new StringBuilder(kerberosName.getShortName());\n<line12>        if (shouldAppendHost(kerberosName)) {\n<line13>            userNameBuilder.append(\"/\").append(kerberosName.getHostName());\n<line14>        }\n<line15>        if (shouldAppendRealm(kerberosName)) {\n<line16>            userNameBuilder.append(\"@\").append(kerberosName.getRealm());\n<line17>        }\n<line18>        LOG.info(\"Setting authorizedID: {}\", userNameBuilder);\n<line19>        ac.setAuthorizedID(userNameBuilder.toString());\n<line20>    } catch (IOException e) {\n<line21>        LOG.error(\"Failed to set name based on Kerberos authentication rules.\", e);\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    StringBuilder userNameBuilder = new StringBuilder(kerberosName.getShortName());\n<line3>    if (shouldAppendHost(kerberosName)) {\n<line4>        userNameBuilder.append(\"/\").append(kerberosName.getHostName());\n<line5>    }\n<line6>    if (shouldAppendRealm(kerberosName)) {\n<line7>        userNameBuilder.append(\"@\").append(kerberosName.getRealm());\n<line8>    }\n<line9>    ac.setAuthorizedID(userNameBuilder.toString());\n<line10>}","output":"<line1>{\n<line2>    StringBuilder userNameBuilder = new StringBuilder(kerberosName.getShortName());\n<line3>    if (shouldAppendHost(kerberosName)) {\n<line4>        userNameBuilder.append(\"/\").append(kerberosName.getHostName());\n<line5>    }\n<line6>    if (shouldAppendRealm(kerberosName)) {\n<line7>        userNameBuilder.append(\"@\").append(kerberosName.getRealm());\n<line8>    }\n<line9>    LOG.info(\"Setting authorizedID: {}\", userNameBuilder);\n<line10>    ac.setAuthorizedID(userNameBuilder.toString());\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to set name based on Kerberos authentication rules.\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        //sanity check, pre-check the availability of the algorithm to avoid some unexpected exceptions in the runtime\n<line4>        generateDigest(DIGEST_ALGORITHM);\n<line5>    } catch (NoSuchAlgorithmException e) {\n<line6>        throw new RuntimeException(\"don't support this ACL digest algorithm: \" + DIGEST_ALGORITHM + \" in the current environment\");\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        //sanity check, pre-check the availability of the algorithm to avoid some unexpected exceptions in the runtime\n<line4>        generateDigest(DIGEST_ALGORITHM);\n<line5>    } catch (NoSuchAlgorithmException e) {\n<line6>        throw new RuntimeException(\"don't support this ACL digest algorithm: \" + DIGEST_ALGORITHM + \" in the current environment\");\n<line7>    }\n<line8>    LOG.info(\"ACL digest algorithm is: {}\", DIGEST_ALGORITHM);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean enabled = Boolean.parseBoolean(System.getProperty(DIGEST_AUTH_ENABLED, \"true\"));\n<line3>    return enabled;\n<line4>}","output":"<line1>{\n<line2>    boolean enabled = Boolean.parseBoolean(System.getProperty(DIGEST_AUTH_ENABLED, \"true\"));\n<line3>    LOG.info(\"{} = {}\", DIGEST_AUTH_ENABLED, enabled);\n<line4>    return enabled;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<Id> ids = new ArrayList<>();\n<line3>    final String id = new String(authData);\n<line4>    try {\n<line5>        final String digest = generateDigest(id);\n<line6>        if (digest.equals(superDigest)) {\n<line7>            ids.add(new Id(\"super\", \"\"));\n<line8>        }\n<line9>        ids.add(new Id(getScheme(), digest));\n<line10>    } catch (final NoSuchAlgorithmException e) {\n<line11>    }\n<line12>    return Collections.unmodifiableList(ids);\n<line13>}","output":"<line1>{\n<line2>    final List<Id> ids = new ArrayList<>();\n<line3>    final String id = new String(authData);\n<line4>    try {\n<line5>        final String digest = generateDigest(id);\n<line6>        if (digest.equals(superDigest)) {\n<line7>            ids.add(new Id(\"super\", \"\"));\n<line8>        }\n<line9>        ids.add(new Id(getScheme(), digest));\n<line10>    } catch (final NoSuchAlgorithmException e) {\n<line11>        LOG.error(\"Missing algorithm\", e);\n<line12>    }\n<line13>    return Collections.unmodifiableList(ids);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Missing algorithm\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ZKConfig config = new ZKConfig();\n<line3>    try (X509Util x509Util = new ClientX509Util()) {\n<line4>        String keyStoreLocation = config.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line5>        String keyStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line6>        String keyStoreTypeProp = config.getProperty(x509Util.getSslKeystoreTypeProperty());\n<line7>        boolean crlEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslCrlEnabledProperty()));\n<line8>        boolean ocspEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslOcspEnabledProperty()));\n<line9>        boolean hostnameVerificationEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));\n<line10>        X509KeyManager km = null;\n<line11>        X509TrustManager tm = null;\n<line12>        if (keyStoreLocation.isEmpty()) {\n<line13>        } else {\n<line14>            try {\n<line15>                km = X509Util.createKeyManager(keyStoreLocation, keyStorePassword, keyStoreTypeProp);\n<line16>            } catch (KeyManagerException e) {\n<line17>            }\n<line18>        }\n<line19>        String trustStoreLocation = config.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line20>        String trustStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line21>        String trustStoreTypeProp = config.getProperty(x509Util.getSslTruststoreTypeProperty());\n<line22>        boolean fipsMode = x509Util.getFipsMode(config);\n<line23>        if (trustStoreLocation.isEmpty()) {\n<line24>        } else {\n<line25>            try {\n<line26>                tm = X509Util.createTrustManager(trustStoreLocation, trustStorePassword, trustStoreTypeProp, crlEnabled, ocspEnabled, hostnameVerificationEnabled, false, fipsMode);\n<line27>            } catch (TrustManagerException e) {\n<line28>            }\n<line29>        }\n<line30>        this.keyManager = km;\n<line31>        this.trustManager = tm;\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    ZKConfig config = new ZKConfig();\n<line3>    try (X509Util x509Util = new ClientX509Util()) {\n<line4>        String keyStoreLocation = config.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line5>        String keyStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line6>        String keyStoreTypeProp = config.getProperty(x509Util.getSslKeystoreTypeProperty());\n<line7>        boolean crlEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslCrlEnabledProperty()));\n<line8>        boolean ocspEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslOcspEnabledProperty()));\n<line9>        boolean hostnameVerificationEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));\n<line10>        X509KeyManager km = null;\n<line11>        X509TrustManager tm = null;\n<line12>        if (keyStoreLocation.isEmpty()) {\n<line13>            LOG.warn(\"keystore not specified for client connection\");\n<line14>        } else {\n<line15>            try {\n<line16>                km = X509Util.createKeyManager(keyStoreLocation, keyStorePassword, keyStoreTypeProp);\n<line17>            } catch (KeyManagerException e) {\n<line18>                LOG.error(\"Failed to create key manager\", e);\n<line19>            }\n<line20>        }\n<line21>        String trustStoreLocation = config.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line22>        String trustStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line23>        String trustStoreTypeProp = config.getProperty(x509Util.getSslTruststoreTypeProperty());\n<line24>        boolean fipsMode = x509Util.getFipsMode(config);\n<line25>        if (trustStoreLocation.isEmpty()) {\n<line26>            LOG.warn(\"Truststore not specified for client connection\");\n<line27>        } else {\n<line28>            try {\n<line29>                tm = X509Util.createTrustManager(trustStoreLocation, trustStorePassword, trustStoreTypeProp, crlEnabled, ocspEnabled, hostnameVerificationEnabled, false, fipsMode);\n<line30>            } catch (TrustManagerException e) {\n<line31>                LOG.error(\"Failed to create trust manager\", e);\n<line32>            }\n<line33>        }\n<line34>        this.keyManager = km;\n<line35>        this.trustManager = tm;\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    String keyStoreLocation = config.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line3>    String keyStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line4>    String keyStoreTypeProp = config.getProperty(x509Util.getSslKeystoreTypeProperty());\n<line5>    boolean crlEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslCrlEnabledProperty()));\n<line6>    boolean ocspEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslOcspEnabledProperty()));\n<line7>    boolean hostnameVerificationEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));\n<line8>    X509KeyManager km = null;\n<line9>    X509TrustManager tm = null;\n<line10>    if (keyStoreLocation.isEmpty()) {\n<line11>    } else {\n<line12>        try {\n<line13>            km = X509Util.createKeyManager(keyStoreLocation, keyStorePassword, keyStoreTypeProp);\n<line14>        } catch (KeyManagerException e) {\n<line15>        }\n<line16>    }\n<line17>    String trustStoreLocation = config.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line18>    String trustStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line19>    String trustStoreTypeProp = config.getProperty(x509Util.getSslTruststoreTypeProperty());\n<line20>    boolean fipsMode = x509Util.getFipsMode(config);\n<line21>    if (trustStoreLocation.isEmpty()) {\n<line22>    } else {\n<line23>        try {\n<line24>            tm = X509Util.createTrustManager(trustStoreLocation, trustStorePassword, trustStoreTypeProp, crlEnabled, ocspEnabled, hostnameVerificationEnabled, false, fipsMode);\n<line25>        } catch (TrustManagerException e) {\n<line26>        }\n<line27>    }\n<line28>    this.keyManager = km;\n<line29>    this.trustManager = tm;\n<line30>}","output":"<line1>{\n<line2>    String keyStoreLocation = config.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line3>    String keyStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line4>    String keyStoreTypeProp = config.getProperty(x509Util.getSslKeystoreTypeProperty());\n<line5>    boolean crlEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslCrlEnabledProperty()));\n<line6>    boolean ocspEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslOcspEnabledProperty()));\n<line7>    boolean hostnameVerificationEnabled = Boolean.parseBoolean(config.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));\n<line8>    X509KeyManager km = null;\n<line9>    X509TrustManager tm = null;\n<line10>    if (keyStoreLocation.isEmpty()) {\n<line11>        LOG.warn(\"keystore not specified for client connection\");\n<line12>    } else {\n<line13>        try {\n<line14>            km = X509Util.createKeyManager(keyStoreLocation, keyStorePassword, keyStoreTypeProp);\n<line15>        } catch (KeyManagerException e) {\n<line16>            LOG.error(\"Failed to create key manager\", e);\n<line17>        }\n<line18>    }\n<line19>    String trustStoreLocation = config.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line20>    String trustStorePassword = x509Util.getPasswordFromConfigPropertyOrFile(config, x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line21>    String trustStoreTypeProp = config.getProperty(x509Util.getSslTruststoreTypeProperty());\n<line22>    boolean fipsMode = x509Util.getFipsMode(config);\n<line23>    if (trustStoreLocation.isEmpty()) {\n<line24>        LOG.warn(\"Truststore not specified for client connection\");\n<line25>    } else {\n<line26>        try {\n<line27>            tm = X509Util.createTrustManager(trustStoreLocation, trustStorePassword, trustStoreTypeProp, crlEnabled, ocspEnabled, hostnameVerificationEnabled, false, fipsMode);\n<line28>        } catch (TrustManagerException e) {\n<line29>            LOG.error(\"Failed to create trust manager\", e);\n<line30>        }\n<line31>    }\n<line32>    this.keyManager = km;\n<line33>    this.trustManager = tm;\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        km = X509Util.createKeyManager(keyStoreLocation, keyStorePassword, keyStoreTypeProp);\n<line4>    } catch (KeyManagerException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        km = X509Util.createKeyManager(keyStoreLocation, keyStorePassword, keyStoreTypeProp);\n<line4>    } catch (KeyManagerException e) {\n<line5>        LOG.error(\"Failed to create key manager\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to create key manager\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        tm = X509Util.createTrustManager(trustStoreLocation, trustStorePassword, trustStoreTypeProp, crlEnabled, ocspEnabled, hostnameVerificationEnabled, false, fipsMode);\n<line4>    } catch (TrustManagerException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        tm = X509Util.createTrustManager(trustStoreLocation, trustStorePassword, trustStoreTypeProp, crlEnabled, ocspEnabled, hostnameVerificationEnabled, false, fipsMode);\n<line4>    } catch (TrustManagerException e) {\n<line5>        LOG.error(\"Failed to create trust manager\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to create trust manager\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    List<Certificate> certs = Arrays.asList(cnxn.getClientCertificateChain());\n<line3>    X509Certificate[] certChain = certs.toArray(new X509Certificate[certs.size()]);\n<line4>    final Collection<Id> ids = handleAuthentication(certChain);\n<line5>    if (ids.isEmpty()) {\n<line6>        return KeeperException.Code.AUTHFAILED;\n<line7>    }\n<line8>    for (Id id : ids) {\n<line9>        cnxn.addAuthInfo(id);\n<line10>    }\n<line11>    return KeeperException.Code.OK;\n<line12>}","output":"<line1>{\n<line2>    List<Certificate> certs = Arrays.asList(cnxn.getClientCertificateChain());\n<line3>    X509Certificate[] certChain = certs.toArray(new X509Certificate[certs.size()]);\n<line4>    final Collection<Id> ids = handleAuthentication(certChain);\n<line5>    if (ids.isEmpty()) {\n<line6>        LOG.error(\"Failed to authenticate session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line7>        return KeeperException.Code.AUTHFAILED;\n<line8>    }\n<line9>    for (Id id : ids) {\n<line10>        cnxn.addAuthInfo(id);\n<line11>    }\n<line12>    return KeeperException.Code.OK;\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    return KeeperException.Code.AUTHFAILED;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to authenticate session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line3>    return KeeperException.Code.AUTHFAILED;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final List<Id> ids = new ArrayList<>();\n<line3>    if (certChain == null || certChain.length == 0) {\n<line4>        return ids;\n<line5>    }\n<line6>    if (trustManager == null) {\n<line7>        return ids;\n<line8>    }\n<line9>    final X509Certificate clientCert = certChain[0];\n<line10>    try {\n<line11>        // Authenticate client certificate\n<line12>        trustManager.checkClientTrusted(certChain, clientCert.getPublicKey().getAlgorithm());\n<line13>    } catch (CertificateException ce) {\n<line14>        return ids;\n<line15>    }\n<line16>    final String clientId = getClientId(clientCert);\n<line17>    if (clientId.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER))) {\n<line18>        ids.add(new Id(\"super\", clientId));\n<line19>    }\n<line20>    final Id id = new Id(getScheme(), clientId);\n<line21>    ids.add(id);\n<line22>    return Collections.unmodifiableList(ids);\n<line23>}","output":"<line1>{\n<line2>    final List<Id> ids = new ArrayList<>();\n<line3>    if (certChain == null || certChain.length == 0) {\n<line4>        LOG.warn(\"No certificate chain available to authenticate\");\n<line5>        return ids;\n<line6>    }\n<line7>    if (trustManager == null) {\n<line8>        LOG.error(\"No trust manager available to authenticate\");\n<line9>        return ids;\n<line10>    }\n<line11>    final X509Certificate clientCert = certChain[0];\n<line12>    try {\n<line13>        // Authenticate client certificate\n<line14>        trustManager.checkClientTrusted(certChain, clientCert.getPublicKey().getAlgorithm());\n<line15>    } catch (CertificateException ce) {\n<line16>        LOG.error(\"Failed to trust certificate\", ce);\n<line17>        return ids;\n<line18>    }\n<line19>    final String clientId = getClientId(clientCert);\n<line20>    if (clientId.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER))) {\n<line21>        ids.add(new Id(\"super\", clientId));\n<line22>        LOG.info(\"Authenticated Id '{}' as super user\", clientId);\n<line23>    }\n<line24>    final Id id = new Id(getScheme(), clientId);\n<line25>    ids.add(id);\n<line26>    LOG.info(\"Authenticated Id '{}' for scheme '{}'\", id.getId(), id.getScheme());\n<line27>    return Collections.unmodifiableList(ids);\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    return ids;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"No trust manager available to authenticate\");\n<line3>    return ids;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return ids;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to trust certificate\", ce);\n<line3>    return ids;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ids.add(new Id(\"super\", clientId));\n<line3>}","output":"<line1>{\n<line2>    ids.add(new Id(\"super\", clientId));\n<line3>    LOG.info(\"Authenticated Id '{}' as super user\", clientId);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String namesCSV = System.getProperty(ENSEMBLE_PROPERTY);\n<line3>    if (namesCSV != null) {\n<line4>        setEnsembleNames(namesCSV);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    String namesCSV = System.getProperty(ENSEMBLE_PROPERTY);\n<line3>    if (namesCSV != null) {\n<line4>        LOG.info(\"Set expected ensemble names to {}\", namesCSV);\n<line5>        setEnsembleNames(namesCSV);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    setEnsembleNames(namesCSV);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Set expected ensemble names to {}\", namesCSV);\n<line3>    setEnsembleNames(namesCSV);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (longVal == null) {\n<line3>        return null;\n<line4>    }\n<line5>    if (longVal == OPEN_UNSAFE_ACL_ID) {\n<line6>        return ZooDefs.Ids.OPEN_ACL_UNSAFE;\n<line7>    }\n<line8>    List<ACL> acls = longKeyMap.get(longVal);\n<line9>    if (acls == null) {\n<line10>        throw new RuntimeException(\"Failed to fetch acls for \" + longVal);\n<line11>    }\n<line12>    return acls;\n<line13>}","output":"<line1>{\n<line2>    if (longVal == null) {\n<line3>        return null;\n<line4>    }\n<line5>    if (longVal == OPEN_UNSAFE_ACL_ID) {\n<line6>        return ZooDefs.Ids.OPEN_ACL_UNSAFE;\n<line7>    }\n<line8>    List<ACL> acls = longKeyMap.get(longVal);\n<line9>    if (acls == null) {\n<line10>        LOG.error(\"ERROR: ACL not available for long {}\", longVal);\n<line11>        throw new RuntimeException(\"Failed to fetch acls for \" + longVal);\n<line12>    }\n<line13>    return acls;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new RuntimeException(\"Failed to fetch acls for \" + longVal);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"ERROR: ACL not available for long {}\", longVal);\n<line3>    throw new RuntimeException(\"Failed to fetch acls for \" + longVal);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (acl == OPEN_UNSAFE_ACL_ID) {\n<line3>        return;\n<line4>    }\n<line5>    if (!longKeyMap.containsKey(acl)) {\n<line6>        return;\n<line7>    }\n<line8>    AtomicLong count = referenceCounter.get(acl);\n<line9>    if (count == null) {\n<line10>        referenceCounter.put(acl, new AtomicLongWithEquals(1));\n<line11>    } else {\n<line12>        count.incrementAndGet();\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    if (acl == OPEN_UNSAFE_ACL_ID) {\n<line3>        return;\n<line4>    }\n<line5>    if (!longKeyMap.containsKey(acl)) {\n<line6>        LOG.info(\"Ignoring acl {} as it does not exist in the cache\", acl);\n<line7>        return;\n<line8>    }\n<line9>    AtomicLong count = referenceCounter.get(acl);\n<line10>    if (count == null) {\n<line11>        referenceCounter.put(acl, new AtomicLongWithEquals(1));\n<line12>    } else {\n<line13>        count.incrementAndGet();\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Ignoring acl {} as it does not exist in the cache\", acl);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (acl == OPEN_UNSAFE_ACL_ID) {\n<line3>        return;\n<line4>    }\n<line5>    if (!longKeyMap.containsKey(acl)) {\n<line6>        return;\n<line7>    }\n<line8>    long newCount = referenceCounter.get(acl).decrementAndGet();\n<line9>    if (newCount <= 0) {\n<line10>        referenceCounter.remove(acl);\n<line11>        aclKeyMap.remove(longKeyMap.get(acl));\n<line12>        longKeyMap.remove(acl);\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    if (acl == OPEN_UNSAFE_ACL_ID) {\n<line3>        return;\n<line4>    }\n<line5>    if (!longKeyMap.containsKey(acl)) {\n<line6>        LOG.info(\"Ignoring acl {} as it does not exist in the cache\", acl);\n<line7>        return;\n<line8>    }\n<line9>    long newCount = referenceCounter.get(acl).decrementAndGet();\n<line10>    if (newCount <= 0) {\n<line11>        referenceCounter.remove(acl);\n<line12>        aclKeyMap.remove(longKeyMap.get(acl));\n<line13>        longKeyMap.remove(acl);\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Ignoring acl {} as it does not exist in the cache\", acl);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);\n<line3>    byte[] bytes = aheadEndpoint.getBytes();\n<line4>    boolean isSSL;\n<line5>    if (bytes == null || bytes.length == 0) {\n<line6>        isSSL = false;\n<line7>    } else {\n<line8>        // TLS first byte is 0x16, let's not support SSLv3 and below\n<line9>        byte b = bytes[0];\n<line10>        // matches SSL detection in NettyServerCnxnFactory.java\n<line11>        isSSL = b == 0x16;\n<line12>    }\n<line13>    EndPoint plainEndpoint;\n<line14>    SslConnection sslConnection;\n<line15>    if (isSSL) {\n<line16>        SSLEngine engine = this.sslContextFactory.newSSLEngine(aheadEndpoint.getRemoteAddress());\n<line17>        engine.setUseClientMode(false);\n<line18>        sslConnection = this.newSslConnection(connector, aheadEndpoint, engine);\n<line19>        sslConnection.setRenegotiationAllowed(this.sslContextFactory.isRenegotiationAllowed());\n<line20>        this.configure(sslConnection, connector, aheadEndpoint);\n<line21>        plainEndpoint = sslConnection.getDecryptedEndPoint();\n<line22>    } else {\n<line23>        sslConnection = null;\n<line24>        plainEndpoint = aheadEndpoint;\n<line25>        ServerMetrics.getMetrics().INSECURE_ADMIN.add(1);\n<line26>    }\n<line27>    ConnectionFactory next = connector.getConnectionFactory(nextProtocol);\n<line28>    Connection connection = next.newConnection(connector, plainEndpoint);\n<line29>    plainEndpoint.setConnection(connection);\n<line30>    return (sslConnection == null) ? connection : sslConnection;\n<line31>}","output":"<line1>{\n<line2>    ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);\n<line3>    byte[] bytes = aheadEndpoint.getBytes();\n<line4>    boolean isSSL;\n<line5>    if (bytes == null || bytes.length == 0) {\n<line6>        isSSL = false;\n<line7>        LOG.warn(\"Incoming connection has no data\");\n<line8>    } else {\n<line9>        // TLS first byte is 0x16, let's not support SSLv3 and below\n<line10>        byte b = bytes[0];\n<line11>        // matches SSL detection in NettyServerCnxnFactory.java\n<line12>        isSSL = b == 0x16;\n<line13>    }\n<line14>    LOG.debug(String.format(\"UnifiedConnectionFactory: newConnection() with SSL = %b\", isSSL));\n<line15>    EndPoint plainEndpoint;\n<line16>    SslConnection sslConnection;\n<line17>    if (isSSL) {\n<line18>        SSLEngine engine = this.sslContextFactory.newSSLEngine(aheadEndpoint.getRemoteAddress());\n<line19>        engine.setUseClientMode(false);\n<line20>        sslConnection = this.newSslConnection(connector, aheadEndpoint, engine);\n<line21>        sslConnection.setRenegotiationAllowed(this.sslContextFactory.isRenegotiationAllowed());\n<line22>        this.configure(sslConnection, connector, aheadEndpoint);\n<line23>        plainEndpoint = sslConnection.getDecryptedEndPoint();\n<line24>    } else {\n<line25>        sslConnection = null;\n<line26>        plainEndpoint = aheadEndpoint;\n<line27>        ServerMetrics.getMetrics().INSECURE_ADMIN.add(1);\n<line28>    }\n<line29>    ConnectionFactory next = connector.getConnectionFactory(nextProtocol);\n<line30>    Connection connection = next.newConnection(connector, plainEndpoint);\n<line31>    plainEndpoint.setConnection(connection);\n<line32>    return (sslConnection == null) ? connection : sslConnection;\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    this.port = port;\n<line3>    this.idleTimeout = timeout;\n<line4>    this.commandUrl = commandUrl;\n<line5>    this.address = address;\n<line6>    server = new Server();\n<line7>    ServerConnector connector = null;\n<line8>    if (!portUnification && !forceHttps) {\n<line9>        connector = new ServerConnector(server);\n<line10>    } else {\n<line11>        SecureRequestCustomizer customizer = new SecureRequestCustomizer();\n<line12>        customizer.setStsMaxAge(DEFAULT_STS_MAX_AGE);\n<line13>        customizer.setStsIncludeSubDomains(true);\n<line14>        HttpConfiguration config = new HttpConfiguration();\n<line15>        config.setSecureScheme(\"https\");\n<line16>        config.addCustomizer(customizer);\n<line17>        try (QuorumX509Util x509Util = new QuorumX509Util()) {\n<line18>            String privateKeyType = System.getProperty(x509Util.getSslKeystoreTypeProperty(), \"\");\n<line19>            String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line20>            String privateKeyPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line21>            String certAuthType = System.getProperty(x509Util.getSslTruststoreTypeProperty(), \"\");\n<line22>            String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line23>            String certAuthPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line24>            KeyStore keyStore = null, trustStore = null;\n<line25>            try {\n<line26>                keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line27>                trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line28>            } catch (Exception e) {\n<line29>                throw e;\n<line30>            }\n<line31>            SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n<line32>            sslContextFactory.setKeyStore(keyStore);\n<line33>            sslContextFactory.setKeyStorePassword(privateKeyPassword);\n<line34>            sslContextFactory.setTrustStore(trustStore);\n<line35>            sslContextFactory.setTrustStorePassword(certAuthPassword);\n<line36>            sslContextFactory.setNeedClientAuth(needClientAuth);\n<line37>            if (forceHttps) {\n<line38>                connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line39>            } else {\n<line40>                connector = new ServerConnector(server, new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line41>            }\n<line42>        }\n<line43>    }\n<line44>    connector.setHost(address);\n<line45>    connector.setPort(port);\n<line46>    connector.setIdleTimeout(idleTimeout);\n<line47>    server.addConnector(connector);\n<line48>    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n<line49>    context.setContextPath(\"/*\");\n<line50>    constrainTraceMethod(context);\n<line51>    server.setHandler(context);\n<line52>    context.addServlet(new ServletHolder(new CommandServlet()), commandUrl + \"/*\");\n<line53>}","output":"<line1>{\n<line2>    this.port = port;\n<line3>    this.idleTimeout = timeout;\n<line4>    this.commandUrl = commandUrl;\n<line5>    this.address = address;\n<line6>    server = new Server();\n<line7>    ServerConnector connector = null;\n<line8>    if (!portUnification && !forceHttps) {\n<line9>        connector = new ServerConnector(server);\n<line10>    } else {\n<line11>        SecureRequestCustomizer customizer = new SecureRequestCustomizer();\n<line12>        customizer.setStsMaxAge(DEFAULT_STS_MAX_AGE);\n<line13>        customizer.setStsIncludeSubDomains(true);\n<line14>        HttpConfiguration config = new HttpConfiguration();\n<line15>        config.setSecureScheme(\"https\");\n<line16>        config.addCustomizer(customizer);\n<line17>        try (QuorumX509Util x509Util = new QuorumX509Util()) {\n<line18>            String privateKeyType = System.getProperty(x509Util.getSslKeystoreTypeProperty(), \"\");\n<line19>            String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line20>            String privateKeyPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line21>            String certAuthType = System.getProperty(x509Util.getSslTruststoreTypeProperty(), \"\");\n<line22>            String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line23>            String certAuthPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line24>            KeyStore keyStore = null, trustStore = null;\n<line25>            try {\n<line26>                keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line27>                trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line28>                LOG.info(\"Successfully loaded private key from {}\", privateKeyPath);\n<line29>                LOG.info(\"Successfully loaded certificate authority from {}\", certAuthPath);\n<line30>            } catch (Exception e) {\n<line31>                LOG.error(\"Failed to load authentication certificates for admin server.\", e);\n<line32>                throw e;\n<line33>            }\n<line34>            SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n<line35>            sslContextFactory.setKeyStore(keyStore);\n<line36>            sslContextFactory.setKeyStorePassword(privateKeyPassword);\n<line37>            sslContextFactory.setTrustStore(trustStore);\n<line38>            sslContextFactory.setTrustStorePassword(certAuthPassword);\n<line39>            sslContextFactory.setNeedClientAuth(needClientAuth);\n<line40>            if (forceHttps) {\n<line41>                connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line42>            } else {\n<line43>                connector = new ServerConnector(server, new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line44>            }\n<line45>        }\n<line46>    }\n<line47>    connector.setHost(address);\n<line48>    connector.setPort(port);\n<line49>    connector.setIdleTimeout(idleTimeout);\n<line50>    server.addConnector(connector);\n<line51>    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n<line52>    context.setContextPath(\"/*\");\n<line53>    constrainTraceMethod(context);\n<line54>    server.setHandler(context);\n<line55>    context.addServlet(new ServletHolder(new CommandServlet()), commandUrl + \"/*\");\n<line56>}"},{"input":"","instruction":"<line1>{\n<line2>    SecureRequestCustomizer customizer = new SecureRequestCustomizer();\n<line3>    customizer.setStsMaxAge(DEFAULT_STS_MAX_AGE);\n<line4>    customizer.setStsIncludeSubDomains(true);\n<line5>    HttpConfiguration config = new HttpConfiguration();\n<line6>    config.setSecureScheme(\"https\");\n<line7>    config.addCustomizer(customizer);\n<line8>    try (QuorumX509Util x509Util = new QuorumX509Util()) {\n<line9>        String privateKeyType = System.getProperty(x509Util.getSslKeystoreTypeProperty(), \"\");\n<line10>        String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line11>        String privateKeyPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line12>        String certAuthType = System.getProperty(x509Util.getSslTruststoreTypeProperty(), \"\");\n<line13>        String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line14>        String certAuthPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line15>        KeyStore keyStore = null, trustStore = null;\n<line16>        try {\n<line17>            keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line18>            trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line19>        } catch (Exception e) {\n<line20>            throw e;\n<line21>        }\n<line22>        SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n<line23>        sslContextFactory.setKeyStore(keyStore);\n<line24>        sslContextFactory.setKeyStorePassword(privateKeyPassword);\n<line25>        sslContextFactory.setTrustStore(trustStore);\n<line26>        sslContextFactory.setTrustStorePassword(certAuthPassword);\n<line27>        sslContextFactory.setNeedClientAuth(needClientAuth);\n<line28>        if (forceHttps) {\n<line29>            connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line30>        } else {\n<line31>            connector = new ServerConnector(server, new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line32>        }\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    SecureRequestCustomizer customizer = new SecureRequestCustomizer();\n<line3>    customizer.setStsMaxAge(DEFAULT_STS_MAX_AGE);\n<line4>    customizer.setStsIncludeSubDomains(true);\n<line5>    HttpConfiguration config = new HttpConfiguration();\n<line6>    config.setSecureScheme(\"https\");\n<line7>    config.addCustomizer(customizer);\n<line8>    try (QuorumX509Util x509Util = new QuorumX509Util()) {\n<line9>        String privateKeyType = System.getProperty(x509Util.getSslKeystoreTypeProperty(), \"\");\n<line10>        String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line11>        String privateKeyPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line12>        String certAuthType = System.getProperty(x509Util.getSslTruststoreTypeProperty(), \"\");\n<line13>        String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line14>        String certAuthPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line15>        KeyStore keyStore = null, trustStore = null;\n<line16>        try {\n<line17>            keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line18>            trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line19>            LOG.info(\"Successfully loaded private key from {}\", privateKeyPath);\n<line20>            LOG.info(\"Successfully loaded certificate authority from {}\", certAuthPath);\n<line21>        } catch (Exception e) {\n<line22>            LOG.error(\"Failed to load authentication certificates for admin server.\", e);\n<line23>            throw e;\n<line24>        }\n<line25>        SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n<line26>        sslContextFactory.setKeyStore(keyStore);\n<line27>        sslContextFactory.setKeyStorePassword(privateKeyPassword);\n<line28>        sslContextFactory.setTrustStore(trustStore);\n<line29>        sslContextFactory.setTrustStorePassword(certAuthPassword);\n<line30>        sslContextFactory.setNeedClientAuth(needClientAuth);\n<line31>        if (forceHttps) {\n<line32>            connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line33>        } else {\n<line34>            connector = new ServerConnector(server, new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line35>        }\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    String privateKeyType = System.getProperty(x509Util.getSslKeystoreTypeProperty(), \"\");\n<line3>    String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line4>    String privateKeyPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line5>    String certAuthType = System.getProperty(x509Util.getSslTruststoreTypeProperty(), \"\");\n<line6>    String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line7>    String certAuthPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line8>    KeyStore keyStore = null, trustStore = null;\n<line9>    try {\n<line10>        keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line11>        trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line12>    } catch (Exception e) {\n<line13>        throw e;\n<line14>    }\n<line15>    SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n<line16>    sslContextFactory.setKeyStore(keyStore);\n<line17>    sslContextFactory.setKeyStorePassword(privateKeyPassword);\n<line18>    sslContextFactory.setTrustStore(trustStore);\n<line19>    sslContextFactory.setTrustStorePassword(certAuthPassword);\n<line20>    sslContextFactory.setNeedClientAuth(needClientAuth);\n<line21>    if (forceHttps) {\n<line22>        connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line23>    } else {\n<line24>        connector = new ServerConnector(server, new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    String privateKeyType = System.getProperty(x509Util.getSslKeystoreTypeProperty(), \"\");\n<line3>    String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), \"\");\n<line4>    String privateKeyPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslKeystorePasswdProperty(), x509Util.getSslKeystorePasswdPathProperty());\n<line5>    String certAuthType = System.getProperty(x509Util.getSslTruststoreTypeProperty(), \"\");\n<line6>    String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), \"\");\n<line7>    String certAuthPassword = getPasswordFromSystemPropertyOrFile(x509Util.getSslTruststorePasswdProperty(), x509Util.getSslTruststorePasswdPathProperty());\n<line8>    KeyStore keyStore = null, trustStore = null;\n<line9>    try {\n<line10>        keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line11>        trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line12>        LOG.info(\"Successfully loaded private key from {}\", privateKeyPath);\n<line13>        LOG.info(\"Successfully loaded certificate authority from {}\", certAuthPath);\n<line14>    } catch (Exception e) {\n<line15>        LOG.error(\"Failed to load authentication certificates for admin server.\", e);\n<line16>        throw e;\n<line17>    }\n<line18>    SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n<line19>    sslContextFactory.setKeyStore(keyStore);\n<line20>    sslContextFactory.setKeyStorePassword(privateKeyPassword);\n<line21>    sslContextFactory.setTrustStore(trustStore);\n<line22>    sslContextFactory.setTrustStorePassword(certAuthPassword);\n<line23>    sslContextFactory.setNeedClientAuth(needClientAuth);\n<line24>    if (forceHttps) {\n<line25>        connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line26>    } else {\n<line27>        connector = new ServerConnector(server, new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()), new HttpConnectionFactory(config));\n<line28>    }\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line3>    trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line4>}","output":"<line1>{\n<line2>    keyStore = X509Util.loadKeyStore(privateKeyPath, privateKeyPassword, privateKeyType);\n<line3>    trustStore = X509Util.loadTrustStore(certAuthPath, certAuthPassword, certAuthType);\n<line4>    LOG.info(\"Successfully loaded private key from {}\", privateKeyPath);\n<line5>    LOG.info(\"Successfully loaded certificate authority from {}\", certAuthPath);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to load authentication certificates for admin server.\", e);\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        server.start();\n<line4>    } catch (Exception e) {\n<line5>        // Server.start() only throws Exception, so let's at least wrap it\n<line6>        // in an identifiable subclass\n<line7>        String message = String.format(\"Problem starting AdminServer on address %s, port %d and command URL %s\", address, port, commandUrl);\n<line8>        throw new AdminServerException(message, e);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    try {\n<line3>        server.start();\n<line4>    } catch (Exception e) {\n<line5>        // Server.start() only throws Exception, so let's at least wrap it\n<line6>        // in an identifiable subclass\n<line7>        String message = String.format(\"Problem starting AdminServer on address %s, port %d and command URL %s\", address, port, commandUrl);\n<line8>        throw new AdminServerException(message, e);\n<line9>    }\n<line10>    LOG.info(\"Started AdminServer on address {}, port {} and command URL {}\", address, port, commandUrl);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    CommandResponse response = initializeResponse();\n<line3>    response.put(\"version\", Version.getFullVersion());\n<line4>    response.put(\"read_only\", zkServer instanceof ReadOnlyZooKeeperServer);\n<line5>    response.put(\"server_stats\", zkServer.serverStats());\n<line6>    response.put(\"client_response\", zkServer.serverStats().getClientResponseStats());\n<line7>    if (zkServer instanceof LeaderZooKeeperServer) {\n<line8>        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();\n<line9>        response.put(\"proposal_stats\", leader.getProposalStats());\n<line10>    }\n<line11>    response.put(\"node_count\", zkServer.getZKDatabase().getNodeCount());\n<line12>    return response;\n<line13>}","output":"<line1>{\n<line2>    CommandResponse response = initializeResponse();\n<line3>    LOG.info(\"running stat\");\n<line4>    response.put(\"version\", Version.getFullVersion());\n<line5>    response.put(\"read_only\", zkServer instanceof ReadOnlyZooKeeperServer);\n<line6>    response.put(\"server_stats\", zkServer.serverStats());\n<line7>    response.put(\"client_response\", zkServer.serverStats().getClientResponseStats());\n<line8>    if (zkServer instanceof LeaderZooKeeperServer) {\n<line9>        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();\n<line10>        response.put(\"proposal_stats\", leader.getProposalStats());\n<line11>    }\n<line12>    response.put(\"node_count\", zkServer.getZKDatabase().getNodeCount());\n<line13>    return response;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (running) {\n<line4>            long waitTime = sessionExpiryQueue.getWaitTime();\n<line5>            if (waitTime > 0) {\n<line6>                Thread.sleep(waitTime);\n<line7>                continue;\n<line8>            }\n<line9>            for (SessionImpl s : sessionExpiryQueue.poll()) {\n<line10>                ServerMetrics.getMetrics().STALE_SESSIONS_EXPIRED.add(1);\n<line11>                setSessionClosing(s.sessionId);\n<line12>                expirer.expire(s);\n<line13>            }\n<line14>        }\n<line15>    } catch (InterruptedException e) {\n<line16>        handleException(this.getName(), e);\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        while (running) {\n<line4>            long waitTime = sessionExpiryQueue.getWaitTime();\n<line5>            if (waitTime > 0) {\n<line6>                Thread.sleep(waitTime);\n<line7>                continue;\n<line8>            }\n<line9>            for (SessionImpl s : sessionExpiryQueue.poll()) {\n<line10>                ServerMetrics.getMetrics().STALE_SESSIONS_EXPIRED.add(1);\n<line11>                setSessionClosing(s.sessionId);\n<line12>                expirer.expire(s);\n<line13>            }\n<line14>        }\n<line15>    } catch (InterruptedException e) {\n<line16>        handleException(this.getName(), e);\n<line17>    }\n<line18>    LOG.info(\"SessionTrackerImpl exited loop!\");\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    SessionImpl s = sessionsById.remove(sessionId);\n<line3>    sessionsWithTimeout.remove(sessionId);\n<line4>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"SessionTrackerImpl --- Removing session 0x\" + Long.toHexString(sessionId));\n<line5>    }\n<line6>    if (s != null) {\n<line7>        sessionExpiryQueue.remove(s);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.debug(\"Removing session 0x{}\", Long.toHexString(sessionId));\n<line3>    SessionImpl s = sessionsById.remove(sessionId);\n<line4>    sessionsWithTimeout.remove(sessionId);\n<line5>    if (LOG.isTraceEnabled()) {\n<line6>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"SessionTrackerImpl --- Removing session 0x\" + Long.toHexString(sessionId));\n<line7>    }\n<line8>    if (s != null) {\n<line9>        sessionExpiryQueue.remove(s);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    running = false;\n<line3>        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), \"Shutdown SessionTrackerImpl!\");\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    running = false;\n<line4>    if (LOG.isTraceEnabled()) {\n<line5>        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), \"Shutdown SessionTrackerImpl!\");\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean added = false;\n<line3>    SessionImpl session = sessionsById.get(id);\n<line4>    if (session == null) {\n<line5>        session = new SessionImpl(id, sessionTimeout);\n<line6>    }\n<line7>    // findbugs2.0.3 complains about get after put.\n<line8>    // long term strategy would be use computeIfAbsent after JDK 1.8\n<line9>    SessionImpl existedSession = sessionsById.putIfAbsent(id, session);\n<line10>    if (existedSession != null) {\n<line11>        session = existedSession;\n<line12>    } else {\n<line13>        added = true;\n<line14>    }\n<line15>        String actionStr = added ? \"Adding\" : \"Existing\";\n<line16>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"SessionTrackerImpl --- \" + actionStr + \" session 0x\" + Long.toHexString(id) + \" \" + sessionTimeout);\n<line17>    }\n<line18>    updateSessionExpiry(session, sessionTimeout);\n<line19>    return added;\n<line20>}","output":"<line1>{\n<line2>    boolean added = false;\n<line3>    SessionImpl session = sessionsById.get(id);\n<line4>    if (session == null) {\n<line5>        session = new SessionImpl(id, sessionTimeout);\n<line6>    }\n<line7>    // findbugs2.0.3 complains about get after put.\n<line8>    // long term strategy would be use computeIfAbsent after JDK 1.8\n<line9>    SessionImpl existedSession = sessionsById.putIfAbsent(id, session);\n<line10>    if (existedSession != null) {\n<line11>        session = existedSession;\n<line12>    } else {\n<line13>        added = true;\n<line14>        LOG.debug(\"Adding session 0x{}\", Long.toHexString(id));\n<line15>    }\n<line16>    if (LOG.isTraceEnabled()) {\n<line17>        String actionStr = added ? \"Adding\" : \"Existing\";\n<line18>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"SessionTrackerImpl --- \" + actionStr + \" session 0x\" + Long.toHexString(id) + \" \" + sessionTimeout);\n<line19>    }\n<line20>    updateSessionExpiry(session, sessionTimeout);\n<line21>    return added;\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    added = true;\n<line3>}","output":"<line1>{\n<line2>    added = true;\n<line3>    LOG.debug(\"Adding session 0x{}\", Long.toHexString(id));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    SessionImpl session = sessionsById.get(sessionId);\n<line3>    if (session == null) {\n<line4>        throw new KeeperException.UnknownSessionException();\n<line5>    }\n<line6>    if (session.isClosing()) {\n<line7>        throw new KeeperException.SessionExpiredException();\n<line8>    }\n<line9>    if (session.owner == null) {\n<line10>        session.owner = owner;\n<line11>    } else if (session.owner != owner) {\n<line12>        throw new KeeperException.SessionMovedException();\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    LOG.debug(\"Checking session 0x{}\", Long.toHexString(sessionId));\n<line3>    SessionImpl session = sessionsById.get(sessionId);\n<line4>    if (session == null) {\n<line5>        throw new KeeperException.UnknownSessionException();\n<line6>    }\n<line7>    if (session.isClosing()) {\n<line8>        throw new KeeperException.SessionExpiredException();\n<line9>    }\n<line10>    if (session.owner == null) {\n<line11>        session.owner = owner;\n<line12>    } else if (session.owner != owner) {\n<line13>        throw new KeeperException.SessionMovedException();\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    this.digestCalculator = digestCalculator;\n<line3>    nodes = new NodeHashMapImpl(digestCalculator);\n<line4>    // rather than fight it, let root have an alias\n<line5>    nodes.put(\"\", root);\n<line6>    nodes.putWithoutDigest(rootZookeeper, root);\n<line7>    // add the proc node and quota node\n<line8>    root.addChild(procChildZookeeper);\n<line9>    nodes.put(procZookeeper, procDataNode);\n<line10>    procDataNode.addChild(quotaChildZookeeper);\n<line11>    nodes.put(quotaZookeeper, quotaDataNode);\n<line12>    addConfigNode();\n<line13>    nodeDataSize.set(approximateDataSize());\n<line14>    try {\n<line15>        dataWatches = WatchManagerFactory.createWatchManager();\n<line16>        childWatches = WatchManagerFactory.createWatchManager();\n<line17>    } catch (Exception e) {\n<line18>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    this.digestCalculator = digestCalculator;\n<line3>    nodes = new NodeHashMapImpl(digestCalculator);\n<line4>    // rather than fight it, let root have an alias\n<line5>    nodes.put(\"\", root);\n<line6>    nodes.putWithoutDigest(rootZookeeper, root);\n<line7>    // add the proc node and quota node\n<line8>    root.addChild(procChildZookeeper);\n<line9>    nodes.put(procZookeeper, procDataNode);\n<line10>    procDataNode.addChild(quotaChildZookeeper);\n<line11>    nodes.put(quotaZookeeper, quotaDataNode);\n<line12>    addConfigNode();\n<line13>    nodeDataSize.set(approximateDataSize());\n<line14>    try {\n<line15>        dataWatches = WatchManagerFactory.createWatchManager();\n<line16>        childWatches = WatchManagerFactory.createWatchManager();\n<line17>    } catch (Exception e) {\n<line18>        LOG.error(\"Unexpected exception when creating WatchManager, exiting abnormally\", e);\n<line19>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception when creating WatchManager, exiting abnormally\", e);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String statNodePath = Quotas.statPath(lastPrefix);\n<line3>    DataNode statNode = nodes.get(statNodePath);\n<line4>    if (statNode == null) {\n<line5>        // should not happen\n<line6>        return;\n<line7>    }\n<line8>    synchronized (statNode) {\n<line9>        StatsTrack updatedStat = new StatsTrack(statNode.data);\n<line10>        updatedStat.setCount(updatedStat.getCount() + countDiff);\n<line11>        updatedStat.setBytes(updatedStat.getBytes() + bytesDiff);\n<line12>        statNode.data = updatedStat.getStatsBytes();\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    String statNodePath = Quotas.statPath(lastPrefix);\n<line3>    DataNode statNode = nodes.get(statNodePath);\n<line4>    if (statNode == null) {\n<line5>        // should not happen\n<line6>        LOG.error(\"Missing node for stat {}\", statNodePath);\n<line7>        return;\n<line8>    }\n<line9>    synchronized (statNode) {\n<line10>        StatsTrack updatedStat = new StatsTrack(statNode.data);\n<line11>        updatedStat.setCount(updatedStat.getCount() + countDiff);\n<line12>        updatedStat.setBytes(updatedStat.getBytes() + bytesDiff);\n<line13>        statNode.data = updatedStat.getStatsBytes();\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    // should not happen\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    // should not happen\n<line3>    LOG.error(\"Missing node for stat {}\", statNodePath);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    ProcessTxnResult rc = new ProcessTxnResult();\n<line3>    try {\n<line4>        rc.clientId = header.getClientId();\n<line5>        rc.cxid = header.getCxid();\n<line6>        rc.zxid = header.getZxid();\n<line7>        rc.type = header.getType();\n<line8>        rc.err = 0;\n<line9>        rc.multiResult = null;\n<line10>        switch(header.getType()) {\n<line11>            case OpCode.create:\n<line12>                CreateTxn createTxn = (CreateTxn) txn;\n<line13>                rc.path = createTxn.getPath();\n<line14>                createNode(createTxn.getPath(), createTxn.getData(), createTxn.getAcl(), createTxn.getEphemeral() ? header.getClientId() : 0, createTxn.getParentCVersion(), header.getZxid(), header.getTime(), null);\n<line15>                break;\n<line16>            case OpCode.create2:\n<line17>                CreateTxn create2Txn = (CreateTxn) txn;\n<line18>                rc.path = create2Txn.getPath();\n<line19>                Stat stat = new Stat();\n<line20>                createNode(create2Txn.getPath(), create2Txn.getData(), create2Txn.getAcl(), create2Txn.getEphemeral() ? header.getClientId() : 0, create2Txn.getParentCVersion(), header.getZxid(), header.getTime(), stat);\n<line21>                rc.stat = stat;\n<line22>                break;\n<line23>            case OpCode.createTTL:\n<line24>                CreateTTLTxn createTtlTxn = (CreateTTLTxn) txn;\n<line25>                rc.path = createTtlTxn.getPath();\n<line26>                stat = new Stat();\n<line27>                createNode(createTtlTxn.getPath(), createTtlTxn.getData(), createTtlTxn.getAcl(), EphemeralType.TTL.toEphemeralOwner(createTtlTxn.getTtl()), createTtlTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);\n<line28>                rc.stat = stat;\n<line29>                break;\n<line30>            case OpCode.createContainer:\n<line31>                CreateContainerTxn createContainerTxn = (CreateContainerTxn) txn;\n<line32>                rc.path = createContainerTxn.getPath();\n<line33>                stat = new Stat();\n<line34>                createNode(createContainerTxn.getPath(), createContainerTxn.getData(), createContainerTxn.getAcl(), EphemeralType.CONTAINER_EPHEMERAL_OWNER, createContainerTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);\n<line35>                rc.stat = stat;\n<line36>                break;\n<line37>            case OpCode.delete:\n<line38>            case OpCode.deleteContainer:\n<line39>                DeleteTxn deleteTxn = (DeleteTxn) txn;\n<line40>                rc.path = deleteTxn.getPath();\n<line41>                deleteNode(deleteTxn.getPath(), header.getZxid());\n<line42>                break;\n<line43>            case OpCode.reconfig:\n<line44>            case OpCode.setData:\n<line45>                SetDataTxn setDataTxn = (SetDataTxn) txn;\n<line46>                rc.path = setDataTxn.getPath();\n<line47>                rc.stat = setData(setDataTxn.getPath(), setDataTxn.getData(), setDataTxn.getVersion(), header.getZxid(), header.getTime());\n<line48>                break;\n<line49>            case OpCode.setACL:\n<line50>                SetACLTxn setACLTxn = (SetACLTxn) txn;\n<line51>                rc.path = setACLTxn.getPath();\n<line52>                rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(), setACLTxn.getVersion());\n<line53>                break;\n<line54>            case OpCode.closeSession:\n<line55>                long sessionId = header.getClientId();\n<line56>                if (txn != null) {\n<line57>                    killSession(sessionId, header.getZxid(), ephemerals.remove(sessionId), ((CloseSessionTxn) txn).getPaths2Delete());\n<line58>                } else {\n<line59>                    killSession(sessionId, header.getZxid());\n<line60>                }\n<line61>                break;\n<line62>            case OpCode.error:\n<line63>                ErrorTxn errTxn = (ErrorTxn) txn;\n<line64>                rc.err = errTxn.getErr();\n<line65>                break;\n<line66>            case OpCode.check:\n<line67>                CheckVersionTxn checkTxn = (CheckVersionTxn) txn;\n<line68>                rc.path = checkTxn.getPath();\n<line69>                break;\n<line70>            case OpCode.multi:\n<line71>                MultiTxn multiTxn = (MultiTxn) txn;\n<line72>                List<Txn> txns = multiTxn.getTxns();\n<line73>                rc.multiResult = new ArrayList<>();\n<line74>                boolean failed = false;\n<line75>                for (Txn subtxn : txns) {\n<line76>                    if (subtxn.getType() == OpCode.error) {\n<line77>                        failed = true;\n<line78>                        break;\n<line79>                    }\n<line80>                }\n<line81>                boolean post_failed = false;\n<line82>                for (Txn subtxn : txns) {\n<line83>                    ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());\n<line84>                    Record record;\n<line85>                    switch(subtxn.getType()) {\n<line86>                        case OpCode.create:\n<line87>                        case OpCode.create2:\n<line88>                            record = new CreateTxn();\n<line89>                            break;\n<line90>                        case OpCode.createTTL:\n<line91>                            record = new CreateTTLTxn();\n<line92>                            break;\n<line93>                        case OpCode.createContainer:\n<line94>                            record = new CreateContainerTxn();\n<line95>                            break;\n<line96>                        case OpCode.delete:\n<line97>                        case OpCode.deleteContainer:\n<line98>                            record = new DeleteTxn();\n<line99>                            break;\n<line100>                        case OpCode.setData:\n<line101>                            record = new SetDataTxn();\n<line102>                            break;\n<line103>                        case OpCode.error:\n<line104>                            record = new ErrorTxn();\n<line105>                            post_failed = true;\n<line106>                            break;\n<line107>                        case OpCode.check:\n<line108>                            record = new CheckVersionTxn();\n<line109>                            break;\n<line110>                        default:\n<line111>                            throw new IOException(\"Invalid type of op: \" + subtxn.getType());\n<line112>                    }\n<line113>                    assert record != null;\n<line114>                    ByteBufferInputStream.byteBuffer2Record(bb, record);\n<line115>                    if (failed && subtxn.getType() != OpCode.error) {\n<line116>                        int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue() : Code.OK.intValue();\n<line117>                        subtxn.setType(OpCode.error);\n<line118>                        record = new ErrorTxn(ec);\n<line119>                    }\n<line120>                    assert !failed || (subtxn.getType() == OpCode.error);\n<line121>                    TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(), header.getZxid(), header.getTime(), subtxn.getType());\n<line122>                    ProcessTxnResult subRc = processTxn(subHdr, record, true);\n<line123>                    rc.multiResult.add(subRc);\n<line124>                    if (subRc.err != 0 && rc.err == 0) {\n<line125>                        rc.err = subRc.err;\n<line126>                    }\n<line127>                }\n<line128>                break;\n<line129>        }\n<line130>    } catch (KeeperException e) {\n<line131>        rc.err = e.code().intValue();\n<line132>    } catch (IOException e) {\n<line133>    }\n<line134>    /*\n<line135>         * Snapshots are taken lazily. When serializing a node, it's data\n<line136>         * and children copied in a synchronization block on that node,\n<line137>         * which means newly created node won't be in the snapshot, so\n<line138>         * we won't have mismatched cversion and pzxid when replaying the\n<line139>         * createNode txn.\n<line140>         *\n<line141>         * But there is a tricky scenario that if the child is deleted due\n<line142>         * to session close and re-created in a different global session\n<line143>         * after that the parent is serialized, then when replay the txn\n<line144>         * because the node belongs to a different session, replay the\n<line145>         * closeSession txn won't delete it anymore, and we'll get NODEEXISTS\n<line146>         * error when replay the createNode txn. In this case, we need to\n<line147>         * update the cversion and pzxid to the new value.\n<line148>         *\n<line149>         * Note, such failures on DT should be seen only during\n<line150>         * restore.\n<line151>         */\n<line152>    if (header.getType() == OpCode.create && rc.err == Code.NODEEXISTS.intValue()) {\n<line153>        int lastSlash = rc.path.lastIndexOf('/');\n<line154>        String parentName = rc.path.substring(0, lastSlash);\n<line155>        CreateTxn cTxn = (CreateTxn) txn;\n<line156>        try {\n<line157>            setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());\n<line158>        } catch (NoNodeException e) {\n<line159>            rc.err = e.code().intValue();\n<line160>        }\n<line161>    } else if (rc.err != Code.OK.intValue()) {\n<line162>    }\n<line163>    /*\n<line164>         * Things we can only update after the whole txn is applied to data\n<line165>         * tree.\n<line166>         *\n<line167>         * If we update the lastProcessedZxid with the first sub txn in multi\n<line168>         * and there is a snapshot in progress, it's possible that the zxid\n<line169>         * associated with the snapshot only include partial of the multi op.\n<line170>         *\n<line171>         * When loading snapshot, it will only load the txns after the zxid\n<line172>         * associated with snapshot file, which could cause data inconsistency\n<line173>         * due to missing sub txns.\n<line174>         *\n<line175>         * To avoid this, we only update the lastProcessedZxid when the whole\n<line176>         * multi-op txn is applied to DataTree.\n<line177>         */\n<line178>    if (!isSubTxn) {\n<line179>        /*\n<line180>             * A snapshot might be in progress while we are modifying the data\n<line181>             * tree. If we set lastProcessedZxid prior to making corresponding\n<line182>             * change to the tree, then the zxid associated with the snapshot\n<line183>             * file will be ahead of its contents. Thus, while restoring from\n<line184>             * the snapshot, the restore method will not apply the transaction\n<line185>             * for zxid associated with the snapshot file, since the restore\n<line186>             * method assumes that transaction to be present in the snapshot.\n<line187>             *\n<line188>             * To avoid this, we first apply the transaction and then modify\n<line189>             * lastProcessedZxid.  During restore, we correctly handle the\n<line190>             * case where the snapshot contains data ahead of the zxid associated\n<line191>             * with the file.\n<line192>             */\n<line193>        if (rc.zxid > lastProcessedZxid) {\n<line194>            lastProcessedZxid = rc.zxid;\n<line195>        }\n<line196>        if (digestFromLoadedSnapshot != null) {\n<line197>            compareSnapshotDigests(rc.zxid);\n<line198>        } else {\n<line199>            // only start recording digest when we're not in fuzzy state\n<line200>            logZxidDigest(rc.zxid, getTreeDigest());\n<line201>        }\n<line202>    }\n<line203>    return rc;\n<line204>}","output":"<line1>{\n<line2>    ProcessTxnResult rc = new ProcessTxnResult();\n<line3>    try {\n<line4>        rc.clientId = header.getClientId();\n<line5>        rc.cxid = header.getCxid();\n<line6>        rc.zxid = header.getZxid();\n<line7>        rc.type = header.getType();\n<line8>        rc.err = 0;\n<line9>        rc.multiResult = null;\n<line10>        switch(header.getType()) {\n<line11>            case OpCode.create:\n<line12>                CreateTxn createTxn = (CreateTxn) txn;\n<line13>                rc.path = createTxn.getPath();\n<line14>                createNode(createTxn.getPath(), createTxn.getData(), createTxn.getAcl(), createTxn.getEphemeral() ? header.getClientId() : 0, createTxn.getParentCVersion(), header.getZxid(), header.getTime(), null);\n<line15>                break;\n<line16>            case OpCode.create2:\n<line17>                CreateTxn create2Txn = (CreateTxn) txn;\n<line18>                rc.path = create2Txn.getPath();\n<line19>                Stat stat = new Stat();\n<line20>                createNode(create2Txn.getPath(), create2Txn.getData(), create2Txn.getAcl(), create2Txn.getEphemeral() ? header.getClientId() : 0, create2Txn.getParentCVersion(), header.getZxid(), header.getTime(), stat);\n<line21>                rc.stat = stat;\n<line22>                break;\n<line23>            case OpCode.createTTL:\n<line24>                CreateTTLTxn createTtlTxn = (CreateTTLTxn) txn;\n<line25>                rc.path = createTtlTxn.getPath();\n<line26>                stat = new Stat();\n<line27>                createNode(createTtlTxn.getPath(), createTtlTxn.getData(), createTtlTxn.getAcl(), EphemeralType.TTL.toEphemeralOwner(createTtlTxn.getTtl()), createTtlTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);\n<line28>                rc.stat = stat;\n<line29>                break;\n<line30>            case OpCode.createContainer:\n<line31>                CreateContainerTxn createContainerTxn = (CreateContainerTxn) txn;\n<line32>                rc.path = createContainerTxn.getPath();\n<line33>                stat = new Stat();\n<line34>                createNode(createContainerTxn.getPath(), createContainerTxn.getData(), createContainerTxn.getAcl(), EphemeralType.CONTAINER_EPHEMERAL_OWNER, createContainerTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);\n<line35>                rc.stat = stat;\n<line36>                break;\n<line37>            case OpCode.delete:\n<line38>            case OpCode.deleteContainer:\n<line39>                DeleteTxn deleteTxn = (DeleteTxn) txn;\n<line40>                rc.path = deleteTxn.getPath();\n<line41>                deleteNode(deleteTxn.getPath(), header.getZxid());\n<line42>                break;\n<line43>            case OpCode.reconfig:\n<line44>            case OpCode.setData:\n<line45>                SetDataTxn setDataTxn = (SetDataTxn) txn;\n<line46>                rc.path = setDataTxn.getPath();\n<line47>                rc.stat = setData(setDataTxn.getPath(), setDataTxn.getData(), setDataTxn.getVersion(), header.getZxid(), header.getTime());\n<line48>                break;\n<line49>            case OpCode.setACL:\n<line50>                SetACLTxn setACLTxn = (SetACLTxn) txn;\n<line51>                rc.path = setACLTxn.getPath();\n<line52>                rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(), setACLTxn.getVersion());\n<line53>                break;\n<line54>            case OpCode.closeSession:\n<line55>                long sessionId = header.getClientId();\n<line56>                if (txn != null) {\n<line57>                    killSession(sessionId, header.getZxid(), ephemerals.remove(sessionId), ((CloseSessionTxn) txn).getPaths2Delete());\n<line58>                } else {\n<line59>                    killSession(sessionId, header.getZxid());\n<line60>                }\n<line61>                break;\n<line62>            case OpCode.error:\n<line63>                ErrorTxn errTxn = (ErrorTxn) txn;\n<line64>                rc.err = errTxn.getErr();\n<line65>                break;\n<line66>            case OpCode.check:\n<line67>                CheckVersionTxn checkTxn = (CheckVersionTxn) txn;\n<line68>                rc.path = checkTxn.getPath();\n<line69>                break;\n<line70>            case OpCode.multi:\n<line71>                MultiTxn multiTxn = (MultiTxn) txn;\n<line72>                List<Txn> txns = multiTxn.getTxns();\n<line73>                rc.multiResult = new ArrayList<>();\n<line74>                boolean failed = false;\n<line75>                for (Txn subtxn : txns) {\n<line76>                    if (subtxn.getType() == OpCode.error) {\n<line77>                        failed = true;\n<line78>                        break;\n<line79>                    }\n<line80>                }\n<line81>                boolean post_failed = false;\n<line82>                for (Txn subtxn : txns) {\n<line83>                    ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());\n<line84>                    Record record;\n<line85>                    switch(subtxn.getType()) {\n<line86>                        case OpCode.create:\n<line87>                        case OpCode.create2:\n<line88>                            record = new CreateTxn();\n<line89>                            break;\n<line90>                        case OpCode.createTTL:\n<line91>                            record = new CreateTTLTxn();\n<line92>                            break;\n<line93>                        case OpCode.createContainer:\n<line94>                            record = new CreateContainerTxn();\n<line95>                            break;\n<line96>                        case OpCode.delete:\n<line97>                        case OpCode.deleteContainer:\n<line98>                            record = new DeleteTxn();\n<line99>                            break;\n<line100>                        case OpCode.setData:\n<line101>                            record = new SetDataTxn();\n<line102>                            break;\n<line103>                        case OpCode.error:\n<line104>                            record = new ErrorTxn();\n<line105>                            post_failed = true;\n<line106>                            break;\n<line107>                        case OpCode.check:\n<line108>                            record = new CheckVersionTxn();\n<line109>                            break;\n<line110>                        default:\n<line111>                            throw new IOException(\"Invalid type of op: \" + subtxn.getType());\n<line112>                    }\n<line113>                    assert record != null;\n<line114>                    ByteBufferInputStream.byteBuffer2Record(bb, record);\n<line115>                    if (failed && subtxn.getType() != OpCode.error) {\n<line116>                        int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue() : Code.OK.intValue();\n<line117>                        subtxn.setType(OpCode.error);\n<line118>                        record = new ErrorTxn(ec);\n<line119>                    }\n<line120>                    assert !failed || (subtxn.getType() == OpCode.error);\n<line121>                    TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(), header.getZxid(), header.getTime(), subtxn.getType());\n<line122>                    ProcessTxnResult subRc = processTxn(subHdr, record, true);\n<line123>                    rc.multiResult.add(subRc);\n<line124>                    if (subRc.err != 0 && rc.err == 0) {\n<line125>                        rc.err = subRc.err;\n<line126>                    }\n<line127>                }\n<line128>                break;\n<line129>        }\n<line130>    } catch (KeeperException e) {\n<line131>        LOG.debug(\"Failed: {}:{}\", header, txn, e);\n<line132>        rc.err = e.code().intValue();\n<line133>    } catch (IOException e) {\n<line134>        LOG.debug(\"Failed: {}:{}\", header, txn, e);\n<line135>    }\n<line136>    /*\n<line137>         * Snapshots are taken lazily. When serializing a node, it's data\n<line138>         * and children copied in a synchronization block on that node,\n<line139>         * which means newly created node won't be in the snapshot, so\n<line140>         * we won't have mismatched cversion and pzxid when replaying the\n<line141>         * createNode txn.\n<line142>         *\n<line143>         * But there is a tricky scenario that if the child is deleted due\n<line144>         * to session close and re-created in a different global session\n<line145>         * after that the parent is serialized, then when replay the txn\n<line146>         * because the node belongs to a different session, replay the\n<line147>         * closeSession txn won't delete it anymore, and we'll get NODEEXISTS\n<line148>         * error when replay the createNode txn. In this case, we need to\n<line149>         * update the cversion and pzxid to the new value.\n<line150>         *\n<line151>         * Note, such failures on DT should be seen only during\n<line152>         * restore.\n<line153>         */\n<line154>    if (header.getType() == OpCode.create && rc.err == Code.NODEEXISTS.intValue()) {\n<line155>        LOG.debug(\"Adjusting parent cversion for Txn: {} path: {} err: {}\", header.getType(), rc.path, rc.err);\n<line156>        int lastSlash = rc.path.lastIndexOf('/');\n<line157>        String parentName = rc.path.substring(0, lastSlash);\n<line158>        CreateTxn cTxn = (CreateTxn) txn;\n<line159>        try {\n<line160>            setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());\n<line161>        } catch (NoNodeException e) {\n<line162>            LOG.error(\"Failed to set parent cversion for: {}\", parentName, e);\n<line163>            rc.err = e.code().intValue();\n<line164>        }\n<line165>    } else if (rc.err != Code.OK.intValue()) {\n<line166>        LOG.debug(\"Ignoring processTxn failure hdr: {} : error: {}\", header.getType(), rc.err);\n<line167>    }\n<line168>    /*\n<line169>         * Things we can only update after the whole txn is applied to data\n<line170>         * tree.\n<line171>         *\n<line172>         * If we update the lastProcessedZxid with the first sub txn in multi\n<line173>         * and there is a snapshot in progress, it's possible that the zxid\n<line174>         * associated with the snapshot only include partial of the multi op.\n<line175>         *\n<line176>         * When loading snapshot, it will only load the txns after the zxid\n<line177>         * associated with snapshot file, which could cause data inconsistency\n<line178>         * due to missing sub txns.\n<line179>         *\n<line180>         * To avoid this, we only update the lastProcessedZxid when the whole\n<line181>         * multi-op txn is applied to DataTree.\n<line182>         */\n<line183>    if (!isSubTxn) {\n<line184>        /*\n<line185>             * A snapshot might be in progress while we are modifying the data\n<line186>             * tree. If we set lastProcessedZxid prior to making corresponding\n<line187>             * change to the tree, then the zxid associated with the snapshot\n<line188>             * file will be ahead of its contents. Thus, while restoring from\n<line189>             * the snapshot, the restore method will not apply the transaction\n<line190>             * for zxid associated with the snapshot file, since the restore\n<line191>             * method assumes that transaction to be present in the snapshot.\n<line192>             *\n<line193>             * To avoid this, we first apply the transaction and then modify\n<line194>             * lastProcessedZxid.  During restore, we correctly handle the\n<line195>             * case where the snapshot contains data ahead of the zxid associated\n<line196>             * with the file.\n<line197>             */\n<line198>        if (rc.zxid > lastProcessedZxid) {\n<line199>            lastProcessedZxid = rc.zxid;\n<line200>        }\n<line201>        if (digestFromLoadedSnapshot != null) {\n<line202>            compareSnapshotDigests(rc.zxid);\n<line203>        } else {\n<line204>            // only start recording digest when we're not in fuzzy state\n<line205>            logZxidDigest(rc.zxid, getTreeDigest());\n<line206>        }\n<line207>    }\n<line208>    return rc;\n<line209>}"},{"input":"","instruction":"<line1>{\n<line2>    rc.err = e.code().intValue();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Failed: {}:{}\", header, txn, e);\n<line3>    rc.err = e.code().intValue();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Failed: {}:{}\", header, txn, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    int lastSlash = rc.path.lastIndexOf('/');\n<line3>    String parentName = rc.path.substring(0, lastSlash);\n<line4>    CreateTxn cTxn = (CreateTxn) txn;\n<line5>    try {\n<line6>        setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());\n<line7>    } catch (NoNodeException e) {\n<line8>        rc.err = e.code().intValue();\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.debug(\"Adjusting parent cversion for Txn: {} path: {} err: {}\", header.getType(), rc.path, rc.err);\n<line3>    int lastSlash = rc.path.lastIndexOf('/');\n<line4>    String parentName = rc.path.substring(0, lastSlash);\n<line5>    CreateTxn cTxn = (CreateTxn) txn;\n<line6>    try {\n<line7>        setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());\n<line8>    } catch (NoNodeException e) {\n<line9>        LOG.error(\"Failed to set parent cversion for: {}\", parentName, e);\n<line10>        rc.err = e.code().intValue();\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    rc.err = e.code().intValue();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to set parent cversion for: {}\", parentName, e);\n<line3>    rc.err = e.code().intValue();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring processTxn failure hdr: {} : error: {}\", header.getType(), rc.err);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    for (String path : paths2Delete) {\n<line3>        boolean deleted = false;\n<line4>        String sessionHex = \"0x\" + Long.toHexString(session);\n<line5>        try {\n<line6>            deleteNode(path, zxid);\n<line7>            deleted = true;\n<line8>        } catch (NoNodeException e) {\n<line9>        }\n<line10>        if (ZKAuditProvider.isAuditEnabled()) {\n<line11>            if (deleted) {\n<line12>                ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.SUCCESS);\n<line13>            } else {\n<line14>                ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.FAILURE);\n<line15>            }\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    for (String path : paths2Delete) {\n<line3>        boolean deleted = false;\n<line4>        String sessionHex = \"0x\" + Long.toHexString(session);\n<line5>        try {\n<line6>            deleteNode(path, zxid);\n<line7>            deleted = true;\n<line8>            LOG.debug(\"Deleting ephemeral node {} for session {}\", path, sessionHex);\n<line9>        } catch (NoNodeException e) {\n<line10>            LOG.warn(\"Ignoring NoNodeException for path {} while removing ephemeral for dead session {}\", path, sessionHex);\n<line11>        }\n<line12>        if (ZKAuditProvider.isAuditEnabled()) {\n<line13>            if (deleted) {\n<line14>                ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.SUCCESS);\n<line15>            } else {\n<line16>                ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.FAILURE);\n<line17>            }\n<line18>        }\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean deleted = false;\n<line3>    String sessionHex = \"0x\" + Long.toHexString(session);\n<line4>    try {\n<line5>        deleteNode(path, zxid);\n<line6>        deleted = true;\n<line7>    } catch (NoNodeException e) {\n<line8>    }\n<line9>    if (ZKAuditProvider.isAuditEnabled()) {\n<line10>        if (deleted) {\n<line11>            ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.SUCCESS);\n<line12>        } else {\n<line13>            ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.FAILURE);\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    boolean deleted = false;\n<line3>    String sessionHex = \"0x\" + Long.toHexString(session);\n<line4>    try {\n<line5>        deleteNode(path, zxid);\n<line6>        deleted = true;\n<line7>        LOG.debug(\"Deleting ephemeral node {} for session {}\", path, sessionHex);\n<line8>    } catch (NoNodeException e) {\n<line9>        LOG.warn(\"Ignoring NoNodeException for path {} while removing ephemeral for dead session {}\", path, sessionHex);\n<line10>    }\n<line11>    if (ZKAuditProvider.isAuditEnabled()) {\n<line12>        if (deleted) {\n<line13>            ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.SUCCESS);\n<line14>        } else {\n<line15>            ZKAuditProvider.log(ZKAuditProvider.getZKUser(), AuditConstants.OP_DEL_EZNODE_EXP, path, null, null, sessionHex, null, Result.FAILURE);\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    deleteNode(path, zxid);\n<line3>    deleted = true;\n<line4>}","output":"<line1>{\n<line2>    deleteNode(path, zxid);\n<line3>    deleted = true;\n<line4>    LOG.debug(\"Deleting ephemeral node {} for session {}\", path, sessionHex);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!ZooKeeperServer.isDigestEnabled()) {\n<line3>        return false;\n<line4>    }\n<line5>    try {\n<line6>        ZxidDigest zxidDigest = new ZxidDigest();\n<line7>        zxidDigest.deserialize(ia);\n<line8>        if (zxidDigest.zxid > 0) {\n<line9>            digestFromLoadedSnapshot = zxidDigest;\n<line10>        } else {\n<line11>            digestFromLoadedSnapshot = null;\n<line12>        }\n<line13>        // There is possibility that the start zxid of a snapshot might\n<line14>        // be larger than the digest zxid in snapshot.\n<line15>        //\n<line16>        // Known cases:\n<line17>        //\n<line18>        // The new leader set the last processed zxid to be the new\n<line19>        // epoch + 0, which is not mapping to any txn, and it uses\n<line20>        // this to take snapshot, which is possible if we don't\n<line21>        // clean database before switching to LOOKING. In this case\n<line22>        // the currentZxidDigest will be the zxid of last epoch, and\n<line23>        // it's smaller than the zxid of the snapshot file.\n<line24>        //\n<line25>        // It's safe to reset the targetZxidDigest to null and start\n<line26>        // to compare digest when replaying the first txn, since it's\n<line27>        // a non-fuzzy snapshot.\n<line28>        if (digestFromLoadedSnapshot != null && digestFromLoadedSnapshot.zxid < startZxidOfSnapshot) {\n<line29>            digestFromLoadedSnapshot = null;\n<line30>        }\n<line31>        return true;\n<line32>    } catch (EOFException e) {\n<line33>        return false;\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    if (!ZooKeeperServer.isDigestEnabled()) {\n<line3>        return false;\n<line4>    }\n<line5>    try {\n<line6>        ZxidDigest zxidDigest = new ZxidDigest();\n<line7>        zxidDigest.deserialize(ia);\n<line8>        if (zxidDigest.zxid > 0) {\n<line9>            digestFromLoadedSnapshot = zxidDigest;\n<line10>            LOG.info(\"The digest in the snapshot has digest version of {}, \" + \"with zxid as 0x{}, and digest value as {}\", digestFromLoadedSnapshot.digestVersion, Long.toHexString(digestFromLoadedSnapshot.zxid), digestFromLoadedSnapshot.digest);\n<line11>        } else {\n<line12>            digestFromLoadedSnapshot = null;\n<line13>            LOG.info(\"The digest value is empty in snapshot\");\n<line14>        }\n<line15>        // There is possibility that the start zxid of a snapshot might\n<line16>        // be larger than the digest zxid in snapshot.\n<line17>        //\n<line18>        // Known cases:\n<line19>        //\n<line20>        // The new leader set the last processed zxid to be the new\n<line21>        // epoch + 0, which is not mapping to any txn, and it uses\n<line22>        // this to take snapshot, which is possible if we don't\n<line23>        // clean database before switching to LOOKING. In this case\n<line24>        // the currentZxidDigest will be the zxid of last epoch, and\n<line25>        // it's smaller than the zxid of the snapshot file.\n<line26>        //\n<line27>        // It's safe to reset the targetZxidDigest to null and start\n<line28>        // to compare digest when replaying the first txn, since it's\n<line29>        // a non-fuzzy snapshot.\n<line30>        if (digestFromLoadedSnapshot != null && digestFromLoadedSnapshot.zxid < startZxidOfSnapshot) {\n<line31>            LOG.info(\"The zxid of snapshot digest 0x{} is smaller \" + \"than the known snapshot highest zxid, the snapshot \" + \"started with zxid 0x{}. It will be invalid to use \" + \"this snapshot digest associated with this zxid, will \" + \"ignore comparing it.\", Long.toHexString(digestFromLoadedSnapshot.zxid), Long.toHexString(startZxidOfSnapshot));\n<line32>            digestFromLoadedSnapshot = null;\n<line33>        }\n<line34>        return true;\n<line35>    } catch (EOFException e) {\n<line36>        LOG.warn(\"Got EOF exception while reading the digest, likely due to the reading an older snapshot.\");\n<line37>        return false;\n<line38>    }\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    ZxidDigest zxidDigest = new ZxidDigest();\n<line3>    zxidDigest.deserialize(ia);\n<line4>    if (zxidDigest.zxid > 0) {\n<line5>        digestFromLoadedSnapshot = zxidDigest;\n<line6>    } else {\n<line7>        digestFromLoadedSnapshot = null;\n<line8>    }\n<line9>    // There is possibility that the start zxid of a snapshot might\n<line10>    // be larger than the digest zxid in snapshot.\n<line11>    //\n<line12>    // Known cases:\n<line13>    //\n<line14>    // The new leader set the last processed zxid to be the new\n<line15>    // epoch + 0, which is not mapping to any txn, and it uses\n<line16>    // this to take snapshot, which is possible if we don't\n<line17>    // clean database before switching to LOOKING. In this case\n<line18>    // the currentZxidDigest will be the zxid of last epoch, and\n<line19>    // it's smaller than the zxid of the snapshot file.\n<line20>    //\n<line21>    // It's safe to reset the targetZxidDigest to null and start\n<line22>    // to compare digest when replaying the first txn, since it's\n<line23>    // a non-fuzzy snapshot.\n<line24>    if (digestFromLoadedSnapshot != null && digestFromLoadedSnapshot.zxid < startZxidOfSnapshot) {\n<line25>        digestFromLoadedSnapshot = null;\n<line26>    }\n<line27>    return true;\n<line28>}","output":"<line1>{\n<line2>    ZxidDigest zxidDigest = new ZxidDigest();\n<line3>    zxidDigest.deserialize(ia);\n<line4>    if (zxidDigest.zxid > 0) {\n<line5>        digestFromLoadedSnapshot = zxidDigest;\n<line6>        LOG.info(\"The digest in the snapshot has digest version of {}, \" + \"with zxid as 0x{}, and digest value as {}\", digestFromLoadedSnapshot.digestVersion, Long.toHexString(digestFromLoadedSnapshot.zxid), digestFromLoadedSnapshot.digest);\n<line7>    } else {\n<line8>        digestFromLoadedSnapshot = null;\n<line9>        LOG.info(\"The digest value is empty in snapshot\");\n<line10>    }\n<line11>    // There is possibility that the start zxid of a snapshot might\n<line12>    // be larger than the digest zxid in snapshot.\n<line13>    //\n<line14>    // Known cases:\n<line15>    //\n<line16>    // The new leader set the last processed zxid to be the new\n<line17>    // epoch + 0, which is not mapping to any txn, and it uses\n<line18>    // this to take snapshot, which is possible if we don't\n<line19>    // clean database before switching to LOOKING. In this case\n<line20>    // the currentZxidDigest will be the zxid of last epoch, and\n<line21>    // it's smaller than the zxid of the snapshot file.\n<line22>    //\n<line23>    // It's safe to reset the targetZxidDigest to null and start\n<line24>    // to compare digest when replaying the first txn, since it's\n<line25>    // a non-fuzzy snapshot.\n<line26>    if (digestFromLoadedSnapshot != null && digestFromLoadedSnapshot.zxid < startZxidOfSnapshot) {\n<line27>        LOG.info(\"The zxid of snapshot digest 0x{} is smaller \" + \"than the known snapshot highest zxid, the snapshot \" + \"started with zxid 0x{}. It will be invalid to use \" + \"this snapshot digest associated with this zxid, will \" + \"ignore comparing it.\", Long.toHexString(digestFromLoadedSnapshot.zxid), Long.toHexString(startZxidOfSnapshot));\n<line28>        digestFromLoadedSnapshot = null;\n<line29>    }\n<line30>    return true;\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    digestFromLoadedSnapshot = zxidDigest;\n<line3>}","output":"<line1>{\n<line2>    digestFromLoadedSnapshot = zxidDigest;\n<line3>    LOG.info(\"The digest in the snapshot has digest version of {}, \" + \"with zxid as 0x{}, and digest value as {}\", digestFromLoadedSnapshot.digestVersion, Long.toHexString(digestFromLoadedSnapshot.zxid), digestFromLoadedSnapshot.digest);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    digestFromLoadedSnapshot = null;\n<line3>}","output":"<line1>{\n<line2>    digestFromLoadedSnapshot = null;\n<line3>    LOG.info(\"The digest value is empty in snapshot\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    digestFromLoadedSnapshot = null;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"The zxid of snapshot digest 0x{} is smaller \" + \"than the known snapshot highest zxid, the snapshot \" + \"started with zxid 0x{}. It will be invalid to use \" + \"this snapshot digest associated with this zxid, will \" + \"ignore comparing it.\", Long.toHexString(digestFromLoadedSnapshot.zxid), Long.toHexString(startZxidOfSnapshot));\n<line3>    digestFromLoadedSnapshot = null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (zxid == digestFromLoadedSnapshot.zxid) {\n<line3>        if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {\n<line4>            digestFromLoadedSnapshot = null;\n<line5>            return;\n<line6>        }\n<line7>        if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {\n<line8>            reportDigestMismatch(zxid);\n<line9>        }\n<line10>        digestFromLoadedSnapshot = null;\n<line11>    } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {\n<line12>        RATE_LOGGER.rateLimitLog(\"The txn 0x{} of snapshot digest does not exist.\", Long.toHexString(digestFromLoadedSnapshot.zxid));\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    if (zxid == digestFromLoadedSnapshot.zxid) {\n<line3>        if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {\n<line4>            LOG.info(\"Digest version changed, local: {}, new: {}, skip comparing digest now.\", digestFromLoadedSnapshot.digestVersion, digestCalculator.getDigestVersion());\n<line5>            digestFromLoadedSnapshot = null;\n<line6>            return;\n<line7>        }\n<line8>        if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {\n<line9>            reportDigestMismatch(zxid);\n<line10>        }\n<line11>        digestFromLoadedSnapshot = null;\n<line12>    } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {\n<line13>        RATE_LOGGER.rateLimitLog(\"The txn 0x{} of snapshot digest does not exist.\", Long.toHexString(digestFromLoadedSnapshot.zxid));\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {\n<line3>        digestFromLoadedSnapshot = null;\n<line4>        return;\n<line5>    }\n<line6>    if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {\n<line7>        reportDigestMismatch(zxid);\n<line8>    }\n<line9>    digestFromLoadedSnapshot = null;\n<line10>}","output":"<line1>{\n<line2>    if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {\n<line3>        LOG.info(\"Digest version changed, local: {}, new: {}, skip comparing digest now.\", digestFromLoadedSnapshot.digestVersion, digestCalculator.getDigestVersion());\n<line4>        digestFromLoadedSnapshot = null;\n<line5>        return;\n<line6>    }\n<line7>    if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {\n<line8>        reportDigestMismatch(zxid);\n<line9>    }\n<line10>    digestFromLoadedSnapshot = null;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    digestFromLoadedSnapshot = null;\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Digest version changed, local: {}, new: {}, skip comparing digest now.\", digestFromLoadedSnapshot.digestVersion, digestCalculator.getDigestVersion());\n<line3>    digestFromLoadedSnapshot = null;\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    long zxid = header.getZxid();\n<line3>    if (!ZooKeeperServer.isDigestEnabled() || digest == null) {\n<line4>        return true;\n<line5>    }\n<line6>    // do not compare digest if we're still in fuzzy state\n<line7>    if (digestFromLoadedSnapshot != null) {\n<line8>        return true;\n<line9>    }\n<line10>    // do not compare digest if there is digest version change\n<line11>    if (digestCalculator.getDigestVersion() != digest.getVersion()) {\n<line12>        RATE_LOGGER.rateLimitLog(\"Digest version not the same on zxid.\", String.valueOf(zxid));\n<line13>        return true;\n<line14>    }\n<line15>    long logDigest = digest.getTreeDigest();\n<line16>    long actualDigest = getTreeDigest();\n<line17>    if (logDigest != actualDigest) {\n<line18>        reportDigestMismatch(zxid);\n<line19>        if (firstMismatchTxn) {\n<line20>            firstMismatchTxn = false;\n<line21>        }\n<line22>        return false;\n<line23>    } else {\n<line24>        RATE_LOGGER.flush();\n<line25>        return true;\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    long zxid = header.getZxid();\n<line3>    if (!ZooKeeperServer.isDigestEnabled() || digest == null) {\n<line4>        return true;\n<line5>    }\n<line6>    // do not compare digest if we're still in fuzzy state\n<line7>    if (digestFromLoadedSnapshot != null) {\n<line8>        return true;\n<line9>    }\n<line10>    // do not compare digest if there is digest version change\n<line11>    if (digestCalculator.getDigestVersion() != digest.getVersion()) {\n<line12>        RATE_LOGGER.rateLimitLog(\"Digest version not the same on zxid.\", String.valueOf(zxid));\n<line13>        return true;\n<line14>    }\n<line15>    long logDigest = digest.getTreeDigest();\n<line16>    long actualDigest = getTreeDigest();\n<line17>    if (logDigest != actualDigest) {\n<line18>        reportDigestMismatch(zxid);\n<line19>        LOG.debug(\"Digest in log: {}, actual tree: {}\", logDigest, actualDigest);\n<line20>        if (firstMismatchTxn) {\n<line21>            LOG.error(\"First digest mismatch on txn: {}, {}, expected digest is {}, actual digest is {}, \", header, txn, digest, actualDigest);\n<line22>            firstMismatchTxn = false;\n<line23>        }\n<line24>        return false;\n<line25>    } else {\n<line26>        RATE_LOGGER.flush();\n<line27>        LOG.debug(\"Digests are matching for Zxid: {}, Digest in log and actual tree: {}\", Long.toHexString(zxid), logDigest);\n<line28>        return true;\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    reportDigestMismatch(zxid);\n<line3>    if (firstMismatchTxn) {\n<line4>        firstMismatchTxn = false;\n<line5>    }\n<line6>    return false;\n<line7>}","output":"<line1>{\n<line2>    reportDigestMismatch(zxid);\n<line3>    LOG.debug(\"Digest in log: {}, actual tree: {}\", logDigest, actualDigest);\n<line4>    if (firstMismatchTxn) {\n<line5>        LOG.error(\"First digest mismatch on txn: {}, {}, expected digest is {}, actual digest is {}, \", header, txn, digest, actualDigest);\n<line6>        firstMismatchTxn = false;\n<line7>    }\n<line8>    return false;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    firstMismatchTxn = false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"First digest mismatch on txn: {}, {}, expected digest is {}, actual digest is {}, \", header, txn, digest, actualDigest);\n<line3>    firstMismatchTxn = false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    RATE_LOGGER.flush();\n<line3>    return true;\n<line4>}","output":"<line1>{\n<line2>    RATE_LOGGER.flush();\n<line3>    LOG.debug(\"Digests are matching for Zxid: {}, Digest in log and actual tree: {}\", Long.toHexString(zxid), logDigest);\n<line4>    return true;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String serverCnxnFactoryName = System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line3>    if (serverCnxnFactoryName == null) {\n<line4>        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();\n<line5>    }\n<line6>    try {\n<line7>        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();\n<line8>        return serverCnxnFactory;\n<line9>    } catch (Exception e) {\n<line10>        IOException ioe = new IOException(\"Couldn't instantiate \" + serverCnxnFactoryName, e);\n<line11>        throw ioe;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    String serverCnxnFactoryName = System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);\n<line3>    if (serverCnxnFactoryName == null) {\n<line4>        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();\n<line5>    }\n<line6>    try {\n<line7>        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();\n<line8>        LOG.info(\"Using {} as server connection factory\", serverCnxnFactoryName);\n<line9>        return serverCnxnFactory;\n<line10>    } catch (Exception e) {\n<line11>        IOException ioe = new IOException(\"Couldn't instantiate \" + serverCnxnFactoryName, e);\n<line12>        throw ioe;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();\n<line3>    return serverCnxnFactory;\n<line4>}","output":"<line1>{\n<line2>    ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();\n<line3>    LOG.info(\"Using {} as server connection factory\", serverCnxnFactoryName);\n<line4>    return serverCnxnFactory;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n<line3>    // Note that 'Configuration' here refers to javax.security.auth.login.Configuration.\n<line4>    AppConfigurationEntry[] entries = null;\n<line5>    SecurityException securityException = null;\n<line6>    try {\n<line7>        entries = Configuration.getConfiguration().getAppConfigurationEntry(serverSection);\n<line8>    } catch (SecurityException e) {\n<line9>        // handle below: might be harmless if the user doesn't intend to use JAAS authentication.\n<line10>        securityException = e;\n<line11>    }\n<line12>    // No entries in jaas.conf\n<line13>    // If there's a configuration exception fetching the jaas section and\n<line14>    // the user has required sasl by specifying a LOGIN_CONTEXT_NAME_KEY or a jaas file\n<line15>    // we throw an exception otherwise we continue without authentication.\n<line16>    if (entries == null) {\n<line17>        String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);\n<line18>        String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);\n<line19>        if (securityException != null && (loginContextName != null || jaasFile != null)) {\n<line20>            String errorMessage = \"No JAAS configuration section named '\" + serverSection + \"' was found\";\n<line21>            if (jaasFile != null) {\n<line22>                errorMessage += \" in '\" + jaasFile + \"'.\";\n<line23>            }\n<line24>            if (loginContextName != null) {\n<line25>                errorMessage += \" But \" + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + \" was set.\";\n<line26>            }\n<line27>            throw new IOException(errorMessage);\n<line28>        }\n<line29>        return;\n<line30>    }\n<line31>    // jaas.conf entry available\n<line32>    try {\n<line33>        saslServerCallbackHandler = new SaslServerCallbackHandler(Configuration.getConfiguration());\n<line34>        login = new Login(serverSection, saslServerCallbackHandler, new ZKConfig());\n<line35>        setLoginUser(login.getUserName());\n<line36>        login.startThreadIfNeeded();\n<line37>    } catch (LoginException e) {\n<line38>        throw new IOException(\"Could not configure server because SASL configuration did not allow the \" + \" ZooKeeper server to authenticate itself properly: \" + e);\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n<line3>    // Note that 'Configuration' here refers to javax.security.auth.login.Configuration.\n<line4>    AppConfigurationEntry[] entries = null;\n<line5>    SecurityException securityException = null;\n<line6>    try {\n<line7>        entries = Configuration.getConfiguration().getAppConfigurationEntry(serverSection);\n<line8>    } catch (SecurityException e) {\n<line9>        // handle below: might be harmless if the user doesn't intend to use JAAS authentication.\n<line10>        securityException = e;\n<line11>    }\n<line12>    // No entries in jaas.conf\n<line13>    // If there's a configuration exception fetching the jaas section and\n<line14>    // the user has required sasl by specifying a LOGIN_CONTEXT_NAME_KEY or a jaas file\n<line15>    // we throw an exception otherwise we continue without authentication.\n<line16>    if (entries == null) {\n<line17>        String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);\n<line18>        String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);\n<line19>        if (securityException != null && (loginContextName != null || jaasFile != null)) {\n<line20>            String errorMessage = \"No JAAS configuration section named '\" + serverSection + \"' was found\";\n<line21>            if (jaasFile != null) {\n<line22>                errorMessage += \" in '\" + jaasFile + \"'.\";\n<line23>            }\n<line24>            if (loginContextName != null) {\n<line25>                errorMessage += \" But \" + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + \" was set.\";\n<line26>            }\n<line27>            LOG.error(errorMessage);\n<line28>            throw new IOException(errorMessage);\n<line29>        }\n<line30>        return;\n<line31>    }\n<line32>    // jaas.conf entry available\n<line33>    try {\n<line34>        saslServerCallbackHandler = new SaslServerCallbackHandler(Configuration.getConfiguration());\n<line35>        login = new Login(serverSection, saslServerCallbackHandler, new ZKConfig());\n<line36>        setLoginUser(login.getUserName());\n<line37>        login.startThreadIfNeeded();\n<line38>    } catch (LoginException e) {\n<line39>        throw new IOException(\"Could not configure server because SASL configuration did not allow the \" + \" ZooKeeper server to authenticate itself properly: \" + e);\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);\n<line3>    String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);\n<line4>    if (securityException != null && (loginContextName != null || jaasFile != null)) {\n<line5>        String errorMessage = \"No JAAS configuration section named '\" + serverSection + \"' was found\";\n<line6>        if (jaasFile != null) {\n<line7>            errorMessage += \" in '\" + jaasFile + \"'.\";\n<line8>        }\n<line9>        if (loginContextName != null) {\n<line10>            errorMessage += \" But \" + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + \" was set.\";\n<line11>        }\n<line12>        throw new IOException(errorMessage);\n<line13>    }\n<line14>    return;\n<line15>}","output":"<line1>{\n<line2>    String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);\n<line3>    String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);\n<line4>    if (securityException != null && (loginContextName != null || jaasFile != null)) {\n<line5>        String errorMessage = \"No JAAS configuration section named '\" + serverSection + \"' was found\";\n<line6>        if (jaasFile != null) {\n<line7>            errorMessage += \" in '\" + jaasFile + \"'.\";\n<line8>        }\n<line9>        if (loginContextName != null) {\n<line10>            errorMessage += \" But \" + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + \" was set.\";\n<line11>        }\n<line12>        LOG.error(errorMessage);\n<line13>        throw new IOException(errorMessage);\n<line14>    }\n<line15>    return;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    String errorMessage = \"No JAAS configuration section named '\" + serverSection + \"' was found\";\n<line3>    if (jaasFile != null) {\n<line4>        errorMessage += \" in '\" + jaasFile + \"'.\";\n<line5>    }\n<line6>    if (loginContextName != null) {\n<line7>        errorMessage += \" But \" + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + \" was set.\";\n<line8>    }\n<line9>    throw new IOException(errorMessage);\n<line10>}","output":"<line1>{\n<line2>    String errorMessage = \"No JAAS configuration section named '\" + serverSection + \"' was found\";\n<line3>    if (jaasFile != null) {\n<line4>        errorMessage += \" in '\" + jaasFile + \"'.\";\n<line5>    }\n<line6>    if (loginContextName != null) {\n<line7>        errorMessage += \" But \" + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + \" was set.\";\n<line8>    }\n<line9>    LOG.error(errorMessage);\n<line10>    throw new IOException(errorMessage);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    maxCnxns = Integer.getInteger(ZOOKEEPER_MAX_CONNECTION, ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n<line3>    if (maxCnxns < 0) {\n<line4>        maxCnxns = ZOOKEEPER_MAX_CONNECTION_DEFAULT;\n<line5>    } else if (maxCnxns == ZOOKEEPER_MAX_CONNECTION_DEFAULT) {\n<line6>    } else {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    maxCnxns = Integer.getInteger(ZOOKEEPER_MAX_CONNECTION, ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n<line3>    if (maxCnxns < 0) {\n<line4>        maxCnxns = ZOOKEEPER_MAX_CONNECTION_DEFAULT;\n<line5>        LOG.warn(\"maxCnxns should be greater than or equal to 0, using default value {}.\", ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n<line6>    } else if (maxCnxns == ZOOKEEPER_MAX_CONNECTION_DEFAULT) {\n<line7>        LOG.warn(\"maxCnxns is not configured, using default value {}.\", ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n<line8>    } else {\n<line9>        LOG.info(\"maxCnxns configured value is {}.\", maxCnxns);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"maxCnxns configured value is {}.\", maxCnxns);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (maxCnxns <= 0) {\n<line3>        // maxCnxns limit is disabled\n<line4>        return false;\n<line5>    }\n<line6>    int cnxns = getNumAliveConnections();\n<line7>    if (cnxns >= maxCnxns) {\n<line8>        return true;\n<line9>    }\n<line10>    return false;\n<line11>}","output":"<line1>{\n<line2>    if (maxCnxns <= 0) {\n<line3>        // maxCnxns limit is disabled\n<line4>        return false;\n<line5>    }\n<line6>    int cnxns = getNumAliveConnections();\n<line7>    if (cnxns >= maxCnxns) {\n<line8>        LOG.error(\"Too many connections \" + cnxns + \" - max is \" + maxCnxns);\n<line9>        return true;\n<line10>    }\n<line11>    return false;\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    return true;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Too many connections \" + cnxns + \" - max is \" + maxCnxns);\n<line3>    return true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    closingChannel = true;\n<line3>    setStale();\n<line4>    // ZOOKEEPER-2743:\n<line5>    // Always unregister connection upon close to prevent\n<line6>    // connection bean leak under certain race conditions.\n<line7>    factory.unregisterConnection(this);\n<line8>    // if this is not in cnxns then it's already closed\n<line9>    if (!factory.cnxns.remove(this)) {\n<line10>        if (channel.isOpen()) {\n<line11>            channel.close();\n<line12>        }\n<line13>        return;\n<line14>    }\n<line15>    factory.removeCnxnFromSessionMap(this);\n<line16>    factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n<line17>    if (zkServer != null) {\n<line18>        zkServer.removeCnxn(this);\n<line19>    }\n<line20>    if (channel.isOpen()) {\n<line21>        // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n<line22>        // that all writes have been completed before closing the channel or we risk data loss\n<line23>        // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n<line24>        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n<line25>\n<line26>            @Override\n<line27>            public void operationComplete(ChannelFuture future) {\n<line28>                future.channel().close().addListener(f -> releaseQueuedBuffer());\n<line29>            }\n<line30>        });\n<line31>    } else {\n<line32>        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n<line33>        channel.eventLoop().execute(this::releaseQueuedBuffer);\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    closingChannel = true;\n<line3>    LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n<line4>    setStale();\n<line5>    // ZOOKEEPER-2743:\n<line6>    // Always unregister connection upon close to prevent\n<line7>    // connection bean leak under certain race conditions.\n<line8>    factory.unregisterConnection(this);\n<line9>    // if this is not in cnxns then it's already closed\n<line10>    if (!factory.cnxns.remove(this)) {\n<line11>        LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n<line12>        if (channel.isOpen()) {\n<line13>            channel.close();\n<line14>        }\n<line15>        return;\n<line16>    }\n<line17>    LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n<line18>    factory.removeCnxnFromSessionMap(this);\n<line19>    factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n<line20>    if (zkServer != null) {\n<line21>        zkServer.removeCnxn(this);\n<line22>    }\n<line23>    if (channel.isOpen()) {\n<line24>        // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n<line25>        // that all writes have been completed before closing the channel or we risk data loss\n<line26>        // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n<line27>        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n<line28>\n<line29>            @Override\n<line30>            public void operationComplete(ChannelFuture future) {\n<line31>                future.channel().close().addListener(f -> releaseQueuedBuffer());\n<line32>            }\n<line33>        });\n<line34>    } else {\n<line35>        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n<line36>        channel.eventLoop().execute(this::releaseQueuedBuffer);\n<line37>    }\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    if (channel.isOpen()) {\n<line3>        channel.close();\n<line4>    }\n<line5>    return;\n<line6>}","output":"<line1>{\n<line2>    LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n<line3>    if (channel.isOpen()) {\n<line4>        channel.close();\n<line5>    }\n<line6>    return;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zkServer.checkACL(this, znodeAcl, ZooDefs.Perms.READ, getAuthInfo(), event.getPath(), null);\n<line4>    } catch (KeeperException.NoAuthException e) {\n<line5>            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, \"Not delivering event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" (filtered by ACL)\");\n<line6>        }\n<line7>        return;\n<line8>    }\n<line9>    ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, event.getZxid(), 0);\n<line10>        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n<line11>    }\n<line12>    // Convert WatchedEvent to a type that can be sent over the wire\n<line13>    WatcherEvent e = event.getWrapper();\n<line14>    try {\n<line15>        int responseSize = sendResponse(h, e, \"notification\");\n<line16>        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n<line17>    } catch (IOException e1) {\n<line18>        close();\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    try {\n<line3>        zkServer.checkACL(this, znodeAcl, ZooDefs.Perms.READ, getAuthInfo(), event.getPath(), null);\n<line4>    } catch (KeeperException.NoAuthException e) {\n<line5>        if (LOG.isTraceEnabled()) {\n<line6>            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, \"Not delivering event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" (filtered by ACL)\");\n<line7>        }\n<line8>        return;\n<line9>    }\n<line10>    ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, event.getZxid(), 0);\n<line11>    if (LOG.isTraceEnabled()) {\n<line12>        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n<line13>    }\n<line14>    // Convert WatchedEvent to a type that can be sent over the wire\n<line15>    WatcherEvent e = event.getWrapper();\n<line16>    try {\n<line17>        int responseSize = sendResponse(h, e, \"notification\");\n<line18>        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n<line19>    } catch (IOException e1) {\n<line20>        LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n<line21>        close();\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    close();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n<line3>    close();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // We take advantage of the limited size of the length to look\n<line3>    // for cmds. They are all 4-bytes which fits inside of an int\n<line4>    if (!FourLetterCommands.isKnown(len)) {\n<line5>        return false;\n<line6>    }\n<line7>    String cmd = FourLetterCommands.getCommandString(len);\n<line8>    // Stops automatic reads of incoming data on this channel. We don't\n<line9>    // expect any more traffic from the client when processing a 4LW\n<line10>    // so this shouldn't break anything.\n<line11>    channel.config().setAutoRead(false);\n<line12>    packetReceived(4);\n<line13>    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n<line14>    // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n<line15>    if (!FourLetterCommands.isEnabled(cmd)) {\n<line16>        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line17>        nopCmd.start();\n<line18>        return true;\n<line19>    }\n<line20>    if (len == FourLetterCommands.setTraceMaskCmd) {\n<line21>        ByteBuffer mask = ByteBuffer.allocate(8);\n<line22>        message.readBytes(mask);\n<line23>        mask.flip();\n<line24>        long traceMask = mask.getLong();\n<line25>        ZooTrace.setTextTraceLevel(traceMask);\n<line26>        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n<line27>        setMask.start();\n<line28>        return true;\n<line29>    } else {\n<line30>        CommandExecutor commandExecutor = new CommandExecutor();\n<line31>        return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    // We take advantage of the limited size of the length to look\n<line3>    // for cmds. They are all 4-bytes which fits inside of an int\n<line4>    if (!FourLetterCommands.isKnown(len)) {\n<line5>        return false;\n<line6>    }\n<line7>    String cmd = FourLetterCommands.getCommandString(len);\n<line8>    // Stops automatic reads of incoming data on this channel. We don't\n<line9>    // expect any more traffic from the client when processing a 4LW\n<line10>    // so this shouldn't break anything.\n<line11>    channel.config().setAutoRead(false);\n<line12>    packetReceived(4);\n<line13>    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n<line14>    // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n<line15>    if (!FourLetterCommands.isEnabled(cmd)) {\n<line16>        LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n<line17>        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line18>        nopCmd.start();\n<line19>        return true;\n<line20>    }\n<line21>    LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n<line22>    if (len == FourLetterCommands.setTraceMaskCmd) {\n<line23>        ByteBuffer mask = ByteBuffer.allocate(8);\n<line24>        message.readBytes(mask);\n<line25>        mask.flip();\n<line26>        long traceMask = mask.getLong();\n<line27>        ZooTrace.setTextTraceLevel(traceMask);\n<line28>        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n<line29>        setMask.start();\n<line30>        return true;\n<line31>    } else {\n<line32>        CommandExecutor commandExecutor = new CommandExecutor();\n<line33>        return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n<line34>    }\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line3>    nopCmd.start();\n<line4>    return true;\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n<line3>    NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line4>    nopCmd.start();\n<line5>    return true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    checkIsInEventLoop(\"processMessage\");\n<line3>    }\n<line4>    if (throttled.get()) {\n<line5>        // we are throttled, so we need to queue\n<line6>        if (queuedBuffer == null) {\n<line7>            queuedBuffer = channel.alloc().compositeBuffer();\n<line8>        }\n<line9>        appendToQueuedBuffer(buf.retainedDuplicate());\n<line10>        }\n<line11>    } else {\n<line12>        if (queuedBuffer != null) {\n<line13>            appendToQueuedBuffer(buf.retainedDuplicate());\n<line14>            processQueuedBuffer();\n<line15>        } else {\n<line16>            receiveMessage(buf);\n<line17>            // Have to check !closingChannel, because an error in\n<line18>            // receiveMessage() could have led to close() being called.\n<line19>            if (!closingChannel && buf.isReadable()) {\n<line20>                }\n<line21>                if (queuedBuffer == null) {\n<line22>                    queuedBuffer = channel.alloc().compositeBuffer();\n<line23>                }\n<line24>                appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n<line25>                }\n<line26>            }\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    checkIsInEventLoop(\"processMessage\");\n<line3>    LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n<line4>    if (LOG.isTraceEnabled()) {\n<line5>        LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n<line6>    }\n<line7>    if (throttled.get()) {\n<line8>        LOG.debug(\"Received message while throttled\");\n<line9>        // we are throttled, so we need to queue\n<line10>        if (queuedBuffer == null) {\n<line11>            LOG.debug(\"allocating queue\");\n<line12>            queuedBuffer = channel.alloc().compositeBuffer();\n<line13>        }\n<line14>        appendToQueuedBuffer(buf.retainedDuplicate());\n<line15>        if (LOG.isTraceEnabled()) {\n<line16>            LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n<line17>        }\n<line18>    } else {\n<line19>        LOG.debug(\"not throttled\");\n<line20>        if (queuedBuffer != null) {\n<line21>            appendToQueuedBuffer(buf.retainedDuplicate());\n<line22>            processQueuedBuffer();\n<line23>        } else {\n<line24>            receiveMessage(buf);\n<line25>            // Have to check !closingChannel, because an error in\n<line26>            // receiveMessage() could have led to close() being called.\n<line27>            if (!closingChannel && buf.isReadable()) {\n<line28>                if (LOG.isTraceEnabled()) {\n<line29>                    LOG.trace(\"Before copy {}\", buf);\n<line30>                }\n<line31>                if (queuedBuffer == null) {\n<line32>                    queuedBuffer = channel.alloc().compositeBuffer();\n<line33>                }\n<line34>                appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n<line35>                if (LOG.isTraceEnabled()) {\n<line36>                    LOG.trace(\"Copy is {}\", queuedBuffer);\n<line37>                    LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n<line38>                }\n<line39>            }\n<line40>        }\n<line41>    }\n<line42>}"},{"input":"","instruction":"<line1>{\n<line2>    // we are throttled, so we need to queue\n<line3>    if (queuedBuffer == null) {\n<line4>        queuedBuffer = channel.alloc().compositeBuffer();\n<line5>    }\n<line6>    appendToQueuedBuffer(buf.retainedDuplicate());\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.debug(\"Received message while throttled\");\n<line3>    // we are throttled, so we need to queue\n<line4>    if (queuedBuffer == null) {\n<line5>        LOG.debug(\"allocating queue\");\n<line6>        queuedBuffer = channel.alloc().compositeBuffer();\n<line7>    }\n<line8>    appendToQueuedBuffer(buf.retainedDuplicate());\n<line9>    if (LOG.isTraceEnabled()) {\n<line10>        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    queuedBuffer = channel.alloc().compositeBuffer();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"allocating queue\");\n<line3>    queuedBuffer = channel.alloc().compositeBuffer();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (queuedBuffer != null) {\n<line3>        appendToQueuedBuffer(buf.retainedDuplicate());\n<line4>        processQueuedBuffer();\n<line5>    } else {\n<line6>        receiveMessage(buf);\n<line7>        // Have to check !closingChannel, because an error in\n<line8>        // receiveMessage() could have led to close() being called.\n<line9>        if (!closingChannel && buf.isReadable()) {\n<line10>            }\n<line11>            if (queuedBuffer == null) {\n<line12>                queuedBuffer = channel.alloc().compositeBuffer();\n<line13>            }\n<line14>            appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n<line15>            }\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    LOG.debug(\"not throttled\");\n<line3>    if (queuedBuffer != null) {\n<line4>        appendToQueuedBuffer(buf.retainedDuplicate());\n<line5>        processQueuedBuffer();\n<line6>    } else {\n<line7>        receiveMessage(buf);\n<line8>        // Have to check !closingChannel, because an error in\n<line9>        // receiveMessage() could have led to close() being called.\n<line10>        if (!closingChannel && buf.isReadable()) {\n<line11>            if (LOG.isTraceEnabled()) {\n<line12>                LOG.trace(\"Before copy {}\", buf);\n<line13>            }\n<line14>            if (queuedBuffer == null) {\n<line15>                queuedBuffer = channel.alloc().compositeBuffer();\n<line16>            }\n<line17>            appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n<line18>            if (LOG.isTraceEnabled()) {\n<line19>                LOG.trace(\"Copy is {}\", queuedBuffer);\n<line20>                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n<line21>            }\n<line22>        }\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    checkIsInEventLoop(\"processQueuedBuffer\");\n<line3>    if (queuedBuffer != null) {\n<line4>        }\n<line5>        receiveMessage(queuedBuffer);\n<line6>        if (closingChannel) {\n<line7>            // close() could have been called if receiveMessage() failed\n<line8>        } else if (!queuedBuffer.isReadable()) {\n<line9>            releaseQueuedBuffer();\n<line10>        } else {\n<line11>            // Try to reduce memory consumption by freeing up buffer space\n<line12>            // which is no longer needed.\n<line13>            queuedBuffer.discardReadComponents();\n<line14>        }\n<line15>    } else {\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    checkIsInEventLoop(\"processQueuedBuffer\");\n<line3>    if (queuedBuffer != null) {\n<line4>        if (LOG.isTraceEnabled()) {\n<line5>            LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n<line6>        }\n<line7>        receiveMessage(queuedBuffer);\n<line8>        if (closingChannel) {\n<line9>            // close() could have been called if receiveMessage() failed\n<line10>            LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n<line11>        } else if (!queuedBuffer.isReadable()) {\n<line12>            LOG.debug(\"Processed queue - no bytes remaining\");\n<line13>            releaseQueuedBuffer();\n<line14>        } else {\n<line15>            LOG.debug(\"Processed queue - bytes remaining\");\n<line16>            // Try to reduce memory consumption by freeing up buffer space\n<line17>            // which is no longer needed.\n<line18>            queuedBuffer.discardReadComponents();\n<line19>        }\n<line20>    } else {\n<line21>        LOG.debug(\"queue empty\");\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    receiveMessage(queuedBuffer);\n<line4>    if (closingChannel) {\n<line5>        // close() could have been called if receiveMessage() failed\n<line6>    } else if (!queuedBuffer.isReadable()) {\n<line7>        releaseQueuedBuffer();\n<line8>    } else {\n<line9>        // Try to reduce memory consumption by freeing up buffer space\n<line10>        // which is no longer needed.\n<line11>        queuedBuffer.discardReadComponents();\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    if (LOG.isTraceEnabled()) {\n<line3>        LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n<line4>    }\n<line5>    receiveMessage(queuedBuffer);\n<line6>    if (closingChannel) {\n<line7>        // close() could have been called if receiveMessage() failed\n<line8>        LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n<line9>    } else if (!queuedBuffer.isReadable()) {\n<line10>        LOG.debug(\"Processed queue - no bytes remaining\");\n<line11>        releaseQueuedBuffer();\n<line12>    } else {\n<line13>        LOG.debug(\"Processed queue - bytes remaining\");\n<line14>        // Try to reduce memory consumption by freeing up buffer space\n<line15>        // which is no longer needed.\n<line16>        queuedBuffer.discardReadComponents();\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    // close() could have been called if receiveMessage() failed\n<line3>}","output":"<line1>{\n<line2>    // close() could have been called if receiveMessage() failed\n<line3>    LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    releaseQueuedBuffer();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Processed queue - no bytes remaining\");\n<line3>    releaseQueuedBuffer();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Try to reduce memory consumption by freeing up buffer space\n<line3>    // which is no longer needed.\n<line4>    queuedBuffer.discardReadComponents();\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(\"Processed queue - bytes remaining\");\n<line3>    // Try to reduce memory consumption by freeing up buffer space\n<line4>    // which is no longer needed.\n<line5>    queuedBuffer.discardReadComponents();\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"queue empty\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    checkIsInEventLoop(\"receiveMessage\");\n<line3>    try {\n<line4>        while (message.isReadable() && !throttled.get()) {\n<line5>            if (bb != null) {\n<line6>                    ByteBuffer dat = bb.duplicate();\n<line7>                    dat.flip();\n<line8>                }\n<line9>                if (bb.remaining() > message.readableBytes()) {\n<line10>                    int newLimit = bb.position() + message.readableBytes();\n<line11>                    bb.limit(newLimit);\n<line12>                }\n<line13>                message.readBytes(bb);\n<line14>                bb.limit(bb.capacity());\n<line15>                    ByteBuffer dat = bb.duplicate();\n<line16>                    dat.flip();\n<line17>                }\n<line18>                if (bb.remaining() == 0) {\n<line19>                    bb.flip();\n<line20>                    packetReceived(4 + bb.remaining());\n<line21>                    ZooKeeperServer zks = this.zkServer;\n<line22>                    if (zks == null || !zks.isRunning()) {\n<line23>                        throw new IOException(\"ZK down\");\n<line24>                    }\n<line25>                    if (initialized) {\n<line26>                        RequestHeader h = new RequestHeader();\n<line27>                        ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line28>                        RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line29>                        zks.processPacket(this, h, request);\n<line30>                    } else {\n<line31>                        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line32>                        ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line33>                        zks.processConnectRequest(this, request);\n<line34>                        initialized = true;\n<line35>                    }\n<line36>                    bb = null;\n<line37>                }\n<line38>            } else {\n<line39>                    ByteBuffer dat = bbLen.duplicate();\n<line40>                    dat.flip();\n<line41>                }\n<line42>                if (message.readableBytes() < bbLen.remaining()) {\n<line43>                    bbLen.limit(bbLen.position() + message.readableBytes());\n<line44>                }\n<line45>                message.readBytes(bbLen);\n<line46>                bbLen.limit(bbLen.capacity());\n<line47>                if (bbLen.remaining() == 0) {\n<line48>                    bbLen.flip();\n<line49>                    }\n<line50>                    int len = bbLen.getInt();\n<line51>                    }\n<line52>                    bbLen.clear();\n<line53>                    if (!initialized) {\n<line54>                        if (checkFourLetterWord(channel, message, len)) {\n<line55>                            return;\n<line56>                        }\n<line57>                    }\n<line58>                    if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line59>                        throw new IOException(\"Len error \" + len);\n<line60>                    }\n<line61>                    ZooKeeperServer zks = this.zkServer;\n<line62>                    if (zks == null || !zks.isRunning()) {\n<line63>                        close(DisconnectReason.IO_EXCEPTION);\n<line64>                        return;\n<line65>                    }\n<line66>                    // checkRequestSize will throw IOException if request is rejected\n<line67>                    zks.checkRequestSizeWhenReceivingMessage(len);\n<line68>                    bb = ByteBuffer.allocate(len);\n<line69>                }\n<line70>            }\n<line71>        }\n<line72>    } catch (IOException e) {\n<line73>        close(DisconnectReason.IO_EXCEPTION);\n<line74>    } catch (ClientCnxnLimitException e) {\n<line75>        // Common case exception, print at debug level\n<line76>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line77>        close(DisconnectReason.CLIENT_RATE_LIMIT);\n<line78>    }\n<line79>}","output":"<line1>{\n<line2>    checkIsInEventLoop(\"receiveMessage\");\n<line3>    try {\n<line4>        while (message.isReadable() && !throttled.get()) {\n<line5>            if (bb != null) {\n<line6>                if (LOG.isTraceEnabled()) {\n<line7>                    LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line8>                    ByteBuffer dat = bb.duplicate();\n<line9>                    dat.flip();\n<line10>                    LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line11>                }\n<line12>                if (bb.remaining() > message.readableBytes()) {\n<line13>                    int newLimit = bb.position() + message.readableBytes();\n<line14>                    bb.limit(newLimit);\n<line15>                }\n<line16>                message.readBytes(bb);\n<line17>                bb.limit(bb.capacity());\n<line18>                if (LOG.isTraceEnabled()) {\n<line19>                    LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line20>                    ByteBuffer dat = bb.duplicate();\n<line21>                    dat.flip();\n<line22>                    LOG.trace(\"after readbytes 0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line23>                }\n<line24>                if (bb.remaining() == 0) {\n<line25>                    bb.flip();\n<line26>                    packetReceived(4 + bb.remaining());\n<line27>                    ZooKeeperServer zks = this.zkServer;\n<line28>                    if (zks == null || !zks.isRunning()) {\n<line29>                        throw new IOException(\"ZK down\");\n<line30>                    }\n<line31>                    if (initialized) {\n<line32>                        RequestHeader h = new RequestHeader();\n<line33>                        ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line34>                        RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line35>                        zks.processPacket(this, h, request);\n<line36>                    } else {\n<line37>                        LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n<line38>                        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line39>                        ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line40>                        zks.processConnectRequest(this, request);\n<line41>                        initialized = true;\n<line42>                    }\n<line43>                    bb = null;\n<line44>                }\n<line45>            } else {\n<line46>                if (LOG.isTraceEnabled()) {\n<line47>                    LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n<line48>                    ByteBuffer dat = bbLen.duplicate();\n<line49>                    dat.flip();\n<line50>                    LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line51>                }\n<line52>                if (message.readableBytes() < bbLen.remaining()) {\n<line53>                    bbLen.limit(bbLen.position() + message.readableBytes());\n<line54>                }\n<line55>                message.readBytes(bbLen);\n<line56>                bbLen.limit(bbLen.capacity());\n<line57>                if (bbLen.remaining() == 0) {\n<line58>                    bbLen.flip();\n<line59>                    if (LOG.isTraceEnabled()) {\n<line60>                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n<line61>                    }\n<line62>                    int len = bbLen.getInt();\n<line63>                    if (LOG.isTraceEnabled()) {\n<line64>                        LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n<line65>                    }\n<line66>                    bbLen.clear();\n<line67>                    if (!initialized) {\n<line68>                        if (checkFourLetterWord(channel, message, len)) {\n<line69>                            return;\n<line70>                        }\n<line71>                    }\n<line72>                    if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line73>                        throw new IOException(\"Len error \" + len);\n<line74>                    }\n<line75>                    ZooKeeperServer zks = this.zkServer;\n<line76>                    if (zks == null || !zks.isRunning()) {\n<line77>                        LOG.info(\"Closing connection to {} because the server is not ready\", getRemoteSocketAddress());\n<line78>                        close(DisconnectReason.IO_EXCEPTION);\n<line79>                        return;\n<line80>                    }\n<line81>                    // checkRequestSize will throw IOException if request is rejected\n<line82>                    zks.checkRequestSizeWhenReceivingMessage(len);\n<line83>                    bb = ByteBuffer.allocate(len);\n<line84>                }\n<line85>            }\n<line86>        }\n<line87>    } catch (IOException e) {\n<line88>        LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n<line89>        close(DisconnectReason.IO_EXCEPTION);\n<line90>    } catch (ClientCnxnLimitException e) {\n<line91>        // Common case exception, print at debug level\n<line92>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line93>        LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n<line94>        close(DisconnectReason.CLIENT_RATE_LIMIT);\n<line95>    }\n<line96>}"},{"input":"","instruction":"<line1>{\n<line2>    while (message.isReadable() && !throttled.get()) {\n<line3>        if (bb != null) {\n<line4>                ByteBuffer dat = bb.duplicate();\n<line5>                dat.flip();\n<line6>            }\n<line7>            if (bb.remaining() > message.readableBytes()) {\n<line8>                int newLimit = bb.position() + message.readableBytes();\n<line9>                bb.limit(newLimit);\n<line10>            }\n<line11>            message.readBytes(bb);\n<line12>            bb.limit(bb.capacity());\n<line13>                ByteBuffer dat = bb.duplicate();\n<line14>                dat.flip();\n<line15>            }\n<line16>            if (bb.remaining() == 0) {\n<line17>                bb.flip();\n<line18>                packetReceived(4 + bb.remaining());\n<line19>                ZooKeeperServer zks = this.zkServer;\n<line20>                if (zks == null || !zks.isRunning()) {\n<line21>                    throw new IOException(\"ZK down\");\n<line22>                }\n<line23>                if (initialized) {\n<line24>                    RequestHeader h = new RequestHeader();\n<line25>                    ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line26>                    RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line27>                    zks.processPacket(this, h, request);\n<line28>                } else {\n<line29>                    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line30>                    ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line31>                    zks.processConnectRequest(this, request);\n<line32>                    initialized = true;\n<line33>                }\n<line34>                bb = null;\n<line35>            }\n<line36>        } else {\n<line37>                ByteBuffer dat = bbLen.duplicate();\n<line38>                dat.flip();\n<line39>            }\n<line40>            if (message.readableBytes() < bbLen.remaining()) {\n<line41>                bbLen.limit(bbLen.position() + message.readableBytes());\n<line42>            }\n<line43>            message.readBytes(bbLen);\n<line44>            bbLen.limit(bbLen.capacity());\n<line45>            if (bbLen.remaining() == 0) {\n<line46>                bbLen.flip();\n<line47>                }\n<line48>                int len = bbLen.getInt();\n<line49>                }\n<line50>                bbLen.clear();\n<line51>                if (!initialized) {\n<line52>                    if (checkFourLetterWord(channel, message, len)) {\n<line53>                        return;\n<line54>                    }\n<line55>                }\n<line56>                if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line57>                    throw new IOException(\"Len error \" + len);\n<line58>                }\n<line59>                ZooKeeperServer zks = this.zkServer;\n<line60>                if (zks == null || !zks.isRunning()) {\n<line61>                    close(DisconnectReason.IO_EXCEPTION);\n<line62>                    return;\n<line63>                }\n<line64>                // checkRequestSize will throw IOException if request is rejected\n<line65>                zks.checkRequestSizeWhenReceivingMessage(len);\n<line66>                bb = ByteBuffer.allocate(len);\n<line67>            }\n<line68>        }\n<line69>    }\n<line70>}","output":"<line1>{\n<line2>    while (message.isReadable() && !throttled.get()) {\n<line3>        if (bb != null) {\n<line4>            if (LOG.isTraceEnabled()) {\n<line5>                LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line6>                ByteBuffer dat = bb.duplicate();\n<line7>                dat.flip();\n<line8>                LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line9>            }\n<line10>            if (bb.remaining() > message.readableBytes()) {\n<line11>                int newLimit = bb.position() + message.readableBytes();\n<line12>                bb.limit(newLimit);\n<line13>            }\n<line14>            message.readBytes(bb);\n<line15>            bb.limit(bb.capacity());\n<line16>            if (LOG.isTraceEnabled()) {\n<line17>                LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line18>                ByteBuffer dat = bb.duplicate();\n<line19>                dat.flip();\n<line20>                LOG.trace(\"after readbytes 0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line21>            }\n<line22>            if (bb.remaining() == 0) {\n<line23>                bb.flip();\n<line24>                packetReceived(4 + bb.remaining());\n<line25>                ZooKeeperServer zks = this.zkServer;\n<line26>                if (zks == null || !zks.isRunning()) {\n<line27>                    throw new IOException(\"ZK down\");\n<line28>                }\n<line29>                if (initialized) {\n<line30>                    RequestHeader h = new RequestHeader();\n<line31>                    ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line32>                    RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line33>                    zks.processPacket(this, h, request);\n<line34>                } else {\n<line35>                    LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n<line36>                    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line37>                    ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line38>                    zks.processConnectRequest(this, request);\n<line39>                    initialized = true;\n<line40>                }\n<line41>                bb = null;\n<line42>            }\n<line43>        } else {\n<line44>            if (LOG.isTraceEnabled()) {\n<line45>                LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n<line46>                ByteBuffer dat = bbLen.duplicate();\n<line47>                dat.flip();\n<line48>                LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line49>            }\n<line50>            if (message.readableBytes() < bbLen.remaining()) {\n<line51>                bbLen.limit(bbLen.position() + message.readableBytes());\n<line52>            }\n<line53>            message.readBytes(bbLen);\n<line54>            bbLen.limit(bbLen.capacity());\n<line55>            if (bbLen.remaining() == 0) {\n<line56>                bbLen.flip();\n<line57>                if (LOG.isTraceEnabled()) {\n<line58>                    LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n<line59>                }\n<line60>                int len = bbLen.getInt();\n<line61>                if (LOG.isTraceEnabled()) {\n<line62>                    LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n<line63>                }\n<line64>                bbLen.clear();\n<line65>                if (!initialized) {\n<line66>                    if (checkFourLetterWord(channel, message, len)) {\n<line67>                        return;\n<line68>                    }\n<line69>                }\n<line70>                if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line71>                    throw new IOException(\"Len error \" + len);\n<line72>                }\n<line73>                ZooKeeperServer zks = this.zkServer;\n<line74>                if (zks == null || !zks.isRunning()) {\n<line75>                    LOG.info(\"Closing connection to {} because the server is not ready\", getRemoteSocketAddress());\n<line76>                    close(DisconnectReason.IO_EXCEPTION);\n<line77>                    return;\n<line78>                }\n<line79>                // checkRequestSize will throw IOException if request is rejected\n<line80>                zks.checkRequestSizeWhenReceivingMessage(len);\n<line81>                bb = ByteBuffer.allocate(len);\n<line82>            }\n<line83>        }\n<line84>    }\n<line85>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bb != null) {\n<line3>            ByteBuffer dat = bb.duplicate();\n<line4>            dat.flip();\n<line5>        }\n<line6>        if (bb.remaining() > message.readableBytes()) {\n<line7>            int newLimit = bb.position() + message.readableBytes();\n<line8>            bb.limit(newLimit);\n<line9>        }\n<line10>        message.readBytes(bb);\n<line11>        bb.limit(bb.capacity());\n<line12>            ByteBuffer dat = bb.duplicate();\n<line13>            dat.flip();\n<line14>        }\n<line15>        if (bb.remaining() == 0) {\n<line16>            bb.flip();\n<line17>            packetReceived(4 + bb.remaining());\n<line18>            ZooKeeperServer zks = this.zkServer;\n<line19>            if (zks == null || !zks.isRunning()) {\n<line20>                throw new IOException(\"ZK down\");\n<line21>            }\n<line22>            if (initialized) {\n<line23>                RequestHeader h = new RequestHeader();\n<line24>                ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line25>                RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line26>                zks.processPacket(this, h, request);\n<line27>            } else {\n<line28>                BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line29>                ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line30>                zks.processConnectRequest(this, request);\n<line31>                initialized = true;\n<line32>            }\n<line33>            bb = null;\n<line34>        }\n<line35>    } else {\n<line36>            ByteBuffer dat = bbLen.duplicate();\n<line37>            dat.flip();\n<line38>        }\n<line39>        if (message.readableBytes() < bbLen.remaining()) {\n<line40>            bbLen.limit(bbLen.position() + message.readableBytes());\n<line41>        }\n<line42>        message.readBytes(bbLen);\n<line43>        bbLen.limit(bbLen.capacity());\n<line44>        if (bbLen.remaining() == 0) {\n<line45>            bbLen.flip();\n<line46>            }\n<line47>            int len = bbLen.getInt();\n<line48>            }\n<line49>            bbLen.clear();\n<line50>            if (!initialized) {\n<line51>                if (checkFourLetterWord(channel, message, len)) {\n<line52>                    return;\n<line53>                }\n<line54>            }\n<line55>            if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line56>                throw new IOException(\"Len error \" + len);\n<line57>            }\n<line58>            ZooKeeperServer zks = this.zkServer;\n<line59>            if (zks == null || !zks.isRunning()) {\n<line60>                close(DisconnectReason.IO_EXCEPTION);\n<line61>                return;\n<line62>            }\n<line63>            // checkRequestSize will throw IOException if request is rejected\n<line64>            zks.checkRequestSizeWhenReceivingMessage(len);\n<line65>            bb = ByteBuffer.allocate(len);\n<line66>        }\n<line67>    }\n<line68>}","output":"<line1>{\n<line2>    if (bb != null) {\n<line3>        if (LOG.isTraceEnabled()) {\n<line4>            LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line5>            ByteBuffer dat = bb.duplicate();\n<line6>            dat.flip();\n<line7>            LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line8>        }\n<line9>        if (bb.remaining() > message.readableBytes()) {\n<line10>            int newLimit = bb.position() + message.readableBytes();\n<line11>            bb.limit(newLimit);\n<line12>        }\n<line13>        message.readBytes(bb);\n<line14>        bb.limit(bb.capacity());\n<line15>        if (LOG.isTraceEnabled()) {\n<line16>            LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line17>            ByteBuffer dat = bb.duplicate();\n<line18>            dat.flip();\n<line19>            LOG.trace(\"after readbytes 0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line20>        }\n<line21>        if (bb.remaining() == 0) {\n<line22>            bb.flip();\n<line23>            packetReceived(4 + bb.remaining());\n<line24>            ZooKeeperServer zks = this.zkServer;\n<line25>            if (zks == null || !zks.isRunning()) {\n<line26>                throw new IOException(\"ZK down\");\n<line27>            }\n<line28>            if (initialized) {\n<line29>                RequestHeader h = new RequestHeader();\n<line30>                ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line31>                RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line32>                zks.processPacket(this, h, request);\n<line33>            } else {\n<line34>                LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n<line35>                BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line36>                ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line37>                zks.processConnectRequest(this, request);\n<line38>                initialized = true;\n<line39>            }\n<line40>            bb = null;\n<line41>        }\n<line42>    } else {\n<line43>        if (LOG.isTraceEnabled()) {\n<line44>            LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n<line45>            ByteBuffer dat = bbLen.duplicate();\n<line46>            dat.flip();\n<line47>            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line48>        }\n<line49>        if (message.readableBytes() < bbLen.remaining()) {\n<line50>            bbLen.limit(bbLen.position() + message.readableBytes());\n<line51>        }\n<line52>        message.readBytes(bbLen);\n<line53>        bbLen.limit(bbLen.capacity());\n<line54>        if (bbLen.remaining() == 0) {\n<line55>            bbLen.flip();\n<line56>            if (LOG.isTraceEnabled()) {\n<line57>                LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n<line58>            }\n<line59>            int len = bbLen.getInt();\n<line60>            if (LOG.isTraceEnabled()) {\n<line61>                LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n<line62>            }\n<line63>            bbLen.clear();\n<line64>            if (!initialized) {\n<line65>                if (checkFourLetterWord(channel, message, len)) {\n<line66>                    return;\n<line67>                }\n<line68>            }\n<line69>            if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line70>                throw new IOException(\"Len error \" + len);\n<line71>            }\n<line72>            ZooKeeperServer zks = this.zkServer;\n<line73>            if (zks == null || !zks.isRunning()) {\n<line74>                LOG.info(\"Closing connection to {} because the server is not ready\", getRemoteSocketAddress());\n<line75>                close(DisconnectReason.IO_EXCEPTION);\n<line76>                return;\n<line77>            }\n<line78>            // checkRequestSize will throw IOException if request is rejected\n<line79>            zks.checkRequestSizeWhenReceivingMessage(len);\n<line80>            bb = ByteBuffer.allocate(len);\n<line81>        }\n<line82>    }\n<line83>}"},{"input":"","instruction":"<line1>{\n<line2>        ByteBuffer dat = bb.duplicate();\n<line3>        dat.flip();\n<line4>    }\n<line5>    if (bb.remaining() > message.readableBytes()) {\n<line6>        int newLimit = bb.position() + message.readableBytes();\n<line7>        bb.limit(newLimit);\n<line8>    }\n<line9>    message.readBytes(bb);\n<line10>    bb.limit(bb.capacity());\n<line11>        ByteBuffer dat = bb.duplicate();\n<line12>        dat.flip();\n<line13>    }\n<line14>    if (bb.remaining() == 0) {\n<line15>        bb.flip();\n<line16>        packetReceived(4 + bb.remaining());\n<line17>        ZooKeeperServer zks = this.zkServer;\n<line18>        if (zks == null || !zks.isRunning()) {\n<line19>            throw new IOException(\"ZK down\");\n<line20>        }\n<line21>        if (initialized) {\n<line22>            RequestHeader h = new RequestHeader();\n<line23>            ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line24>            RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line25>            zks.processPacket(this, h, request);\n<line26>        } else {\n<line27>            BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line28>            ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line29>            zks.processConnectRequest(this, request);\n<line30>            initialized = true;\n<line31>        }\n<line32>        bb = null;\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    if (LOG.isTraceEnabled()) {\n<line3>        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line4>        ByteBuffer dat = bb.duplicate();\n<line5>        dat.flip();\n<line6>        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line7>    }\n<line8>    if (bb.remaining() > message.readableBytes()) {\n<line9>        int newLimit = bb.position() + message.readableBytes();\n<line10>        bb.limit(newLimit);\n<line11>    }\n<line12>    message.readBytes(bb);\n<line13>    bb.limit(bb.capacity());\n<line14>    if (LOG.isTraceEnabled()) {\n<line15>        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n<line16>        ByteBuffer dat = bb.duplicate();\n<line17>        dat.flip();\n<line18>        LOG.trace(\"after readbytes 0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line19>    }\n<line20>    if (bb.remaining() == 0) {\n<line21>        bb.flip();\n<line22>        packetReceived(4 + bb.remaining());\n<line23>        ZooKeeperServer zks = this.zkServer;\n<line24>        if (zks == null || !zks.isRunning()) {\n<line25>            throw new IOException(\"ZK down\");\n<line26>        }\n<line27>        if (initialized) {\n<line28>            RequestHeader h = new RequestHeader();\n<line29>            ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line30>            RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line31>            zks.processPacket(this, h, request);\n<line32>        } else {\n<line33>            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n<line34>            BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line35>            ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line36>            zks.processConnectRequest(this, request);\n<line37>            initialized = true;\n<line38>        }\n<line39>        bb = null;\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    bb.flip();\n<line3>    packetReceived(4 + bb.remaining());\n<line4>    ZooKeeperServer zks = this.zkServer;\n<line5>    if (zks == null || !zks.isRunning()) {\n<line6>        throw new IOException(\"ZK down\");\n<line7>    }\n<line8>    if (initialized) {\n<line9>        RequestHeader h = new RequestHeader();\n<line10>        ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line11>        RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line12>        zks.processPacket(this, h, request);\n<line13>    } else {\n<line14>        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line15>        ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line16>        zks.processConnectRequest(this, request);\n<line17>        initialized = true;\n<line18>    }\n<line19>    bb = null;\n<line20>}","output":"<line1>{\n<line2>    bb.flip();\n<line3>    packetReceived(4 + bb.remaining());\n<line4>    ZooKeeperServer zks = this.zkServer;\n<line5>    if (zks == null || !zks.isRunning()) {\n<line6>        throw new IOException(\"ZK down\");\n<line7>    }\n<line8>    if (initialized) {\n<line9>        RequestHeader h = new RequestHeader();\n<line10>        ByteBufferInputStream.byteBuffer2Record(bb, h);\n<line11>        RequestRecord request = RequestRecord.fromBytes(bb.slice());\n<line12>        zks.processPacket(this, h, request);\n<line13>    } else {\n<line14>        LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n<line15>        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line16>        ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line17>        zks.processConnectRequest(this, request);\n<line18>        initialized = true;\n<line19>    }\n<line20>    bb = null;\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line3>    ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line4>    zks.processConnectRequest(this, request);\n<line5>    initialized = true;\n<line6>}","output":"<line1>{\n<line2>    LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n<line3>    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n<line4>    ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n<line5>    zks.processConnectRequest(this, request);\n<line6>    initialized = true;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>        ByteBuffer dat = bbLen.duplicate();\n<line3>        dat.flip();\n<line4>    }\n<line5>    if (message.readableBytes() < bbLen.remaining()) {\n<line6>        bbLen.limit(bbLen.position() + message.readableBytes());\n<line7>    }\n<line8>    message.readBytes(bbLen);\n<line9>    bbLen.limit(bbLen.capacity());\n<line10>    if (bbLen.remaining() == 0) {\n<line11>        bbLen.flip();\n<line12>        }\n<line13>        int len = bbLen.getInt();\n<line14>        }\n<line15>        bbLen.clear();\n<line16>        if (!initialized) {\n<line17>            if (checkFourLetterWord(channel, message, len)) {\n<line18>                return;\n<line19>            }\n<line20>        }\n<line21>        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line22>            throw new IOException(\"Len error \" + len);\n<line23>        }\n<line24>        ZooKeeperServer zks = this.zkServer;\n<line25>        if (zks == null || !zks.isRunning()) {\n<line26>            close(DisconnectReason.IO_EXCEPTION);\n<line27>            return;\n<line28>        }\n<line29>        // checkRequestSize will throw IOException if request is rejected\n<line30>        zks.checkRequestSizeWhenReceivingMessage(len);\n<line31>        bb = ByteBuffer.allocate(len);\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    if (LOG.isTraceEnabled()) {\n<line3>        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n<line4>        ByteBuffer dat = bbLen.duplicate();\n<line5>        dat.flip();\n<line6>        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n<line7>    }\n<line8>    if (message.readableBytes() < bbLen.remaining()) {\n<line9>        bbLen.limit(bbLen.position() + message.readableBytes());\n<line10>    }\n<line11>    message.readBytes(bbLen);\n<line12>    bbLen.limit(bbLen.capacity());\n<line13>    if (bbLen.remaining() == 0) {\n<line14>        bbLen.flip();\n<line15>        if (LOG.isTraceEnabled()) {\n<line16>            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n<line17>        }\n<line18>        int len = bbLen.getInt();\n<line19>        if (LOG.isTraceEnabled()) {\n<line20>            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n<line21>        }\n<line22>        bbLen.clear();\n<line23>        if (!initialized) {\n<line24>            if (checkFourLetterWord(channel, message, len)) {\n<line25>                return;\n<line26>            }\n<line27>        }\n<line28>        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line29>            throw new IOException(\"Len error \" + len);\n<line30>        }\n<line31>        ZooKeeperServer zks = this.zkServer;\n<line32>        if (zks == null || !zks.isRunning()) {\n<line33>            LOG.info(\"Closing connection to {} because the server is not ready\", getRemoteSocketAddress());\n<line34>            close(DisconnectReason.IO_EXCEPTION);\n<line35>            return;\n<line36>        }\n<line37>        // checkRequestSize will throw IOException if request is rejected\n<line38>        zks.checkRequestSizeWhenReceivingMessage(len);\n<line39>        bb = ByteBuffer.allocate(len);\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    bbLen.flip();\n<line3>    }\n<line4>    int len = bbLen.getInt();\n<line5>    }\n<line6>    bbLen.clear();\n<line7>    if (!initialized) {\n<line8>        if (checkFourLetterWord(channel, message, len)) {\n<line9>            return;\n<line10>        }\n<line11>    }\n<line12>    if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line13>        throw new IOException(\"Len error \" + len);\n<line14>    }\n<line15>    ZooKeeperServer zks = this.zkServer;\n<line16>    if (zks == null || !zks.isRunning()) {\n<line17>        close(DisconnectReason.IO_EXCEPTION);\n<line18>        return;\n<line19>    }\n<line20>    // checkRequestSize will throw IOException if request is rejected\n<line21>    zks.checkRequestSizeWhenReceivingMessage(len);\n<line22>    bb = ByteBuffer.allocate(len);\n<line23>}","output":"<line1>{\n<line2>    bbLen.flip();\n<line3>    if (LOG.isTraceEnabled()) {\n<line4>        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n<line5>    }\n<line6>    int len = bbLen.getInt();\n<line7>    if (LOG.isTraceEnabled()) {\n<line8>        LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n<line9>    }\n<line10>    bbLen.clear();\n<line11>    if (!initialized) {\n<line12>        if (checkFourLetterWord(channel, message, len)) {\n<line13>            return;\n<line14>        }\n<line15>    }\n<line16>    if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n<line17>        throw new IOException(\"Len error \" + len);\n<line18>    }\n<line19>    ZooKeeperServer zks = this.zkServer;\n<line20>    if (zks == null || !zks.isRunning()) {\n<line21>        LOG.info(\"Closing connection to {} because the server is not ready\", getRemoteSocketAddress());\n<line22>        close(DisconnectReason.IO_EXCEPTION);\n<line23>        return;\n<line24>    }\n<line25>    // checkRequestSize will throw IOException if request is rejected\n<line26>    zks.checkRequestSizeWhenReceivingMessage(len);\n<line27>    bb = ByteBuffer.allocate(len);\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    close(DisconnectReason.IO_EXCEPTION);\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Closing connection to {} because the server is not ready\", getRemoteSocketAddress());\n<line3>    close(DisconnectReason.IO_EXCEPTION);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // Common case exception, print at debug level\n<line3>    ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line4>    close(DisconnectReason.CLIENT_RATE_LIMIT);\n<line5>}","output":"<line1>{\n<line2>    // Common case exception, print at debug level\n<line3>    ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line4>    LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n<line5>    close(DisconnectReason.CLIENT_RATE_LIMIT);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (throttled.compareAndSet(false, true)) {\n<line3>        channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (throttled.compareAndSet(false, true)) {\n<line3>        LOG.debug(\"Throttling - disabling recv {}\", this);\n<line4>        channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Throttling - disabling recv {}\", this);\n<line3>    channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (throttled.compareAndSet(true, false)) {\n<line3>        channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (throttled.compareAndSet(true, false)) {\n<line3>        LOG.debug(\"Sending unthrottle event {}\", this);\n<line4>        channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Sending unthrottle event {}\", this);\n<line3>    channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperServerMain main = new ZooKeeperServerMain();\n<line3>    try {\n<line4>        main.initializeAndRun(args);\n<line5>    } catch (IllegalArgumentException e) {\n<line6>        System.err.println(USAGE);\n<line7>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line8>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line9>    } catch (ConfigException e) {\n<line10>        System.err.println(\"Invalid config, exiting abnormally\");\n<line11>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line12>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line13>    } catch (DatadirException e) {\n<line14>        System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line15>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line16>        ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line17>    } catch (AdminServerException e) {\n<line18>        System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line19>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line20>        ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line21>    } catch (Exception e) {\n<line22>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line23>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line24>    }\n<line25>    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line26>}","output":"<line1>{\n<line2>    ZooKeeperServerMain main = new ZooKeeperServerMain();\n<line3>    try {\n<line4>        main.initializeAndRun(args);\n<line5>    } catch (IllegalArgumentException e) {\n<line6>        LOG.error(\"Invalid arguments, exiting abnormally\", e);\n<line7>        LOG.info(USAGE);\n<line8>        System.err.println(USAGE);\n<line9>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line10>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line11>    } catch (ConfigException e) {\n<line12>        LOG.error(\"Invalid config, exiting abnormally\", e);\n<line13>        System.err.println(\"Invalid config, exiting abnormally\");\n<line14>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line15>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line16>    } catch (DatadirException e) {\n<line17>        LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n<line18>        System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line19>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line20>        ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line21>    } catch (AdminServerException e) {\n<line22>        LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n<line23>        System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line24>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line25>        ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line26>    } catch (Exception e) {\n<line27>        LOG.error(\"Unexpected exception, exiting abnormally\", e);\n<line28>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line29>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line30>    }\n<line31>    LOG.info(\"Exiting normally\");\n<line32>    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(USAGE);\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Invalid arguments, exiting abnormally\", e);\n<line3>    LOG.info(USAGE);\n<line4>    System.err.println(USAGE);\n<line5>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line6>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(\"Invalid config, exiting abnormally\");\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Invalid config, exiting abnormally\", e);\n<line3>    System.err.println(\"Invalid config, exiting abnormally\");\n<line4>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line5>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n<line3>    System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line4>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line5>    ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n<line3>    System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line4>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line5>    ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception, exiting abnormally\", e);\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    FileTxnSnapLog txnLog = null;\n<line3>    try {\n<line4>        try {\n<line5>            metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());\n<line6>        } catch (MetricsProviderLifeCycleException error) {\n<line7>            throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n<line8>        }\n<line9>        ServerMetrics.metricsProviderInitialized(metricsProvider);\n<line10>        ProviderRegistry.initialize();\n<line11>        // Note that this thread isn't going to be doing anything else,\n<line12>        // so rather than spawning another thread, we will just call\n<line13>        // run() in this thread.\n<line14>        // create a file logger url from the command line args\n<line15>        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);\n<line16>        JvmPauseMonitor jvmPauseMonitor = null;\n<line17>        if (config.jvmPauseMonitorToRun) {\n<line18>            jvmPauseMonitor = new JvmPauseMonitor(config);\n<line19>        }\n<line20>        final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);\n<line21>        txnLog.setServerStats(zkServer.serverStats());\n<line22>        // Registers shutdown handler which will be used to know the\n<line23>        // server error or shutdown state changes.\n<line24>        final CountDownLatch shutdownLatch = new CountDownLatch(1);\n<line25>        zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));\n<line26>        // Start Admin server\n<line27>        adminServer = AdminServerFactory.createAdminServer();\n<line28>        adminServer.setZooKeeperServer(zkServer);\n<line29>        adminServer.start();\n<line30>        boolean needStartZKServer = true;\n<line31>        if (config.getClientPortAddress() != null) {\n<line32>            cnxnFactory = ServerCnxnFactory.createFactory();\n<line33>            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n<line34>            cnxnFactory.startup(zkServer);\n<line35>            // zkServer has been started. So we don't need to start it again in secureCnxnFactory.\n<line36>            needStartZKServer = false;\n<line37>        }\n<line38>        if (config.getSecureClientPortAddress() != null) {\n<line39>            secureCnxnFactory = ServerCnxnFactory.createFactory();\n<line40>            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n<line41>            secureCnxnFactory.startup(zkServer, needStartZKServer);\n<line42>        }\n<line43>        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor, Integer.getInteger(\"znode.container.checkIntervalMs\", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger(\"znode.container.maxPerMinute\", 10000), Long.getLong(\"znode.container.maxNeverUsedIntervalMs\", 0));\n<line44>        containerManager.start();\n<line45>        ZKAuditProvider.addZKStartStopAuditLog();\n<line46>        serverStarted();\n<line47>        // Watch status of ZooKeeper server. It will do a graceful shutdown\n<line48>        // if the server is not running or hits an internal error.\n<line49>        shutdownLatch.await();\n<line50>        shutdown();\n<line51>        if (cnxnFactory != null) {\n<line52>            cnxnFactory.join();\n<line53>        }\n<line54>        if (secureCnxnFactory != null) {\n<line55>            secureCnxnFactory.join();\n<line56>        }\n<line57>        if (zkServer.canShutdown()) {\n<line58>            zkServer.shutdown(true);\n<line59>        }\n<line60>    } catch (InterruptedException e) {\n<line61>        // warn, but generally this is ok\n<line62>    } finally {\n<line63>        if (txnLog != null) {\n<line64>            txnLog.close();\n<line65>        }\n<line66>        if (metricsProvider != null) {\n<line67>            try {\n<line68>                metricsProvider.stop();\n<line69>            } catch (Throwable error) {\n<line70>            }\n<line71>        }\n<line72>    }\n<line73>}","output":"<line1>{\n<line2>    LOG.info(\"Starting server\");\n<line3>    FileTxnSnapLog txnLog = null;\n<line4>    try {\n<line5>        try {\n<line6>            metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());\n<line7>        } catch (MetricsProviderLifeCycleException error) {\n<line8>            throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n<line9>        }\n<line10>        ServerMetrics.metricsProviderInitialized(metricsProvider);\n<line11>        ProviderRegistry.initialize();\n<line12>        // Note that this thread isn't going to be doing anything else,\n<line13>        // so rather than spawning another thread, we will just call\n<line14>        // run() in this thread.\n<line15>        // create a file logger url from the command line args\n<line16>        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);\n<line17>        JvmPauseMonitor jvmPauseMonitor = null;\n<line18>        if (config.jvmPauseMonitorToRun) {\n<line19>            jvmPauseMonitor = new JvmPauseMonitor(config);\n<line20>        }\n<line21>        final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);\n<line22>        txnLog.setServerStats(zkServer.serverStats());\n<line23>        // Registers shutdown handler which will be used to know the\n<line24>        // server error or shutdown state changes.\n<line25>        final CountDownLatch shutdownLatch = new CountDownLatch(1);\n<line26>        zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));\n<line27>        // Start Admin server\n<line28>        adminServer = AdminServerFactory.createAdminServer();\n<line29>        adminServer.setZooKeeperServer(zkServer);\n<line30>        adminServer.start();\n<line31>        boolean needStartZKServer = true;\n<line32>        if (config.getClientPortAddress() != null) {\n<line33>            cnxnFactory = ServerCnxnFactory.createFactory();\n<line34>            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n<line35>            cnxnFactory.startup(zkServer);\n<line36>            // zkServer has been started. So we don't need to start it again in secureCnxnFactory.\n<line37>            needStartZKServer = false;\n<line38>        }\n<line39>        if (config.getSecureClientPortAddress() != null) {\n<line40>            secureCnxnFactory = ServerCnxnFactory.createFactory();\n<line41>            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n<line42>            secureCnxnFactory.startup(zkServer, needStartZKServer);\n<line43>        }\n<line44>        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor, Integer.getInteger(\"znode.container.checkIntervalMs\", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger(\"znode.container.maxPerMinute\", 10000), Long.getLong(\"znode.container.maxNeverUsedIntervalMs\", 0));\n<line45>        containerManager.start();\n<line46>        ZKAuditProvider.addZKStartStopAuditLog();\n<line47>        serverStarted();\n<line48>        // Watch status of ZooKeeper server. It will do a graceful shutdown\n<line49>        // if the server is not running or hits an internal error.\n<line50>        shutdownLatch.await();\n<line51>        shutdown();\n<line52>        if (cnxnFactory != null) {\n<line53>            cnxnFactory.join();\n<line54>        }\n<line55>        if (secureCnxnFactory != null) {\n<line56>            secureCnxnFactory.join();\n<line57>        }\n<line58>        if (zkServer.canShutdown()) {\n<line59>            zkServer.shutdown(true);\n<line60>        }\n<line61>    } catch (InterruptedException e) {\n<line62>        // warn, but generally this is ok\n<line63>        LOG.warn(\"Server interrupted\", e);\n<line64>    } finally {\n<line65>        if (txnLog != null) {\n<line66>            txnLog.close();\n<line67>        }\n<line68>        if (metricsProvider != null) {\n<line69>            try {\n<line70>                metricsProvider.stop();\n<line71>            } catch (Throwable error) {\n<line72>                LOG.warn(\"Error while stopping metrics\", error);\n<line73>            }\n<line74>        }\n<line75>    }\n<line76>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerCnxnFactory primaryCnxnFactory = this.cnxnFactory;\n<line3>    ServerCnxnFactory secondaryCnxnFactory = this.secureCnxnFactory;\n<line4>    try {\n<line5>        if (primaryCnxnFactory == null) {\n<line6>            // in case of pure TLS we can hook into secureCnxnFactory\n<line7>            primaryCnxnFactory = secondaryCnxnFactory;\n<line8>        }\n<line9>        if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {\n<line10>            return;\n<line11>        }\n<line12>        ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();\n<line13>        zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);\n<line14>        try {\n<line15>            // ServerCnxnFactory will call the shutdown\n<line16>            primaryCnxnFactory.join();\n<line17>        } catch (InterruptedException ex) {\n<line18>            Thread.currentThread().interrupt();\n<line19>        }\n<line20>    } finally {\n<line21>        // ensure that we are closing the sockets\n<line22>        if (primaryCnxnFactory != null) {\n<line23>            primaryCnxnFactory.shutdown();\n<line24>        }\n<line25>        if (secondaryCnxnFactory != null) {\n<line26>            secondaryCnxnFactory.shutdown();\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    ServerCnxnFactory primaryCnxnFactory = this.cnxnFactory;\n<line3>    ServerCnxnFactory secondaryCnxnFactory = this.secureCnxnFactory;\n<line4>    try {\n<line5>        if (primaryCnxnFactory == null) {\n<line6>            // in case of pure TLS we can hook into secureCnxnFactory\n<line7>            primaryCnxnFactory = secondaryCnxnFactory;\n<line8>        }\n<line9>        if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {\n<line10>            LOG.info(\"Connection factory did not start\");\n<line11>            return;\n<line12>        }\n<line13>        ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();\n<line14>        zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);\n<line15>        try {\n<line16>            // ServerCnxnFactory will call the shutdown\n<line17>            primaryCnxnFactory.join();\n<line18>        } catch (InterruptedException ex) {\n<line19>            Thread.currentThread().interrupt();\n<line20>        }\n<line21>    } finally {\n<line22>        // ensure that we are closing the sockets\n<line23>        if (primaryCnxnFactory != null) {\n<line24>            primaryCnxnFactory.shutdown();\n<line25>        }\n<line26>        if (secondaryCnxnFactory != null) {\n<line27>            secondaryCnxnFactory.shutdown();\n<line28>        }\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    if (primaryCnxnFactory == null) {\n<line3>        // in case of pure TLS we can hook into secureCnxnFactory\n<line4>        primaryCnxnFactory = secondaryCnxnFactory;\n<line5>    }\n<line6>    if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {\n<line7>        return;\n<line8>    }\n<line9>    ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();\n<line10>    zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);\n<line11>    try {\n<line12>        // ServerCnxnFactory will call the shutdown\n<line13>        primaryCnxnFactory.join();\n<line14>    } catch (InterruptedException ex) {\n<line15>        Thread.currentThread().interrupt();\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    if (primaryCnxnFactory == null) {\n<line3>        // in case of pure TLS we can hook into secureCnxnFactory\n<line4>        primaryCnxnFactory = secondaryCnxnFactory;\n<line5>    }\n<line6>    if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {\n<line7>        LOG.info(\"Connection factory did not start\");\n<line8>        return;\n<line9>    }\n<line10>    ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();\n<line11>    zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);\n<line12>    try {\n<line13>        // ServerCnxnFactory will call the shutdown\n<line14>        primaryCnxnFactory.join();\n<line15>    } catch (InterruptedException ex) {\n<line16>        Thread.currentThread().interrupt();\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Connection factory did not start\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.config = config;\n<line3>    run();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Starting quorum peer from peer config\");\n<line3>    this.config = config;\n<line4>    run();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        initService();\n<line4>    } catch (Exception ex) {\n<line5>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line6>    }\n<line7>    runServices();\n<line8>    cleanup();\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        initService();\n<line4>    } catch (Exception ex) {\n<line5>        LOG.error(\"Failed to start ControllerService.\", ex);\n<line6>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line7>    }\n<line8>    runServices();\n<line9>    cleanup();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to start ControllerService.\", ex);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        quorumPeer.start();\n<line4>        quorumPeer.join();\n<line5>    } catch (Exception ex) {\n<line6>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        quorumPeer.start();\n<line4>        quorumPeer.join();\n<line5>    } catch (Exception ex) {\n<line6>        LOG.error(\"Fatal error starting quorum peer\", ex);\n<line7>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Fatal error starting quorum peer\", ex);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (command == null) {\n<line3>        throw new IllegalArgumentException(\"Invalid command parameter!\");\n<line4>    }\n<line5>    // Don't process command if we are shutting down or still initializing.\n<line6>    if (!isReady()) {\n<line7>        throw new IllegalStateException(\"Service is not ready. It has already been shutdown or is still initializing.\");\n<line8>    }\n<line9>    switch(command.getAction()) {\n<line10>        case PING:\n<line11>            // NO-OP\n<line12>            break;\n<line13>        case SHUTDOWN:\n<line14>            shutdown();\n<line15>            break;\n<line16>        case CLOSECONNECTION:\n<line17>            if (command.getParameter() == null) {\n<line18>                cnxnFactory.closeAll(ServerCnxn.DisconnectReason.CLOSE_ALL_CONNECTIONS_FORCED);\n<line19>            } else {\n<line20>                // A single parameter should be a session id as long.\n<line21>                // Parse failure exceptions will be sent to the caller.\n<line22>                cnxnFactory.closeSession(Long.decode(command.getParameter()), ServerCnxn.DisconnectReason.CONNECTION_CLOSE_FORCED);\n<line23>            }\n<line24>            break;\n<line25>        case EXPIRESESSION:\n<line26>            if (command.getParameter() == null) {\n<line27>                expireAllSessions();\n<line28>            } else {\n<line29>                // A single parameter should be a session id as long.\n<line30>                // Parse failure exceptions will be sent to the caller\n<line31>                expireSession(Long.decode(command.getParameter()));\n<line32>            }\n<line33>            break;\n<line34>        case REJECTCONNECTIONS:\n<line35>            // TODO: (hanm) implement once dependent feature is ready.\n<line36>            //cnxnFactory.rejectNewConnections();\n<line37>            break;\n<line38>        case ADDDELAY:\n<line39>            cnxnFactory.delayResponses(command.getParameter() == null ? DEFAULT_DELAY_MS : Long.decode(command.getParameter()));\n<line40>            break;\n<line41>        case NORESPONSE:\n<line42>            if (command.getParameter() == null) {\n<line43>                cnxnFactory.holdAllFutureResponses();\n<line44>            } else {\n<line45>                cnxnFactory.holdFutureResponses(Long.decode(command.getParameter()));\n<line46>            }\n<line47>            break;\n<line48>        case FAILREQUESTS:\n<line49>            if (command.getParameter() == null) {\n<line50>                cnxnFactory.failAllFutureRequests();\n<line51>            } else {\n<line52>                cnxnFactory.failFutureRequests(Long.decode(command.getParameter()));\n<line53>            }\n<line54>            break;\n<line55>        case RESET:\n<line56>            cnxnFactory.resetBadBehavior();\n<line57>            break;\n<line58>        case ELECTNEWLEADER:\n<line59>            quorumPeer.startLeaderElection();\n<line60>            break;\n<line61>        default:\n<line62>            throw new IllegalArgumentException(\"Unknown command: \" + command);\n<line63>    }\n<line64>}","output":"<line1>{\n<line2>    if (command == null) {\n<line3>        throw new IllegalArgumentException(\"Invalid command parameter!\");\n<line4>    }\n<line5>    LOG.info(\"processing command {}{}\", command.getAction(), command.getParameter() == null ? \"\" : \"[\" + command.getParameter() + \"]\");\n<line6>    // Don't process command if we are shutting down or still initializing.\n<line7>    if (!isReady()) {\n<line8>        throw new IllegalStateException(\"Service is not ready. It has already been shutdown or is still initializing.\");\n<line9>    }\n<line10>    switch(command.getAction()) {\n<line11>        case PING:\n<line12>            // NO-OP\n<line13>            break;\n<line14>        case SHUTDOWN:\n<line15>            shutdown();\n<line16>            break;\n<line17>        case CLOSECONNECTION:\n<line18>            if (command.getParameter() == null) {\n<line19>                cnxnFactory.closeAll(ServerCnxn.DisconnectReason.CLOSE_ALL_CONNECTIONS_FORCED);\n<line20>            } else {\n<line21>                // A single parameter should be a session id as long.\n<line22>                // Parse failure exceptions will be sent to the caller.\n<line23>                cnxnFactory.closeSession(Long.decode(command.getParameter()), ServerCnxn.DisconnectReason.CONNECTION_CLOSE_FORCED);\n<line24>            }\n<line25>            break;\n<line26>        case EXPIRESESSION:\n<line27>            if (command.getParameter() == null) {\n<line28>                expireAllSessions();\n<line29>            } else {\n<line30>                // A single parameter should be a session id as long.\n<line31>                // Parse failure exceptions will be sent to the caller\n<line32>                expireSession(Long.decode(command.getParameter()));\n<line33>            }\n<line34>            break;\n<line35>        case REJECTCONNECTIONS:\n<line36>            // TODO: (hanm) implement once dependent feature is ready.\n<line37>            //cnxnFactory.rejectNewConnections();\n<line38>            break;\n<line39>        case ADDDELAY:\n<line40>            cnxnFactory.delayResponses(command.getParameter() == null ? DEFAULT_DELAY_MS : Long.decode(command.getParameter()));\n<line41>            break;\n<line42>        case NORESPONSE:\n<line43>            if (command.getParameter() == null) {\n<line44>                cnxnFactory.holdAllFutureResponses();\n<line45>            } else {\n<line46>                cnxnFactory.holdFutureResponses(Long.decode(command.getParameter()));\n<line47>            }\n<line48>            break;\n<line49>        case FAILREQUESTS:\n<line50>            if (command.getParameter() == null) {\n<line51>                cnxnFactory.failAllFutureRequests();\n<line52>            } else {\n<line53>                cnxnFactory.failFutureRequests(Long.decode(command.getParameter()));\n<line54>            }\n<line55>            break;\n<line56>        case RESET:\n<line57>            cnxnFactory.resetBadBehavior();\n<line58>            break;\n<line59>        case ELECTNEWLEADER:\n<line60>            quorumPeer.startLeaderElection();\n<line61>            break;\n<line62>        default:\n<line63>            throw new IllegalArgumentException(\"Unknown command: \" + command);\n<line64>    }\n<line65>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!started) {\n<line4>            client.start();\n<line5>            started = true;\n<line6>        }\n<line7>        ContentResponse response = sendCommand(action, commandParameter);\n<line8>        return (response.getStatus() == 200);\n<line9>    } catch (InterruptedException | IOException ex) {\n<line10>    } catch (Exception ex) {\n<line11>    }\n<line12>    return false;\n<line13>}","output":"<line1>{\n<line2>    try {\n<line3>        if (!started) {\n<line4>            client.start();\n<line5>            started = true;\n<line6>        }\n<line7>        ContentResponse response = sendCommand(action, commandParameter);\n<line8>        LOG.info(\"Received {} response from the server\", response);\n<line9>        return (response.getStatus() == 200);\n<line10>    } catch (InterruptedException | IOException ex) {\n<line11>        LOG.warn(\"Failed to get response from server\", ex);\n<line12>    } catch (Exception ex) {\n<line13>        LOG.error(\"Unknown exception when sending command\", ex);\n<line14>    }\n<line15>    return false;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!started) {\n<line3>        client.start();\n<line4>        started = true;\n<line5>    }\n<line6>    ContentResponse response = sendCommand(action, commandParameter);\n<line7>    return (response.getStatus() == 200);\n<line8>}","output":"<line1>{\n<line2>    if (!started) {\n<line3>        client.start();\n<line4>        started = true;\n<line5>    }\n<line6>    ContentResponse response = sendCommand(action, commandParameter);\n<line7>    LOG.info(\"Received {} response from the server\", response);\n<line8>    return (response.getStatus() == 200);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unknown exception when sending command\", ex);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String command = String.format(\"%s%s:%s/%s\", \"http://\", this.hostName, this.hostPort, ControlCommand.createCommandUri(action, commandParameter));\n<line3>    ContentResponse response = this.client.newRequest(command).timeout(this.requestTimeoutInMs, TimeUnit.MILLISECONDS).send();\n<line4>    return response;\n<line5>}","output":"<line1>{\n<line2>    String command = String.format(\"%s%s:%s/%s\", \"http://\", this.hostName, this.hostPort, ControlCommand.createCommandUri(action, commandParameter));\n<line3>    ContentResponse response = this.client.newRequest(command).timeout(this.requestTimeoutInMs, TimeUnit.MILLISECONDS).send();\n<line4>    LOG.info(\"Sent command {}\", command);\n<line5>    LOG.info(\"Response body {}\", new String(response.getContent(), StandardCharsets.UTF_8));\n<line6>    return response;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        this.controller = controller;\n<line4>        String host = config.getControllerAddress().getHostName();\n<line5>        int port = config.getControllerAddress().getPort();\n<line6>        server = new Server(port);\n<line7>        server.setHandler(new CommandHandler());\n<line8>        server.start();\n<line9>    } catch (Exception ex) {\n<line10>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        this.controller = controller;\n<line4>        String host = config.getControllerAddress().getHostName();\n<line5>        int port = config.getControllerAddress().getPort();\n<line6>        server = new Server(port);\n<line7>        LOG.info(\"CommandListener server host: {} with port: {}\", host, port);\n<line8>        server.setHandler(new CommandHandler());\n<line9>        server.start();\n<line10>    } catch (Exception ex) {\n<line11>        LOG.error(\"Failed to instantiate CommandListener.\", ex);\n<line12>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    this.controller = controller;\n<line3>    String host = config.getControllerAddress().getHostName();\n<line4>    int port = config.getControllerAddress().getPort();\n<line5>    server = new Server(port);\n<line6>    server.setHandler(new CommandHandler());\n<line7>    server.start();\n<line8>}","output":"<line1>{\n<line2>    this.controller = controller;\n<line3>    String host = config.getControllerAddress().getHostName();\n<line4>    int port = config.getControllerAddress().getPort();\n<line5>    server = new Server(port);\n<line6>    LOG.info(\"CommandListener server host: {} with port: {}\", host, port);\n<line7>    server.setHandler(new CommandHandler());\n<line8>    server.start();\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to instantiate CommandListener.\", ex);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Extract command string from request path. Remove leading '/'.\n<line3>    String commandStr = request.getPathInfo().substring(1);\n<line4>    int responseCode;\n<line5>    response.setContentType(\"text/html;charset=utf-8\");\n<line6>    try {\n<line7>        ControlCommand command = ControlCommand.parseUri(commandStr);\n<line8>        controller.processCommand(command);\n<line9>        baseRequest.setHandled(true);\n<line10>        responseCode = HttpServletResponse.SC_OK;\n<line11>    } catch (IllegalArgumentException ex) {\n<line12>        responseCode = HttpServletResponse.SC_BAD_REQUEST;\n<line13>    } catch (Exception ex) {\n<line14>        throw ex;\n<line15>    }\n<line16>    response.setStatus(responseCode);\n<line17>    response.getWriter().println(commandStr);\n<line18>}","output":"<line1>{\n<line2>    // Extract command string from request path. Remove leading '/'.\n<line3>    String commandStr = request.getPathInfo().substring(1);\n<line4>    int responseCode;\n<line5>    response.setContentType(\"text/html;charset=utf-8\");\n<line6>    try {\n<line7>        ControlCommand command = ControlCommand.parseUri(commandStr);\n<line8>        controller.processCommand(command);\n<line9>        baseRequest.setHandled(true);\n<line10>        responseCode = HttpServletResponse.SC_OK;\n<line11>    } catch (IllegalArgumentException ex) {\n<line12>        LOG.error(\"Bad argument or command\", ex);\n<line13>        responseCode = HttpServletResponse.SC_BAD_REQUEST;\n<line14>    } catch (Exception ex) {\n<line15>        LOG.error(\"Failed processing the request\", ex);\n<line16>        throw ex;\n<line17>    }\n<line18>    response.setStatus(responseCode);\n<line19>    response.getWriter().println(commandStr);\n<line20>    LOG.info(\"CommandListener processed command {} with response code {}\", commandStr, responseCode);\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    responseCode = HttpServletResponse.SC_BAD_REQUEST;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Bad argument or command\", ex);\n<line3>    responseCode = HttpServletResponse.SC_BAD_REQUEST;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throw ex;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed processing the request\", ex);\n<line3>    throw ex;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (connectionWeightEnabled) {\n<line3>    } else {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (connectionWeightEnabled) {\n<line3>        LOG.info(\"Weighed connection throttling is enabled. \" + \"But it will only be effective if connection throttling is enabled\");\n<line4>        LOG.info(\"The weights for different session types are: global {} renew {} local {}\", DEFAULT_GLOBAL_SESSION_WEIGHT, DEFAULT_RENEW_SESSION_WEIGHT, DEFAULT_LOCAL_SESSION_WEIGHT);\n<line5>    } else {\n<line6>        LOG.info(\"Weighed connection throttling is disabled\");\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Weighed connection throttling is enabled. \" + \"But it will only be effective if connection throttling is enabled\");\n<line3>    LOG.info(\"The weights for different session types are: global {} renew {} local {}\", DEFAULT_GLOBAL_SESSION_WEIGHT, DEFAULT_RENEW_SESSION_WEIGHT, DEFAULT_LOCAL_SESSION_WEIGHT);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Weighed connection throttling is disabled\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    LOG = LoggerFactory.getLogger(ZooKeeperServer.class);\n<line3>    RATE_LOGGER = new RateLogger(LOG);\n<line4>    ZookeeperBanner.printBanner(LOG);\n<line5>    Environment.logEnv(\"Server environment:\", LOG);\n<line6>    enableEagerACLCheck = Boolean.getBoolean(ENABLE_EAGER_ACL_CHECK);\n<line7>    skipACL = System.getProperty(SKIP_ACL, \"no\").equals(\"yes\");\n<line8>    if (skipACL) {\n<line9>    }\n<line10>    enforceQuota = Boolean.parseBoolean(System.getProperty(ENFORCE_QUOTA, \"false\"));\n<line11>    if (enforceQuota) {\n<line12>    }\n<line13>    digestEnabled = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DIGEST_ENABLED, \"true\"));\n<line14>    closeSessionTxnEnabled = Boolean.parseBoolean(System.getProperty(CLOSE_SESSION_TXN_ENABLED, \"true\"));\n<line15>    setSerializeLastProcessedZxidEnabled(Boolean.parseBoolean(System.getProperty(ZOOKEEPER_SERIALIZE_LAST_PROCESSED_ZXID_ENABLED, \"true\")));\n<line16>}","output":"<line1>{\n<line2>    LOG = LoggerFactory.getLogger(ZooKeeperServer.class);\n<line3>    RATE_LOGGER = new RateLogger(LOG);\n<line4>    ZookeeperBanner.printBanner(LOG);\n<line5>    Environment.logEnv(\"Server environment:\", LOG);\n<line6>    enableEagerACLCheck = Boolean.getBoolean(ENABLE_EAGER_ACL_CHECK);\n<line7>    LOG.info(\"{} = {}\", ENABLE_EAGER_ACL_CHECK, enableEagerACLCheck);\n<line8>    skipACL = System.getProperty(SKIP_ACL, \"no\").equals(\"yes\");\n<line9>    if (skipACL) {\n<line10>        LOG.info(\"{}==\\\"yes\\\", ACL checks will be skipped\", SKIP_ACL);\n<line11>    }\n<line12>    enforceQuota = Boolean.parseBoolean(System.getProperty(ENFORCE_QUOTA, \"false\"));\n<line13>    if (enforceQuota) {\n<line14>        LOG.info(\"{} = {}, Quota Enforce enables\", ENFORCE_QUOTA, enforceQuota);\n<line15>    }\n<line16>    digestEnabled = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DIGEST_ENABLED, \"true\"));\n<line17>    LOG.info(\"{} = {}\", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);\n<line18>    closeSessionTxnEnabled = Boolean.parseBoolean(System.getProperty(CLOSE_SESSION_TXN_ENABLED, \"true\"));\n<line19>    LOG.info(\"{} = {}\", CLOSE_SESSION_TXN_ENABLED, closeSessionTxnEnabled);\n<line20>    setSerializeLastProcessedZxidEnabled(Boolean.parseBoolean(System.getProperty(ZOOKEEPER_SERIALIZE_LAST_PROCESSED_ZXID_ENABLED, \"true\")));\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"{}==\\\"yes\\\", ACL checks will be skipped\", SKIP_ACL);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {}, Quota Enforce enables\", ENFORCE_QUOTA, enforceQuota);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperServer.enableEagerACLCheck = enabled;\n<line3>}","output":"<line1>{\n<line2>    ZooKeeperServer.enableEagerACLCheck = enabled;\n<line3>    LOG.info(\"Update {} to {}\", ENABLE_EAGER_ACL_CHECK, enabled);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperServer.closeSessionTxnEnabled = enabled;\n<line3>}","output":"<line1>{\n<line2>    ZooKeeperServer.closeSessionTxnEnabled = enabled;\n<line3>    LOG.info(\"Update {} to {}\", CLOSE_SESSION_TXN_ENABLED, ZooKeeperServer.closeSessionTxnEnabled);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    long configuredFlushDelay = Long.getLong(FLUSH_DELAY, 0);\n<line3>    setFlushDelay(configuredFlushDelay);\n<line4>    setMaxWriteQueuePollTime(Long.getLong(MAX_WRITE_QUEUE_POLL_SIZE, configuredFlushDelay / 3));\n<line5>    setMaxBatchSize(Integer.getInteger(MAX_BATCH_SIZE, 1000));\n<line6>    intBufferStartingSizeBytes = Integer.getInteger(INT_BUFFER_STARTING_SIZE_BYTES, DEFAULT_STARTING_BUFFER_SIZE);\n<line7>    if (intBufferStartingSizeBytes < 32) {\n<line8>        String msg = \"Buffer starting size (\" + intBufferStartingSizeBytes + \") must be greater than or equal to 32. \" + \"Configure with \\\"-Dzookeeper.intBufferStartingSizeBytes=<size>\\\" \";\n<line9>        throw new IllegalArgumentException(msg);\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    long configuredFlushDelay = Long.getLong(FLUSH_DELAY, 0);\n<line3>    setFlushDelay(configuredFlushDelay);\n<line4>    setMaxWriteQueuePollTime(Long.getLong(MAX_WRITE_QUEUE_POLL_SIZE, configuredFlushDelay / 3));\n<line5>    setMaxBatchSize(Integer.getInteger(MAX_BATCH_SIZE, 1000));\n<line6>    intBufferStartingSizeBytes = Integer.getInteger(INT_BUFFER_STARTING_SIZE_BYTES, DEFAULT_STARTING_BUFFER_SIZE);\n<line7>    if (intBufferStartingSizeBytes < 32) {\n<line8>        String msg = \"Buffer starting size (\" + intBufferStartingSizeBytes + \") must be greater than or equal to 32. \" + \"Configure with \\\"-Dzookeeper.intBufferStartingSizeBytes=<size>\\\" \";\n<line9>        LOG.error(msg);\n<line10>        throw new IllegalArgumentException(msg);\n<line11>    }\n<line12>    LOG.info(\"{} = {}\", INT_BUFFER_STARTING_SIZE_BYTES, intBufferStartingSizeBytes);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Buffer starting size (\" + intBufferStartingSizeBytes + \") must be greater than or equal to 32. \" + \"Configure with \\\"-Dzookeeper.intBufferStartingSizeBytes=<size>\\\" \";\n<line3>    throw new IllegalArgumentException(msg);\n<line4>}","output":"<line1>{\n<line2>    String msg = \"Buffer starting size (\" + intBufferStartingSizeBytes + \") must be greater than or equal to 32. \" + \"Configure with \\\"-Dzookeeper.intBufferStartingSizeBytes=<size>\\\" \";\n<line3>    LOG.error(msg);\n<line4>    throw new IllegalArgumentException(msg);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    serverStats = new ServerStats(this);\n<line3>    this.txnLogFactory = txnLogFactory;\n<line4>    this.txnLogFactory.setServerStats(this.serverStats);\n<line5>    this.zkDb = zkDb;\n<line6>    this.tickTime = tickTime;\n<line7>    setMinSessionTimeout(minSessionTimeout);\n<line8>    setMaxSessionTimeout(maxSessionTimeout);\n<line9>    this.listenBacklog = clientPortListenBacklog;\n<line10>    this.reconfigEnabled = reconfigEnabled;\n<line11>    listener = new ZooKeeperServerListenerImpl(this);\n<line12>    readResponseCache = new ResponseCache(Integer.getInteger(GET_DATA_RESPONSE_CACHE_SIZE, ResponseCache.DEFAULT_RESPONSE_CACHE_SIZE), \"getData\");\n<line13>    getChildrenResponseCache = new ResponseCache(Integer.getInteger(GET_CHILDREN_RESPONSE_CACHE_SIZE, ResponseCache.DEFAULT_RESPONSE_CACHE_SIZE), \"getChildren\");\n<line14>    this.initialConfig = initialConfig;\n<line15>    this.requestPathMetricsCollector = new RequestPathMetricsCollector();\n<line16>    this.initLargeRequestThrottlingSettings();\n<line17>}","output":"<line1>{\n<line2>    serverStats = new ServerStats(this);\n<line3>    this.txnLogFactory = txnLogFactory;\n<line4>    this.txnLogFactory.setServerStats(this.serverStats);\n<line5>    this.zkDb = zkDb;\n<line6>    this.tickTime = tickTime;\n<line7>    setMinSessionTimeout(minSessionTimeout);\n<line8>    setMaxSessionTimeout(maxSessionTimeout);\n<line9>    this.listenBacklog = clientPortListenBacklog;\n<line10>    this.reconfigEnabled = reconfigEnabled;\n<line11>    listener = new ZooKeeperServerListenerImpl(this);\n<line12>    readResponseCache = new ResponseCache(Integer.getInteger(GET_DATA_RESPONSE_CACHE_SIZE, ResponseCache.DEFAULT_RESPONSE_CACHE_SIZE), \"getData\");\n<line13>    getChildrenResponseCache = new ResponseCache(Integer.getInteger(GET_CHILDREN_RESPONSE_CACHE_SIZE, ResponseCache.DEFAULT_RESPONSE_CACHE_SIZE), \"getChildren\");\n<line14>    this.initialConfig = initialConfig;\n<line15>    this.requestPathMetricsCollector = new RequestPathMetricsCollector();\n<line16>    this.initLargeRequestThrottlingSettings();\n<line17>    LOG.info(\"Created server with\" + \" tickTime {} ms\" + \" minSessionTimeout {} ms\" + \" maxSessionTimeout {} ms\" + \" clientPortListenBacklog {}\" + \" dataLogdir {}\" + \" snapdir {}\", tickTime, getMinSessionTimeout(), getMaxSessionTimeout(), getClientPortListenBacklog(), txnLogFactory.getDataLogDir(), txnLogFactory.getSnapDir());\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    this(txnLogFactory, tickTime, minSessionTimeout, maxSessionTimeout, clientPortListenBacklog, zkDb, initialConfig, QuorumPeerConfig.isReconfigEnabled());\n<line3>    this.jvmPauseMonitor = jvmPauseMonitor;\n<line4>    if (jvmPauseMonitor != null) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    this(txnLogFactory, tickTime, minSessionTimeout, maxSessionTimeout, clientPortListenBacklog, zkDb, initialConfig, QuorumPeerConfig.isReconfigEnabled());\n<line3>    this.jvmPauseMonitor = jvmPauseMonitor;\n<line4>    if (jvmPauseMonitor != null) {\n<line5>        LOG.info(\"Added JvmPauseMonitor to server\");\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Added JvmPauseMonitor to server\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    long start = Time.currentElapsedTime();\n<line3>    File snapFile = null;\n<line4>    try {\n<line5>        if (fastForwardFromEdits) {\n<line6>            zkDb.fastForwardDataBase();\n<line7>        }\n<line8>        snapFile = txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), syncSnap);\n<line9>    } catch (IOException e) {\n<line10>        if (isSevere) {\n<line11>            // This is a severe error that we cannot recover from,\n<line12>            // so we need to exit\n<line13>            ServiceUtils.requestSystemExit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());\n<line14>        } else {\n<line15>            throw e;\n<line16>        }\n<line17>    }\n<line18>    long elapsed = Time.currentElapsedTime() - start;\n<line19>    ServerMetrics.getMetrics().SNAPSHOT_TIME.add(elapsed);\n<line20>    return snapFile;\n<line21>}","output":"<line1>{\n<line2>    long start = Time.currentElapsedTime();\n<line3>    File snapFile = null;\n<line4>    try {\n<line5>        if (fastForwardFromEdits) {\n<line6>            zkDb.fastForwardDataBase();\n<line7>        }\n<line8>        snapFile = txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), syncSnap);\n<line9>    } catch (IOException e) {\n<line10>        if (isSevere) {\n<line11>            LOG.error(\"Severe unrecoverable error, exiting\", e);\n<line12>            // This is a severe error that we cannot recover from,\n<line13>            // so we need to exit\n<line14>            ServiceUtils.requestSystemExit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());\n<line15>        } else {\n<line16>            throw e;\n<line17>        }\n<line18>    }\n<line19>    long elapsed = Time.currentElapsedTime() - start;\n<line20>    LOG.info(\"Snapshot taken in {} ms\", elapsed);\n<line21>    ServerMetrics.getMetrics().SNAPSHOT_TIME.add(elapsed);\n<line22>    return snapFile;\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    if (isSevere) {\n<line3>        // This is a severe error that we cannot recover from,\n<line4>        // so we need to exit\n<line5>        ServiceUtils.requestSystemExit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());\n<line6>    } else {\n<line7>        throw e;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (isSevere) {\n<line3>        LOG.error(\"Severe unrecoverable error, exiting\", e);\n<line4>        // This is a severe error that we cannot recover from,\n<line5>        // so we need to exit\n<line6>        ServiceUtils.requestSystemExit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());\n<line7>    } else {\n<line8>        throw e;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    // This is a severe error that we cannot recover from,\n<line3>    // so we need to exit\n<line4>    ServiceUtils.requestSystemExit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Severe unrecoverable error, exiting\", e);\n<line3>    // This is a severe error that we cannot recover from,\n<line4>    // so we need to exit\n<line5>    ServiceUtils.requestSystemExit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (inputStream == null) {\n<line3>        throw new IllegalArgumentException(\"InputStream can not be null when restoring from snapshot\");\n<line4>    }\n<line5>    long start = Time.currentElapsedTime();\n<line6>    // restore to a new zkDatabase\n<line7>    final ZKDatabase newZKDatabase = new ZKDatabase(this.txnLogFactory);\n<line8>    final CheckedInputStream cis = new CheckedInputStream(new BufferedInputStream(inputStream), new Adler32());\n<line9>    final InputArchive ia = BinaryInputArchive.getArchive(cis);\n<line10>    newZKDatabase.deserializeSnapshot(ia, cis);\n<line11>    // create a CountDownLatch\n<line12>    restoreLatch = new CountDownLatch(1);\n<line13>    try {\n<line14>        // set to the new zkDatabase\n<line15>        setZKDatabase(newZKDatabase);\n<line16>        // re-create SessionTrack\n<line17>        createSessionTracker();\n<line18>    } finally {\n<line19>        // unblock request submission\n<line20>        restoreLatch.countDown();\n<line21>        restoreLatch = null;\n<line22>    }\n<line23>    long elapsed = Time.currentElapsedTime() - start;\n<line24>    ServerMetrics.getMetrics().RESTORE_TIME.add(elapsed);\n<line25>    return getLastProcessedZxid();\n<line26>}","output":"<line1>{\n<line2>    if (inputStream == null) {\n<line3>        throw new IllegalArgumentException(\"InputStream can not be null when restoring from snapshot\");\n<line4>    }\n<line5>    long start = Time.currentElapsedTime();\n<line6>    LOG.info(\"Before restore database. lastProcessedZxid={}, nodeCount={}sessionCount={}\", getZKDatabase().getDataTreeLastProcessedZxid(), getZKDatabase().dataTree.getNodeCount(), getZKDatabase().getSessionCount());\n<line7>    // restore to a new zkDatabase\n<line8>    final ZKDatabase newZKDatabase = new ZKDatabase(this.txnLogFactory);\n<line9>    final CheckedInputStream cis = new CheckedInputStream(new BufferedInputStream(inputStream), new Adler32());\n<line10>    final InputArchive ia = BinaryInputArchive.getArchive(cis);\n<line11>    newZKDatabase.deserializeSnapshot(ia, cis);\n<line12>    LOG.info(\"Restored to a new database. lastProcessedZxid={}, nodeCount={}, sessionCount={}\", newZKDatabase.getDataTreeLastProcessedZxid(), newZKDatabase.dataTree.getNodeCount(), newZKDatabase.getSessionCount());\n<line13>    // create a CountDownLatch\n<line14>    restoreLatch = new CountDownLatch(1);\n<line15>    try {\n<line16>        // set to the new zkDatabase\n<line17>        setZKDatabase(newZKDatabase);\n<line18>        // re-create SessionTrack\n<line19>        createSessionTracker();\n<line20>    } finally {\n<line21>        // unblock request submission\n<line22>        restoreLatch.countDown();\n<line23>        restoreLatch = null;\n<line24>    }\n<line25>    LOG.info(\"After restore database. lastProcessedZxid={}, nodeCount={}, sessionCount={}\", getZKDatabase().getDataTreeLastProcessedZxid(), getZKDatabase().dataTree.getNodeCount(), getZKDatabase().getSessionCount());\n<line26>    long elapsed = Time.currentElapsedTime() - start;\n<line27>    LOG.info(\"Restore taken in {} ms\", elapsed);\n<line28>    ServerMetrics.getMetrics().RESTORE_TIME.add(elapsed);\n<line29>    return getLastProcessedZxid();\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    // we do not want to wait for a session close. send it as soon as we\n<line3>    // detect it!\n<line4>    close(sessionId);\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Closing session 0x{}\", Long.toHexString(sessionId));\n<line3>    // we do not want to wait for a session close. send it as soon as we\n<line4>    // detect it!\n<line5>    close(sessionId);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    long sessionId = session.getSessionId();\n<line3>    close(sessionId);\n<line4>}","output":"<line1>{\n<line2>    long sessionId = session.getSessionId();\n<line3>    LOG.info(\"Expiring session 0x{}, timeout of {}ms exceeded\", Long.toHexString(sessionId), session.getTimeout());\n<line4>    close(sessionId);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    close(sessionId);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"forcibly expiring session 0x{}\", Long.toHexString(sessionId));\n<line3>    close(sessionId);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.state = state;\n<line3>    // Notify server state changes to the registered shutdown handler, if any.\n<line4>    if (zkShutdownHandler != null) {\n<line5>        zkShutdownHandler.handle(state);\n<line6>    } else {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    this.state = state;\n<line3>    // Notify server state changes to the registered shutdown handler, if any.\n<line4>    if (zkShutdownHandler != null) {\n<line5>        zkShutdownHandler.handle(state);\n<line6>    } else {\n<line7>        LOG.debug(\"ZKShutdownHandler is not registered, so ZooKeeper server\" + \" won't take any action on ERROR or SHUTDOWN server state changes\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ZKShutdownHandler is not registered, so ZooKeeper server\" + \" won't take any action on ERROR or SHUTDOWN server state changes\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        if (fullyShutDown && zkDb != null) {\n<line4>            zkDb.clear();\n<line5>        }\n<line6>        return;\n<line7>    }\n<line8>    // new RuntimeException(\"Calling shutdown\").printStackTrace();\n<line9>    setState(State.SHUTDOWN);\n<line10>    // unregister all metrics that are keeping a strong reference to this object\n<line11>    // subclasses will do their specific clean up\n<line12>    unregisterMetrics();\n<line13>    if (requestThrottler != null) {\n<line14>        requestThrottler.shutdown();\n<line15>    }\n<line16>    // Since sessionTracker and syncThreads poll we just have to\n<line17>    // set running to false and they will detect it during the poll\n<line18>    // interval.\n<line19>    if (sessionTracker != null) {\n<line20>        sessionTracker.shutdown();\n<line21>    }\n<line22>    if (firstProcessor != null) {\n<line23>        firstProcessor.shutdown();\n<line24>    }\n<line25>    if (jvmPauseMonitor != null) {\n<line26>        jvmPauseMonitor.serviceStop();\n<line27>    }\n<line28>    if (zkDb != null) {\n<line29>        if (fullyShutDown) {\n<line30>            zkDb.clear();\n<line31>        } else {\n<line32>            // else there is no need to clear the database\n<line33>            //  * When a new quorum is established we can still apply the diff\n<line34>            //    on top of the same zkDb data\n<line35>            //  * If we fetch a new snapshot from leader, the zkDb will be\n<line36>            //    cleared anyway before loading the snapshot\n<line37>            try {\n<line38>                //This will fast forward the database to the latest recorded transactions\n<line39>                zkDb.fastForwardDataBase();\n<line40>            } catch (IOException e) {\n<line41>                zkDb.clear();\n<line42>            }\n<line43>        }\n<line44>    }\n<line45>    requestPathMetricsCollector.shutdown();\n<line46>    unregisterJMX();\n<line47>}","output":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        if (fullyShutDown && zkDb != null) {\n<line4>            zkDb.clear();\n<line5>        }\n<line6>        LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line7>        return;\n<line8>    }\n<line9>    LOG.info(\"shutting down\");\n<line10>    // new RuntimeException(\"Calling shutdown\").printStackTrace();\n<line11>    setState(State.SHUTDOWN);\n<line12>    // unregister all metrics that are keeping a strong reference to this object\n<line13>    // subclasses will do their specific clean up\n<line14>    unregisterMetrics();\n<line15>    if (requestThrottler != null) {\n<line16>        requestThrottler.shutdown();\n<line17>    }\n<line18>    // Since sessionTracker and syncThreads poll we just have to\n<line19>    // set running to false and they will detect it during the poll\n<line20>    // interval.\n<line21>    if (sessionTracker != null) {\n<line22>        sessionTracker.shutdown();\n<line23>    }\n<line24>    if (firstProcessor != null) {\n<line25>        firstProcessor.shutdown();\n<line26>    }\n<line27>    if (jvmPauseMonitor != null) {\n<line28>        jvmPauseMonitor.serviceStop();\n<line29>    }\n<line30>    if (zkDb != null) {\n<line31>        if (fullyShutDown) {\n<line32>            zkDb.clear();\n<line33>        } else {\n<line34>            // else there is no need to clear the database\n<line35>            //  * When a new quorum is established we can still apply the diff\n<line36>            //    on top of the same zkDb data\n<line37>            //  * If we fetch a new snapshot from leader, the zkDb will be\n<line38>            //    cleared anyway before loading the snapshot\n<line39>            try {\n<line40>                //This will fast forward the database to the latest recorded transactions\n<line41>                zkDb.fastForwardDataBase();\n<line42>            } catch (IOException e) {\n<line43>                LOG.error(\"Error updating DB\", e);\n<line44>                zkDb.clear();\n<line45>            }\n<line46>        }\n<line47>    }\n<line48>    requestPathMetricsCollector.shutdown();\n<line49>    unregisterJMX();\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>    if (fullyShutDown && zkDb != null) {\n<line3>        zkDb.clear();\n<line4>    }\n<line5>    return;\n<line6>}","output":"<line1>{\n<line2>    if (fullyShutDown && zkDb != null) {\n<line3>        zkDb.clear();\n<line4>    }\n<line5>    LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line6>    return;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (fullyShutDown) {\n<line3>        zkDb.clear();\n<line4>    } else {\n<line5>        // else there is no need to clear the database\n<line6>        //  * When a new quorum is established we can still apply the diff\n<line7>        //    on top of the same zkDb data\n<line8>        //  * If we fetch a new snapshot from leader, the zkDb will be\n<line9>        //    cleared anyway before loading the snapshot\n<line10>        try {\n<line11>            //This will fast forward the database to the latest recorded transactions\n<line12>            zkDb.fastForwardDataBase();\n<line13>        } catch (IOException e) {\n<line14>            zkDb.clear();\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    if (fullyShutDown) {\n<line3>        zkDb.clear();\n<line4>    } else {\n<line5>        // else there is no need to clear the database\n<line6>        //  * When a new quorum is established we can still apply the diff\n<line7>        //    on top of the same zkDb data\n<line8>        //  * If we fetch a new snapshot from leader, the zkDb will be\n<line9>        //    cleared anyway before loading the snapshot\n<line10>        try {\n<line11>            //This will fast forward the database to the latest recorded transactions\n<line12>            zkDb.fastForwardDataBase();\n<line13>        } catch (IOException e) {\n<line14>            LOG.error(\"Error updating DB\", e);\n<line15>            zkDb.clear();\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    // else there is no need to clear the database\n<line3>    //  * When a new quorum is established we can still apply the diff\n<line4>    //    on top of the same zkDb data\n<line5>    //  * If we fetch a new snapshot from leader, the zkDb will be\n<line6>    //    cleared anyway before loading the snapshot\n<line7>    try {\n<line8>        //This will fast forward the database to the latest recorded transactions\n<line9>        zkDb.fastForwardDataBase();\n<line10>    } catch (IOException e) {\n<line11>        zkDb.clear();\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    // else there is no need to clear the database\n<line3>    //  * When a new quorum is established we can still apply the diff\n<line4>    //    on top of the same zkDb data\n<line5>    //  * If we fetch a new snapshot from leader, the zkDb will be\n<line6>    //    cleared anyway before loading the snapshot\n<line7>    try {\n<line8>        //This will fast forward the database to the latest recorded transactions\n<line9>        zkDb.fastForwardDataBase();\n<line10>    } catch (IOException e) {\n<line11>        LOG.error(\"Error updating DB\", e);\n<line12>        zkDb.clear();\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    zkDb.clear();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error updating DB\", e);\n<line3>    zkDb.clear();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // register with JMX\n<line3>    try {\n<line4>        if (valid) {\n<line5>            if (serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn)) {\n<line6>                serverCnxnFactory.registerConnection(cnxn);\n<line7>            } else if (secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn)) {\n<line8>                secureServerCnxnFactory.registerConnection(cnxn);\n<line9>            }\n<line10>        }\n<line11>    } catch (Exception e) {\n<line12>    }\n<line13>    try {\n<line14>        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0, // send 0 if session is no\n<line15>        valid ? cnxn.getSessionId() : 0, // longer valid\n<line16>        valid ? generatePasswd(cnxn.getSessionId()) : new byte[16], this instanceof ReadOnlyZooKeeperServer);\n<line17>        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line18>        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);\n<line19>        bos.writeInt(-1, \"len\");\n<line20>        rsp.serialize(bos, \"connect\");\n<line21>        baos.close();\n<line22>        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line23>        bb.putInt(bb.remaining() - 4).rewind();\n<line24>        cnxn.sendBuffer(bb);\n<line25>        if (valid) {\n<line26>            cnxn.enableRecv();\n<line27>        } else {\n<line28>            cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line29>        }\n<line30>    } catch (Exception e) {\n<line31>        cnxn.close(ServerCnxn.DisconnectReason.IO_EXCEPTION_IN_SESSION_INIT);\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    // register with JMX\n<line3>    try {\n<line4>        if (valid) {\n<line5>            if (serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn)) {\n<line6>                serverCnxnFactory.registerConnection(cnxn);\n<line7>            } else if (secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn)) {\n<line8>                secureServerCnxnFactory.registerConnection(cnxn);\n<line9>            }\n<line10>        }\n<line11>    } catch (Exception e) {\n<line12>        LOG.warn(\"Failed to register with JMX\", e);\n<line13>    }\n<line14>    try {\n<line15>        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0, // send 0 if session is no\n<line16>        valid ? cnxn.getSessionId() : 0, // longer valid\n<line17>        valid ? generatePasswd(cnxn.getSessionId()) : new byte[16], this instanceof ReadOnlyZooKeeperServer);\n<line18>        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line19>        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);\n<line20>        bos.writeInt(-1, \"len\");\n<line21>        rsp.serialize(bos, \"connect\");\n<line22>        baos.close();\n<line23>        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line24>        bb.putInt(bb.remaining() - 4).rewind();\n<line25>        cnxn.sendBuffer(bb);\n<line26>        if (valid) {\n<line27>            LOG.debug(\"Established session 0x{} with negotiated timeout {} for client {}\", Long.toHexString(cnxn.getSessionId()), cnxn.getSessionTimeout(), cnxn.getRemoteSocketAddress());\n<line28>            cnxn.enableRecv();\n<line29>        } else {\n<line30>            LOG.info(\"Invalid session 0x{} for client {}, probably expired\", Long.toHexString(cnxn.getSessionId()), cnxn.getRemoteSocketAddress());\n<line31>            cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line32>        }\n<line33>    } catch (Exception e) {\n<line34>        LOG.warn(\"Exception while establishing session, closing\", e);\n<line35>        cnxn.close(ServerCnxn.DisconnectReason.IO_EXCEPTION_IN_SESSION_INIT);\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0, // send 0 if session is no\n<line3>    valid ? cnxn.getSessionId() : 0, // longer valid\n<line4>    valid ? generatePasswd(cnxn.getSessionId()) : new byte[16], this instanceof ReadOnlyZooKeeperServer);\n<line5>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line6>    BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);\n<line7>    bos.writeInt(-1, \"len\");\n<line8>    rsp.serialize(bos, \"connect\");\n<line9>    baos.close();\n<line10>    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line11>    bb.putInt(bb.remaining() - 4).rewind();\n<line12>    cnxn.sendBuffer(bb);\n<line13>    if (valid) {\n<line14>        cnxn.enableRecv();\n<line15>    } else {\n<line16>        cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0, // send 0 if session is no\n<line3>    valid ? cnxn.getSessionId() : 0, // longer valid\n<line4>    valid ? generatePasswd(cnxn.getSessionId()) : new byte[16], this instanceof ReadOnlyZooKeeperServer);\n<line5>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line6>    BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);\n<line7>    bos.writeInt(-1, \"len\");\n<line8>    rsp.serialize(bos, \"connect\");\n<line9>    baos.close();\n<line10>    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line11>    bb.putInt(bb.remaining() - 4).rewind();\n<line12>    cnxn.sendBuffer(bb);\n<line13>    if (valid) {\n<line14>        LOG.debug(\"Established session 0x{} with negotiated timeout {} for client {}\", Long.toHexString(cnxn.getSessionId()), cnxn.getSessionTimeout(), cnxn.getRemoteSocketAddress());\n<line15>        cnxn.enableRecv();\n<line16>    } else {\n<line17>        LOG.info(\"Invalid session 0x{} for client {}, probably expired\", Long.toHexString(cnxn.getSessionId()), cnxn.getRemoteSocketAddress());\n<line18>        cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    cnxn.enableRecv();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Established session 0x{} with negotiated timeout {} for client {}\", Long.toHexString(cnxn.getSessionId()), cnxn.getSessionTimeout(), cnxn.getRemoteSocketAddress());\n<line3>    cnxn.enableRecv();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Invalid session 0x{} for client {}, probably expired\", Long.toHexString(cnxn.getSessionId()), cnxn.getRemoteSocketAddress());\n<line3>    cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (restoreLatch != null) {\n<line3>        try {\n<line4>            restoreLatch.await();\n<line5>        } catch (final InterruptedException e) {\n<line6>        }\n<line7>    }\n<line8>    enqueueRequest(si);\n<line9>}","output":"<line1>{\n<line2>    if (restoreLatch != null) {\n<line3>        try {\n<line4>            LOG.info(\"Blocking request submission while restore is in progress\");\n<line5>            restoreLatch.await();\n<line6>        } catch (final InterruptedException e) {\n<line7>            LOG.warn(\"Unexpected interruption\", e);\n<line8>        }\n<line9>    }\n<line10>    enqueueRequest(si);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        restoreLatch.await();\n<line4>    } catch (final InterruptedException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"Blocking request submission while restore is in progress\");\n<line4>        restoreLatch.await();\n<line5>    } catch (final InterruptedException e) {\n<line6>        LOG.warn(\"Unexpected interruption\", e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    restoreLatch.await();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Blocking request submission while restore is in progress\");\n<line3>    restoreLatch.await();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (firstProcessor == null) {\n<line3>        synchronized (this) {\n<line4>            try {\n<line5>                // Since all requests are passed to the request\n<line6>                // processor it should wait for setting up the request\n<line7>                // processor chain. The state will be updated to RUNNING\n<line8>                // after the setup.\n<line9>                while (state == State.INITIAL) {\n<line10>                    wait(1000);\n<line11>                }\n<line12>            } catch (InterruptedException e) {\n<line13>            }\n<line14>            if (firstProcessor == null || state != State.RUNNING) {\n<line15>                throw new RuntimeException(\"Not started\");\n<line16>            }\n<line17>        }\n<line18>    }\n<line19>    try {\n<line20>        touch(si.cnxn);\n<line21>        boolean validpacket = Request.isValid(si.type);\n<line22>        if (validpacket) {\n<line23>            setLocalSessionFlag(si);\n<line24>            firstProcessor.processRequest(si);\n<line25>            if (si.cnxn != null) {\n<line26>                incInProcess();\n<line27>            }\n<line28>        } else {\n<line29>            // Update request accounting/throttling limits\n<line30>            requestFinished(si);\n<line31>            new UnimplementedRequestProcessor().processRequest(si);\n<line32>        }\n<line33>    } catch (MissingSessionException e) {\n<line34>        // Update request accounting/throttling limits\n<line35>        requestFinished(si);\n<line36>    } catch (RequestProcessorException e) {\n<line37>        // Update request accounting/throttling limits\n<line38>        requestFinished(si);\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    if (firstProcessor == null) {\n<line3>        synchronized (this) {\n<line4>            try {\n<line5>                // Since all requests are passed to the request\n<line6>                // processor it should wait for setting up the request\n<line7>                // processor chain. The state will be updated to RUNNING\n<line8>                // after the setup.\n<line9>                while (state == State.INITIAL) {\n<line10>                    wait(1000);\n<line11>                }\n<line12>            } catch (InterruptedException e) {\n<line13>                LOG.warn(\"Unexpected interruption\", e);\n<line14>            }\n<line15>            if (firstProcessor == null || state != State.RUNNING) {\n<line16>                throw new RuntimeException(\"Not started\");\n<line17>            }\n<line18>        }\n<line19>    }\n<line20>    try {\n<line21>        touch(si.cnxn);\n<line22>        boolean validpacket = Request.isValid(si.type);\n<line23>        if (validpacket) {\n<line24>            setLocalSessionFlag(si);\n<line25>            firstProcessor.processRequest(si);\n<line26>            if (si.cnxn != null) {\n<line27>                incInProcess();\n<line28>            }\n<line29>        } else {\n<line30>            LOG.warn(\"Received packet at server of unknown type {}\", si.type);\n<line31>            // Update request accounting/throttling limits\n<line32>            requestFinished(si);\n<line33>            new UnimplementedRequestProcessor().processRequest(si);\n<line34>        }\n<line35>    } catch (MissingSessionException e) {\n<line36>        LOG.debug(\"Dropping request.\", e);\n<line37>        // Update request accounting/throttling limits\n<line38>        requestFinished(si);\n<line39>    } catch (RequestProcessorException e) {\n<line40>        LOG.error(\"Unable to process request\", e);\n<line41>        // Update request accounting/throttling limits\n<line42>        requestFinished(si);\n<line43>    }\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    // Update request accounting/throttling limits\n<line3>    requestFinished(si);\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"Dropping request.\", e);\n<line3>    // Update request accounting/throttling limits\n<line4>    requestFinished(si);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // Update request accounting/throttling limits\n<line3>    requestFinished(si);\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to process request\", e);\n<line3>    // Update request accounting/throttling limits\n<line4>    requestFinished(si);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // 4GB by default\n<line3>    long size = Long.getLong(\"zookeeper.snapSizeLimitInKb\", 4194304L);\n<line4>    if (size <= 0) {\n<line5>    }\n<line6>    // Convert to bytes\n<line7>    return size * 1024;\n<line8>}","output":"<line1>{\n<line2>    // 4GB by default\n<line3>    long size = Long.getLong(\"zookeeper.snapSizeLimitInKb\", 4194304L);\n<line4>    if (size <= 0) {\n<line5>        LOG.info(\"zookeeper.snapSizeLimitInKb set to a non-positive value {}; disabling feature\", size);\n<line6>    }\n<line7>    // Convert to bytes\n<line8>    return size * 1024;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"zookeeper.snapSizeLimitInKb set to a non-positive value {}; disabling feature\", size);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    this.tickTime = tickTime;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"tickTime set to {} ms\", tickTime);\n<line3>    this.tickTime = tickTime;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throttledOpWaitTime = time;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"throttledOpWaitTime set to {} ms\", time);\n<line3>    throttledOpWaitTime = time;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.minSessionTimeout = min == -1 ? tickTime * 2 : min;\n<line3>}","output":"<line1>{\n<line2>    this.minSessionTimeout = min == -1 ? tickTime * 2 : min;\n<line3>    LOG.info(\"minSessionTimeout set to {} ms\", this.minSessionTimeout);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.maxSessionTimeout = max == -1 ? tickTime * 20 : max;\n<line3>}","output":"<line1>{\n<line2>    this.maxSessionTimeout = max == -1 ? tickTime * 20 : max;\n<line3>    LOG.info(\"maxSessionTimeout set to {} ms\", this.maxSessionTimeout);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.listenBacklog = backlog;\n<line3>}","output":"<line1>{\n<line2>    this.listenBacklog = backlog;\n<line3>    LOG.info(\"clientPortListenBacklog set to {}\", backlog);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    long sessionId = request.getSessionId();\n<line3>    int tokensNeeded = 1;\n<line4>    if (connThrottle.isConnectionWeightEnabled()) {\n<line5>        if (sessionId == 0) {\n<line6>            if (localSessionEnabled) {\n<line7>                tokensNeeded = connThrottle.getRequiredTokensForLocal();\n<line8>            } else {\n<line9>                tokensNeeded = connThrottle.getRequiredTokensForGlobal();\n<line10>            }\n<line11>        } else {\n<line12>            tokensNeeded = connThrottle.getRequiredTokensForRenew();\n<line13>        }\n<line14>    }\n<line15>    if (!connThrottle.checkLimit(tokensNeeded)) {\n<line16>        throw new ClientCnxnLimitException();\n<line17>    }\n<line18>    ServerMetrics.getMetrics().CONNECTION_TOKEN_DEFICIT.add(connThrottle.getDeficit());\n<line19>    ServerMetrics.getMetrics().CONNECTION_REQUEST_COUNT.add(1);\n<line20>    if (!cnxn.protocolManager.isReadonlyAvailable()) {\n<line21>    }\n<line22>    if (!request.getReadOnly() && this instanceof ReadOnlyZooKeeperServer) {\n<line23>        String msg = \"Refusing session request for not-read-only client \" + cnxn.getRemoteSocketAddress();\n<line24>        throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.NOT_READ_ONLY_CLIENT);\n<line25>    }\n<line26>    if (request.getLastZxidSeen() > zkDb.dataTree.lastProcessedZxid) {\n<line27>        String msg = \"Refusing session(0x\" + Long.toHexString(sessionId) + \") request for client \" + cnxn.getRemoteSocketAddress() + \" as it has seen zxid 0x\" + Long.toHexString(request.getLastZxidSeen()) + \" our last zxid is 0x\" + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid()) + \" client must try another server\";\n<line28>        throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.CLIENT_ZXID_AHEAD);\n<line29>    }\n<line30>    int sessionTimeout = request.getTimeOut();\n<line31>    byte[] passwd = request.getPasswd();\n<line32>    int minSessionTimeout = getMinSessionTimeout();\n<line33>    if (sessionTimeout < minSessionTimeout) {\n<line34>        sessionTimeout = minSessionTimeout;\n<line35>    }\n<line36>    int maxSessionTimeout = getMaxSessionTimeout();\n<line37>    if (sessionTimeout > maxSessionTimeout) {\n<line38>        sessionTimeout = maxSessionTimeout;\n<line39>    }\n<line40>    cnxn.setSessionTimeout(sessionTimeout);\n<line41>    // We don't want to receive any packets until we are sure that the\n<line42>    // session is setup\n<line43>    cnxn.disableRecv();\n<line44>    if (sessionId == 0) {\n<line45>        long id = createSession(cnxn, passwd, sessionTimeout);\n<line46>    } else {\n<line47>        validateSession(cnxn, sessionId);\n<line48>        if (serverCnxnFactory != null) {\n<line49>            serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line50>        }\n<line51>        if (secureServerCnxnFactory != null) {\n<line52>            secureServerCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line53>        }\n<line54>        cnxn.setSessionId(sessionId);\n<line55>        reopenSession(cnxn, sessionId, passwd, sessionTimeout);\n<line56>        ServerMetrics.getMetrics().CONNECTION_REVALIDATE_COUNT.add(1);\n<line57>    }\n<line58>}","output":"<line1>{\n<line2>    LOG.debug(\"Session establishment request from client {} client's lastZxid is 0x{}\", cnxn.getRemoteSocketAddress(), Long.toHexString(request.getLastZxidSeen()));\n<line3>    long sessionId = request.getSessionId();\n<line4>    int tokensNeeded = 1;\n<line5>    if (connThrottle.isConnectionWeightEnabled()) {\n<line6>        if (sessionId == 0) {\n<line7>            if (localSessionEnabled) {\n<line8>                tokensNeeded = connThrottle.getRequiredTokensForLocal();\n<line9>            } else {\n<line10>                tokensNeeded = connThrottle.getRequiredTokensForGlobal();\n<line11>            }\n<line12>        } else {\n<line13>            tokensNeeded = connThrottle.getRequiredTokensForRenew();\n<line14>        }\n<line15>    }\n<line16>    if (!connThrottle.checkLimit(tokensNeeded)) {\n<line17>        throw new ClientCnxnLimitException();\n<line18>    }\n<line19>    ServerMetrics.getMetrics().CONNECTION_TOKEN_DEFICIT.add(connThrottle.getDeficit());\n<line20>    ServerMetrics.getMetrics().CONNECTION_REQUEST_COUNT.add(1);\n<line21>    if (!cnxn.protocolManager.isReadonlyAvailable()) {\n<line22>        LOG.warn(\"Connection request from old client {}; will be dropped if server is in r-o mode\", cnxn.getRemoteSocketAddress());\n<line23>    }\n<line24>    if (!request.getReadOnly() && this instanceof ReadOnlyZooKeeperServer) {\n<line25>        String msg = \"Refusing session request for not-read-only client \" + cnxn.getRemoteSocketAddress();\n<line26>        LOG.info(msg);\n<line27>        throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.NOT_READ_ONLY_CLIENT);\n<line28>    }\n<line29>    if (request.getLastZxidSeen() > zkDb.dataTree.lastProcessedZxid) {\n<line30>        String msg = \"Refusing session(0x\" + Long.toHexString(sessionId) + \") request for client \" + cnxn.getRemoteSocketAddress() + \" as it has seen zxid 0x\" + Long.toHexString(request.getLastZxidSeen()) + \" our last zxid is 0x\" + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid()) + \" client must try another server\";\n<line31>        LOG.info(msg);\n<line32>        throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.CLIENT_ZXID_AHEAD);\n<line33>    }\n<line34>    int sessionTimeout = request.getTimeOut();\n<line35>    byte[] passwd = request.getPasswd();\n<line36>    int minSessionTimeout = getMinSessionTimeout();\n<line37>    if (sessionTimeout < minSessionTimeout) {\n<line38>        sessionTimeout = minSessionTimeout;\n<line39>    }\n<line40>    int maxSessionTimeout = getMaxSessionTimeout();\n<line41>    if (sessionTimeout > maxSessionTimeout) {\n<line42>        sessionTimeout = maxSessionTimeout;\n<line43>    }\n<line44>    cnxn.setSessionTimeout(sessionTimeout);\n<line45>    // We don't want to receive any packets until we are sure that the\n<line46>    // session is setup\n<line47>    cnxn.disableRecv();\n<line48>    if (sessionId == 0) {\n<line49>        long id = createSession(cnxn, passwd, sessionTimeout);\n<line50>        LOG.debug(\"Client attempting to establish new session: session = 0x{}, zxid = 0x{}, timeout = {}, address = {}\", Long.toHexString(id), Long.toHexString(request.getLastZxidSeen()), request.getTimeOut(), cnxn.getRemoteSocketAddress());\n<line51>    } else {\n<line52>        validateSession(cnxn, sessionId);\n<line53>        LOG.debug(\"Client attempting to renew session: session = 0x{}, zxid = 0x{}, timeout = {}, address = {}\", Long.toHexString(sessionId), Long.toHexString(request.getLastZxidSeen()), request.getTimeOut(), cnxn.getRemoteSocketAddress());\n<line54>        if (serverCnxnFactory != null) {\n<line55>            serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line56>        }\n<line57>        if (secureServerCnxnFactory != null) {\n<line58>            secureServerCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line59>        }\n<line60>        cnxn.setSessionId(sessionId);\n<line61>        reopenSession(cnxn, sessionId, passwd, sessionTimeout);\n<line62>        ServerMetrics.getMetrics().CONNECTION_REVALIDATE_COUNT.add(1);\n<line63>    }\n<line64>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Refusing session request for not-read-only client \" + cnxn.getRemoteSocketAddress();\n<line3>    throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.NOT_READ_ONLY_CLIENT);\n<line4>}","output":"<line1>{\n<line2>    String msg = \"Refusing session request for not-read-only client \" + cnxn.getRemoteSocketAddress();\n<line3>    LOG.info(msg);\n<line4>    throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.NOT_READ_ONLY_CLIENT);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Refusing session(0x\" + Long.toHexString(sessionId) + \") request for client \" + cnxn.getRemoteSocketAddress() + \" as it has seen zxid 0x\" + Long.toHexString(request.getLastZxidSeen()) + \" our last zxid is 0x\" + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid()) + \" client must try another server\";\n<line3>    throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.CLIENT_ZXID_AHEAD);\n<line4>}","output":"<line1>{\n<line2>    String msg = \"Refusing session(0x\" + Long.toHexString(sessionId) + \") request for client \" + cnxn.getRemoteSocketAddress() + \" as it has seen zxid 0x\" + Long.toHexString(request.getLastZxidSeen()) + \" our last zxid is 0x\" + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid()) + \" client must try another server\";\n<line3>    LOG.info(msg);\n<line4>    throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.CLIENT_ZXID_AHEAD);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    long id = createSession(cnxn, passwd, sessionTimeout);\n<line3>}","output":"<line1>{\n<line2>    long id = createSession(cnxn, passwd, sessionTimeout);\n<line3>    LOG.debug(\"Client attempting to establish new session: session = 0x{}, zxid = 0x{}, timeout = {}, address = {}\", Long.toHexString(id), Long.toHexString(request.getLastZxidSeen()), request.getTimeOut(), cnxn.getRemoteSocketAddress());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    validateSession(cnxn, sessionId);\n<line3>    if (serverCnxnFactory != null) {\n<line4>        serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line5>    }\n<line6>    if (secureServerCnxnFactory != null) {\n<line7>        secureServerCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line8>    }\n<line9>    cnxn.setSessionId(sessionId);\n<line10>    reopenSession(cnxn, sessionId, passwd, sessionTimeout);\n<line11>    ServerMetrics.getMetrics().CONNECTION_REVALIDATE_COUNT.add(1);\n<line12>}","output":"<line1>{\n<line2>    validateSession(cnxn, sessionId);\n<line3>    LOG.debug(\"Client attempting to renew session: session = 0x{}, zxid = 0x{}, timeout = {}, address = {}\", Long.toHexString(sessionId), Long.toHexString(request.getLastZxidSeen()), request.getTimeOut(), cnxn.getRemoteSocketAddress());\n<line4>    if (serverCnxnFactory != null) {\n<line5>        serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line6>    }\n<line7>    if (secureServerCnxnFactory != null) {\n<line8>        secureServerCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);\n<line9>    }\n<line10>    cnxn.setSessionId(sessionId);\n<line11>    reopenSession(cnxn, sessionId, passwd, sessionTimeout);\n<line12>    ServerMetrics.getMetrics().CONNECTION_REVALIDATE_COUNT.add(1);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    flushDelay = delay;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {} ms\", FLUSH_DELAY, delay);\n<line3>    flushDelay = delay;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    maxWriteQueuePollTime = maxTime;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {} ms\", MAX_WRITE_QUEUE_POLL_SIZE, maxTime);\n<line3>    maxWriteQueuePollTime = maxTime;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    maxBatchSize = size;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"{}={}\", MAX_BATCH_SIZE, size);\n<line3>    maxBatchSize = size;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (bytes <= 0) {\n<line3>    } else {\n<line4>        largeRequestMaxBytes = bytes;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (bytes <= 0) {\n<line3>        LOG.warn(\"Invalid max bytes for all large requests {}. It should be a positive number.\", bytes);\n<line4>        LOG.warn(\"Will not change the setting. The max bytes stay at {}\", largeRequestMaxBytes);\n<line5>    } else {\n<line6>        largeRequestMaxBytes = bytes;\n<line7>        LOG.info(\"The max bytes for all large requests are set to {}\", largeRequestMaxBytes);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    largeRequestMaxBytes = bytes;\n<line3>}","output":"<line1>{\n<line2>    largeRequestMaxBytes = bytes;\n<line3>    LOG.info(\"The max bytes for all large requests are set to {}\", largeRequestMaxBytes);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (threshold == 0 || threshold < -1) {\n<line3>        largeRequestThreshold = -1;\n<line4>    } else {\n<line5>        largeRequestThreshold = threshold;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (threshold == 0 || threshold < -1) {\n<line3>        LOG.warn(\"Invalid large request threshold {}. It should be -1 or positive. Setting to -1 \", threshold);\n<line4>        largeRequestThreshold = -1;\n<line5>    } else {\n<line6>        largeRequestThreshold = threshold;\n<line7>        LOG.info(\"The large request threshold is set to {}\", largeRequestThreshold);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    largeRequestThreshold = threshold;\n<line3>}","output":"<line1>{\n<line2>    largeRequestThreshold = threshold;\n<line3>    LOG.info(\"The large request threshold is set to {}\", largeRequestThreshold);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Need to increase the outstanding request count first, otherwise\n<line3>    // there might be a race condition that it enabled recv after\n<line4>    // processing request and then disabled when check throttling.\n<line5>    //\n<line6>    // Be aware that we're actually checking the global outstanding\n<line7>    // request before this request.\n<line8>    //\n<line9>    // It's fine if the IOException thrown before we decrease the count\n<line10>    // in cnxn, since it will close the cnxn anyway.\n<line11>    cnxn.incrOutstandingAndCheckThrottle(h);\n<line12>    if (h.getType() == OpCode.auth) {\n<line13>        AuthPacket authPacket = request.readRecord(AuthPacket::new);\n<line14>        String scheme = authPacket.getScheme();\n<line15>        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);\n<line16>        Code authReturn = KeeperException.Code.AUTHFAILED;\n<line17>        if (ap != null) {\n<line18>            try {\n<line19>                // handleAuthentication may close the connection, to allow the client to choose\n<line20>                // a different server to connect to.\n<line21>                authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());\n<line22>            } catch (RuntimeException e) {\n<line23>                authReturn = KeeperException.Code.AUTHFAILED;\n<line24>            }\n<line25>        }\n<line26>        if (authReturn == KeeperException.Code.OK) {\n<line27>            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n<line28>            cnxn.sendResponse(rh, null, null);\n<line29>        } else {\n<line30>            if (ap == null) {\n<line31>            } else {\n<line32>            }\n<line33>            // send a response...\n<line34>            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());\n<line35>            cnxn.sendResponse(rh, null, null);\n<line36>            // ... and close connection\n<line37>            cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line38>            cnxn.disableRecv();\n<line39>        }\n<line40>        return;\n<line41>    } else if (h.getType() == OpCode.sasl) {\n<line42>        processSasl(request, cnxn, h);\n<line43>    } else {\n<line44>        if (!authHelper.enforceAuthentication(cnxn, h.getXid())) {\n<line45>            // Authentication enforcement is failed\n<line46>            // Already sent response to user about failure and closed the session, lets return\n<line47>            return;\n<line48>        } else {\n<line49>            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), request, cnxn.getAuthInfo());\n<line50>            int length = request.limit();\n<line51>            if (isLargeRequest(length)) {\n<line52>                // checkRequestSize will throw IOException if request is rejected\n<line53>                checkRequestSizeWhenMessageReceived(length);\n<line54>                si.setLargeRequestSize(length);\n<line55>            }\n<line56>            si.setOwner(ServerCnxn.me);\n<line57>            submitRequest(si);\n<line58>        }\n<line59>    }\n<line60>}","output":"<line1>{\n<line2>    // Need to increase the outstanding request count first, otherwise\n<line3>    // there might be a race condition that it enabled recv after\n<line4>    // processing request and then disabled when check throttling.\n<line5>    //\n<line6>    // Be aware that we're actually checking the global outstanding\n<line7>    // request before this request.\n<line8>    //\n<line9>    // It's fine if the IOException thrown before we decrease the count\n<line10>    // in cnxn, since it will close the cnxn anyway.\n<line11>    cnxn.incrOutstandingAndCheckThrottle(h);\n<line12>    if (h.getType() == OpCode.auth) {\n<line13>        LOG.info(\"got auth packet {}\", cnxn.getRemoteSocketAddress());\n<line14>        AuthPacket authPacket = request.readRecord(AuthPacket::new);\n<line15>        String scheme = authPacket.getScheme();\n<line16>        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);\n<line17>        Code authReturn = KeeperException.Code.AUTHFAILED;\n<line18>        if (ap != null) {\n<line19>            try {\n<line20>                // handleAuthentication may close the connection, to allow the client to choose\n<line21>                // a different server to connect to.\n<line22>                authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());\n<line23>            } catch (RuntimeException e) {\n<line24>                LOG.warn(\"Caught runtime exception from AuthenticationProvider: {}\", scheme, e);\n<line25>                authReturn = KeeperException.Code.AUTHFAILED;\n<line26>            }\n<line27>        }\n<line28>        if (authReturn == KeeperException.Code.OK) {\n<line29>            LOG.info(\"Session 0x{}: auth success for scheme {} and address {}\", Long.toHexString(cnxn.getSessionId()), scheme, cnxn.getRemoteSocketAddress());\n<line30>            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n<line31>            cnxn.sendResponse(rh, null, null);\n<line32>        } else {\n<line33>            if (ap == null) {\n<line34>                LOG.warn(\"No authentication provider for scheme: {} has {}\", scheme, ProviderRegistry.listProviders());\n<line35>            } else {\n<line36>                LOG.warn(\"Authentication failed for scheme: {}\", scheme);\n<line37>            }\n<line38>            // send a response...\n<line39>            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());\n<line40>            cnxn.sendResponse(rh, null, null);\n<line41>            // ... and close connection\n<line42>            cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line43>            cnxn.disableRecv();\n<line44>        }\n<line45>        return;\n<line46>    } else if (h.getType() == OpCode.sasl) {\n<line47>        processSasl(request, cnxn, h);\n<line48>    } else {\n<line49>        if (!authHelper.enforceAuthentication(cnxn, h.getXid())) {\n<line50>            // Authentication enforcement is failed\n<line51>            // Already sent response to user about failure and closed the session, lets return\n<line52>            return;\n<line53>        } else {\n<line54>            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), request, cnxn.getAuthInfo());\n<line55>            int length = request.limit();\n<line56>            if (isLargeRequest(length)) {\n<line57>                // checkRequestSize will throw IOException if request is rejected\n<line58>                checkRequestSizeWhenMessageReceived(length);\n<line59>                si.setLargeRequestSize(length);\n<line60>            }\n<line61>            si.setOwner(ServerCnxn.me);\n<line62>            submitRequest(si);\n<line63>        }\n<line64>    }\n<line65>}"},{"input":"","instruction":"<line1>{\n<line2>    AuthPacket authPacket = request.readRecord(AuthPacket::new);\n<line3>    String scheme = authPacket.getScheme();\n<line4>    ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);\n<line5>    Code authReturn = KeeperException.Code.AUTHFAILED;\n<line6>    if (ap != null) {\n<line7>        try {\n<line8>            // handleAuthentication may close the connection, to allow the client to choose\n<line9>            // a different server to connect to.\n<line10>            authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());\n<line11>        } catch (RuntimeException e) {\n<line12>            authReturn = KeeperException.Code.AUTHFAILED;\n<line13>        }\n<line14>    }\n<line15>    if (authReturn == KeeperException.Code.OK) {\n<line16>        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n<line17>        cnxn.sendResponse(rh, null, null);\n<line18>    } else {\n<line19>        if (ap == null) {\n<line20>        } else {\n<line21>        }\n<line22>        // send a response...\n<line23>        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());\n<line24>        cnxn.sendResponse(rh, null, null);\n<line25>        // ... and close connection\n<line26>        cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line27>        cnxn.disableRecv();\n<line28>    }\n<line29>    return;\n<line30>}","output":"<line1>{\n<line2>    LOG.info(\"got auth packet {}\", cnxn.getRemoteSocketAddress());\n<line3>    AuthPacket authPacket = request.readRecord(AuthPacket::new);\n<line4>    String scheme = authPacket.getScheme();\n<line5>    ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);\n<line6>    Code authReturn = KeeperException.Code.AUTHFAILED;\n<line7>    if (ap != null) {\n<line8>        try {\n<line9>            // handleAuthentication may close the connection, to allow the client to choose\n<line10>            // a different server to connect to.\n<line11>            authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());\n<line12>        } catch (RuntimeException e) {\n<line13>            LOG.warn(\"Caught runtime exception from AuthenticationProvider: {}\", scheme, e);\n<line14>            authReturn = KeeperException.Code.AUTHFAILED;\n<line15>        }\n<line16>    }\n<line17>    if (authReturn == KeeperException.Code.OK) {\n<line18>        LOG.info(\"Session 0x{}: auth success for scheme {} and address {}\", Long.toHexString(cnxn.getSessionId()), scheme, cnxn.getRemoteSocketAddress());\n<line19>        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n<line20>        cnxn.sendResponse(rh, null, null);\n<line21>    } else {\n<line22>        if (ap == null) {\n<line23>            LOG.warn(\"No authentication provider for scheme: {} has {}\", scheme, ProviderRegistry.listProviders());\n<line24>        } else {\n<line25>            LOG.warn(\"Authentication failed for scheme: {}\", scheme);\n<line26>        }\n<line27>        // send a response...\n<line28>        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());\n<line29>        cnxn.sendResponse(rh, null, null);\n<line30>        // ... and close connection\n<line31>        cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n<line32>        cnxn.disableRecv();\n<line33>    }\n<line34>    return;\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n<line3>    cnxn.sendResponse(rh, null, null);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Session 0x{}: auth success for scheme {} and address {}\", Long.toHexString(cnxn.getSessionId()), scheme, cnxn.getRemoteSocketAddress());\n<line3>    ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n<line4>    cnxn.sendResponse(rh, null, null);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    GetSASLRequest clientTokenRecord = request.readRecord(GetSASLRequest::new);\n<line3>    byte[] clientToken = clientTokenRecord.getToken();\n<line4>    byte[] responseToken = null;\n<line5>    try {\n<line6>        ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;\n<line7>        try {\n<line8>            // note that clientToken might be empty (clientToken.length == 0):\n<line9>            // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n<line10>            // SASL negotiation process.\n<line11>            responseToken = saslServer.evaluateResponse(clientToken);\n<line12>            if (saslServer.isComplete()) {\n<line13>                String authorizationID = saslServer.getAuthorizationID();\n<line14>                cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line15>                if (isSaslSuperUser(authorizationID)) {\n<line16>                    cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line17>                }\n<line18>            }\n<line19>        } catch (SaslException e) {\n<line20>            if (shouldAllowSaslFailedClientsConnect() && !authHelper.isSaslAuthRequired()) {\n<line21>            } else {\n<line22>                int error;\n<line23>                if (authHelper.isSaslAuthRequired()) {\n<line24>                    error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();\n<line25>                } else {\n<line26>                    error = Code.AUTHFAILED.intValue();\n<line27>                }\n<line28>                ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);\n<line29>                cnxn.sendResponse(replyHeader, new SetSASLResponse(null), \"response\");\n<line30>                cnxn.sendCloseSession();\n<line31>                cnxn.disableRecv();\n<line32>                return;\n<line33>            }\n<line34>        }\n<line35>    } catch (NullPointerException e) {\n<line36>    }\n<line37>    if (responseToken != null) {\n<line38>    }\n<line39>    ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, Code.OK.intValue());\n<line40>    Record record = new SetSASLResponse(responseToken);\n<line41>    cnxn.sendResponse(replyHeader, record, \"response\");\n<line42>}","output":"<line1>{\n<line2>    LOG.debug(\"Responding to client SASL token.\");\n<line3>    GetSASLRequest clientTokenRecord = request.readRecord(GetSASLRequest::new);\n<line4>    byte[] clientToken = clientTokenRecord.getToken();\n<line5>    LOG.debug(\"Size of client SASL token: {}\", clientToken.length);\n<line6>    byte[] responseToken = null;\n<line7>    try {\n<line8>        ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;\n<line9>        try {\n<line10>            // note that clientToken might be empty (clientToken.length == 0):\n<line11>            // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n<line12>            // SASL negotiation process.\n<line13>            responseToken = saslServer.evaluateResponse(clientToken);\n<line14>            if (saslServer.isComplete()) {\n<line15>                String authorizationID = saslServer.getAuthorizationID();\n<line16>                LOG.info(\"Session 0x{}: adding SASL authorization for authorizationID: {}\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line17>                cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line18>                if (isSaslSuperUser(authorizationID)) {\n<line19>                    cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line20>                    LOG.info(\"Session 0x{}: Authenticated Id '{}' as super user\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line21>                }\n<line22>            }\n<line23>        } catch (SaslException e) {\n<line24>            LOG.warn(\"Client {} failed to SASL authenticate: {}\", cnxn.getRemoteSocketAddress(), e);\n<line25>            if (shouldAllowSaslFailedClientsConnect() && !authHelper.isSaslAuthRequired()) {\n<line26>                LOG.warn(\"Maintaining client connection despite SASL authentication failure.\");\n<line27>            } else {\n<line28>                int error;\n<line29>                if (authHelper.isSaslAuthRequired()) {\n<line30>                    LOG.warn(\"Closing client connection due to server requires client SASL authenticaiton,\" + \"but client SASL authentication has failed, or client is not configured with SASL \" + \"authentication.\");\n<line31>                    error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();\n<line32>                } else {\n<line33>                    LOG.warn(\"Closing client connection due to SASL authentication failure.\");\n<line34>                    error = Code.AUTHFAILED.intValue();\n<line35>                }\n<line36>                ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);\n<line37>                cnxn.sendResponse(replyHeader, new SetSASLResponse(null), \"response\");\n<line38>                cnxn.sendCloseSession();\n<line39>                cnxn.disableRecv();\n<line40>                return;\n<line41>            }\n<line42>        }\n<line43>    } catch (NullPointerException e) {\n<line44>        LOG.error(\"cnxn.saslServer is null: cnxn object did not initialize its saslServer properly.\");\n<line45>    }\n<line46>    if (responseToken != null) {\n<line47>        LOG.debug(\"Size of server SASL response: {}\", responseToken.length);\n<line48>    }\n<line49>    ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, Code.OK.intValue());\n<line50>    Record record = new SetSASLResponse(responseToken);\n<line51>    cnxn.sendResponse(replyHeader, record, \"response\");\n<line52>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;\n<line3>    try {\n<line4>        // note that clientToken might be empty (clientToken.length == 0):\n<line5>        // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n<line6>        // SASL negotiation process.\n<line7>        responseToken = saslServer.evaluateResponse(clientToken);\n<line8>        if (saslServer.isComplete()) {\n<line9>            String authorizationID = saslServer.getAuthorizationID();\n<line10>            cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line11>            if (isSaslSuperUser(authorizationID)) {\n<line12>                cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line13>            }\n<line14>        }\n<line15>    } catch (SaslException e) {\n<line16>        if (shouldAllowSaslFailedClientsConnect() && !authHelper.isSaslAuthRequired()) {\n<line17>        } else {\n<line18>            int error;\n<line19>            if (authHelper.isSaslAuthRequired()) {\n<line20>                error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();\n<line21>            } else {\n<line22>                error = Code.AUTHFAILED.intValue();\n<line23>            }\n<line24>            ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);\n<line25>            cnxn.sendResponse(replyHeader, new SetSASLResponse(null), \"response\");\n<line26>            cnxn.sendCloseSession();\n<line27>            cnxn.disableRecv();\n<line28>            return;\n<line29>        }\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;\n<line3>    try {\n<line4>        // note that clientToken might be empty (clientToken.length == 0):\n<line5>        // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n<line6>        // SASL negotiation process.\n<line7>        responseToken = saslServer.evaluateResponse(clientToken);\n<line8>        if (saslServer.isComplete()) {\n<line9>            String authorizationID = saslServer.getAuthorizationID();\n<line10>            LOG.info(\"Session 0x{}: adding SASL authorization for authorizationID: {}\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line11>            cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line12>            if (isSaslSuperUser(authorizationID)) {\n<line13>                cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line14>                LOG.info(\"Session 0x{}: Authenticated Id '{}' as super user\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line15>            }\n<line16>        }\n<line17>    } catch (SaslException e) {\n<line18>        LOG.warn(\"Client {} failed to SASL authenticate: {}\", cnxn.getRemoteSocketAddress(), e);\n<line19>        if (shouldAllowSaslFailedClientsConnect() && !authHelper.isSaslAuthRequired()) {\n<line20>            LOG.warn(\"Maintaining client connection despite SASL authentication failure.\");\n<line21>        } else {\n<line22>            int error;\n<line23>            if (authHelper.isSaslAuthRequired()) {\n<line24>                LOG.warn(\"Closing client connection due to server requires client SASL authenticaiton,\" + \"but client SASL authentication has failed, or client is not configured with SASL \" + \"authentication.\");\n<line25>                error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();\n<line26>            } else {\n<line27>                LOG.warn(\"Closing client connection due to SASL authentication failure.\");\n<line28>                error = Code.AUTHFAILED.intValue();\n<line29>            }\n<line30>            ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);\n<line31>            cnxn.sendResponse(replyHeader, new SetSASLResponse(null), \"response\");\n<line32>            cnxn.sendCloseSession();\n<line33>            cnxn.disableRecv();\n<line34>            return;\n<line35>        }\n<line36>    }\n<line37>}"},{"input":"","instruction":"<line1>{\n<line2>    // note that clientToken might be empty (clientToken.length == 0):\n<line3>    // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n<line4>    // SASL negotiation process.\n<line5>    responseToken = saslServer.evaluateResponse(clientToken);\n<line6>    if (saslServer.isComplete()) {\n<line7>        String authorizationID = saslServer.getAuthorizationID();\n<line8>        cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line9>        if (isSaslSuperUser(authorizationID)) {\n<line10>            cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line11>        }\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    // note that clientToken might be empty (clientToken.length == 0):\n<line3>    // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n<line4>    // SASL negotiation process.\n<line5>    responseToken = saslServer.evaluateResponse(clientToken);\n<line6>    if (saslServer.isComplete()) {\n<line7>        String authorizationID = saslServer.getAuthorizationID();\n<line8>        LOG.info(\"Session 0x{}: adding SASL authorization for authorizationID: {}\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line9>        cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line10>        if (isSaslSuperUser(authorizationID)) {\n<line11>            cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line12>            LOG.info(\"Session 0x{}: Authenticated Id '{}' as super user\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line13>        }\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    String authorizationID = saslServer.getAuthorizationID();\n<line3>    cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line4>    if (isSaslSuperUser(authorizationID)) {\n<line5>        cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    String authorizationID = saslServer.getAuthorizationID();\n<line3>    LOG.info(\"Session 0x{}: adding SASL authorization for authorizationID: {}\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line4>    cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n<line5>    if (isSaslSuperUser(authorizationID)) {\n<line6>        cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line7>        LOG.info(\"Session 0x{}: Authenticated Id '{}' as super user\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line3>}","output":"<line1>{\n<line2>    cnxn.addAuthInfo(new Id(\"super\", \"\"));\n<line3>    LOG.info(\"Session 0x{}: Authenticated Id '{}' as super user\", Long.toHexString(cnxn.getSessionId()), authorizationID);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"cnxn.saslServer is null: cnxn object did not initialize its saslServer properly.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Size of server SASL response: {}\", responseToken.length);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (skipACL) {\n<line3>        return;\n<line4>    }\n<line5>    if (acl == null || acl.size() == 0) {\n<line6>        return;\n<line7>    }\n<line8>    for (Id authId : ids) {\n<line9>        if (authId.getScheme().equals(\"super\")) {\n<line10>            return;\n<line11>        }\n<line12>    }\n<line13>    for (ACL a : acl) {\n<line14>        Id id = a.getId();\n<line15>        if ((a.getPerms() & perm) != 0) {\n<line16>            if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n<line17>                return;\n<line18>            }\n<line19>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());\n<line20>            if (ap != null) {\n<line21>                for (Id authId : ids) {\n<line22>                    if (authId.getScheme().equals(id.getScheme()) && ap.matches(new ServerAuthenticationProvider.ServerObjs(this, cnxn), new ServerAuthenticationProvider.MatchValues(path, authId.getId(), id.getId(), perm, setAcls))) {\n<line23>                        return;\n<line24>                    }\n<line25>                }\n<line26>            }\n<line27>        }\n<line28>    }\n<line29>    throw new KeeperException.NoAuthException();\n<line30>}","output":"<line1>{\n<line2>    if (skipACL) {\n<line3>        return;\n<line4>    }\n<line5>    LOG.debug(\"Permission requested: {} \", perm);\n<line6>    LOG.debug(\"ACLs for node: {}\", acl);\n<line7>    LOG.debug(\"Client credentials: {}\", ids);\n<line8>    if (acl == null || acl.size() == 0) {\n<line9>        return;\n<line10>    }\n<line11>    for (Id authId : ids) {\n<line12>        if (authId.getScheme().equals(\"super\")) {\n<line13>            return;\n<line14>        }\n<line15>    }\n<line16>    for (ACL a : acl) {\n<line17>        Id id = a.getId();\n<line18>        if ((a.getPerms() & perm) != 0) {\n<line19>            if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n<line20>                return;\n<line21>            }\n<line22>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());\n<line23>            if (ap != null) {\n<line24>                for (Id authId : ids) {\n<line25>                    if (authId.getScheme().equals(id.getScheme()) && ap.matches(new ServerAuthenticationProvider.ServerObjs(this, cnxn), new ServerAuthenticationProvider.MatchValues(path, authId.getId(), id.getId(), perm, setAcls))) {\n<line26>                        return;\n<line27>                    }\n<line28>                }\n<line29>            }\n<line30>        }\n<line31>    }\n<line32>    throw new KeeperException.NoAuthException();\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    // now check the quota we set\n<line3>    String limitNode = Quotas.limitPath(lastPrefix);\n<line4>    DataNode node = getZKDatabase().getNode(limitNode);\n<line5>    StatsTrack limitStats;\n<line6>    if (node == null) {\n<line7>        // should not happen\n<line8>        return;\n<line9>    }\n<line10>    synchronized (node) {\n<line11>        limitStats = new StatsTrack(node.data);\n<line12>    }\n<line13>    //check the quota\n<line14>    boolean checkCountQuota = countDiff != 0 && (limitStats.getCount() > -1 || limitStats.getCountHardLimit() > -1);\n<line15>    boolean checkByteQuota = bytesDiff != 0 && (limitStats.getBytes() > -1 || limitStats.getByteHardLimit() > -1);\n<line16>    if (!checkCountQuota && !checkByteQuota) {\n<line17>        return;\n<line18>    }\n<line19>    //check the statPath quota\n<line20>    String statNode = Quotas.statPath(lastPrefix);\n<line21>    node = getZKDatabase().getNode(statNode);\n<line22>    StatsTrack currentStats;\n<line23>    if (node == null) {\n<line24>        // should not happen\n<line25>        return;\n<line26>    }\n<line27>    synchronized (node) {\n<line28>        currentStats = new StatsTrack(node.data);\n<line29>    }\n<line30>    //check the Count Quota\n<line31>    if (checkCountQuota) {\n<line32>        long newCount = currentStats.getCount() + countDiff;\n<line33>        boolean isCountHardLimit = limitStats.getCountHardLimit() > -1;\n<line34>        long countLimit = isCountHardLimit ? limitStats.getCountHardLimit() : limitStats.getCount();\n<line35>        if (newCount > countLimit) {\n<line36>            String msg = \"Quota exceeded: \" + lastPrefix + \" [current count=\" + newCount + \", \" + (isCountHardLimit ? \"hard\" : \"soft\") + \"CountLimit=\" + countLimit + \"]\";\n<line37>            RATE_LOGGER.rateLimitLog(msg);\n<line38>            if (isCountHardLimit) {\n<line39>                updateQuotaExceededMetrics(namespace);\n<line40>                throw new KeeperException.QuotaExceededException(lastPrefix);\n<line41>            }\n<line42>        }\n<line43>    }\n<line44>    //check the Byte Quota\n<line45>    if (checkByteQuota) {\n<line46>        long newBytes = currentStats.getBytes() + bytesDiff;\n<line47>        boolean isByteHardLimit = limitStats.getByteHardLimit() > -1;\n<line48>        long byteLimit = isByteHardLimit ? limitStats.getByteHardLimit() : limitStats.getBytes();\n<line49>        if (newBytes > byteLimit) {\n<line50>            String msg = \"Quota exceeded: \" + lastPrefix + \" [current bytes=\" + newBytes + \", \" + (isByteHardLimit ? \"hard\" : \"soft\") + \"ByteLimit=\" + byteLimit + \"]\";\n<line51>            RATE_LOGGER.rateLimitLog(msg);\n<line52>            if (isByteHardLimit) {\n<line53>                updateQuotaExceededMetrics(namespace);\n<line54>                throw new KeeperException.QuotaExceededException(lastPrefix);\n<line55>            }\n<line56>        }\n<line57>    }\n<line58>}","output":"<line1>{\n<line2>    LOG.debug(\"checkQuota: lastPrefix={}, bytesDiff={}, countDiff={}\", lastPrefix, bytesDiff, countDiff);\n<line3>    // now check the quota we set\n<line4>    String limitNode = Quotas.limitPath(lastPrefix);\n<line5>    DataNode node = getZKDatabase().getNode(limitNode);\n<line6>    StatsTrack limitStats;\n<line7>    if (node == null) {\n<line8>        // should not happen\n<line9>        LOG.error(\"Missing limit node for quota {}\", limitNode);\n<line10>        return;\n<line11>    }\n<line12>    synchronized (node) {\n<line13>        limitStats = new StatsTrack(node.data);\n<line14>    }\n<line15>    //check the quota\n<line16>    boolean checkCountQuota = countDiff != 0 && (limitStats.getCount() > -1 || limitStats.getCountHardLimit() > -1);\n<line17>    boolean checkByteQuota = bytesDiff != 0 && (limitStats.getBytes() > -1 || limitStats.getByteHardLimit() > -1);\n<line18>    if (!checkCountQuota && !checkByteQuota) {\n<line19>        return;\n<line20>    }\n<line21>    //check the statPath quota\n<line22>    String statNode = Quotas.statPath(lastPrefix);\n<line23>    node = getZKDatabase().getNode(statNode);\n<line24>    StatsTrack currentStats;\n<line25>    if (node == null) {\n<line26>        // should not happen\n<line27>        LOG.error(\"Missing node for stat {}\", statNode);\n<line28>        return;\n<line29>    }\n<line30>    synchronized (node) {\n<line31>        currentStats = new StatsTrack(node.data);\n<line32>    }\n<line33>    //check the Count Quota\n<line34>    if (checkCountQuota) {\n<line35>        long newCount = currentStats.getCount() + countDiff;\n<line36>        boolean isCountHardLimit = limitStats.getCountHardLimit() > -1;\n<line37>        long countLimit = isCountHardLimit ? limitStats.getCountHardLimit() : limitStats.getCount();\n<line38>        if (newCount > countLimit) {\n<line39>            String msg = \"Quota exceeded: \" + lastPrefix + \" [current count=\" + newCount + \", \" + (isCountHardLimit ? \"hard\" : \"soft\") + \"CountLimit=\" + countLimit + \"]\";\n<line40>            RATE_LOGGER.rateLimitLog(msg);\n<line41>            if (isCountHardLimit) {\n<line42>                updateQuotaExceededMetrics(namespace);\n<line43>                throw new KeeperException.QuotaExceededException(lastPrefix);\n<line44>            }\n<line45>        }\n<line46>    }\n<line47>    //check the Byte Quota\n<line48>    if (checkByteQuota) {\n<line49>        long newBytes = currentStats.getBytes() + bytesDiff;\n<line50>        boolean isByteHardLimit = limitStats.getByteHardLimit() > -1;\n<line51>        long byteLimit = isByteHardLimit ? limitStats.getByteHardLimit() : limitStats.getBytes();\n<line52>        if (newBytes > byteLimit) {\n<line53>            String msg = \"Quota exceeded: \" + lastPrefix + \" [current bytes=\" + newBytes + \", \" + (isByteHardLimit ? \"hard\" : \"soft\") + \"ByteLimit=\" + byteLimit + \"]\";\n<line54>            RATE_LOGGER.rateLimitLog(msg);\n<line55>            if (isByteHardLimit) {\n<line56>                updateQuotaExceededMetrics(namespace);\n<line57>                throw new KeeperException.QuotaExceededException(lastPrefix);\n<line58>            }\n<line59>        }\n<line60>    }\n<line61>}"},{"input":"","instruction":"<line1>{\n<line2>    // should not happen\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    // should not happen\n<line3>    LOG.error(\"Missing limit node for quota {}\", limitNode);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // should not happen\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    // should not happen\n<line3>    LOG.error(\"Missing node for stat {}\", statNode);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    ZooKeeperServer.digestEnabled = digestEnabled;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {}\", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);\n<line3>    ZooKeeperServer.digestEnabled = digestEnabled;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    serializeLastProcessedZxidEnabled = serializeLastZxidEnabled;\n<line3>}","output":"<line1>{\n<line2>    serializeLastProcessedZxidEnabled = serializeLastZxidEnabled;\n<line3>    LOG.info(\"{} = {}\", ZOOKEEPER_SERIALIZE_LAST_PROCESSED_ZXID_ENABLED, serializeLastZxidEnabled);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int err;\n<line3>    String pathToCheck;\n<line4>    if (!enableEagerACLCheck) {\n<line5>        return true;\n<line6>    }\n<line7>    err = KeeperException.Code.OK.intValue();\n<line8>    try {\n<line9>        pathToCheck = effectiveACLPath(request);\n<line10>        if (pathToCheck != null) {\n<line11>            checkACL(request.cnxn, zkDb.getACL(pathToCheck, null), effectiveACLPerms(request), request.authInfo, pathToCheck, null);\n<line12>        }\n<line13>    } catch (KeeperException.NoAuthException e) {\n<line14>        err = e.code().intValue();\n<line15>    } catch (KeeperException.InvalidACLException e) {\n<line16>        err = e.code().intValue();\n<line17>    } catch (KeeperException.NoNodeException e) {\n<line18>    } catch (KeeperException.BadArgumentsException e) {\n<line19>    } catch (Throwable t) {\n<line20>        throw t;\n<line21>    } finally {\n<line22>        if (err != KeeperException.Code.OK.intValue()) {\n<line23>            /*  This request has a bad ACL, so we are dismissing it early. */\n<line24>            decInProcess();\n<line25>            ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);\n<line26>            try {\n<line27>                request.cnxn.sendResponse(rh, null, null);\n<line28>            } catch (IOException e) {\n<line29>            }\n<line30>        }\n<line31>    }\n<line32>    return err == KeeperException.Code.OK.intValue();\n<line33>}","output":"<line1>{\n<line2>    int err;\n<line3>    String pathToCheck;\n<line4>    if (!enableEagerACLCheck) {\n<line5>        return true;\n<line6>    }\n<line7>    err = KeeperException.Code.OK.intValue();\n<line8>    try {\n<line9>        pathToCheck = effectiveACLPath(request);\n<line10>        if (pathToCheck != null) {\n<line11>            checkACL(request.cnxn, zkDb.getACL(pathToCheck, null), effectiveACLPerms(request), request.authInfo, pathToCheck, null);\n<line12>        }\n<line13>    } catch (KeeperException.NoAuthException e) {\n<line14>        LOG.debug(\"Request failed ACL check\", e);\n<line15>        err = e.code().intValue();\n<line16>    } catch (KeeperException.InvalidACLException e) {\n<line17>        LOG.debug(\"Request has an invalid ACL check\", e);\n<line18>        err = e.code().intValue();\n<line19>    } catch (KeeperException.NoNodeException e) {\n<line20>        LOG.debug(\"ACL check against non-existent node: {}\", e.getMessage());\n<line21>    } catch (KeeperException.BadArgumentsException e) {\n<line22>        LOG.debug(\"ACL check against illegal node path: {}\", e.getMessage());\n<line23>    } catch (Throwable t) {\n<line24>        LOG.error(\"Uncaught exception in authWriteRequest with: \", t);\n<line25>        throw t;\n<line26>    } finally {\n<line27>        if (err != KeeperException.Code.OK.intValue()) {\n<line28>            /*  This request has a bad ACL, so we are dismissing it early. */\n<line29>            decInProcess();\n<line30>            ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);\n<line31>            try {\n<line32>                request.cnxn.sendResponse(rh, null, null);\n<line33>            } catch (IOException e) {\n<line34>                LOG.error(\"IOException : {}\", e);\n<line35>            }\n<line36>        }\n<line37>    }\n<line38>    return err == KeeperException.Code.OK.intValue();\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    err = e.code().intValue();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Request failed ACL check\", e);\n<line3>    err = e.code().intValue();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    err = e.code().intValue();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Request has an invalid ACL check\", e);\n<line3>    err = e.code().intValue();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ACL check against non-existent node: {}\", e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ACL check against illegal node path: {}\", e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    throw t;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Uncaught exception in authWriteRequest with: \", t);\n<line3>    throw t;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (err != KeeperException.Code.OK.intValue()) {\n<line3>        /*  This request has a bad ACL, so we are dismissing it early. */\n<line4>        decInProcess();\n<line5>        ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);\n<line6>        try {\n<line7>            request.cnxn.sendResponse(rh, null, null);\n<line8>        } catch (IOException e) {\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    if (err != KeeperException.Code.OK.intValue()) {\n<line3>        /*  This request has a bad ACL, so we are dismissing it early. */\n<line4>        decInProcess();\n<line5>        ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);\n<line6>        try {\n<line7>            request.cnxn.sendResponse(rh, null, null);\n<line8>        } catch (IOException e) {\n<line9>            LOG.error(\"IOException : {}\", e);\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    /*  This request has a bad ACL, so we are dismissing it early. */\n<line3>    decInProcess();\n<line4>    ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);\n<line5>    try {\n<line6>        request.cnxn.sendResponse(rh, null, null);\n<line7>    } catch (IOException e) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    /*  This request has a bad ACL, so we are dismissing it early. */\n<line3>    decInProcess();\n<line4>    ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);\n<line5>    try {\n<line6>        request.cnxn.sendResponse(rh, null, null);\n<line7>    } catch (IOException e) {\n<line8>        LOG.error(\"IOException : {}\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"IOException : {}\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // we do this in an attempt to ensure that not all of the servers\n<line4>        // in the ensemble take a snapshot at the same time\n<line5>        resetSnapshotStats();\n<line6>        lastFlushTime = Time.currentElapsedTime();\n<line7>        while (true) {\n<line8>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n<line9>            long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());\n<line10>            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);\n<line11>            if (si == null) {\n<line12>                /* We timed out looking for more writes to batch, go ahead and flush immediately */\n<line13>                flush();\n<line14>                si = queuedRequests.take();\n<line15>            }\n<line16>            if (si == REQUEST_OF_DEATH) {\n<line17>                break;\n<line18>            }\n<line19>            long startProcessTime = Time.currentElapsedTime();\n<line20>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);\n<line21>            // track the number of records written to the log\n<line22>            if (!si.isThrottled() && zks.getZKDatabase().append(si)) {\n<line23>                if (shouldSnapshot()) {\n<line24>                    resetSnapshotStats();\n<line25>                    // roll the log\n<line26>                    zks.getZKDatabase().rollLog();\n<line27>                    // take a snapshot\n<line28>                    if (!snapThreadMutex.tryAcquire()) {\n<line29>                    } else {\n<line30>                        new ZooKeeperThread(\"Snapshot Thread\") {\n<line31>\n<line32>                            public void run() {\n<line33>                                try {\n<line34>                                    zks.takeSnapshot();\n<line35>                                } catch (Exception e) {\n<line36>                                } finally {\n<line37>                                    snapThreadMutex.release();\n<line38>                                }\n<line39>                            }\n<line40>                        }.start();\n<line41>                    }\n<line42>                }\n<line43>            } else if (toFlush.isEmpty()) {\n<line44>                // optimization for read heavy workloads\n<line45>                // iff this is a read or a throttled request(which doesn't need to be written to the disk),\n<line46>                // and there are no pending flushes (writes), then just pass this to the next processor\n<line47>                if (nextProcessor != null) {\n<line48>                    nextProcessor.processRequest(si);\n<line49>                    if (nextProcessor instanceof Flushable) {\n<line50>                        ((Flushable) nextProcessor).flush();\n<line51>                    }\n<line52>                }\n<line53>                continue;\n<line54>            }\n<line55>            toFlush.add(si);\n<line56>            if (shouldFlush()) {\n<line57>                flush();\n<line58>            }\n<line59>            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);\n<line60>        }\n<line61>    } catch (Throwable t) {\n<line62>        handleException(this.getName(), t);\n<line63>    }\n<line64>}","output":"<line1>{\n<line2>    try {\n<line3>        // we do this in an attempt to ensure that not all of the servers\n<line4>        // in the ensemble take a snapshot at the same time\n<line5>        resetSnapshotStats();\n<line6>        lastFlushTime = Time.currentElapsedTime();\n<line7>        while (true) {\n<line8>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n<line9>            long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());\n<line10>            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);\n<line11>            if (si == null) {\n<line12>                /* We timed out looking for more writes to batch, go ahead and flush immediately */\n<line13>                flush();\n<line14>                si = queuedRequests.take();\n<line15>            }\n<line16>            if (si == REQUEST_OF_DEATH) {\n<line17>                break;\n<line18>            }\n<line19>            long startProcessTime = Time.currentElapsedTime();\n<line20>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);\n<line21>            // track the number of records written to the log\n<line22>            if (!si.isThrottled() && zks.getZKDatabase().append(si)) {\n<line23>                if (shouldSnapshot()) {\n<line24>                    resetSnapshotStats();\n<line25>                    // roll the log\n<line26>                    zks.getZKDatabase().rollLog();\n<line27>                    // take a snapshot\n<line28>                    if (!snapThreadMutex.tryAcquire()) {\n<line29>                        LOG.warn(\"Too busy to snap, skipping\");\n<line30>                    } else {\n<line31>                        new ZooKeeperThread(\"Snapshot Thread\") {\n<line32>\n<line33>                            public void run() {\n<line34>                                try {\n<line35>                                    zks.takeSnapshot();\n<line36>                                } catch (Exception e) {\n<line37>                                    LOG.warn(\"Unexpected exception\", e);\n<line38>                                } finally {\n<line39>                                    snapThreadMutex.release();\n<line40>                                }\n<line41>                            }\n<line42>                        }.start();\n<line43>                    }\n<line44>                }\n<line45>            } else if (toFlush.isEmpty()) {\n<line46>                // optimization for read heavy workloads\n<line47>                // iff this is a read or a throttled request(which doesn't need to be written to the disk),\n<line48>                // and there are no pending flushes (writes), then just pass this to the next processor\n<line49>                if (nextProcessor != null) {\n<line50>                    nextProcessor.processRequest(si);\n<line51>                    if (nextProcessor instanceof Flushable) {\n<line52>                        ((Flushable) nextProcessor).flush();\n<line53>                    }\n<line54>                }\n<line55>                continue;\n<line56>            }\n<line57>            toFlush.add(si);\n<line58>            if (shouldFlush()) {\n<line59>                flush();\n<line60>            }\n<line61>            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);\n<line62>        }\n<line63>    } catch (Throwable t) {\n<line64>        handleException(this.getName(), t);\n<line65>    }\n<line66>    LOG.info(\"SyncRequestProcessor exited!\");\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    queuedRequests.add(REQUEST_OF_DEATH);\n<line3>    try {\n<line4>        this.join();\n<line5>        this.flush();\n<line6>    } catch (InterruptedException e) {\n<line7>        Thread.currentThread().interrupt();\n<line8>    } catch (IOException e) {\n<line9>    } catch (RequestProcessorException e) {\n<line10>    }\n<line11>    if (nextProcessor != null) {\n<line12>        nextProcessor.shutdown();\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    queuedRequests.add(REQUEST_OF_DEATH);\n<line4>    try {\n<line5>        this.join();\n<line6>        this.flush();\n<line7>    } catch (InterruptedException e) {\n<line8>        LOG.warn(\"Interrupted while wating for {} to finish\", this);\n<line9>        Thread.currentThread().interrupt();\n<line10>    } catch (IOException e) {\n<line11>        LOG.warn(\"Got IO exception during shutdown\");\n<line12>    } catch (RequestProcessorException e) {\n<line13>        LOG.warn(\"Got request processor exception during shutdown\");\n<line14>    }\n<line15>    if (nextProcessor != null) {\n<line16>        nextProcessor.shutdown();\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    traceMask = mask;\n<line3>    final Logger LOG = LoggerFactory.getLogger(ZooTrace.class);\n<line4>}","output":"<line1>{\n<line2>    traceMask = mask;\n<line3>    final Logger LOG = LoggerFactory.getLogger(ZooTrace.class);\n<line4>    LOG.info(\"Set text trace mask to 0x{}\", Long.toHexString(mask));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    this.cacheSize = cacheSize;\n<line3>    cache = Collections.synchronizedMap(new LRUCache<>(cacheSize));\n<line4>}","output":"<line1>{\n<line2>    this.cacheSize = cacheSize;\n<line3>    cache = Collections.synchronizedMap(new LRUCache<>(cacheSize));\n<line4>    LOG.info(\"{} response cache size is initialized with value {}.\", requestType, cacheSize);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        byte[] bytes = ia.readBuffer(\"txtEntry\");\n<line4>        // Since we preallocate, we define EOF to be an\n<line5>        // empty transaction\n<line6>        if (bytes.length == 0) {\n<line7>            return bytes;\n<line8>        }\n<line9>        if (ia.readByte(\"EOF\") != 'B') {\n<line10>            return null;\n<line11>        }\n<line12>        return bytes;\n<line13>    } catch (EOFException e) {\n<line14>    }\n<line15>    return null;\n<line16>}","output":"<line1>{\n<line2>    try {\n<line3>        byte[] bytes = ia.readBuffer(\"txtEntry\");\n<line4>        // Since we preallocate, we define EOF to be an\n<line5>        // empty transaction\n<line6>        if (bytes.length == 0) {\n<line7>            return bytes;\n<line8>        }\n<line9>        if (ia.readByte(\"EOF\") != 'B') {\n<line10>            LOG.error(\"Last transaction was partial.\");\n<line11>            return null;\n<line12>        }\n<line13>        return bytes;\n<line14>    } catch (EOFException e) {\n<line15>    }\n<line16>    return null;\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] bytes = ia.readBuffer(\"txtEntry\");\n<line3>    // Since we preallocate, we define EOF to be an\n<line4>    // empty transaction\n<line5>    if (bytes.length == 0) {\n<line6>        return bytes;\n<line7>    }\n<line8>    if (ia.readByte(\"EOF\") != 'B') {\n<line9>        return null;\n<line10>    }\n<line11>    return bytes;\n<line12>}","output":"<line1>{\n<line2>    byte[] bytes = ia.readBuffer(\"txtEntry\");\n<line3>    // Since we preallocate, we define EOF to be an\n<line4>    // empty transaction\n<line5>    if (bytes.length == 0) {\n<line6>        return bytes;\n<line7>    }\n<line8>    if (ia.readByte(\"EOF\") != 'B') {\n<line9>        LOG.error(\"Last transaction was partial.\");\n<line10>        return null;\n<line11>    }\n<line12>    return bytes;\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Last transaction was partial.\");\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.dataDir = new File(dataDir, version + VERSION);\n<line3>    this.snapDir = new File(snapDir, version + VERSION);\n<line4>    // by default create snap/log dirs, but otherwise complain instead\n<line5>    // See ZOOKEEPER-1161 for more details\n<line6>    boolean enableAutocreate = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n<line7>    trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n<line8>    if (!this.dataDir.exists()) {\n<line9>        if (!enableAutocreate) {\n<line10>            throw new DatadirException(String.format(\"Missing data directory %s, automatic data directory creation is disabled (%s is false).\" + \" Please create this directory manually.\", this.dataDir, ZOOKEEPER_DATADIR_AUTOCREATE));\n<line11>        }\n<line12>        if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n<line13>            throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n<line14>        }\n<line15>    }\n<line16>    if (!this.dataDir.canWrite()) {\n<line17>        throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n<line18>    }\n<line19>    if (!this.snapDir.exists()) {\n<line20>        // by default create this directory, but otherwise complain instead\n<line21>        // See ZOOKEEPER-1161 for more details\n<line22>        if (!enableAutocreate) {\n<line23>            throw new DatadirException(String.format(\"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\" + \"Please create this directory manually.\", this.snapDir, ZOOKEEPER_DATADIR_AUTOCREATE));\n<line24>        }\n<line25>        if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n<line26>            throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n<line27>        }\n<line28>    }\n<line29>    if (!this.snapDir.canWrite()) {\n<line30>        throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n<line31>    }\n<line32>    // check content of transaction log and snapshot dirs if they are two different directories\n<line33>    // See ZOOKEEPER-2967 for more details\n<line34>    if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n<line35>        checkLogDir();\n<line36>        checkSnapDir();\n<line37>    }\n<line38>    txnLog = new FileTxnLog(this.dataDir);\n<line39>    snapLog = new FileSnap(this.snapDir);\n<line40>    autoCreateDB = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n<line41>}","output":"<line1>{\n<line2>    LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n<line3>    this.dataDir = new File(dataDir, version + VERSION);\n<line4>    this.snapDir = new File(snapDir, version + VERSION);\n<line5>    // by default create snap/log dirs, but otherwise complain instead\n<line6>    // See ZOOKEEPER-1161 for more details\n<line7>    boolean enableAutocreate = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n<line8>    trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n<line9>    LOG.info(\"{} : {}\", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);\n<line10>    if (!this.dataDir.exists()) {\n<line11>        if (!enableAutocreate) {\n<line12>            throw new DatadirException(String.format(\"Missing data directory %s, automatic data directory creation is disabled (%s is false).\" + \" Please create this directory manually.\", this.dataDir, ZOOKEEPER_DATADIR_AUTOCREATE));\n<line13>        }\n<line14>        if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n<line15>            throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n<line16>        }\n<line17>    }\n<line18>    if (!this.dataDir.canWrite()) {\n<line19>        throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n<line20>    }\n<line21>    if (!this.snapDir.exists()) {\n<line22>        // by default create this directory, but otherwise complain instead\n<line23>        // See ZOOKEEPER-1161 for more details\n<line24>        if (!enableAutocreate) {\n<line25>            throw new DatadirException(String.format(\"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\" + \"Please create this directory manually.\", this.snapDir, ZOOKEEPER_DATADIR_AUTOCREATE));\n<line26>        }\n<line27>        if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n<line28>            throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n<line29>        }\n<line30>    }\n<line31>    if (!this.snapDir.canWrite()) {\n<line32>        throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n<line33>    }\n<line34>    // check content of transaction log and snapshot dirs if they are two different directories\n<line35>    // See ZOOKEEPER-2967 for more details\n<line36>    if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n<line37>        checkLogDir();\n<line38>        checkSnapDir();\n<line39>    }\n<line40>    txnLog = new FileTxnLog(this.dataDir);\n<line41>    snapLog = new FileSnap(this.snapDir);\n<line42>    autoCreateDB = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    long snapLoadingStartTime = Time.currentElapsedTime();\n<line3>    long deserializeResult = snapLog.deserialize(dt, sessions);\n<line4>    ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n<line5>    FileTxnLog txnLog = new FileTxnLog(dataDir);\n<line6>    boolean trustEmptyDB;\n<line7>    File initFile = new File(dataDir.getParent(), \"initialize\");\n<line8>    if (Files.deleteIfExists(initFile.toPath())) {\n<line9>        trustEmptyDB = true;\n<line10>    } else {\n<line11>        trustEmptyDB = autoCreateDB;\n<line12>    }\n<line13>    RestoreFinalizer finalizer = () -> {\n<line14>        long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n<line15>        // The snapshotZxidDigest will reset after replaying the txn of the\n<line16>        // zxid in the snapshotZxidDigest, if it's not reset to null after\n<line17>        // restoring, it means either there are not enough txns to cover that\n<line18>        // zxid or that txn is missing\n<line19>        DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n<line20>        if (snapshotZxidDigest != null) {\n<line21>        }\n<line22>        return highestZxid;\n<line23>    };\n<line24>    if (-1L == deserializeResult) {\n<line25>        /* this means that we couldn't find any snapshot, so we need to\n<line26>             * initialize an empty database (reported in ZOOKEEPER-2325) */\n<line27>        if (txnLog.getLastLoggedZxid() != -1) {\n<line28>            // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n<line29>            // from old versions of zookeeper (3.4.x, pre 3.5.3).\n<line30>            if (!trustEmptySnapshot) {\n<line31>                throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n<line32>            } else {\n<line33>                return finalizer.run();\n<line34>            }\n<line35>        }\n<line36>        if (trustEmptyDB) {\n<line37>            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n<line38>                 *       or use Map on save() */\n<line39>            save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n<line40>            /* return a zxid of 0, since we know the database is empty */\n<line41>            return 0L;\n<line42>        } else {\n<line43>            /* return a zxid of -1, since we are possibly missing data */\n<line44>            dt.lastProcessedZxid = -1L;\n<line45>            return -1L;\n<line46>        }\n<line47>    }\n<line48>    return finalizer.run();\n<line49>}","output":"<line1>{\n<line2>    long snapLoadingStartTime = Time.currentElapsedTime();\n<line3>    long deserializeResult = snapLog.deserialize(dt, sessions);\n<line4>    ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n<line5>    FileTxnLog txnLog = new FileTxnLog(dataDir);\n<line6>    boolean trustEmptyDB;\n<line7>    File initFile = new File(dataDir.getParent(), \"initialize\");\n<line8>    if (Files.deleteIfExists(initFile.toPath())) {\n<line9>        LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n<line10>        trustEmptyDB = true;\n<line11>    } else {\n<line12>        trustEmptyDB = autoCreateDB;\n<line13>    }\n<line14>    RestoreFinalizer finalizer = () -> {\n<line15>        long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n<line16>        // The snapshotZxidDigest will reset after replaying the txn of the\n<line17>        // zxid in the snapshotZxidDigest, if it's not reset to null after\n<line18>        // restoring, it means either there are not enough txns to cover that\n<line19>        // zxid or that txn is missing\n<line20>        DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n<line21>        if (snapshotZxidDigest != null) {\n<line22>            LOG.warn(\"Highest txn zxid 0x{} is not covering the snapshot digest zxid 0x{}, \" + \"which might lead to inconsistent state\", Long.toHexString(highestZxid), Long.toHexString(snapshotZxidDigest.getZxid()));\n<line23>        }\n<line24>        return highestZxid;\n<line25>    };\n<line26>    if (-1L == deserializeResult) {\n<line27>        /* this means that we couldn't find any snapshot, so we need to\n<line28>             * initialize an empty database (reported in ZOOKEEPER-2325) */\n<line29>        if (txnLog.getLastLoggedZxid() != -1) {\n<line30>            // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n<line31>            // from old versions of zookeeper (3.4.x, pre 3.5.3).\n<line32>            if (!trustEmptySnapshot) {\n<line33>                throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n<line34>            } else {\n<line35>                LOG.warn(\"{}This should only be allowed during upgrading.\", EMPTY_SNAPSHOT_WARNING);\n<line36>                return finalizer.run();\n<line37>            }\n<line38>        }\n<line39>        if (trustEmptyDB) {\n<line40>            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n<line41>                 *       or use Map on save() */\n<line42>            save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n<line43>            /* return a zxid of 0, since we know the database is empty */\n<line44>            return 0L;\n<line45>        } else {\n<line46>            /* return a zxid of -1, since we are possibly missing data */\n<line47>            LOG.warn(\"Unexpected empty data tree, setting zxid to -1\");\n<line48>            dt.lastProcessedZxid = -1L;\n<line49>            return -1L;\n<line50>        }\n<line51>    }\n<line52>    return finalizer.run();\n<line53>}"},{"input":"","instruction":"<line1>{\n<line2>    trustEmptyDB = true;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n<line3>    trustEmptyDB = true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);\n<line3>    long highestZxid = dt.lastProcessedZxid;\n<line4>    TxnHeader hdr;\n<line5>    int txnLoaded = 0;\n<line6>    long startTime = Time.currentElapsedTime();\n<line7>    try {\n<line8>        while (true) {\n<line9>            // iterator points to\n<line10>            // the first valid txn when initialized\n<line11>            hdr = itr.getHeader();\n<line12>            if (hdr == null) {\n<line13>                //empty logs\n<line14>                return dt.lastProcessedZxid;\n<line15>            }\n<line16>            if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n<line17>            } else {\n<line18>                highestZxid = hdr.getZxid();\n<line19>            }\n<line20>            try {\n<line21>                processTransaction(hdr, dt, sessions, itr.getTxn());\n<line22>                dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n<line23>                txnLoaded++;\n<line24>            } catch (KeeperException.NoNodeException e) {\n<line25>                throw new IOException(\"Failed to process transaction type: \" + hdr.getType() + \" error: \" + e.getMessage(), e);\n<line26>            }\n<line27>            listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n<line28>            if (!itr.next()) {\n<line29>                break;\n<line30>            }\n<line31>        }\n<line32>    } finally {\n<line33>        if (itr != null) {\n<line34>            itr.close();\n<line35>        }\n<line36>    }\n<line37>    long loadTime = Time.currentElapsedTime() - startTime;\n<line38>    ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);\n<line39>    ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);\n<line40>    return highestZxid;\n<line41>}","output":"<line1>{\n<line2>    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);\n<line3>    long highestZxid = dt.lastProcessedZxid;\n<line4>    TxnHeader hdr;\n<line5>    int txnLoaded = 0;\n<line6>    long startTime = Time.currentElapsedTime();\n<line7>    try {\n<line8>        while (true) {\n<line9>            // iterator points to\n<line10>            // the first valid txn when initialized\n<line11>            hdr = itr.getHeader();\n<line12>            if (hdr == null) {\n<line13>                //empty logs\n<line14>                return dt.lastProcessedZxid;\n<line15>            }\n<line16>            if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n<line17>                LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n<line18>            } else {\n<line19>                highestZxid = hdr.getZxid();\n<line20>            }\n<line21>            try {\n<line22>                processTransaction(hdr, dt, sessions, itr.getTxn());\n<line23>                dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n<line24>                txnLoaded++;\n<line25>            } catch (KeeperException.NoNodeException e) {\n<line26>                throw new IOException(\"Failed to process transaction type: \" + hdr.getType() + \" error: \" + e.getMessage(), e);\n<line27>            }\n<line28>            listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n<line29>            if (!itr.next()) {\n<line30>                break;\n<line31>            }\n<line32>        }\n<line33>    } finally {\n<line34>        if (itr != null) {\n<line35>            itr.close();\n<line36>        }\n<line37>    }\n<line38>    long loadTime = Time.currentElapsedTime() - startTime;\n<line39>    LOG.info(\"{} txns loaded in {} ms\", txnLoaded, loadTime);\n<line40>    ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);\n<line41>    ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);\n<line42>    return highestZxid;\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    while (true) {\n<line3>        // iterator points to\n<line4>        // the first valid txn when initialized\n<line5>        hdr = itr.getHeader();\n<line6>        if (hdr == null) {\n<line7>            //empty logs\n<line8>            return dt.lastProcessedZxid;\n<line9>        }\n<line10>        if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n<line11>        } else {\n<line12>            highestZxid = hdr.getZxid();\n<line13>        }\n<line14>        try {\n<line15>            processTransaction(hdr, dt, sessions, itr.getTxn());\n<line16>            dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n<line17>            txnLoaded++;\n<line18>        } catch (KeeperException.NoNodeException e) {\n<line19>            throw new IOException(\"Failed to process transaction type: \" + hdr.getType() + \" error: \" + e.getMessage(), e);\n<line20>        }\n<line21>        listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n<line22>        if (!itr.next()) {\n<line23>            break;\n<line24>        }\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    while (true) {\n<line3>        // iterator points to\n<line4>        // the first valid txn when initialized\n<line5>        hdr = itr.getHeader();\n<line6>        if (hdr == null) {\n<line7>            //empty logs\n<line8>            return dt.lastProcessedZxid;\n<line9>        }\n<line10>        if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n<line11>            LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n<line12>        } else {\n<line13>            highestZxid = hdr.getZxid();\n<line14>        }\n<line15>        try {\n<line16>            processTransaction(hdr, dt, sessions, itr.getTxn());\n<line17>            dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n<line18>            txnLoaded++;\n<line19>        } catch (KeeperException.NoNodeException e) {\n<line20>            throw new IOException(\"Failed to process transaction type: \" + hdr.getType() + \" error: \" + e.getMessage(), e);\n<line21>        }\n<line22>        listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n<line23>        if (!itr.next()) {\n<line24>            break;\n<line25>        }\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    // iterator points to\n<line3>    // the first valid txn when initialized\n<line4>    hdr = itr.getHeader();\n<line5>    if (hdr == null) {\n<line6>        //empty logs\n<line7>        return dt.lastProcessedZxid;\n<line8>    }\n<line9>    if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n<line10>    } else {\n<line11>        highestZxid = hdr.getZxid();\n<line12>    }\n<line13>    try {\n<line14>        processTransaction(hdr, dt, sessions, itr.getTxn());\n<line15>        dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n<line16>        txnLoaded++;\n<line17>    } catch (KeeperException.NoNodeException e) {\n<line18>        throw new IOException(\"Failed to process transaction type: \" + hdr.getType() + \" error: \" + e.getMessage(), e);\n<line19>    }\n<line20>    listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n<line21>    if (!itr.next()) {\n<line22>        break;\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    // iterator points to\n<line3>    // the first valid txn when initialized\n<line4>    hdr = itr.getHeader();\n<line5>    if (hdr == null) {\n<line6>        //empty logs\n<line7>        return dt.lastProcessedZxid;\n<line8>    }\n<line9>    if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n<line10>        LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n<line11>    } else {\n<line12>        highestZxid = hdr.getZxid();\n<line13>    }\n<line14>    try {\n<line15>        processTransaction(hdr, dt, sessions, itr.getTxn());\n<line16>        dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n<line17>        txnLoaded++;\n<line18>    } catch (KeeperException.NoNodeException e) {\n<line19>        throw new IOException(\"Failed to process transaction type: \" + hdr.getType() + \" error: \" + e.getMessage(), e);\n<line20>    }\n<line21>    listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n<line22>    if (!itr.next()) {\n<line23>        break;\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ProcessTxnResult rc;\n<line3>    switch(hdr.getType()) {\n<line4>        case OpCode.createSession:\n<line5>            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());\n<line6>                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"playLog --- create session in log: 0x\" + Long.toHexString(hdr.getClientId()) + \" with timeout: \" + ((CreateSessionTxn) txn).getTimeOut());\n<line7>            }\n<line8>            // give dataTree a chance to sync its lastProcessedZxid\n<line9>            rc = dt.processTxn(hdr, txn);\n<line10>            break;\n<line11>        case OpCode.closeSession:\n<line12>            sessions.remove(hdr.getClientId());\n<line13>                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"playLog --- close session in log: 0x\" + Long.toHexString(hdr.getClientId()));\n<line14>            }\n<line15>            rc = dt.processTxn(hdr, txn);\n<line16>            break;\n<line17>        default:\n<line18>            rc = dt.processTxn(hdr, txn);\n<line19>    }\n<line20>    /*\n<line21>         * Snapshots are lazily created. So when a snapshot is in progress,\n<line22>         * there is a chance for later transactions to make into the\n<line23>         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n<line24>         * errors could occur. It should be safe to ignore these.\n<line25>         */\n<line26>    if (rc.err != Code.OK.intValue()) {\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    ProcessTxnResult rc;\n<line3>    switch(hdr.getType()) {\n<line4>        case OpCode.createSession:\n<line5>            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());\n<line6>            if (LOG.isTraceEnabled()) {\n<line7>                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"playLog --- create session in log: 0x\" + Long.toHexString(hdr.getClientId()) + \" with timeout: \" + ((CreateSessionTxn) txn).getTimeOut());\n<line8>            }\n<line9>            // give dataTree a chance to sync its lastProcessedZxid\n<line10>            rc = dt.processTxn(hdr, txn);\n<line11>            break;\n<line12>        case OpCode.closeSession:\n<line13>            sessions.remove(hdr.getClientId());\n<line14>            if (LOG.isTraceEnabled()) {\n<line15>                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"playLog --- close session in log: 0x\" + Long.toHexString(hdr.getClientId()));\n<line16>            }\n<line17>            rc = dt.processTxn(hdr, txn);\n<line18>            break;\n<line19>        default:\n<line20>            rc = dt.processTxn(hdr, txn);\n<line21>    }\n<line22>    /*\n<line23>         * Snapshots are lazily created. So when a snapshot is in progress,\n<line24>         * there is a chance for later transactions to make into the\n<line25>         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n<line26>         * errors could occur. It should be safe to ignore these.\n<line27>         */\n<line28>    if (rc.err != Code.OK.intValue()) {\n<line29>        LOG.debug(\"Ignoring processTxn failure hdr: {}, error: {}, path: {}\", hdr.getType(), rc.err, rc.path);\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring processTxn failure hdr: {}, error: {}, path: {}\", hdr.getType(), rc.err, rc.path);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    long lastZxid = dataTree.lastProcessedZxid;\n<line3>    File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));\n<line4>    try {\n<line5>        snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);\n<line6>        return snapshotFile;\n<line7>    } catch (IOException e) {\n<line8>        if (snapshotFile.length() == 0) {\n<line9>            /* This may be caused by a full disk. In such a case, the server\n<line10>                 * will get stuck in a loop where it tries to write a snapshot\n<line11>                 * out to disk, and ends up creating an empty file instead.\n<line12>                 * Doing so will eventually result in valid snapshots being\n<line13>                 * removed during cleanup. */\n<line14>            if (snapshotFile.delete()) {\n<line15>            } else {\n<line16>            }\n<line17>        } else {\n<line18>            /* Something else went wrong when writing the snapshot out to\n<line19>                 * disk. If this snapshot file is invalid, when restarting,\n<line20>                 * ZooKeeper will skip it, and find the last known good snapshot\n<line21>                 * instead. */\n<line22>        }\n<line23>        throw e;\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    long lastZxid = dataTree.lastProcessedZxid;\n<line3>    File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));\n<line4>    LOG.info(\"Snapshotting: 0x{} to {}\", Long.toHexString(lastZxid), snapshotFile);\n<line5>    try {\n<line6>        snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);\n<line7>        return snapshotFile;\n<line8>    } catch (IOException e) {\n<line9>        if (snapshotFile.length() == 0) {\n<line10>            /* This may be caused by a full disk. In such a case, the server\n<line11>                 * will get stuck in a loop where it tries to write a snapshot\n<line12>                 * out to disk, and ends up creating an empty file instead.\n<line13>                 * Doing so will eventually result in valid snapshots being\n<line14>                 * removed during cleanup. */\n<line15>            if (snapshotFile.delete()) {\n<line16>                LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line17>            } else {\n<line18>                LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line19>            }\n<line20>        } else {\n<line21>            /* Something else went wrong when writing the snapshot out to\n<line22>                 * disk. If this snapshot file is invalid, when restarting,\n<line23>                 * ZooKeeper will skip it, and find the last known good snapshot\n<line24>                 * instead. */\n<line25>        }\n<line26>        throw e;\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    if (snapshotFile.length() == 0) {\n<line3>        /* This may be caused by a full disk. In such a case, the server\n<line4>                 * will get stuck in a loop where it tries to write a snapshot\n<line5>                 * out to disk, and ends up creating an empty file instead.\n<line6>                 * Doing so will eventually result in valid snapshots being\n<line7>                 * removed during cleanup. */\n<line8>        if (snapshotFile.delete()) {\n<line9>        } else {\n<line10>        }\n<line11>    } else {\n<line12>        /* Something else went wrong when writing the snapshot out to\n<line13>                 * disk. If this snapshot file is invalid, when restarting,\n<line14>                 * ZooKeeper will skip it, and find the last known good snapshot\n<line15>                 * instead. */\n<line16>    }\n<line17>    throw e;\n<line18>}","output":"<line1>{\n<line2>    if (snapshotFile.length() == 0) {\n<line3>        /* This may be caused by a full disk. In such a case, the server\n<line4>                 * will get stuck in a loop where it tries to write a snapshot\n<line5>                 * out to disk, and ends up creating an empty file instead.\n<line6>                 * Doing so will eventually result in valid snapshots being\n<line7>                 * removed during cleanup. */\n<line8>        if (snapshotFile.delete()) {\n<line9>            LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line10>        } else {\n<line11>            LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line12>        }\n<line13>    } else {\n<line14>        /* Something else went wrong when writing the snapshot out to\n<line15>                 * disk. If this snapshot file is invalid, when restarting,\n<line16>                 * ZooKeeper will skip it, and find the last known good snapshot\n<line17>                 * instead. */\n<line18>    }\n<line19>    throw e;\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    /* This may be caused by a full disk. In such a case, the server\n<line3>                 * will get stuck in a loop where it tries to write a snapshot\n<line4>                 * out to disk, and ends up creating an empty file instead.\n<line5>                 * Doing so will eventually result in valid snapshots being\n<line6>                 * removed during cleanup. */\n<line7>    if (snapshotFile.delete()) {\n<line8>    } else {\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    /* This may be caused by a full disk. In such a case, the server\n<line3>                 * will get stuck in a loop where it tries to write a snapshot\n<line4>                 * out to disk, and ends up creating an empty file instead.\n<line5>                 * Doing so will eventually result in valid snapshots being\n<line6>                 * removed during cleanup. */\n<line7>    if (snapshotFile.delete()) {\n<line8>        LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line9>    } else {\n<line10>        LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // close the existing txnLog and snapLog\n<line4>        close();\n<line5>        // truncate it\n<line6>        try (FileTxnLog truncLog = new FileTxnLog(dataDir)) {\n<line7>            boolean truncated = truncLog.truncate(zxid);\n<line8>            // re-open the txnLog and snapLog\n<line9>            // I'd rather just close/reopen this object itself, however that\n<line10>            // would have a big impact outside ZKDatabase as there are other\n<line11>            // objects holding a reference to this object.\n<line12>            txnLog = new FileTxnLog(dataDir);\n<line13>            snapLog = new FileSnap(snapDir);\n<line14>            return truncated;\n<line15>        }\n<line16>    } catch (IOException e) {\n<line17>        return false;\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    try {\n<line3>        // close the existing txnLog and snapLog\n<line4>        close();\n<line5>        // truncate it\n<line6>        try (FileTxnLog truncLog = new FileTxnLog(dataDir)) {\n<line7>            boolean truncated = truncLog.truncate(zxid);\n<line8>            // re-open the txnLog and snapLog\n<line9>            // I'd rather just close/reopen this object itself, however that\n<line10>            // would have a big impact outside ZKDatabase as there are other\n<line11>            // objects holding a reference to this object.\n<line12>            txnLog = new FileTxnLog(dataDir);\n<line13>            snapLog = new FileSnap(snapDir);\n<line14>            return truncated;\n<line15>        }\n<line16>    } catch (IOException e) {\n<line17>        LOG.error(\"Unable to truncate Txn log\", e);\n<line18>        return false;\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to truncate Txn log\", e);\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // we run through 100 snapshots (not all of them)\n<line3>    // if we cannot get it running within 100 snapshots\n<line4>    // we should  give up\n<line5>    List<File> snapList = findNValidSnapshots(100);\n<line6>    if (snapList.size() == 0) {\n<line7>        return -1L;\n<line8>    }\n<line9>    File snap = null;\n<line10>    long snapZxid = -1;\n<line11>    boolean foundValid = false;\n<line12>    for (int i = 0, snapListSize = snapList.size(); i < snapListSize; i++) {\n<line13>        snap = snapList.get(i);\n<line14>        snapZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);\n<line15>        try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {\n<line16>            InputArchive ia = BinaryInputArchive.getArchive(snapIS);\n<line17>            deserialize(dt, sessions, ia);\n<line18>            SnapStream.checkSealIntegrity(snapIS, ia);\n<line19>            // Digest feature was added after the CRC to make it backward\n<line20>            // compatible, the older code can still read snapshots which\n<line21>            // includes digest.\n<line22>            //\n<line23>            // To check the intact, after adding digest we added another\n<line24>            // CRC check.\n<line25>            if (dt.deserializeZxidDigest(ia, snapZxid)) {\n<line26>                SnapStream.checkSealIntegrity(snapIS, ia);\n<line27>            }\n<line28>            // deserialize lastProcessedZxid and check inconsistency\n<line29>            if (dt.deserializeLastProcessedZxid(ia)) {\n<line30>                SnapStream.checkSealIntegrity(snapIS, ia);\n<line31>            }\n<line32>            foundValid = true;\n<line33>            break;\n<line34>        } catch (IOException e) {\n<line35>        }\n<line36>    }\n<line37>    if (!foundValid) {\n<line38>        throw new IOException(\"Not able to find valid snapshots in \" + snapDir);\n<line39>    }\n<line40>    dt.lastProcessedZxid = snapZxid;\n<line41>    lastSnapshotInfo = new SnapshotInfo(dt.lastProcessedZxid, snap.lastModified() / 1000);\n<line42>    // compare the digest if this is not a fuzzy snapshot, we want to compare\n<line43>    // and find inconsistent asap.\n<line44>    if (dt.getDigestFromLoadedSnapshot() != null) {\n<line45>        dt.compareSnapshotDigests(dt.lastProcessedZxid);\n<line46>    }\n<line47>    return dt.lastProcessedZxid;\n<line48>}","output":"<line1>{\n<line2>    // we run through 100 snapshots (not all of them)\n<line3>    // if we cannot get it running within 100 snapshots\n<line4>    // we should  give up\n<line5>    List<File> snapList = findNValidSnapshots(100);\n<line6>    if (snapList.size() == 0) {\n<line7>        return -1L;\n<line8>    }\n<line9>    File snap = null;\n<line10>    long snapZxid = -1;\n<line11>    boolean foundValid = false;\n<line12>    for (int i = 0, snapListSize = snapList.size(); i < snapListSize; i++) {\n<line13>        snap = snapList.get(i);\n<line14>        LOG.info(\"Reading snapshot {}\", snap);\n<line15>        snapZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);\n<line16>        try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {\n<line17>            InputArchive ia = BinaryInputArchive.getArchive(snapIS);\n<line18>            deserialize(dt, sessions, ia);\n<line19>            SnapStream.checkSealIntegrity(snapIS, ia);\n<line20>            // Digest feature was added after the CRC to make it backward\n<line21>            // compatible, the older code can still read snapshots which\n<line22>            // includes digest.\n<line23>            //\n<line24>            // To check the intact, after adding digest we added another\n<line25>            // CRC check.\n<line26>            if (dt.deserializeZxidDigest(ia, snapZxid)) {\n<line27>                SnapStream.checkSealIntegrity(snapIS, ia);\n<line28>            }\n<line29>            // deserialize lastProcessedZxid and check inconsistency\n<line30>            if (dt.deserializeLastProcessedZxid(ia)) {\n<line31>                SnapStream.checkSealIntegrity(snapIS, ia);\n<line32>            }\n<line33>            foundValid = true;\n<line34>            break;\n<line35>        } catch (IOException e) {\n<line36>            LOG.warn(\"problem reading snap file {}\", snap, e);\n<line37>        }\n<line38>    }\n<line39>    if (!foundValid) {\n<line40>        throw new IOException(\"Not able to find valid snapshots in \" + snapDir);\n<line41>    }\n<line42>    dt.lastProcessedZxid = snapZxid;\n<line43>    lastSnapshotInfo = new SnapshotInfo(dt.lastProcessedZxid, snap.lastModified() / 1000);\n<line44>    // compare the digest if this is not a fuzzy snapshot, we want to compare\n<line45>    // and find inconsistent asap.\n<line46>    if (dt.getDigestFromLoadedSnapshot() != null) {\n<line47>        dt.compareSnapshotDigests(dt.lastProcessedZxid);\n<line48>    }\n<line49>    return dt.lastProcessedZxid;\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>    snap = snapList.get(i);\n<line3>    snapZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);\n<line4>    try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {\n<line5>        InputArchive ia = BinaryInputArchive.getArchive(snapIS);\n<line6>        deserialize(dt, sessions, ia);\n<line7>        SnapStream.checkSealIntegrity(snapIS, ia);\n<line8>        // Digest feature was added after the CRC to make it backward\n<line9>        // compatible, the older code can still read snapshots which\n<line10>        // includes digest.\n<line11>        //\n<line12>        // To check the intact, after adding digest we added another\n<line13>        // CRC check.\n<line14>        if (dt.deserializeZxidDigest(ia, snapZxid)) {\n<line15>            SnapStream.checkSealIntegrity(snapIS, ia);\n<line16>        }\n<line17>        // deserialize lastProcessedZxid and check inconsistency\n<line18>        if (dt.deserializeLastProcessedZxid(ia)) {\n<line19>            SnapStream.checkSealIntegrity(snapIS, ia);\n<line20>        }\n<line21>        foundValid = true;\n<line22>        break;\n<line23>    } catch (IOException e) {\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    snap = snapList.get(i);\n<line3>    LOG.info(\"Reading snapshot {}\", snap);\n<line4>    snapZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);\n<line5>    try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {\n<line6>        InputArchive ia = BinaryInputArchive.getArchive(snapIS);\n<line7>        deserialize(dt, sessions, ia);\n<line8>        SnapStream.checkSealIntegrity(snapIS, ia);\n<line9>        // Digest feature was added after the CRC to make it backward\n<line10>        // compatible, the older code can still read snapshots which\n<line11>        // includes digest.\n<line12>        //\n<line13>        // To check the intact, after adding digest we added another\n<line14>        // CRC check.\n<line15>        if (dt.deserializeZxidDigest(ia, snapZxid)) {\n<line16>            SnapStream.checkSealIntegrity(snapIS, ia);\n<line17>        }\n<line18>        // deserialize lastProcessedZxid and check inconsistency\n<line19>        if (dt.deserializeLastProcessedZxid(ia)) {\n<line20>            SnapStream.checkSealIntegrity(snapIS, ia);\n<line21>        }\n<line22>        foundValid = true;\n<line23>        break;\n<line24>    } catch (IOException e) {\n<line25>        LOG.warn(\"problem reading snap file {}\", snap, e);\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    LOG = LoggerFactory.getLogger(FileTxnLog.class);\n<line3>    /**\n<line4>     * Local variable to read fsync.warningthresholdms into\n<line5>     */\n<line6>    Long fsyncWarningThreshold;\n<line7>    if ((fsyncWarningThreshold = Long.getLong(ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY)) == null) {\n<line8>        fsyncWarningThreshold = Long.getLong(FSYNC_WARNING_THRESHOLD_MS_PROPERTY, 1000);\n<line9>    }\n<line10>    fsyncWarningThresholdMS = fsyncWarningThreshold;\n<line11>    Long logSize = Long.getLong(txnLogSizeLimitSetting, -1);\n<line12>    if (logSize > 0) {\n<line13>        // Convert to bytes\n<line14>        logSize = logSize * 1024;\n<line15>        txnLogSizeLimit = logSize;\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    LOG = LoggerFactory.getLogger(FileTxnLog.class);\n<line3>    /**\n<line4>     * Local variable to read fsync.warningthresholdms into\n<line5>     */\n<line6>    Long fsyncWarningThreshold;\n<line7>    if ((fsyncWarningThreshold = Long.getLong(ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY)) == null) {\n<line8>        fsyncWarningThreshold = Long.getLong(FSYNC_WARNING_THRESHOLD_MS_PROPERTY, 1000);\n<line9>    }\n<line10>    fsyncWarningThresholdMS = fsyncWarningThreshold;\n<line11>    Long logSize = Long.getLong(txnLogSizeLimitSetting, -1);\n<line12>    if (logSize > 0) {\n<line13>        LOG.info(\"{} = {}\", txnLogSizeLimitSetting, logSize);\n<line14>        // Convert to bytes\n<line15>        logSize = logSize * 1024;\n<line16>        txnLogSizeLimit = logSize;\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    // Convert to bytes\n<line3>    logSize = logSize * 1024;\n<line4>    txnLogSizeLimit = logSize;\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {}\", txnLogSizeLimitSetting, logSize);\n<line3>    // Convert to bytes\n<line4>    logSize = logSize * 1024;\n<line5>    txnLogSizeLimit = logSize;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    TxnHeader hdr = request.getHdr();\n<line3>    if (hdr == null) {\n<line4>        return false;\n<line5>    }\n<line6>    if (hdr.getZxid() <= lastZxidSeen) {\n<line7>    } else {\n<line8>        lastZxidSeen = hdr.getZxid();\n<line9>    }\n<line10>    if (logStream == null) {\n<line11>        logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));\n<line12>        fos = new FileOutputStream(logFileWrite);\n<line13>        logStream = new BufferedOutputStream(fos);\n<line14>        oa = BinaryOutputArchive.getArchive(logStream);\n<line15>        FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);\n<line16>        long dataSize = oa.getDataSize();\n<line17>        fhdr.serialize(oa, \"fileheader\");\n<line18>        // Make sure that the magic number is written before padding.\n<line19>        logStream.flush();\n<line20>        // Before writing data, first obtain the size of the OutputArchive.\n<line21>        // After writing the data, obtain the size of the OutputArchive again,\n<line22>        // so we can obtain the size of the data written this time.\n<line23>        // In this case, the data already flush into the channel, so add the size to filePosition.\n<line24>        filePosition += oa.getDataSize() - dataSize;\n<line25>        filePadding.setCurrentSize(filePosition);\n<line26>        streamsToFlush.add(fos);\n<line27>    }\n<line28>    fileSize = filePadding.padFile(fos.getChannel(), filePosition);\n<line29>    byte[] buf = request.getSerializeData();\n<line30>    if (buf == null || buf.length == 0) {\n<line31>        throw new IOException(\"Faulty serialization for header \" + \"and txn\");\n<line32>    }\n<line33>    long dataSize = oa.getDataSize();\n<line34>    Checksum crc = makeChecksumAlgorithm();\n<line35>    crc.update(buf, 0, buf.length);\n<line36>    oa.writeLong(crc.getValue(), \"txnEntryCRC\");\n<line37>    Util.writeTxnBytes(oa, buf);\n<line38>    // Before writing data, first obtain the size of the OutputArchive.\n<line39>    // After writing the data, obtain the size of the OutputArchive again,\n<line40>    // so we can obtain the size of the data written this time.\n<line41>    // In this case, the data just write to the cache, not flushed, so add the size to unFlushedSize.\n<line42>    // After flushed, the unFlushedSize will add to the filePosition.\n<line43>    unFlushedSize += oa.getDataSize() - dataSize;\n<line44>    return true;\n<line45>}","output":"<line1>{\n<line2>    TxnHeader hdr = request.getHdr();\n<line3>    if (hdr == null) {\n<line4>        return false;\n<line5>    }\n<line6>    if (hdr.getZxid() <= lastZxidSeen) {\n<line7>        LOG.warn(\"Current zxid {} is <= {} for {}\", hdr.getZxid(), lastZxidSeen, Request.op2String(hdr.getType()));\n<line8>    } else {\n<line9>        lastZxidSeen = hdr.getZxid();\n<line10>    }\n<line11>    if (logStream == null) {\n<line12>        LOG.info(\"Creating new log file: {}\", Util.makeLogName(hdr.getZxid()));\n<line13>        logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));\n<line14>        fos = new FileOutputStream(logFileWrite);\n<line15>        logStream = new BufferedOutputStream(fos);\n<line16>        oa = BinaryOutputArchive.getArchive(logStream);\n<line17>        FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);\n<line18>        long dataSize = oa.getDataSize();\n<line19>        fhdr.serialize(oa, \"fileheader\");\n<line20>        // Make sure that the magic number is written before padding.\n<line21>        logStream.flush();\n<line22>        // Before writing data, first obtain the size of the OutputArchive.\n<line23>        // After writing the data, obtain the size of the OutputArchive again,\n<line24>        // so we can obtain the size of the data written this time.\n<line25>        // In this case, the data already flush into the channel, so add the size to filePosition.\n<line26>        filePosition += oa.getDataSize() - dataSize;\n<line27>        filePadding.setCurrentSize(filePosition);\n<line28>        streamsToFlush.add(fos);\n<line29>    }\n<line30>    fileSize = filePadding.padFile(fos.getChannel(), filePosition);\n<line31>    byte[] buf = request.getSerializeData();\n<line32>    if (buf == null || buf.length == 0) {\n<line33>        throw new IOException(\"Faulty serialization for header \" + \"and txn\");\n<line34>    }\n<line35>    long dataSize = oa.getDataSize();\n<line36>    Checksum crc = makeChecksumAlgorithm();\n<line37>    crc.update(buf, 0, buf.length);\n<line38>    oa.writeLong(crc.getValue(), \"txnEntryCRC\");\n<line39>    Util.writeTxnBytes(oa, buf);\n<line40>    // Before writing data, first obtain the size of the OutputArchive.\n<line41>    // After writing the data, obtain the size of the OutputArchive again,\n<line42>    // so we can obtain the size of the data written this time.\n<line43>    // In this case, the data just write to the cache, not flushed, so add the size to unFlushedSize.\n<line44>    // After flushed, the unFlushedSize will add to the filePosition.\n<line45>    unFlushedSize += oa.getDataSize() - dataSize;\n<line46>    return true;\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));\n<line3>    fos = new FileOutputStream(logFileWrite);\n<line4>    logStream = new BufferedOutputStream(fos);\n<line5>    oa = BinaryOutputArchive.getArchive(logStream);\n<line6>    FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);\n<line7>    long dataSize = oa.getDataSize();\n<line8>    fhdr.serialize(oa, \"fileheader\");\n<line9>    // Make sure that the magic number is written before padding.\n<line10>    logStream.flush();\n<line11>    // Before writing data, first obtain the size of the OutputArchive.\n<line12>    // After writing the data, obtain the size of the OutputArchive again,\n<line13>    // so we can obtain the size of the data written this time.\n<line14>    // In this case, the data already flush into the channel, so add the size to filePosition.\n<line15>    filePosition += oa.getDataSize() - dataSize;\n<line16>    filePadding.setCurrentSize(filePosition);\n<line17>    streamsToFlush.add(fos);\n<line18>}","output":"<line1>{\n<line2>    LOG.info(\"Creating new log file: {}\", Util.makeLogName(hdr.getZxid()));\n<line3>    logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));\n<line4>    fos = new FileOutputStream(logFileWrite);\n<line5>    logStream = new BufferedOutputStream(fos);\n<line6>    oa = BinaryOutputArchive.getArchive(logStream);\n<line7>    FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);\n<line8>    long dataSize = oa.getDataSize();\n<line9>    fhdr.serialize(oa, \"fileheader\");\n<line10>    // Make sure that the magic number is written before padding.\n<line11>    logStream.flush();\n<line12>    // Before writing data, first obtain the size of the OutputArchive.\n<line13>    // After writing the data, obtain the size of the OutputArchive again,\n<line14>    // so we can obtain the size of the data written this time.\n<line15>    // In this case, the data already flush into the channel, so add the size to filePosition.\n<line16>    filePosition += oa.getDataSize() - dataSize;\n<line17>    filePadding.setCurrentSize(filePosition);\n<line18>    streamsToFlush.add(fos);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (logStream != null) {\n<line3>        logStream.flush();\n<line4>        filePosition += unFlushedSize;\n<line5>        // If we have written more than we have previously preallocated,\n<line6>        // we should override the fileSize by filePosition.\n<line7>        if (filePosition > fileSize) {\n<line8>            fileSize = filePosition;\n<line9>        }\n<line10>        unFlushedSize = 0;\n<line11>    }\n<line12>    for (FileOutputStream log : streamsToFlush) {\n<line13>        if (forceSync) {\n<line14>            long startSyncNS = System.nanoTime();\n<line15>            channel.force(false);\n<line16>            syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);\n<line17>            if (syncElapsedMS > fsyncWarningThresholdMS) {\n<line18>                if (serverStats != null) {\n<line19>                    serverStats.incrementFsyncThresholdExceedCount();\n<line20>                }\n<line21>            }\n<line22>            ServerMetrics.getMetrics().FSYNC_TIME.add(syncElapsedMS);\n<line23>        }\n<line24>    }\n<line25>    while (streamsToFlush.size() > 1) {\n<line26>        streamsToFlush.poll().close();\n<line27>    }\n<line28>    // Roll the log file if we exceed the size limit\n<line29>    if (txnLogSizeLimit > 0) {\n<line30>        long logSize = getCurrentLogSize();\n<line31>        if (logSize > txnLogSizeLimit) {\n<line32>            rollLog();\n<line33>        }\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    if (logStream != null) {\n<line3>        logStream.flush();\n<line4>        filePosition += unFlushedSize;\n<line5>        // If we have written more than we have previously preallocated,\n<line6>        // we should override the fileSize by filePosition.\n<line7>        if (filePosition > fileSize) {\n<line8>            fileSize = filePosition;\n<line9>        }\n<line10>        unFlushedSize = 0;\n<line11>    }\n<line12>    for (FileOutputStream log : streamsToFlush) {\n<line13>        log.flush();\n<line14>        if (forceSync) {\n<line15>            long startSyncNS = System.nanoTime();\n<line16>            FileChannel channel = log.getChannel();\n<line17>            channel.force(false);\n<line18>            syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);\n<line19>            if (syncElapsedMS > fsyncWarningThresholdMS) {\n<line20>                if (serverStats != null) {\n<line21>                    serverStats.incrementFsyncThresholdExceedCount();\n<line22>                }\n<line23>                LOG.warn(\"fsync-ing the write ahead log in {} took {}ms which will adversely effect operation latency.\" + \"File size is {} bytes. See the ZooKeeper troubleshooting guide\", Thread.currentThread().getName(), syncElapsedMS, channel.size());\n<line24>            }\n<line25>            ServerMetrics.getMetrics().FSYNC_TIME.add(syncElapsedMS);\n<line26>        }\n<line27>    }\n<line28>    while (streamsToFlush.size() > 1) {\n<line29>        streamsToFlush.poll().close();\n<line30>    }\n<line31>    // Roll the log file if we exceed the size limit\n<line32>    if (txnLogSizeLimit > 0) {\n<line33>        long logSize = getCurrentLogSize();\n<line34>        if (logSize > txnLogSizeLimit) {\n<line35>            LOG.debug(\"Log size limit reached: {}\", logSize);\n<line36>            rollLog();\n<line37>        }\n<line38>    }\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    long logSize = getCurrentLogSize();\n<line3>    if (logSize > txnLogSizeLimit) {\n<line4>        rollLog();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    long logSize = getCurrentLogSize();\n<line3>    if (logSize > txnLogSizeLimit) {\n<line4>        LOG.debug(\"Log size limit reached: {}\", logSize);\n<line5>        rollLog();\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    rollLog();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Log size limit reached: {}\", logSize);\n<line3>    rollLog();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (inputStream == null) {\n<line3>        inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));\n<line4>        ia = BinaryInputArchive.getArchive(inputStream);\n<line5>        inStreamCreated(ia, inputStream);\n<line6>    }\n<line7>    return ia;\n<line8>}","output":"<line1>{\n<line2>    if (inputStream == null) {\n<line3>        inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));\n<line4>        LOG.debug(\"Created new input stream: {}\", logFile);\n<line5>        ia = BinaryInputArchive.getArchive(inputStream);\n<line6>        inStreamCreated(ia, inputStream);\n<line7>        LOG.debug(\"Created new input archive: {}\", logFile);\n<line8>    }\n<line9>    return ia;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));\n<line3>    ia = BinaryInputArchive.getArchive(inputStream);\n<line4>    inStreamCreated(ia, inputStream);\n<line5>}","output":"<line1>{\n<line2>    inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));\n<line3>    LOG.debug(\"Created new input stream: {}\", logFile);\n<line4>    ia = BinaryInputArchive.getArchive(inputStream);\n<line5>    inStreamCreated(ia, inputStream);\n<line6>    LOG.debug(\"Created new input archive: {}\", logFile);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (ia == null) {\n<line3>        return false;\n<line4>    }\n<line5>    try {\n<line6>        long crcValue = ia.readLong(\"crcvalue\");\n<line7>        byte[] bytes = Util.readTxnBytes(ia);\n<line8>        // Since we preallocate, we define EOF to be an\n<line9>        if (bytes == null || bytes.length == 0) {\n<line10>            throw new EOFException(\"Failed to read \" + logFile);\n<line11>        }\n<line12>        // EOF or corrupted record\n<line13>        // validate CRC\n<line14>        Checksum crc = makeChecksumAlgorithm();\n<line15>        crc.update(bytes, 0, bytes.length);\n<line16>        if (crcValue != crc.getValue()) {\n<line17>            throw new IOException(CRC_ERROR);\n<line18>        }\n<line19>        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n<line20>        hdr = logEntry.getHeader();\n<line21>        record = logEntry.getTxn();\n<line22>        digest = logEntry.getDigest();\n<line23>    } catch (EOFException e) {\n<line24>        inputStream.close();\n<line25>        inputStream = null;\n<line26>        ia = null;\n<line27>        hdr = null;\n<line28>        // this means that the file has ended\n<line29>        // we should go to the next file\n<line30>        if (!goToNextLog()) {\n<line31>            return false;\n<line32>        }\n<line33>        // if we went to the next log file, we should call next() again\n<line34>        return next();\n<line35>    } catch (IOException e) {\n<line36>        inputStream.close();\n<line37>        throw e;\n<line38>    }\n<line39>    return true;\n<line40>}","output":"<line1>{\n<line2>    if (ia == null) {\n<line3>        return false;\n<line4>    }\n<line5>    try {\n<line6>        long crcValue = ia.readLong(\"crcvalue\");\n<line7>        byte[] bytes = Util.readTxnBytes(ia);\n<line8>        // Since we preallocate, we define EOF to be an\n<line9>        if (bytes == null || bytes.length == 0) {\n<line10>            throw new EOFException(\"Failed to read \" + logFile);\n<line11>        }\n<line12>        // EOF or corrupted record\n<line13>        // validate CRC\n<line14>        Checksum crc = makeChecksumAlgorithm();\n<line15>        crc.update(bytes, 0, bytes.length);\n<line16>        if (crcValue != crc.getValue()) {\n<line17>            throw new IOException(CRC_ERROR);\n<line18>        }\n<line19>        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n<line20>        hdr = logEntry.getHeader();\n<line21>        record = logEntry.getTxn();\n<line22>        digest = logEntry.getDigest();\n<line23>    } catch (EOFException e) {\n<line24>        LOG.debug(\"EOF exception\", e);\n<line25>        inputStream.close();\n<line26>        inputStream = null;\n<line27>        ia = null;\n<line28>        hdr = null;\n<line29>        // this means that the file has ended\n<line30>        // we should go to the next file\n<line31>        if (!goToNextLog()) {\n<line32>            return false;\n<line33>        }\n<line34>        // if we went to the next log file, we should call next() again\n<line35>        return next();\n<line36>    } catch (IOException e) {\n<line37>        inputStream.close();\n<line38>        throw e;\n<line39>    }\n<line40>    return true;\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    inputStream.close();\n<line3>    inputStream = null;\n<line4>    ia = null;\n<line5>    hdr = null;\n<line6>    // this means that the file has ended\n<line7>    // we should go to the next file\n<line8>    if (!goToNextLog()) {\n<line9>        return false;\n<line10>    }\n<line11>    // if we went to the next log file, we should call next() again\n<line12>    return next();\n<line13>}","output":"<line1>{\n<line2>    LOG.debug(\"EOF exception\", e);\n<line3>    inputStream.close();\n<line4>    inputStream = null;\n<line5>    ia = null;\n<line6>    hdr = null;\n<line7>    // this means that the file has ended\n<line8>    // we should go to the next file\n<line9>    if (!goToNextLog()) {\n<line10>        return false;\n<line11>    }\n<line12>    // if we went to the next log file, we should call next() again\n<line13>    return next();\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {}\", ZOOKEEPER_SHAPSHOT_STREAM_MODE, streamMode);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] byteArray = new byte[2];\n<line3>    try (FileInputStream fis = new FileInputStream(f)) {\n<line4>        if (2 != fis.read(byteArray, 0, 2)) {\n<line5>            return false;\n<line6>        }\n<line7>        ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line8>        byte[] magicHeader = new byte[2];\n<line9>        bb.get(magicHeader, 0, 2);\n<line10>        int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);\n<line11>        return magic == GZIPInputStream.GZIP_MAGIC;\n<line12>    } catch (FileNotFoundException e) {\n<line13>        return false;\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    byte[] byteArray = new byte[2];\n<line3>    try (FileInputStream fis = new FileInputStream(f)) {\n<line4>        if (2 != fis.read(byteArray, 0, 2)) {\n<line5>            LOG.error(\"Read incorrect number of bytes from {}\", f.getName());\n<line6>            return false;\n<line7>        }\n<line8>        ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line9>        byte[] magicHeader = new byte[2];\n<line10>        bb.get(magicHeader, 0, 2);\n<line11>        int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);\n<line12>        return magic == GZIPInputStream.GZIP_MAGIC;\n<line13>    } catch (FileNotFoundException e) {\n<line14>        LOG.error(\"Unable to open file {}\", f.getName(), e);\n<line15>        return false;\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    if (2 != fis.read(byteArray, 0, 2)) {\n<line3>        return false;\n<line4>    }\n<line5>    ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line6>    byte[] magicHeader = new byte[2];\n<line7>    bb.get(magicHeader, 0, 2);\n<line8>    int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);\n<line9>    return magic == GZIPInputStream.GZIP_MAGIC;\n<line10>}","output":"<line1>{\n<line2>    if (2 != fis.read(byteArray, 0, 2)) {\n<line3>        LOG.error(\"Read incorrect number of bytes from {}\", f.getName());\n<line4>        return false;\n<line5>    }\n<line6>    ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line7>    byte[] magicHeader = new byte[2];\n<line8>    bb.get(magicHeader, 0, 2);\n<line9>    int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);\n<line10>    return magic == GZIPInputStream.GZIP_MAGIC;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Read incorrect number of bytes from {}\", f.getName());\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to open file {}\", f.getName(), e);\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];\n<line3>    try (FileInputStream fis = new FileInputStream(f)) {\n<line4>        if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {\n<line5>            return false;\n<line6>        }\n<line7>        ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line8>        byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];\n<line9>        bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);\n<line10>        return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());\n<line11>    } catch (FileNotFoundException e) {\n<line12>        return false;\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];\n<line3>    try (FileInputStream fis = new FileInputStream(f)) {\n<line4>        if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {\n<line5>            LOG.error(\"Read incorrect number of bytes from {}\", f.getName());\n<line6>            return false;\n<line7>        }\n<line8>        ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line9>        byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];\n<line10>        bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);\n<line11>        return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());\n<line12>    } catch (FileNotFoundException e) {\n<line13>        LOG.error(\"Unable to open file {}\", f.getName(), e);\n<line14>        return false;\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {\n<line3>        return false;\n<line4>    }\n<line5>    ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line6>    byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];\n<line7>    bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);\n<line8>    return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());\n<line9>}","output":"<line1>{\n<line2>    if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {\n<line3>        LOG.error(\"Read incorrect number of bytes from {}\", f.getName());\n<line4>        return false;\n<line5>    }\n<line6>    ByteBuffer bb = ByteBuffer.wrap(byteArray);\n<line7>    byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];\n<line8>    bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);\n<line9>    return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Read incorrect number of bytes from {}\", f.getName());\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to open file {}\", f.getName(), e);\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try (RandomAccessFile raf = new RandomAccessFile(f, \"r\")) {\n<line3>        // including the header and the last / bytes\n<line4>        // the snapshot should be at least 10 bytes\n<line5>        if (raf.length() < 10) {\n<line6>            return false;\n<line7>        }\n<line8>        raf.seek(raf.length() - 5);\n<line9>        byte[] bytes = new byte[5];\n<line10>        int readlen = 0;\n<line11>        int l;\n<line12>        while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {\n<line13>            readlen += l;\n<line14>        }\n<line15>        if (readlen != bytes.length) {\n<line16>            return false;\n<line17>        }\n<line18>        ByteBuffer bb = ByteBuffer.wrap(bytes);\n<line19>        int len = bb.getInt();\n<line20>        byte b = bb.get();\n<line21>        if (len != 1 || b != '/') {\n<line22>            return false;\n<line23>        }\n<line24>    }\n<line25>    return true;\n<line26>}","output":"<line1>{\n<line2>    try (RandomAccessFile raf = new RandomAccessFile(f, \"r\")) {\n<line3>        // including the header and the last / bytes\n<line4>        // the snapshot should be at least 10 bytes\n<line5>        if (raf.length() < 10) {\n<line6>            return false;\n<line7>        }\n<line8>        raf.seek(raf.length() - 5);\n<line9>        byte[] bytes = new byte[5];\n<line10>        int readlen = 0;\n<line11>        int l;\n<line12>        while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {\n<line13>            readlen += l;\n<line14>        }\n<line15>        if (readlen != bytes.length) {\n<line16>            LOG.info(\"Invalid snapshot {}. too short, len = {} bytes\", f.getName(), readlen);\n<line17>            return false;\n<line18>        }\n<line19>        ByteBuffer bb = ByteBuffer.wrap(bytes);\n<line20>        int len = bb.getInt();\n<line21>        byte b = bb.get();\n<line22>        if (len != 1 || b != '/') {\n<line23>            LOG.info(\"Invalid snapshot {}. len = {}, byte = {}\", f.getName(), len, (b & 0xff));\n<line24>            return false;\n<line25>        }\n<line26>    }\n<line27>    return true;\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    // including the header and the last / bytes\n<line3>    // the snapshot should be at least 10 bytes\n<line4>    if (raf.length() < 10) {\n<line5>        return false;\n<line6>    }\n<line7>    raf.seek(raf.length() - 5);\n<line8>    byte[] bytes = new byte[5];\n<line9>    int readlen = 0;\n<line10>    int l;\n<line11>    while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {\n<line12>        readlen += l;\n<line13>    }\n<line14>    if (readlen != bytes.length) {\n<line15>        return false;\n<line16>    }\n<line17>    ByteBuffer bb = ByteBuffer.wrap(bytes);\n<line18>    int len = bb.getInt();\n<line19>    byte b = bb.get();\n<line20>    if (len != 1 || b != '/') {\n<line21>        return false;\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    // including the header and the last / bytes\n<line3>    // the snapshot should be at least 10 bytes\n<line4>    if (raf.length() < 10) {\n<line5>        return false;\n<line6>    }\n<line7>    raf.seek(raf.length() - 5);\n<line8>    byte[] bytes = new byte[5];\n<line9>    int readlen = 0;\n<line10>    int l;\n<line11>    while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {\n<line12>        readlen += l;\n<line13>    }\n<line14>    if (readlen != bytes.length) {\n<line15>        LOG.info(\"Invalid snapshot {}. too short, len = {} bytes\", f.getName(), readlen);\n<line16>        return false;\n<line17>    }\n<line18>    ByteBuffer bb = ByteBuffer.wrap(bytes);\n<line19>    int len = bb.getInt();\n<line20>    byte b = bb.get();\n<line21>    if (len != 1 || b != '/') {\n<line22>        LOG.info(\"Invalid snapshot {}. len = {}, byte = {}\", f.getName(), len, (b & 0xff));\n<line23>        return false;\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Invalid snapshot {}. too short, len = {} bytes\", f.getName(), readlen);\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Invalid snapshot {}. len = {}, byte = {}\", f.getName(), len, (b & 0xff));\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (true) {\n<line4>            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());\n<line5>            Request request = submittedRequests.take();\n<line6>            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME.add(Time.currentElapsedTime() - request.prepQueueStartTime);\n<line7>                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n<line8>                if (request.type == OpCode.ping) {\n<line9>                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;\n<line10>                }\n<line11>                ZooTrace.logRequest(LOG, traceMask, 'P', request, \"\");\n<line12>            }\n<line13>            if (Request.requestOfDeath == request) {\n<line14>                break;\n<line15>            }\n<line16>            request.prepStartTime = Time.currentElapsedTime();\n<line17>            pRequest(request);\n<line18>        }\n<line19>    } catch (Exception e) {\n<line20>        handleException(this.getName(), e);\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    LOG.info(String.format(\"PrepRequestProcessor (sid:%d) started, reconfigEnabled=%s\", zks.getServerId(), zks.reconfigEnabled));\n<line3>    try {\n<line4>        while (true) {\n<line5>            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());\n<line6>            Request request = submittedRequests.take();\n<line7>            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME.add(Time.currentElapsedTime() - request.prepQueueStartTime);\n<line8>            if (LOG.isTraceEnabled()) {\n<line9>                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n<line10>                if (request.type == OpCode.ping) {\n<line11>                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;\n<line12>                }\n<line13>                ZooTrace.logRequest(LOG, traceMask, 'P', request, \"\");\n<line14>            }\n<line15>            if (Request.requestOfDeath == request) {\n<line16>                break;\n<line17>            }\n<line18>            request.prepStartTime = Time.currentElapsedTime();\n<line19>            pRequest(request);\n<line20>        }\n<line21>    } catch (Exception e) {\n<line22>        handleException(this.getName(), e);\n<line23>    }\n<line24>    LOG.info(\"PrepRequestProcessor exited loop!\");\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    int lastSlash = path.lastIndexOf('/');\n<line3>    if (lastSlash == -1 || path.indexOf('\\0') != -1 || failCreate) {\n<line4>        throw new KeeperException.BadArgumentsException(path);\n<line5>    }\n<line6>    return path.substring(0, lastSlash);\n<line7>}","output":"<line1>{\n<line2>    int lastSlash = path.lastIndexOf('/');\n<line3>    if (lastSlash == -1 || path.indexOf('\\0') != -1 || failCreate) {\n<line4>        LOG.info(\"Invalid path {} with session 0x{}\", path, Long.toHexString(sessionId));\n<line5>        throw new KeeperException.BadArgumentsException(path);\n<line6>    }\n<line7>    return path.substring(0, lastSlash);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new KeeperException.BadArgumentsException(path);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Invalid path {} with session 0x{}\", path, Long.toHexString(sessionId));\n<line3>    throw new KeeperException.BadArgumentsException(path);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.getHdr() == null) {\n<line3>        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), type));\n<line4>    }\n<line5>    switch(type) {\n<line6>        case OpCode.create:\n<line7>        case OpCode.create2:\n<line8>        case OpCode.createTTL:\n<line9>        case OpCode.createContainer:\n<line10>            {\n<line11>                pRequest2TxnCreate(type, request, record);\n<line12>                break;\n<line13>            }\n<line14>        case OpCode.deleteContainer:\n<line15>            {\n<line16>                DeleteContainerRequest txn = (DeleteContainerRequest) record;\n<line17>                String path = txn.getPath();\n<line18>                String parentPath = getParentPathAndValidate(path);\n<line19>                ChangeRecord nodeRecord = getRecordForPath(path);\n<line20>                if (nodeRecord.childCount > 0) {\n<line21>                    throw new KeeperException.NotEmptyException(path);\n<line22>                }\n<line23>                if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {\n<line24>                    throw new KeeperException.BadVersionException(path);\n<line25>                }\n<line26>                ChangeRecord parentRecord = getRecordForPath(parentPath);\n<line27>                request.setTxn(new DeleteTxn(path));\n<line28>                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n<line29>                parentRecord.childCount--;\n<line30>                parentRecord.stat.setPzxid(request.getHdr().getZxid());\n<line31>                parentRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);\n<line32>                addChangeRecord(parentRecord);\n<line33>                nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);\n<line34>                nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);\n<line35>                setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line36>                addChangeRecord(nodeRecord);\n<line37>                break;\n<line38>            }\n<line39>        case OpCode.delete:\n<line40>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line41>            DeleteRequest deleteRequest = (DeleteRequest) record;\n<line42>            String path = deleteRequest.getPath();\n<line43>            String parentPath = getParentPathAndValidate(path);\n<line44>            ChangeRecord parentRecord = getRecordForPath(parentPath);\n<line45>            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);\n<line46>            ChangeRecord nodeRecord = getRecordForPath(path);\n<line47>            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);\n<line48>            if (nodeRecord.childCount > 0) {\n<line49>                throw new KeeperException.NotEmptyException(path);\n<line50>            }\n<line51>            request.setTxn(new DeleteTxn(path));\n<line52>            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n<line53>            parentRecord.childCount--;\n<line54>            parentRecord.stat.setPzxid(request.getHdr().getZxid());\n<line55>            parentRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);\n<line56>            addChangeRecord(parentRecord);\n<line57>            nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);\n<line58>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);\n<line59>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line60>            addChangeRecord(nodeRecord);\n<line61>            break;\n<line62>        case OpCode.setData:\n<line63>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line64>            SetDataRequest setDataRequest = (SetDataRequest) record;\n<line65>            path = setDataRequest.getPath();\n<line66>            validatePath(path, request.sessionId);\n<line67>            nodeRecord = getRecordForPath(path);\n<line68>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);\n<line69>            zks.checkQuota(path, nodeRecord.data, setDataRequest.getData(), OpCode.setData);\n<line70>            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);\n<line71>            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));\n<line72>            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n<line73>            nodeRecord.stat.setVersion(newVersion);\n<line74>            nodeRecord.stat.setMtime(request.getHdr().getTime());\n<line75>            nodeRecord.stat.setMzxid(zxid);\n<line76>            nodeRecord.data = setDataRequest.getData();\n<line77>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);\n<line78>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line79>            addChangeRecord(nodeRecord);\n<line80>            break;\n<line81>        case OpCode.reconfig:\n<line82>            if (!zks.isReconfigEnabled()) {\n<line83>                throw new KeeperException.ReconfigDisabledException();\n<line84>            }\n<line85>            if (ZooKeeperServer.skipACL) {\n<line86>            }\n<line87>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line88>            LeaderZooKeeperServer lzks;\n<line89>            try {\n<line90>                lzks = (LeaderZooKeeperServer) zks;\n<line91>            } catch (ClassCastException e) {\n<line92>                // standalone mode - reconfiguration currently not supported\n<line93>                throw new KeeperException.UnimplementedException();\n<line94>            }\n<line95>            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();\n<line96>            // check that there's no reconfig in progress\n<line97>            if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {\n<line98>                throw new KeeperException.ReconfigInProgress();\n<line99>            }\n<line100>            ReconfigRequest reconfigRequest = (ReconfigRequest) record;\n<line101>            long configId = reconfigRequest.getCurConfigId();\n<line102>            if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {\n<line103>                String msg = \"Reconfiguration from version \" + configId + \" failed -- last seen version is \" + lzks.self.getLastSeenQuorumVerifier().getVersion();\n<line104>                throw new KeeperException.BadVersionException(msg);\n<line105>            }\n<line106>            String newMembers = reconfigRequest.getNewMembers();\n<line107>            if (newMembers != null) {\n<line108>                //non-incremental membership change\n<line109>                // Input may be delimited by either commas or newlines so convert to common newline separated format\n<line110>                newMembers = newMembers.replaceAll(\",\", \"\\n\");\n<line111>                try {\n<line112>                    Properties props = new Properties();\n<line113>                    props.load(new StringReader(newMembers));\n<line114>                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false, lastSeenQV.getOraclePath());\n<line115>                    request.qv.setVersion(request.getHdr().getZxid());\n<line116>                } catch (IOException | ConfigException e) {\n<line117>                    throw new KeeperException.BadArgumentsException(e.getMessage());\n<line118>                }\n<line119>            } else {\n<line120>                //incremental change - must be a majority quorum system\n<line121>                List<String> joiningServers = null;\n<line122>                String joiningServersString = reconfigRequest.getJoiningServers();\n<line123>                if (joiningServersString != null) {\n<line124>                    joiningServers = StringUtils.split(joiningServersString, \",\");\n<line125>                }\n<line126>                List<String> leavingServers = null;\n<line127>                String leavingServersString = reconfigRequest.getLeavingServers();\n<line128>                if (leavingServersString != null) {\n<line129>                    leavingServers = StringUtils.split(leavingServersString, \",\");\n<line130>                }\n<line131>                if (!(lastSeenQV instanceof QuorumMaj) && !(lastSeenQV instanceof QuorumOracleMaj)) {\n<line132>                    String msg = \"Incremental reconfiguration requested but last configuration seen has a non-majority quorum system\";\n<line133>                    throw new KeeperException.BadArgumentsException(msg);\n<line134>                }\n<line135>                Map<Long, QuorumServer> nextServers = new HashMap<>(lastSeenQV.getAllMembers());\n<line136>                try {\n<line137>                    if (leavingServers != null) {\n<line138>                        for (String leaving : leavingServers) {\n<line139>                            long sid = Long.parseLong(leaving);\n<line140>                            nextServers.remove(sid);\n<line141>                        }\n<line142>                    }\n<line143>                    if (joiningServers != null) {\n<line144>                        for (String joiner : joiningServers) {\n<line145>                            // joiner should have the following format: server.x = server_spec;client_spec\n<line146>                            String[] parts = StringUtils.split(joiner, \"=\").toArray(new String[0]);\n<line147>                            if (parts.length != 2) {\n<line148>                                throw new KeeperException.BadArgumentsException(\"Wrong format of server string\");\n<line149>                            }\n<line150>                            // extract server id x from first part of joiner: server.x\n<line151>                            Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));\n<line152>                            QuorumServer qs = new QuorumServer(sid, parts[1]);\n<line153>                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {\n<line154>                                throw new KeeperException.BadArgumentsException(\"Wrong format of server string - each server should have 3 ports specified\");\n<line155>                            }\n<line156>                            // check duplication of addresses and ports\n<line157>                            for (QuorumServer nqs : nextServers.values()) {\n<line158>                                if (qs.id == nqs.id) {\n<line159>                                    continue;\n<line160>                                }\n<line161>                                qs.checkAddressDuplicate(nqs);\n<line162>                            }\n<line163>                            nextServers.remove(qs.id);\n<line164>                            nextServers.put(qs.id, qs);\n<line165>                        }\n<line166>                    }\n<line167>                } catch (ConfigException e) {\n<line168>                    throw new KeeperException.BadArgumentsException(\"Reconfiguration failed\");\n<line169>                }\n<line170>                if (lastSeenQV instanceof QuorumMaj) {\n<line171>                    request.qv = new QuorumMaj(nextServers);\n<line172>                } else {\n<line173>                    request.qv = new QuorumOracleMaj(nextServers, lastSeenQV.getOraclePath());\n<line174>                }\n<line175>                request.qv.setVersion(request.getHdr().getZxid());\n<line176>            }\n<line177>            if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {\n<line178>                String msg = \"Reconfig failed - new configuration must include at least 2 followers\";\n<line179>                throw new KeeperException.BadArgumentsException(msg);\n<line180>            } else if (request.qv.getVotingMembers().size() < 1) {\n<line181>                String msg = \"Reconfig failed - new configuration must include at least 1 follower\";\n<line182>                throw new KeeperException.BadArgumentsException(msg);\n<line183>            }\n<line184>            if (!lzks.getLeader().isQuorumSynced(request.qv)) {\n<line185>                String msg2 = \"Reconfig failed - there must be a connected and synced quorum in new configuration\";\n<line186>                throw new KeeperException.NewConfigNoQuorum();\n<line187>            }\n<line188>            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);\n<line189>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);\n<line190>            SetDataTxn setDataTxn = new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1);\n<line191>            request.setTxn(setDataTxn);\n<line192>            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n<line193>            nodeRecord.stat.setVersion(-1);\n<line194>            nodeRecord.stat.setMtime(request.getHdr().getTime());\n<line195>            nodeRecord.stat.setMzxid(zxid);\n<line196>            nodeRecord.data = setDataTxn.getData();\n<line197>            // Reconfig is currently a noop from digest computation\n<line198>            // perspective since config node is not covered by the digests.\n<line199>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.NOOP, ZooDefs.CONFIG_NODE, nodeRecord.data, nodeRecord.stat);\n<line200>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line201>            addChangeRecord(nodeRecord);\n<line202>            break;\n<line203>        case OpCode.setACL:\n<line204>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line205>            SetACLRequest setAclRequest = (SetACLRequest) record;\n<line206>            path = setAclRequest.getPath();\n<line207>            validatePath(path, request.sessionId);\n<line208>            List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());\n<line209>            nodeRecord = getRecordForPath(path);\n<line210>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);\n<line211>            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);\n<line212>            request.setTxn(new SetACLTxn(path, listACL, newVersion));\n<line213>            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n<line214>            nodeRecord.stat.setAversion(newVersion);\n<line215>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);\n<line216>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line217>            addChangeRecord(nodeRecord);\n<line218>            break;\n<line219>        case OpCode.createSession:\n<line220>            CreateSessionTxn createSessionTxn = request.readRequestRecord(CreateSessionTxn::new);\n<line221>            request.setTxn(createSessionTxn);\n<line222>            // only add the global session tracker but not to ZKDb\n<line223>            zks.sessionTracker.trackSession(request.sessionId, createSessionTxn.getTimeOut());\n<line224>            zks.setOwner(request.sessionId, request.getOwner());\n<line225>            break;\n<line226>        case OpCode.closeSession:\n<line227>            // We don't want to do this check since the session expiration thread\n<line228>            // queues up this operation without being the session owner.\n<line229>            // this request is the last of the session so it should be ok\n<line230>            //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line231>            long startTime = Time.currentElapsedTime();\n<line232>            synchronized (zks.outstandingChanges) {\n<line233>                // need to move getEphemerals into zks.outstandingChanges\n<line234>                // synchronized block, otherwise there will be a race\n<line235>                // condition with the on flying deleteNode txn, and we'll\n<line236>                // delete the node again here, which is not correct\n<line237>                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);\n<line238>                for (ChangeRecord c : zks.outstandingChanges) {\n<line239>                    if (c.stat == null) {\n<line240>                        // Doing a delete\n<line241>                        es.remove(c.path);\n<line242>                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {\n<line243>                        es.add(c.path);\n<line244>                    }\n<line245>                }\n<line246>                for (String path2Delete : es) {\n<line247>                    if (digestEnabled) {\n<line248>                        parentPath = getParentPathAndValidate(path2Delete);\n<line249>                        parentRecord = getRecordForPath(parentPath);\n<line250>                        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n<line251>                        parentRecord.stat.setPzxid(request.getHdr().getZxid());\n<line252>                        parentRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);\n<line253>                        addChangeRecord(parentRecord);\n<line254>                    }\n<line255>                    nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null);\n<line256>                    nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path2Delete);\n<line257>                    addChangeRecord(nodeRecord);\n<line258>                }\n<line259>                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {\n<line260>                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));\n<line261>                }\n<line262>                zks.sessionTracker.setSessionClosing(request.sessionId);\n<line263>            }\n<line264>            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);\n<line265>            break;\n<line266>        case OpCode.check:\n<line267>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line268>            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;\n<line269>            path = checkVersionRequest.getPath();\n<line270>            validatePath(path, request.sessionId);\n<line271>            nodeRecord = getRecordForPath(path);\n<line272>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);\n<line273>            request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));\n<line274>            break;\n<line275>        default:\n<line276>            break;\n<line277>    }\n<line278>    // If the txn is not going to mutate anything, like createSession,\n<line279>    // we just set the current tree digest in it\n<line280>    if (request.getTxnDigest() == null && digestEnabled) {\n<line281>        setTxnDigest(request);\n<line282>    }\n<line283>}","output":"<line1>{\n<line2>    if (request.getHdr() == null) {\n<line3>        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), type));\n<line4>    }\n<line5>    switch(type) {\n<line6>        case OpCode.create:\n<line7>        case OpCode.create2:\n<line8>        case OpCode.createTTL:\n<line9>        case OpCode.createContainer:\n<line10>            {\n<line11>                pRequest2TxnCreate(type, request, record);\n<line12>                break;\n<line13>            }\n<line14>        case OpCode.deleteContainer:\n<line15>            {\n<line16>                DeleteContainerRequest txn = (DeleteContainerRequest) record;\n<line17>                String path = txn.getPath();\n<line18>                String parentPath = getParentPathAndValidate(path);\n<line19>                ChangeRecord nodeRecord = getRecordForPath(path);\n<line20>                if (nodeRecord.childCount > 0) {\n<line21>                    throw new KeeperException.NotEmptyException(path);\n<line22>                }\n<line23>                if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {\n<line24>                    throw new KeeperException.BadVersionException(path);\n<line25>                }\n<line26>                ChangeRecord parentRecord = getRecordForPath(parentPath);\n<line27>                request.setTxn(new DeleteTxn(path));\n<line28>                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n<line29>                parentRecord.childCount--;\n<line30>                parentRecord.stat.setPzxid(request.getHdr().getZxid());\n<line31>                parentRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);\n<line32>                addChangeRecord(parentRecord);\n<line33>                nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);\n<line34>                nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);\n<line35>                setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line36>                addChangeRecord(nodeRecord);\n<line37>                break;\n<line38>            }\n<line39>        case OpCode.delete:\n<line40>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line41>            DeleteRequest deleteRequest = (DeleteRequest) record;\n<line42>            String path = deleteRequest.getPath();\n<line43>            String parentPath = getParentPathAndValidate(path);\n<line44>            ChangeRecord parentRecord = getRecordForPath(parentPath);\n<line45>            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);\n<line46>            ChangeRecord nodeRecord = getRecordForPath(path);\n<line47>            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);\n<line48>            if (nodeRecord.childCount > 0) {\n<line49>                throw new KeeperException.NotEmptyException(path);\n<line50>            }\n<line51>            request.setTxn(new DeleteTxn(path));\n<line52>            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n<line53>            parentRecord.childCount--;\n<line54>            parentRecord.stat.setPzxid(request.getHdr().getZxid());\n<line55>            parentRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);\n<line56>            addChangeRecord(parentRecord);\n<line57>            nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null);\n<line58>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);\n<line59>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line60>            addChangeRecord(nodeRecord);\n<line61>            break;\n<line62>        case OpCode.setData:\n<line63>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line64>            SetDataRequest setDataRequest = (SetDataRequest) record;\n<line65>            path = setDataRequest.getPath();\n<line66>            validatePath(path, request.sessionId);\n<line67>            nodeRecord = getRecordForPath(path);\n<line68>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);\n<line69>            zks.checkQuota(path, nodeRecord.data, setDataRequest.getData(), OpCode.setData);\n<line70>            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);\n<line71>            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));\n<line72>            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n<line73>            nodeRecord.stat.setVersion(newVersion);\n<line74>            nodeRecord.stat.setMtime(request.getHdr().getTime());\n<line75>            nodeRecord.stat.setMzxid(zxid);\n<line76>            nodeRecord.data = setDataRequest.getData();\n<line77>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);\n<line78>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line79>            addChangeRecord(nodeRecord);\n<line80>            break;\n<line81>        case OpCode.reconfig:\n<line82>            if (!zks.isReconfigEnabled()) {\n<line83>                LOG.error(\"Reconfig operation requested but reconfig feature is disabled.\");\n<line84>                throw new KeeperException.ReconfigDisabledException();\n<line85>            }\n<line86>            if (ZooKeeperServer.skipACL) {\n<line87>                LOG.warn(\"skipACL is set, reconfig operation will skip ACL checks!\");\n<line88>            }\n<line89>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line90>            LeaderZooKeeperServer lzks;\n<line91>            try {\n<line92>                lzks = (LeaderZooKeeperServer) zks;\n<line93>            } catch (ClassCastException e) {\n<line94>                // standalone mode - reconfiguration currently not supported\n<line95>                throw new KeeperException.UnimplementedException();\n<line96>            }\n<line97>            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();\n<line98>            // check that there's no reconfig in progress\n<line99>            if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {\n<line100>                throw new KeeperException.ReconfigInProgress();\n<line101>            }\n<line102>            ReconfigRequest reconfigRequest = (ReconfigRequest) record;\n<line103>            long configId = reconfigRequest.getCurConfigId();\n<line104>            if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {\n<line105>                String msg = \"Reconfiguration from version \" + configId + \" failed -- last seen version is \" + lzks.self.getLastSeenQuorumVerifier().getVersion();\n<line106>                throw new KeeperException.BadVersionException(msg);\n<line107>            }\n<line108>            String newMembers = reconfigRequest.getNewMembers();\n<line109>            if (newMembers != null) {\n<line110>                //non-incremental membership change\n<line111>                LOG.info(\"Non-incremental reconfig\");\n<line112>                // Input may be delimited by either commas or newlines so convert to common newline separated format\n<line113>                newMembers = newMembers.replaceAll(\",\", \"\\n\");\n<line114>                try {\n<line115>                    Properties props = new Properties();\n<line116>                    props.load(new StringReader(newMembers));\n<line117>                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false, lastSeenQV.getOraclePath());\n<line118>                    request.qv.setVersion(request.getHdr().getZxid());\n<line119>                } catch (IOException | ConfigException e) {\n<line120>                    throw new KeeperException.BadArgumentsException(e.getMessage());\n<line121>                }\n<line122>            } else {\n<line123>                //incremental change - must be a majority quorum system\n<line124>                LOG.info(\"Incremental reconfig\");\n<line125>                List<String> joiningServers = null;\n<line126>                String joiningServersString = reconfigRequest.getJoiningServers();\n<line127>                if (joiningServersString != null) {\n<line128>                    joiningServers = StringUtils.split(joiningServersString, \",\");\n<line129>                }\n<line130>                List<String> leavingServers = null;\n<line131>                String leavingServersString = reconfigRequest.getLeavingServers();\n<line132>                if (leavingServersString != null) {\n<line133>                    leavingServers = StringUtils.split(leavingServersString, \",\");\n<line134>                }\n<line135>                if (!(lastSeenQV instanceof QuorumMaj) && !(lastSeenQV instanceof QuorumOracleMaj)) {\n<line136>                    String msg = \"Incremental reconfiguration requested but last configuration seen has a non-majority quorum system\";\n<line137>                    LOG.warn(msg);\n<line138>                    throw new KeeperException.BadArgumentsException(msg);\n<line139>                }\n<line140>                Map<Long, QuorumServer> nextServers = new HashMap<>(lastSeenQV.getAllMembers());\n<line141>                try {\n<line142>                    if (leavingServers != null) {\n<line143>                        for (String leaving : leavingServers) {\n<line144>                            long sid = Long.parseLong(leaving);\n<line145>                            nextServers.remove(sid);\n<line146>                        }\n<line147>                    }\n<line148>                    if (joiningServers != null) {\n<line149>                        for (String joiner : joiningServers) {\n<line150>                            // joiner should have the following format: server.x = server_spec;client_spec\n<line151>                            String[] parts = StringUtils.split(joiner, \"=\").toArray(new String[0]);\n<line152>                            if (parts.length != 2) {\n<line153>                                throw new KeeperException.BadArgumentsException(\"Wrong format of server string\");\n<line154>                            }\n<line155>                            // extract server id x from first part of joiner: server.x\n<line156>                            Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));\n<line157>                            QuorumServer qs = new QuorumServer(sid, parts[1]);\n<line158>                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {\n<line159>                                throw new KeeperException.BadArgumentsException(\"Wrong format of server string - each server should have 3 ports specified\");\n<line160>                            }\n<line161>                            // check duplication of addresses and ports\n<line162>                            for (QuorumServer nqs : nextServers.values()) {\n<line163>                                if (qs.id == nqs.id) {\n<line164>                                    continue;\n<line165>                                }\n<line166>                                qs.checkAddressDuplicate(nqs);\n<line167>                            }\n<line168>                            nextServers.remove(qs.id);\n<line169>                            nextServers.put(qs.id, qs);\n<line170>                        }\n<line171>                    }\n<line172>                } catch (ConfigException e) {\n<line173>                    throw new KeeperException.BadArgumentsException(\"Reconfiguration failed\");\n<line174>                }\n<line175>                if (lastSeenQV instanceof QuorumMaj) {\n<line176>                    request.qv = new QuorumMaj(nextServers);\n<line177>                } else {\n<line178>                    request.qv = new QuorumOracleMaj(nextServers, lastSeenQV.getOraclePath());\n<line179>                }\n<line180>                request.qv.setVersion(request.getHdr().getZxid());\n<line181>            }\n<line182>            if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {\n<line183>                String msg = \"Reconfig failed - new configuration must include at least 2 followers\";\n<line184>                LOG.warn(msg);\n<line185>                throw new KeeperException.BadArgumentsException(msg);\n<line186>            } else if (request.qv.getVotingMembers().size() < 1) {\n<line187>                String msg = \"Reconfig failed - new configuration must include at least 1 follower\";\n<line188>                LOG.warn(msg);\n<line189>                throw new KeeperException.BadArgumentsException(msg);\n<line190>            }\n<line191>            if (!lzks.getLeader().isQuorumSynced(request.qv)) {\n<line192>                String msg2 = \"Reconfig failed - there must be a connected and synced quorum in new configuration\";\n<line193>                LOG.warn(msg2);\n<line194>                throw new KeeperException.NewConfigNoQuorum();\n<line195>            }\n<line196>            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);\n<line197>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);\n<line198>            SetDataTxn setDataTxn = new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1);\n<line199>            request.setTxn(setDataTxn);\n<line200>            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n<line201>            nodeRecord.stat.setVersion(-1);\n<line202>            nodeRecord.stat.setMtime(request.getHdr().getTime());\n<line203>            nodeRecord.stat.setMzxid(zxid);\n<line204>            nodeRecord.data = setDataTxn.getData();\n<line205>            // Reconfig is currently a noop from digest computation\n<line206>            // perspective since config node is not covered by the digests.\n<line207>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.NOOP, ZooDefs.CONFIG_NODE, nodeRecord.data, nodeRecord.stat);\n<line208>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line209>            addChangeRecord(nodeRecord);\n<line210>            break;\n<line211>        case OpCode.setACL:\n<line212>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line213>            SetACLRequest setAclRequest = (SetACLRequest) record;\n<line214>            path = setAclRequest.getPath();\n<line215>            validatePath(path, request.sessionId);\n<line216>            List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());\n<line217>            nodeRecord = getRecordForPath(path);\n<line218>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);\n<line219>            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);\n<line220>            request.setTxn(new SetACLTxn(path, listACL, newVersion));\n<line221>            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n<line222>            nodeRecord.stat.setAversion(newVersion);\n<line223>            nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);\n<line224>            setTxnDigest(request, nodeRecord.precalculatedDigest);\n<line225>            addChangeRecord(nodeRecord);\n<line226>            break;\n<line227>        case OpCode.createSession:\n<line228>            CreateSessionTxn createSessionTxn = request.readRequestRecord(CreateSessionTxn::new);\n<line229>            request.setTxn(createSessionTxn);\n<line230>            // only add the global session tracker but not to ZKDb\n<line231>            zks.sessionTracker.trackSession(request.sessionId, createSessionTxn.getTimeOut());\n<line232>            zks.setOwner(request.sessionId, request.getOwner());\n<line233>            break;\n<line234>        case OpCode.closeSession:\n<line235>            // We don't want to do this check since the session expiration thread\n<line236>            // queues up this operation without being the session owner.\n<line237>            // this request is the last of the session so it should be ok\n<line238>            //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line239>            long startTime = Time.currentElapsedTime();\n<line240>            synchronized (zks.outstandingChanges) {\n<line241>                // need to move getEphemerals into zks.outstandingChanges\n<line242>                // synchronized block, otherwise there will be a race\n<line243>                // condition with the on flying deleteNode txn, and we'll\n<line244>                // delete the node again here, which is not correct\n<line245>                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);\n<line246>                for (ChangeRecord c : zks.outstandingChanges) {\n<line247>                    if (c.stat == null) {\n<line248>                        // Doing a delete\n<line249>                        es.remove(c.path);\n<line250>                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {\n<line251>                        es.add(c.path);\n<line252>                    }\n<line253>                }\n<line254>                for (String path2Delete : es) {\n<line255>                    if (digestEnabled) {\n<line256>                        parentPath = getParentPathAndValidate(path2Delete);\n<line257>                        parentRecord = getRecordForPath(parentPath);\n<line258>                        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n<line259>                        parentRecord.stat.setPzxid(request.getHdr().getZxid());\n<line260>                        parentRecord.precalculatedDigest = precalculateDigest(DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);\n<line261>                        addChangeRecord(parentRecord);\n<line262>                    }\n<line263>                    nodeRecord = new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null);\n<line264>                    nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path2Delete);\n<line265>                    addChangeRecord(nodeRecord);\n<line266>                }\n<line267>                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {\n<line268>                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));\n<line269>                }\n<line270>                zks.sessionTracker.setSessionClosing(request.sessionId);\n<line271>            }\n<line272>            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);\n<line273>            break;\n<line274>        case OpCode.check:\n<line275>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line276>            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;\n<line277>            path = checkVersionRequest.getPath();\n<line278>            validatePath(path, request.sessionId);\n<line279>            nodeRecord = getRecordForPath(path);\n<line280>            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);\n<line281>            request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));\n<line282>            break;\n<line283>        default:\n<line284>            LOG.warn(\"unknown type {}\", type);\n<line285>            break;\n<line286>    }\n<line287>    // If the txn is not going to mutate anything, like createSession,\n<line288>    // we just set the current tree digest in it\n<line289>    if (request.getTxnDigest() == null && digestEnabled) {\n<line290>        setTxnDigest(request);\n<line291>    }\n<line292>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new KeeperException.ReconfigDisabledException();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Reconfig operation requested but reconfig feature is disabled.\");\n<line3>    throw new KeeperException.ReconfigDisabledException();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    //non-incremental membership change\n<line3>    // Input may be delimited by either commas or newlines so convert to common newline separated format\n<line4>    newMembers = newMembers.replaceAll(\",\", \"\\n\");\n<line5>    try {\n<line6>        Properties props = new Properties();\n<line7>        props.load(new StringReader(newMembers));\n<line8>        request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false, lastSeenQV.getOraclePath());\n<line9>        request.qv.setVersion(request.getHdr().getZxid());\n<line10>    } catch (IOException | ConfigException e) {\n<line11>        throw new KeeperException.BadArgumentsException(e.getMessage());\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    //non-incremental membership change\n<line3>    LOG.info(\"Non-incremental reconfig\");\n<line4>    // Input may be delimited by either commas or newlines so convert to common newline separated format\n<line5>    newMembers = newMembers.replaceAll(\",\", \"\\n\");\n<line6>    try {\n<line7>        Properties props = new Properties();\n<line8>        props.load(new StringReader(newMembers));\n<line9>        request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false, lastSeenQV.getOraclePath());\n<line10>        request.qv.setVersion(request.getHdr().getZxid());\n<line11>    } catch (IOException | ConfigException e) {\n<line12>        throw new KeeperException.BadArgumentsException(e.getMessage());\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    //incremental change - must be a majority quorum system\n<line3>    List<String> joiningServers = null;\n<line4>    String joiningServersString = reconfigRequest.getJoiningServers();\n<line5>    if (joiningServersString != null) {\n<line6>        joiningServers = StringUtils.split(joiningServersString, \",\");\n<line7>    }\n<line8>    List<String> leavingServers = null;\n<line9>    String leavingServersString = reconfigRequest.getLeavingServers();\n<line10>    if (leavingServersString != null) {\n<line11>        leavingServers = StringUtils.split(leavingServersString, \",\");\n<line12>    }\n<line13>    if (!(lastSeenQV instanceof QuorumMaj) && !(lastSeenQV instanceof QuorumOracleMaj)) {\n<line14>        String msg = \"Incremental reconfiguration requested but last configuration seen has a non-majority quorum system\";\n<line15>        throw new KeeperException.BadArgumentsException(msg);\n<line16>    }\n<line17>    Map<Long, QuorumServer> nextServers = new HashMap<>(lastSeenQV.getAllMembers());\n<line18>    try {\n<line19>        if (leavingServers != null) {\n<line20>            for (String leaving : leavingServers) {\n<line21>                long sid = Long.parseLong(leaving);\n<line22>                nextServers.remove(sid);\n<line23>            }\n<line24>        }\n<line25>        if (joiningServers != null) {\n<line26>            for (String joiner : joiningServers) {\n<line27>                // joiner should have the following format: server.x = server_spec;client_spec\n<line28>                String[] parts = StringUtils.split(joiner, \"=\").toArray(new String[0]);\n<line29>                if (parts.length != 2) {\n<line30>                    throw new KeeperException.BadArgumentsException(\"Wrong format of server string\");\n<line31>                }\n<line32>                // extract server id x from first part of joiner: server.x\n<line33>                Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));\n<line34>                QuorumServer qs = new QuorumServer(sid, parts[1]);\n<line35>                if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {\n<line36>                    throw new KeeperException.BadArgumentsException(\"Wrong format of server string - each server should have 3 ports specified\");\n<line37>                }\n<line38>                // check duplication of addresses and ports\n<line39>                for (QuorumServer nqs : nextServers.values()) {\n<line40>                    if (qs.id == nqs.id) {\n<line41>                        continue;\n<line42>                    }\n<line43>                    qs.checkAddressDuplicate(nqs);\n<line44>                }\n<line45>                nextServers.remove(qs.id);\n<line46>                nextServers.put(qs.id, qs);\n<line47>            }\n<line48>        }\n<line49>    } catch (ConfigException e) {\n<line50>        throw new KeeperException.BadArgumentsException(\"Reconfiguration failed\");\n<line51>    }\n<line52>    if (lastSeenQV instanceof QuorumMaj) {\n<line53>        request.qv = new QuorumMaj(nextServers);\n<line54>    } else {\n<line55>        request.qv = new QuorumOracleMaj(nextServers, lastSeenQV.getOraclePath());\n<line56>    }\n<line57>    request.qv.setVersion(request.getHdr().getZxid());\n<line58>}","output":"<line1>{\n<line2>    //incremental change - must be a majority quorum system\n<line3>    LOG.info(\"Incremental reconfig\");\n<line4>    List<String> joiningServers = null;\n<line5>    String joiningServersString = reconfigRequest.getJoiningServers();\n<line6>    if (joiningServersString != null) {\n<line7>        joiningServers = StringUtils.split(joiningServersString, \",\");\n<line8>    }\n<line9>    List<String> leavingServers = null;\n<line10>    String leavingServersString = reconfigRequest.getLeavingServers();\n<line11>    if (leavingServersString != null) {\n<line12>        leavingServers = StringUtils.split(leavingServersString, \",\");\n<line13>    }\n<line14>    if (!(lastSeenQV instanceof QuorumMaj) && !(lastSeenQV instanceof QuorumOracleMaj)) {\n<line15>        String msg = \"Incremental reconfiguration requested but last configuration seen has a non-majority quorum system\";\n<line16>        LOG.warn(msg);\n<line17>        throw new KeeperException.BadArgumentsException(msg);\n<line18>    }\n<line19>    Map<Long, QuorumServer> nextServers = new HashMap<>(lastSeenQV.getAllMembers());\n<line20>    try {\n<line21>        if (leavingServers != null) {\n<line22>            for (String leaving : leavingServers) {\n<line23>                long sid = Long.parseLong(leaving);\n<line24>                nextServers.remove(sid);\n<line25>            }\n<line26>        }\n<line27>        if (joiningServers != null) {\n<line28>            for (String joiner : joiningServers) {\n<line29>                // joiner should have the following format: server.x = server_spec;client_spec\n<line30>                String[] parts = StringUtils.split(joiner, \"=\").toArray(new String[0]);\n<line31>                if (parts.length != 2) {\n<line32>                    throw new KeeperException.BadArgumentsException(\"Wrong format of server string\");\n<line33>                }\n<line34>                // extract server id x from first part of joiner: server.x\n<line35>                Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));\n<line36>                QuorumServer qs = new QuorumServer(sid, parts[1]);\n<line37>                if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {\n<line38>                    throw new KeeperException.BadArgumentsException(\"Wrong format of server string - each server should have 3 ports specified\");\n<line39>                }\n<line40>                // check duplication of addresses and ports\n<line41>                for (QuorumServer nqs : nextServers.values()) {\n<line42>                    if (qs.id == nqs.id) {\n<line43>                        continue;\n<line44>                    }\n<line45>                    qs.checkAddressDuplicate(nqs);\n<line46>                }\n<line47>                nextServers.remove(qs.id);\n<line48>                nextServers.put(qs.id, qs);\n<line49>            }\n<line50>        }\n<line51>    } catch (ConfigException e) {\n<line52>        throw new KeeperException.BadArgumentsException(\"Reconfiguration failed\");\n<line53>    }\n<line54>    if (lastSeenQV instanceof QuorumMaj) {\n<line55>        request.qv = new QuorumMaj(nextServers);\n<line56>    } else {\n<line57>        request.qv = new QuorumOracleMaj(nextServers, lastSeenQV.getOraclePath());\n<line58>    }\n<line59>    request.qv.setVersion(request.getHdr().getZxid());\n<line60>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        PathUtils.validatePath(path);\n<line4>    } catch (IllegalArgumentException ie) {\n<line5>        throw new BadArgumentsException(path);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        PathUtils.validatePath(path);\n<line4>    } catch (IllegalArgumentException ie) {\n<line5>        LOG.info(\"Invalid path {} with session 0x{}, reason: {}\", path, Long.toHexString(sessionId), ie.getMessage());\n<line6>        throw new BadArgumentsException(path);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new BadArgumentsException(path);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Invalid path {} with session 0x{}, reason: {}\", path, Long.toHexString(sessionId), ie.getMessage());\n<line3>    throw new BadArgumentsException(path);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        switch(request.type) {\n<line4>            case OpCode.createContainer:\n<line5>            case OpCode.create:\n<line6>            case OpCode.create2:\n<line7>                CreateRequest create2Request = request.readRequestRecord(CreateRequest::new);\n<line8>                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request);\n<line9>                break;\n<line10>            case OpCode.createTTL:\n<line11>                CreateTTLRequest createTtlRequest = request.readRequestRecord(CreateTTLRequest::new);\n<line12>                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest);\n<line13>                break;\n<line14>            case OpCode.deleteContainer:\n<line15>                DeleteContainerRequest deleteContainerRequest = request.readRequestRecord(DeleteContainerRequest::new);\n<line16>                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteContainerRequest);\n<line17>                break;\n<line18>            case OpCode.delete:\n<line19>                DeleteRequest deleteRequest = request.readRequestRecord(DeleteRequest::new);\n<line20>                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest);\n<line21>                break;\n<line22>            case OpCode.setData:\n<line23>                SetDataRequest setDataRequest = request.readRequestRecord(SetDataRequest::new);\n<line24>                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest);\n<line25>                break;\n<line26>            case OpCode.reconfig:\n<line27>                ReconfigRequest reconfigRequest = request.readRequestRecord(ReconfigRequest::new);\n<line28>                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest);\n<line29>                break;\n<line30>            case OpCode.setACL:\n<line31>                SetACLRequest setAclRequest = request.readRequestRecord(SetACLRequest::new);\n<line32>                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest);\n<line33>                break;\n<line34>            case OpCode.check:\n<line35>                CheckVersionRequest checkRequest = request.readRequestRecord(CheckVersionRequest::new);\n<line36>                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest);\n<line37>                break;\n<line38>            case OpCode.multi:\n<line39>                MultiOperationRecord multiRequest;\n<line40>                try {\n<line41>                    multiRequest = request.readRequestRecord(MultiOperationRecord::new);\n<line42>                } catch (IOException e) {\n<line43>                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));\n<line44>                    throw e;\n<line45>                }\n<line46>                List<Txn> txns = new ArrayList<>();\n<line47>                //Each op in a multi-op must have the same zxid!\n<line48>                long zxid = zks.getNextZxid();\n<line49>                KeeperException ke = null;\n<line50>                //Store off current pending change records in case we need to rollback\n<line51>                Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);\n<line52>                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));\n<line53>                for (Op op : multiRequest) {\n<line54>                    Record subrequest = op.toRequestRecord();\n<line55>                    int type;\n<line56>                    Record txn;\n<line57>                    /* If we've already failed one of the ops, don't bother\n<line58>                     * trying the rest as we know it's going to fail and it\n<line59>                     * would be confusing in the logfiles.\n<line60>                     */\n<line61>                    if (ke != null) {\n<line62>                        type = OpCode.error;\n<line63>                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n<line64>                    } else {\n<line65>                        /* Prep the request and convert to a Txn */\n<line66>                        try {\n<line67>                            pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line68>                            type = op.getType();\n<line69>                            txn = request.getTxn();\n<line70>                        } catch (KeeperException e) {\n<line71>                            ke = e;\n<line72>                            type = OpCode.error;\n<line73>                            txn = new ErrorTxn(e.code().intValue());\n<line74>                            if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line75>                            }\n<line76>                            request.setException(e);\n<line77>                            /* Rollback change records from failed multi-op */\n<line78>                            rollbackPendingChanges(zxid, pendingChanges);\n<line79>                        }\n<line80>                    }\n<line81>                    // TODO: I don't want to have to serialize it here and then\n<line82>                    //       immediately deserialize in next processor. But I'm\n<line83>                    //       not sure how else to get the txn stored into our list.\n<line84>                    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n<line85>                        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line86>                        txn.serialize(boa, \"request\");\n<line87>                        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line88>                        txns.add(new Txn(type, bb.array()));\n<line89>                    }\n<line90>                }\n<line91>                request.setTxn(new MultiTxn(txns));\n<line92>                if (digestEnabled) {\n<line93>                    setTxnDigest(request);\n<line94>                }\n<line95>                break;\n<line96>            //create/close session don't require request record\n<line97>            case OpCode.createSession:\n<line98>            case OpCode.closeSession:\n<line99>                if (!request.isLocalSession()) {\n<line100>                    pRequest2Txn(request.type, zks.getNextZxid(), request, null);\n<line101>                }\n<line102>                break;\n<line103>            //All the rest don't need to create a Txn - just verify session\n<line104>            case OpCode.sync:\n<line105>            case OpCode.exists:\n<line106>            case OpCode.getData:\n<line107>            case OpCode.getACL:\n<line108>            case OpCode.getChildren:\n<line109>            case OpCode.getAllChildrenNumber:\n<line110>            case OpCode.getChildren2:\n<line111>            case OpCode.ping:\n<line112>            case OpCode.setWatches:\n<line113>            case OpCode.setWatches2:\n<line114>            case OpCode.checkWatches:\n<line115>            case OpCode.removeWatches:\n<line116>            case OpCode.getEphemerals:\n<line117>            case OpCode.multiRead:\n<line118>            case OpCode.addWatch:\n<line119>            case OpCode.whoAmI:\n<line120>                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line121>                break;\n<line122>            default:\n<line123>                break;\n<line124>        }\n<line125>    } catch (KeeperException e) {\n<line126>        if (request.getHdr() != null) {\n<line127>            request.getHdr().setType(OpCode.error);\n<line128>            request.setTxn(new ErrorTxn(e.code().intValue()));\n<line129>        }\n<line130>        if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line131>        }\n<line132>        request.setException(e);\n<line133>    } catch (Exception e) {\n<line134>        // log at error level as we are returning a marshalling\n<line135>        // error to the user\n<line136>        String digest = request.requestDigest();\n<line137>        if (request.getHdr() == null) {\n<line138>            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getZxid(), Time.currentWallTime(), request.type));\n<line139>        }\n<line140>        request.getHdr().setType(OpCode.error);\n<line141>        request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));\n<line142>    }\n<line143>}","output":"<line1>{\n<line2>    try {\n<line3>        switch(request.type) {\n<line4>            case OpCode.createContainer:\n<line5>            case OpCode.create:\n<line6>            case OpCode.create2:\n<line7>                CreateRequest create2Request = request.readRequestRecord(CreateRequest::new);\n<line8>                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request);\n<line9>                break;\n<line10>            case OpCode.createTTL:\n<line11>                CreateTTLRequest createTtlRequest = request.readRequestRecord(CreateTTLRequest::new);\n<line12>                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest);\n<line13>                break;\n<line14>            case OpCode.deleteContainer:\n<line15>                DeleteContainerRequest deleteContainerRequest = request.readRequestRecord(DeleteContainerRequest::new);\n<line16>                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteContainerRequest);\n<line17>                break;\n<line18>            case OpCode.delete:\n<line19>                DeleteRequest deleteRequest = request.readRequestRecord(DeleteRequest::new);\n<line20>                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest);\n<line21>                break;\n<line22>            case OpCode.setData:\n<line23>                SetDataRequest setDataRequest = request.readRequestRecord(SetDataRequest::new);\n<line24>                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest);\n<line25>                break;\n<line26>            case OpCode.reconfig:\n<line27>                ReconfigRequest reconfigRequest = request.readRequestRecord(ReconfigRequest::new);\n<line28>                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest);\n<line29>                break;\n<line30>            case OpCode.setACL:\n<line31>                SetACLRequest setAclRequest = request.readRequestRecord(SetACLRequest::new);\n<line32>                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest);\n<line33>                break;\n<line34>            case OpCode.check:\n<line35>                CheckVersionRequest checkRequest = request.readRequestRecord(CheckVersionRequest::new);\n<line36>                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest);\n<line37>                break;\n<line38>            case OpCode.multi:\n<line39>                MultiOperationRecord multiRequest;\n<line40>                try {\n<line41>                    multiRequest = request.readRequestRecord(MultiOperationRecord::new);\n<line42>                } catch (IOException e) {\n<line43>                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));\n<line44>                    throw e;\n<line45>                }\n<line46>                List<Txn> txns = new ArrayList<>();\n<line47>                //Each op in a multi-op must have the same zxid!\n<line48>                long zxid = zks.getNextZxid();\n<line49>                KeeperException ke = null;\n<line50>                //Store off current pending change records in case we need to rollback\n<line51>                Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);\n<line52>                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));\n<line53>                for (Op op : multiRequest) {\n<line54>                    Record subrequest = op.toRequestRecord();\n<line55>                    int type;\n<line56>                    Record txn;\n<line57>                    /* If we've already failed one of the ops, don't bother\n<line58>                     * trying the rest as we know it's going to fail and it\n<line59>                     * would be confusing in the logfiles.\n<line60>                     */\n<line61>                    if (ke != null) {\n<line62>                        type = OpCode.error;\n<line63>                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n<line64>                    } else {\n<line65>                        /* Prep the request and convert to a Txn */\n<line66>                        try {\n<line67>                            pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line68>                            type = op.getType();\n<line69>                            txn = request.getTxn();\n<line70>                        } catch (KeeperException e) {\n<line71>                            ke = e;\n<line72>                            type = OpCode.error;\n<line73>                            txn = new ErrorTxn(e.code().intValue());\n<line74>                            if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line75>                                LOG.info(\"Got user-level KeeperException when processing {} aborting\" + \" remaining multi ops. Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line76>                            }\n<line77>                            request.setException(e);\n<line78>                            /* Rollback change records from failed multi-op */\n<line79>                            rollbackPendingChanges(zxid, pendingChanges);\n<line80>                        }\n<line81>                    }\n<line82>                    // TODO: I don't want to have to serialize it here and then\n<line83>                    //       immediately deserialize in next processor. But I'm\n<line84>                    //       not sure how else to get the txn stored into our list.\n<line85>                    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n<line86>                        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line87>                        txn.serialize(boa, \"request\");\n<line88>                        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line89>                        txns.add(new Txn(type, bb.array()));\n<line90>                    }\n<line91>                }\n<line92>                request.setTxn(new MultiTxn(txns));\n<line93>                if (digestEnabled) {\n<line94>                    setTxnDigest(request);\n<line95>                }\n<line96>                break;\n<line97>            //create/close session don't require request record\n<line98>            case OpCode.createSession:\n<line99>            case OpCode.closeSession:\n<line100>                if (!request.isLocalSession()) {\n<line101>                    pRequest2Txn(request.type, zks.getNextZxid(), request, null);\n<line102>                }\n<line103>                break;\n<line104>            //All the rest don't need to create a Txn - just verify session\n<line105>            case OpCode.sync:\n<line106>            case OpCode.exists:\n<line107>            case OpCode.getData:\n<line108>            case OpCode.getACL:\n<line109>            case OpCode.getChildren:\n<line110>            case OpCode.getAllChildrenNumber:\n<line111>            case OpCode.getChildren2:\n<line112>            case OpCode.ping:\n<line113>            case OpCode.setWatches:\n<line114>            case OpCode.setWatches2:\n<line115>            case OpCode.checkWatches:\n<line116>            case OpCode.removeWatches:\n<line117>            case OpCode.getEphemerals:\n<line118>            case OpCode.multiRead:\n<line119>            case OpCode.addWatch:\n<line120>            case OpCode.whoAmI:\n<line121>                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line122>                break;\n<line123>            default:\n<line124>                LOG.warn(\"unknown type {}\", request.type);\n<line125>                break;\n<line126>        }\n<line127>    } catch (KeeperException e) {\n<line128>        if (request.getHdr() != null) {\n<line129>            request.getHdr().setType(OpCode.error);\n<line130>            request.setTxn(new ErrorTxn(e.code().intValue()));\n<line131>        }\n<line132>        if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line133>            LOG.info(\"Got user-level KeeperException when processing {} Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line134>        }\n<line135>        request.setException(e);\n<line136>    } catch (Exception e) {\n<line137>        // log at error level as we are returning a marshalling\n<line138>        // error to the user\n<line139>        LOG.error(\"Failed to process {}\", request, e);\n<line140>        String digest = request.requestDigest();\n<line141>        LOG.error(\"Dumping request buffer for request type {}: 0x{}\", Request.op2String(request.type), digest);\n<line142>        if (request.getHdr() == null) {\n<line143>            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getZxid(), Time.currentWallTime(), request.type));\n<line144>        }\n<line145>        request.getHdr().setType(OpCode.error);\n<line146>        request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));\n<line147>    }\n<line148>}"},{"input":"","instruction":"<line1>{\n<line2>    switch(request.type) {\n<line3>        case OpCode.createContainer:\n<line4>        case OpCode.create:\n<line5>        case OpCode.create2:\n<line6>            CreateRequest create2Request = request.readRequestRecord(CreateRequest::new);\n<line7>            pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request);\n<line8>            break;\n<line9>        case OpCode.createTTL:\n<line10>            CreateTTLRequest createTtlRequest = request.readRequestRecord(CreateTTLRequest::new);\n<line11>            pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest);\n<line12>            break;\n<line13>        case OpCode.deleteContainer:\n<line14>            DeleteContainerRequest deleteContainerRequest = request.readRequestRecord(DeleteContainerRequest::new);\n<line15>            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteContainerRequest);\n<line16>            break;\n<line17>        case OpCode.delete:\n<line18>            DeleteRequest deleteRequest = request.readRequestRecord(DeleteRequest::new);\n<line19>            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest);\n<line20>            break;\n<line21>        case OpCode.setData:\n<line22>            SetDataRequest setDataRequest = request.readRequestRecord(SetDataRequest::new);\n<line23>            pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest);\n<line24>            break;\n<line25>        case OpCode.reconfig:\n<line26>            ReconfigRequest reconfigRequest = request.readRequestRecord(ReconfigRequest::new);\n<line27>            pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest);\n<line28>            break;\n<line29>        case OpCode.setACL:\n<line30>            SetACLRequest setAclRequest = request.readRequestRecord(SetACLRequest::new);\n<line31>            pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest);\n<line32>            break;\n<line33>        case OpCode.check:\n<line34>            CheckVersionRequest checkRequest = request.readRequestRecord(CheckVersionRequest::new);\n<line35>            pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest);\n<line36>            break;\n<line37>        case OpCode.multi:\n<line38>            MultiOperationRecord multiRequest;\n<line39>            try {\n<line40>                multiRequest = request.readRequestRecord(MultiOperationRecord::new);\n<line41>            } catch (IOException e) {\n<line42>                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));\n<line43>                throw e;\n<line44>            }\n<line45>            List<Txn> txns = new ArrayList<>();\n<line46>            //Each op in a multi-op must have the same zxid!\n<line47>            long zxid = zks.getNextZxid();\n<line48>            KeeperException ke = null;\n<line49>            //Store off current pending change records in case we need to rollback\n<line50>            Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);\n<line51>            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));\n<line52>            for (Op op : multiRequest) {\n<line53>                Record subrequest = op.toRequestRecord();\n<line54>                int type;\n<line55>                Record txn;\n<line56>                /* If we've already failed one of the ops, don't bother\n<line57>                     * trying the rest as we know it's going to fail and it\n<line58>                     * would be confusing in the logfiles.\n<line59>                     */\n<line60>                if (ke != null) {\n<line61>                    type = OpCode.error;\n<line62>                    txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n<line63>                } else {\n<line64>                    /* Prep the request and convert to a Txn */\n<line65>                    try {\n<line66>                        pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line67>                        type = op.getType();\n<line68>                        txn = request.getTxn();\n<line69>                    } catch (KeeperException e) {\n<line70>                        ke = e;\n<line71>                        type = OpCode.error;\n<line72>                        txn = new ErrorTxn(e.code().intValue());\n<line73>                        if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line74>                        }\n<line75>                        request.setException(e);\n<line76>                        /* Rollback change records from failed multi-op */\n<line77>                        rollbackPendingChanges(zxid, pendingChanges);\n<line78>                    }\n<line79>                }\n<line80>                // TODO: I don't want to have to serialize it here and then\n<line81>                //       immediately deserialize in next processor. But I'm\n<line82>                //       not sure how else to get the txn stored into our list.\n<line83>                try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n<line84>                    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line85>                    txn.serialize(boa, \"request\");\n<line86>                    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line87>                    txns.add(new Txn(type, bb.array()));\n<line88>                }\n<line89>            }\n<line90>            request.setTxn(new MultiTxn(txns));\n<line91>            if (digestEnabled) {\n<line92>                setTxnDigest(request);\n<line93>            }\n<line94>            break;\n<line95>        //create/close session don't require request record\n<line96>        case OpCode.createSession:\n<line97>        case OpCode.closeSession:\n<line98>            if (!request.isLocalSession()) {\n<line99>                pRequest2Txn(request.type, zks.getNextZxid(), request, null);\n<line100>            }\n<line101>            break;\n<line102>        //All the rest don't need to create a Txn - just verify session\n<line103>        case OpCode.sync:\n<line104>        case OpCode.exists:\n<line105>        case OpCode.getData:\n<line106>        case OpCode.getACL:\n<line107>        case OpCode.getChildren:\n<line108>        case OpCode.getAllChildrenNumber:\n<line109>        case OpCode.getChildren2:\n<line110>        case OpCode.ping:\n<line111>        case OpCode.setWatches:\n<line112>        case OpCode.setWatches2:\n<line113>        case OpCode.checkWatches:\n<line114>        case OpCode.removeWatches:\n<line115>        case OpCode.getEphemerals:\n<line116>        case OpCode.multiRead:\n<line117>        case OpCode.addWatch:\n<line118>        case OpCode.whoAmI:\n<line119>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line120>            break;\n<line121>        default:\n<line122>            break;\n<line123>    }\n<line124>}","output":"<line1>{\n<line2>    switch(request.type) {\n<line3>        case OpCode.createContainer:\n<line4>        case OpCode.create:\n<line5>        case OpCode.create2:\n<line6>            CreateRequest create2Request = request.readRequestRecord(CreateRequest::new);\n<line7>            pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request);\n<line8>            break;\n<line9>        case OpCode.createTTL:\n<line10>            CreateTTLRequest createTtlRequest = request.readRequestRecord(CreateTTLRequest::new);\n<line11>            pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest);\n<line12>            break;\n<line13>        case OpCode.deleteContainer:\n<line14>            DeleteContainerRequest deleteContainerRequest = request.readRequestRecord(DeleteContainerRequest::new);\n<line15>            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteContainerRequest);\n<line16>            break;\n<line17>        case OpCode.delete:\n<line18>            DeleteRequest deleteRequest = request.readRequestRecord(DeleteRequest::new);\n<line19>            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest);\n<line20>            break;\n<line21>        case OpCode.setData:\n<line22>            SetDataRequest setDataRequest = request.readRequestRecord(SetDataRequest::new);\n<line23>            pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest);\n<line24>            break;\n<line25>        case OpCode.reconfig:\n<line26>            ReconfigRequest reconfigRequest = request.readRequestRecord(ReconfigRequest::new);\n<line27>            pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest);\n<line28>            break;\n<line29>        case OpCode.setACL:\n<line30>            SetACLRequest setAclRequest = request.readRequestRecord(SetACLRequest::new);\n<line31>            pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest);\n<line32>            break;\n<line33>        case OpCode.check:\n<line34>            CheckVersionRequest checkRequest = request.readRequestRecord(CheckVersionRequest::new);\n<line35>            pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest);\n<line36>            break;\n<line37>        case OpCode.multi:\n<line38>            MultiOperationRecord multiRequest;\n<line39>            try {\n<line40>                multiRequest = request.readRequestRecord(MultiOperationRecord::new);\n<line41>            } catch (IOException e) {\n<line42>                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));\n<line43>                throw e;\n<line44>            }\n<line45>            List<Txn> txns = new ArrayList<>();\n<line46>            //Each op in a multi-op must have the same zxid!\n<line47>            long zxid = zks.getNextZxid();\n<line48>            KeeperException ke = null;\n<line49>            //Store off current pending change records in case we need to rollback\n<line50>            Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);\n<line51>            request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));\n<line52>            for (Op op : multiRequest) {\n<line53>                Record subrequest = op.toRequestRecord();\n<line54>                int type;\n<line55>                Record txn;\n<line56>                /* If we've already failed one of the ops, don't bother\n<line57>                     * trying the rest as we know it's going to fail and it\n<line58>                     * would be confusing in the logfiles.\n<line59>                     */\n<line60>                if (ke != null) {\n<line61>                    type = OpCode.error;\n<line62>                    txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n<line63>                } else {\n<line64>                    /* Prep the request and convert to a Txn */\n<line65>                    try {\n<line66>                        pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line67>                        type = op.getType();\n<line68>                        txn = request.getTxn();\n<line69>                    } catch (KeeperException e) {\n<line70>                        ke = e;\n<line71>                        type = OpCode.error;\n<line72>                        txn = new ErrorTxn(e.code().intValue());\n<line73>                        if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line74>                            LOG.info(\"Got user-level KeeperException when processing {} aborting\" + \" remaining multi ops. Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line75>                        }\n<line76>                        request.setException(e);\n<line77>                        /* Rollback change records from failed multi-op */\n<line78>                        rollbackPendingChanges(zxid, pendingChanges);\n<line79>                    }\n<line80>                }\n<line81>                // TODO: I don't want to have to serialize it here and then\n<line82>                //       immediately deserialize in next processor. But I'm\n<line83>                //       not sure how else to get the txn stored into our list.\n<line84>                try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n<line85>                    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line86>                    txn.serialize(boa, \"request\");\n<line87>                    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line88>                    txns.add(new Txn(type, bb.array()));\n<line89>                }\n<line90>            }\n<line91>            request.setTxn(new MultiTxn(txns));\n<line92>            if (digestEnabled) {\n<line93>                setTxnDigest(request);\n<line94>            }\n<line95>            break;\n<line96>        //create/close session don't require request record\n<line97>        case OpCode.createSession:\n<line98>        case OpCode.closeSession:\n<line99>            if (!request.isLocalSession()) {\n<line100>                pRequest2Txn(request.type, zks.getNextZxid(), request, null);\n<line101>            }\n<line102>            break;\n<line103>        //All the rest don't need to create a Txn - just verify session\n<line104>        case OpCode.sync:\n<line105>        case OpCode.exists:\n<line106>        case OpCode.getData:\n<line107>        case OpCode.getACL:\n<line108>        case OpCode.getChildren:\n<line109>        case OpCode.getAllChildrenNumber:\n<line110>        case OpCode.getChildren2:\n<line111>        case OpCode.ping:\n<line112>        case OpCode.setWatches:\n<line113>        case OpCode.setWatches2:\n<line114>        case OpCode.checkWatches:\n<line115>        case OpCode.removeWatches:\n<line116>        case OpCode.getEphemerals:\n<line117>        case OpCode.multiRead:\n<line118>        case OpCode.addWatch:\n<line119>        case OpCode.whoAmI:\n<line120>            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n<line121>            break;\n<line122>        default:\n<line123>            LOG.warn(\"unknown type {}\", request.type);\n<line124>            break;\n<line125>    }\n<line126>}"},{"input":"","instruction":"<line1>{\n<line2>    Record subrequest = op.toRequestRecord();\n<line3>    int type;\n<line4>    Record txn;\n<line5>    /* If we've already failed one of the ops, don't bother\n<line6>                     * trying the rest as we know it's going to fail and it\n<line7>                     * would be confusing in the logfiles.\n<line8>                     */\n<line9>    if (ke != null) {\n<line10>        type = OpCode.error;\n<line11>        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n<line12>    } else {\n<line13>        /* Prep the request and convert to a Txn */\n<line14>        try {\n<line15>            pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line16>            type = op.getType();\n<line17>            txn = request.getTxn();\n<line18>        } catch (KeeperException e) {\n<line19>            ke = e;\n<line20>            type = OpCode.error;\n<line21>            txn = new ErrorTxn(e.code().intValue());\n<line22>            if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line23>            }\n<line24>            request.setException(e);\n<line25>            /* Rollback change records from failed multi-op */\n<line26>            rollbackPendingChanges(zxid, pendingChanges);\n<line27>        }\n<line28>    }\n<line29>    // TODO: I don't want to have to serialize it here and then\n<line30>    //       immediately deserialize in next processor. But I'm\n<line31>    //       not sure how else to get the txn stored into our list.\n<line32>    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n<line33>        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line34>        txn.serialize(boa, \"request\");\n<line35>        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line36>        txns.add(new Txn(type, bb.array()));\n<line37>    }\n<line38>}","output":"<line1>{\n<line2>    Record subrequest = op.toRequestRecord();\n<line3>    int type;\n<line4>    Record txn;\n<line5>    /* If we've already failed one of the ops, don't bother\n<line6>                     * trying the rest as we know it's going to fail and it\n<line7>                     * would be confusing in the logfiles.\n<line8>                     */\n<line9>    if (ke != null) {\n<line10>        type = OpCode.error;\n<line11>        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n<line12>    } else {\n<line13>        /* Prep the request and convert to a Txn */\n<line14>        try {\n<line15>            pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line16>            type = op.getType();\n<line17>            txn = request.getTxn();\n<line18>        } catch (KeeperException e) {\n<line19>            ke = e;\n<line20>            type = OpCode.error;\n<line21>            txn = new ErrorTxn(e.code().intValue());\n<line22>            if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line23>                LOG.info(\"Got user-level KeeperException when processing {} aborting\" + \" remaining multi ops. Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line24>            }\n<line25>            request.setException(e);\n<line26>            /* Rollback change records from failed multi-op */\n<line27>            rollbackPendingChanges(zxid, pendingChanges);\n<line28>        }\n<line29>    }\n<line30>    // TODO: I don't want to have to serialize it here and then\n<line31>    //       immediately deserialize in next processor. But I'm\n<line32>    //       not sure how else to get the txn stored into our list.\n<line33>    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n<line34>        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n<line35>        txn.serialize(boa, \"request\");\n<line36>        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n<line37>        txns.add(new Txn(type, bb.array()));\n<line38>    }\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    /* Prep the request and convert to a Txn */\n<line3>    try {\n<line4>        pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line5>        type = op.getType();\n<line6>        txn = request.getTxn();\n<line7>    } catch (KeeperException e) {\n<line8>        ke = e;\n<line9>        type = OpCode.error;\n<line10>        txn = new ErrorTxn(e.code().intValue());\n<line11>        if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line12>        }\n<line13>        request.setException(e);\n<line14>        /* Rollback change records from failed multi-op */\n<line15>        rollbackPendingChanges(zxid, pendingChanges);\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    /* Prep the request and convert to a Txn */\n<line3>    try {\n<line4>        pRequest2Txn(op.getType(), zxid, request, subrequest);\n<line5>        type = op.getType();\n<line6>        txn = request.getTxn();\n<line7>    } catch (KeeperException e) {\n<line8>        ke = e;\n<line9>        type = OpCode.error;\n<line10>        txn = new ErrorTxn(e.code().intValue());\n<line11>        if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line12>            LOG.info(\"Got user-level KeeperException when processing {} aborting\" + \" remaining multi ops. Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line13>        }\n<line14>        request.setException(e);\n<line15>        /* Rollback change records from failed multi-op */\n<line16>        rollbackPendingChanges(zxid, pendingChanges);\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    ke = e;\n<line3>    type = OpCode.error;\n<line4>    txn = new ErrorTxn(e.code().intValue());\n<line5>    if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line6>    }\n<line7>    request.setException(e);\n<line8>    /* Rollback change records from failed multi-op */\n<line9>    rollbackPendingChanges(zxid, pendingChanges);\n<line10>}","output":"<line1>{\n<line2>    ke = e;\n<line3>    type = OpCode.error;\n<line4>    txn = new ErrorTxn(e.code().intValue());\n<line5>    if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line6>        LOG.info(\"Got user-level KeeperException when processing {} aborting\" + \" remaining multi ops. Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line7>    }\n<line8>    request.setException(e);\n<line9>    /* Rollback change records from failed multi-op */\n<line10>    rollbackPendingChanges(zxid, pendingChanges);\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Got user-level KeeperException when processing {} aborting\" + \" remaining multi ops. Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.getHdr() != null) {\n<line3>        request.getHdr().setType(OpCode.error);\n<line4>        request.setTxn(new ErrorTxn(e.code().intValue()));\n<line5>    }\n<line6>    if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line7>    }\n<line8>    request.setException(e);\n<line9>}","output":"<line1>{\n<line2>    if (request.getHdr() != null) {\n<line3>        request.getHdr().setType(OpCode.error);\n<line4>        request.setTxn(new ErrorTxn(e.code().intValue()));\n<line5>    }\n<line6>    if (e.code().intValue() > Code.APIERROR.intValue()) {\n<line7>        LOG.info(\"Got user-level KeeperException when processing {} Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line8>    }\n<line9>    request.setException(e);\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Got user-level KeeperException when processing {} Error Path:{} Error:{}\", request.toString(), e.getPath(), e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // log at error level as we are returning a marshalling\n<line3>    // error to the user\n<line4>    String digest = request.requestDigest();\n<line5>    if (request.getHdr() == null) {\n<line6>        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getZxid(), Time.currentWallTime(), request.type));\n<line7>    }\n<line8>    request.getHdr().setType(OpCode.error);\n<line9>    request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));\n<line10>}","output":"<line1>{\n<line2>    // log at error level as we are returning a marshalling\n<line3>    // error to the user\n<line4>    LOG.error(\"Failed to process {}\", request, e);\n<line5>    String digest = request.requestDigest();\n<line6>    LOG.error(\"Dumping request buffer for request type {}: 0x{}\", Request.op2String(request.type), digest);\n<line7>    if (request.getHdr() == null) {\n<line8>        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getZxid(), Time.currentWallTime(), request.type));\n<line9>    }\n<line10>    request.getHdr().setType(OpCode.error);\n<line11>    request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // check for well formed ACLs\n<line3>    // This resolves https://issues.apache.org/jira/browse/ZOOKEEPER-1877\n<line4>    List<ACL> uniqacls = removeDuplicates(acls);\n<line5>    if (uniqacls == null || uniqacls.size() == 0) {\n<line6>        throw new KeeperException.InvalidACLException(path);\n<line7>    }\n<line8>    List<ACL> rv = new ArrayList<>();\n<line9>    for (ACL a : uniqacls) {\n<line10>        if (a == null) {\n<line11>            throw new KeeperException.InvalidACLException(path);\n<line12>        }\n<line13>        Id id = a.getId();\n<line14>        if (id == null || id.getScheme() == null) {\n<line15>            throw new KeeperException.InvalidACLException(path);\n<line16>        }\n<line17>        if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n<line18>            rv.add(a);\n<line19>        } else if (id.getScheme().equals(\"auth\")) {\n<line20>            // This is the \"auth\" id, so we have to expand it to the\n<line21>            // authenticated ids of the requestor\n<line22>            boolean authIdValid = false;\n<line23>            for (Id cid : authInfo) {\n<line24>                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line25>                if (ap == null) {\n<line26>                } else if (ap.isAuthenticated()) {\n<line27>                    authIdValid = true;\n<line28>                    rv.add(new ACL(a.getPerms(), cid));\n<line29>                }\n<line30>            }\n<line31>            if (!authIdValid) {\n<line32>                throw new KeeperException.InvalidACLException(path);\n<line33>            }\n<line34>        } else {\n<line35>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());\n<line36>            if (ap == null || !ap.isValid(id.getId())) {\n<line37>                throw new KeeperException.InvalidACLException(path);\n<line38>            }\n<line39>            rv.add(a);\n<line40>        }\n<line41>    }\n<line42>    return rv;\n<line43>}","output":"<line1>{\n<line2>    // check for well formed ACLs\n<line3>    // This resolves https://issues.apache.org/jira/browse/ZOOKEEPER-1877\n<line4>    List<ACL> uniqacls = removeDuplicates(acls);\n<line5>    if (uniqacls == null || uniqacls.size() == 0) {\n<line6>        throw new KeeperException.InvalidACLException(path);\n<line7>    }\n<line8>    List<ACL> rv = new ArrayList<>();\n<line9>    for (ACL a : uniqacls) {\n<line10>        LOG.debug(\"Processing ACL: {}\", a);\n<line11>        if (a == null) {\n<line12>            throw new KeeperException.InvalidACLException(path);\n<line13>        }\n<line14>        Id id = a.getId();\n<line15>        if (id == null || id.getScheme() == null) {\n<line16>            throw new KeeperException.InvalidACLException(path);\n<line17>        }\n<line18>        if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n<line19>            rv.add(a);\n<line20>        } else if (id.getScheme().equals(\"auth\")) {\n<line21>            // This is the \"auth\" id, so we have to expand it to the\n<line22>            // authenticated ids of the requestor\n<line23>            boolean authIdValid = false;\n<line24>            for (Id cid : authInfo) {\n<line25>                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line26>                if (ap == null) {\n<line27>                    LOG.error(\"Missing AuthenticationProvider for {}\", cid.getScheme());\n<line28>                } else if (ap.isAuthenticated()) {\n<line29>                    authIdValid = true;\n<line30>                    rv.add(new ACL(a.getPerms(), cid));\n<line31>                }\n<line32>            }\n<line33>            if (!authIdValid) {\n<line34>                throw new KeeperException.InvalidACLException(path);\n<line35>            }\n<line36>        } else {\n<line37>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());\n<line38>            if (ap == null || !ap.isValid(id.getId())) {\n<line39>                throw new KeeperException.InvalidACLException(path);\n<line40>            }\n<line41>            rv.add(a);\n<line42>        }\n<line43>    }\n<line44>    return rv;\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    if (a == null) {\n<line3>        throw new KeeperException.InvalidACLException(path);\n<line4>    }\n<line5>    Id id = a.getId();\n<line6>    if (id == null || id.getScheme() == null) {\n<line7>        throw new KeeperException.InvalidACLException(path);\n<line8>    }\n<line9>    if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n<line10>        rv.add(a);\n<line11>    } else if (id.getScheme().equals(\"auth\")) {\n<line12>        // This is the \"auth\" id, so we have to expand it to the\n<line13>        // authenticated ids of the requestor\n<line14>        boolean authIdValid = false;\n<line15>        for (Id cid : authInfo) {\n<line16>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line17>            if (ap == null) {\n<line18>            } else if (ap.isAuthenticated()) {\n<line19>                authIdValid = true;\n<line20>                rv.add(new ACL(a.getPerms(), cid));\n<line21>            }\n<line22>        }\n<line23>        if (!authIdValid) {\n<line24>            throw new KeeperException.InvalidACLException(path);\n<line25>        }\n<line26>    } else {\n<line27>        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());\n<line28>        if (ap == null || !ap.isValid(id.getId())) {\n<line29>            throw new KeeperException.InvalidACLException(path);\n<line30>        }\n<line31>        rv.add(a);\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    LOG.debug(\"Processing ACL: {}\", a);\n<line3>    if (a == null) {\n<line4>        throw new KeeperException.InvalidACLException(path);\n<line5>    }\n<line6>    Id id = a.getId();\n<line7>    if (id == null || id.getScheme() == null) {\n<line8>        throw new KeeperException.InvalidACLException(path);\n<line9>    }\n<line10>    if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n<line11>        rv.add(a);\n<line12>    } else if (id.getScheme().equals(\"auth\")) {\n<line13>        // This is the \"auth\" id, so we have to expand it to the\n<line14>        // authenticated ids of the requestor\n<line15>        boolean authIdValid = false;\n<line16>        for (Id cid : authInfo) {\n<line17>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line18>            if (ap == null) {\n<line19>                LOG.error(\"Missing AuthenticationProvider for {}\", cid.getScheme());\n<line20>            } else if (ap.isAuthenticated()) {\n<line21>                authIdValid = true;\n<line22>                rv.add(new ACL(a.getPerms(), cid));\n<line23>            }\n<line24>        }\n<line25>        if (!authIdValid) {\n<line26>            throw new KeeperException.InvalidACLException(path);\n<line27>        }\n<line28>    } else {\n<line29>        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());\n<line30>        if (ap == null || !ap.isValid(id.getId())) {\n<line31>            throw new KeeperException.InvalidACLException(path);\n<line32>        }\n<line33>        rv.add(a);\n<line34>    }\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    // This is the \"auth\" id, so we have to expand it to the\n<line3>    // authenticated ids of the requestor\n<line4>    boolean authIdValid = false;\n<line5>    for (Id cid : authInfo) {\n<line6>        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line7>        if (ap == null) {\n<line8>        } else if (ap.isAuthenticated()) {\n<line9>            authIdValid = true;\n<line10>            rv.add(new ACL(a.getPerms(), cid));\n<line11>        }\n<line12>    }\n<line13>    if (!authIdValid) {\n<line14>        throw new KeeperException.InvalidACLException(path);\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    // This is the \"auth\" id, so we have to expand it to the\n<line3>    // authenticated ids of the requestor\n<line4>    boolean authIdValid = false;\n<line5>    for (Id cid : authInfo) {\n<line6>        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line7>        if (ap == null) {\n<line8>            LOG.error(\"Missing AuthenticationProvider for {}\", cid.getScheme());\n<line9>        } else if (ap.isAuthenticated()) {\n<line10>            authIdValid = true;\n<line11>            rv.add(new ACL(a.getPerms(), cid));\n<line12>        }\n<line13>    }\n<line14>    if (!authIdValid) {\n<line15>        throw new KeeperException.InvalidACLException(path);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line3>    if (ap == null) {\n<line4>    } else if (ap.isAuthenticated()) {\n<line5>        authIdValid = true;\n<line6>        rv.add(new ACL(a.getPerms(), cid));\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());\n<line3>    if (ap == null) {\n<line4>        LOG.error(\"Missing AuthenticationProvider for {}\", cid.getScheme());\n<line5>    } else if (ap.isAuthenticated()) {\n<line6>        authIdValid = true;\n<line7>        rv.add(new ACL(a.getPerms(), cid));\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Missing AuthenticationProvider for {}\", cid.getScheme());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    submittedRequests.clear();\n<line3>    submittedRequests.add(Request.requestOfDeath);\n<line4>    nextProcessor.shutdown();\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    submittedRequests.clear();\n<line4>    submittedRequests.add(Request.requestOfDeath);\n<line5>    nextProcessor.shutdown();\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    long digest;\n<line3>    synchronized (zks.outstandingChanges) {\n<line4>        if (zks.outstandingChanges.isEmpty()) {\n<line5>            digest = zks.getZKDatabase().getDataTree().getTreeDigest();\n<line6>        } else {\n<line7>            digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;\n<line8>        }\n<line9>    }\n<line10>    return digest;\n<line11>}","output":"<line1>{\n<line2>    long digest;\n<line3>    synchronized (zks.outstandingChanges) {\n<line4>        if (zks.outstandingChanges.isEmpty()) {\n<line5>            digest = zks.getZKDatabase().getDataTree().getTreeDigest();\n<line6>            LOG.debug(\"Digest got from data tree is: {}\", digest);\n<line7>        } else {\n<line8>            digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;\n<line9>            LOG.debug(\"Digest got from outstandingChanges is: {}\", digest);\n<line10>        }\n<line11>    }\n<line12>    return digest;\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (zks.outstandingChanges.isEmpty()) {\n<line3>        digest = zks.getZKDatabase().getDataTree().getTreeDigest();\n<line4>    } else {\n<line5>        digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (zks.outstandingChanges.isEmpty()) {\n<line3>        digest = zks.getZKDatabase().getDataTree().getTreeDigest();\n<line4>        LOG.debug(\"Digest got from data tree is: {}\", digest);\n<line5>    } else {\n<line6>        digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;\n<line7>        LOG.debug(\"Digest got from outstandingChanges is: {}\", digest);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    digest = zks.getZKDatabase().getDataTree().getTreeDigest();\n<line3>}","output":"<line1>{\n<line2>    digest = zks.getZKDatabase().getDataTree().getTreeDigest();\n<line3>    LOG.debug(\"Digest got from data tree is: {}\", digest);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;\n<line3>}","output":"<line1>{\n<line2>    digest = zks.outstandingChanges.peekLast().precalculatedDigest.treeDigest;\n<line3>    LOG.debug(\"Digest got from outstandingChanges is: {}\", digest);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.snapDir = snapDir;\n<line3>    this.dataLogDir = dataLogDir;\n<line4>    this.snapRetainCount = snapRetainCount;\n<line5>    this.purgeInterval = purgeInterval;\n<line6>}","output":"<line1>{\n<line2>    this.snapDir = snapDir;\n<line3>    this.dataLogDir = dataLogDir;\n<line4>    this.snapRetainCount = snapRetainCount;\n<line5>    this.purgeInterval = purgeInterval;\n<line6>    LOG.info(\"autopurge.snapRetainCount set to {}\", snapRetainCount);\n<line7>    LOG.info(\"autopurge.purgeInterval set to {}\", purgeInterval);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {\n<line3>        return;\n<line4>    }\n<line5>    // Don't schedule the purge task with zero or negative purge interval.\n<line6>    if (purgeInterval <= 0) {\n<line7>        return;\n<line8>    }\n<line9>    timer = new Timer(\"PurgeTask\", true);\n<line10>    TimerTask task = new PurgeTask(dataLogDir, snapDir, snapRetainCount);\n<line11>    timer.scheduleAtFixedRate(task, 0, TimeUnit.HOURS.toMillis(purgeInterval));\n<line12>    purgeTaskStatus = PurgeTaskStatus.STARTED;\n<line13>}","output":"<line1>{\n<line2>    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {\n<line3>        LOG.warn(\"Purge task is already running.\");\n<line4>        return;\n<line5>    }\n<line6>    // Don't schedule the purge task with zero or negative purge interval.\n<line7>    if (purgeInterval <= 0) {\n<line8>        LOG.info(\"Purge task is not scheduled.\");\n<line9>        return;\n<line10>    }\n<line11>    timer = new Timer(\"PurgeTask\", true);\n<line12>    TimerTask task = new PurgeTask(dataLogDir, snapDir, snapRetainCount);\n<line13>    timer.scheduleAtFixedRate(task, 0, TimeUnit.HOURS.toMillis(purgeInterval));\n<line14>    purgeTaskStatus = PurgeTaskStatus.STARTED;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Purge task is not scheduled.\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {\n<line3>        timer.cancel();\n<line4>        purgeTaskStatus = PurgeTaskStatus.COMPLETED;\n<line5>    } else {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {\n<line3>        LOG.info(\"Shutting down purge task.\");\n<line4>        timer.cancel();\n<line5>        purgeTaskStatus = PurgeTaskStatus.COMPLETED;\n<line6>    } else {\n<line7>        LOG.warn(\"Purge task not started. Ignoring shutdown!\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    timer.cancel();\n<line3>    purgeTaskStatus = PurgeTaskStatus.COMPLETED;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down purge task.\");\n<line3>    timer.cancel();\n<line4>    purgeTaskStatus = PurgeTaskStatus.COMPLETED;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);\n<line4>    } catch (Exception e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Purge task started.\");\n<line3>    try {\n<line4>        PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);\n<line5>    } catch (Exception e) {\n<line6>        LOG.error(\"Error occurred while purging.\", e);\n<line7>    }\n<line8>    LOG.info(\"Purge task completed.\");\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error occurred while purging.\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean result = false;\n<line3>    // Need readLock to exclusively lock with removeWatcher, otherwise we\n<line4>    // may add a dead watch whose connection was just closed.\n<line5>    //\n<line6>    // Creating new watcher bit and adding it to the BitHashSet has it's\n<line7>    // own lock to minimize the write lock scope\n<line8>    addRemovePathRWLock.readLock().lock();\n<line9>    try {\n<line10>        // avoid race condition of adding a on flying dead watcher\n<line11>        if (isDeadWatcher(watcher)) {\n<line12>        } else {\n<line13>            Integer bit = watcherBitIdMap.add(watcher);\n<line14>            BitHashSet watchers = pathWatches.get(path);\n<line15>            if (watchers == null) {\n<line16>                watchers = new BitHashSet();\n<line17>                BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);\n<line18>                // it's possible multiple thread might add to pathWatches\n<line19>                // while we're holding read lock, so we need this check\n<line20>                // here\n<line21>                if (existingWatchers != null) {\n<line22>                    watchers = existingWatchers;\n<line23>                }\n<line24>            }\n<line25>            result = watchers.add(bit);\n<line26>        }\n<line27>    } finally {\n<line28>        addRemovePathRWLock.readLock().unlock();\n<line29>    }\n<line30>    return result;\n<line31>}","output":"<line1>{\n<line2>    boolean result = false;\n<line3>    // Need readLock to exclusively lock with removeWatcher, otherwise we\n<line4>    // may add a dead watch whose connection was just closed.\n<line5>    //\n<line6>    // Creating new watcher bit and adding it to the BitHashSet has it's\n<line7>    // own lock to minimize the write lock scope\n<line8>    addRemovePathRWLock.readLock().lock();\n<line9>    try {\n<line10>        // avoid race condition of adding a on flying dead watcher\n<line11>        if (isDeadWatcher(watcher)) {\n<line12>            LOG.debug(\"Ignoring addWatch with closed cnxn\");\n<line13>        } else {\n<line14>            Integer bit = watcherBitIdMap.add(watcher);\n<line15>            BitHashSet watchers = pathWatches.get(path);\n<line16>            if (watchers == null) {\n<line17>                watchers = new BitHashSet();\n<line18>                BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);\n<line19>                // it's possible multiple thread might add to pathWatches\n<line20>                // while we're holding read lock, so we need this check\n<line21>                // here\n<line22>                if (existingWatchers != null) {\n<line23>                    watchers = existingWatchers;\n<line24>                }\n<line25>            }\n<line26>            result = watchers.add(bit);\n<line27>        }\n<line28>    } finally {\n<line29>        addRemovePathRWLock.readLock().unlock();\n<line30>    }\n<line31>    return result;\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    // avoid race condition of adding a on flying dead watcher\n<line3>    if (isDeadWatcher(watcher)) {\n<line4>    } else {\n<line5>        Integer bit = watcherBitIdMap.add(watcher);\n<line6>        BitHashSet watchers = pathWatches.get(path);\n<line7>        if (watchers == null) {\n<line8>            watchers = new BitHashSet();\n<line9>            BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);\n<line10>            // it's possible multiple thread might add to pathWatches\n<line11>            // while we're holding read lock, so we need this check\n<line12>            // here\n<line13>            if (existingWatchers != null) {\n<line14>                watchers = existingWatchers;\n<line15>            }\n<line16>        }\n<line17>        result = watchers.add(bit);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    // avoid race condition of adding a on flying dead watcher\n<line3>    if (isDeadWatcher(watcher)) {\n<line4>        LOG.debug(\"Ignoring addWatch with closed cnxn\");\n<line5>    } else {\n<line6>        Integer bit = watcherBitIdMap.add(watcher);\n<line7>        BitHashSet watchers = pathWatches.get(path);\n<line8>        if (watchers == null) {\n<line9>            watchers = new BitHashSet();\n<line10>            BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);\n<line11>            // it's possible multiple thread might add to pathWatches\n<line12>            // while we're holding read lock, so we need this check\n<line13>            // here\n<line14>            if (existingWatchers != null) {\n<line15>                watchers = existingWatchers;\n<line16>            }\n<line17>        }\n<line18>        result = watchers.add(bit);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring addWatch with closed cnxn\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    this.listener = listener;\n<line3>    this.watcherCleanThreshold = watcherCleanThreshold;\n<line4>    this.watcherCleanIntervalInSeconds = watcherCleanIntervalInSeconds;\n<line5>    int suggestedMaxInProcessingThreshold = watcherCleanThreshold * watcherCleanThreadsNum;\n<line6>    if (maxInProcessingDeadWatchers > 0 && maxInProcessingDeadWatchers < suggestedMaxInProcessingThreshold) {\n<line7>        maxInProcessingDeadWatchers = suggestedMaxInProcessingThreshold;\n<line8>    }\n<line9>    this.maxInProcessingDeadWatchers = maxInProcessingDeadWatchers;\n<line10>    this.deadWatchers = new HashSet<>();\n<line11>    this.cleaners = new WorkerService(\"DeadWatcherCleanner\", watcherCleanThreadsNum, false);\n<line12>}","output":"<line1>{\n<line2>    this.listener = listener;\n<line3>    this.watcherCleanThreshold = watcherCleanThreshold;\n<line4>    this.watcherCleanIntervalInSeconds = watcherCleanIntervalInSeconds;\n<line5>    int suggestedMaxInProcessingThreshold = watcherCleanThreshold * watcherCleanThreadsNum;\n<line6>    if (maxInProcessingDeadWatchers > 0 && maxInProcessingDeadWatchers < suggestedMaxInProcessingThreshold) {\n<line7>        maxInProcessingDeadWatchers = suggestedMaxInProcessingThreshold;\n<line8>        LOG.info(\"The maxInProcessingDeadWatchers config is smaller than the suggested one, change it to use {}\", maxInProcessingDeadWatchers);\n<line9>    }\n<line10>    this.maxInProcessingDeadWatchers = maxInProcessingDeadWatchers;\n<line11>    this.deadWatchers = new HashSet<>();\n<line12>    this.cleaners = new WorkerService(\"DeadWatcherCleanner\", watcherCleanThreadsNum, false);\n<line13>    LOG.info(\"watcherCleanThreshold={}, watcherCleanIntervalInSeconds={}\" + \", watcherCleanThreadsNum={}, maxInProcessingDeadWatchers={}\", watcherCleanThreshold, watcherCleanIntervalInSeconds, watcherCleanThreadsNum, maxInProcessingDeadWatchers);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    maxInProcessingDeadWatchers = suggestedMaxInProcessingThreshold;\n<line3>}","output":"<line1>{\n<line2>    maxInProcessingDeadWatchers = suggestedMaxInProcessingThreshold;\n<line3>    LOG.info(\"The maxInProcessingDeadWatchers config is smaller than the suggested one, change it to use {}\", maxInProcessingDeadWatchers);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Wait if there are too many watchers waiting to be closed,\n<line3>    // this is will slow down the socket packet processing and\n<line4>    // the adding watches in the ZK pipeline.\n<line5>    while (maxInProcessingDeadWatchers > 0 && !stopped && totalDeadWatchers.get() >= maxInProcessingDeadWatchers) {\n<line6>        try {\n<line7>            RATE_LOGGER.rateLimitLog(\"Waiting for dead watchers cleaning\");\n<line8>            long startTime = Time.currentElapsedTime();\n<line9>            synchronized (processingCompletedEvent) {\n<line10>                processingCompletedEvent.wait(100);\n<line11>            }\n<line12>            long latency = Time.currentElapsedTime() - startTime;\n<line13>            ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);\n<line14>        } catch (InterruptedException e) {\n<line15>            break;\n<line16>        }\n<line17>    }\n<line18>    synchronized (this) {\n<line19>        if (deadWatchers.add(watcherBit)) {\n<line20>            totalDeadWatchers.incrementAndGet();\n<line21>            ServerMetrics.getMetrics().DEAD_WATCHERS_QUEUED.add(1);\n<line22>            if (deadWatchers.size() >= watcherCleanThreshold) {\n<line23>                synchronized (cleanEvent) {\n<line24>                    cleanEvent.notifyAll();\n<line25>                }\n<line26>            }\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    // Wait if there are too many watchers waiting to be closed,\n<line3>    // this is will slow down the socket packet processing and\n<line4>    // the adding watches in the ZK pipeline.\n<line5>    while (maxInProcessingDeadWatchers > 0 && !stopped && totalDeadWatchers.get() >= maxInProcessingDeadWatchers) {\n<line6>        try {\n<line7>            RATE_LOGGER.rateLimitLog(\"Waiting for dead watchers cleaning\");\n<line8>            long startTime = Time.currentElapsedTime();\n<line9>            synchronized (processingCompletedEvent) {\n<line10>                processingCompletedEvent.wait(100);\n<line11>            }\n<line12>            long latency = Time.currentElapsedTime() - startTime;\n<line13>            ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);\n<line14>        } catch (InterruptedException e) {\n<line15>            LOG.info(\"Got interrupted while waiting for dead watches queue size\");\n<line16>            break;\n<line17>        }\n<line18>    }\n<line19>    synchronized (this) {\n<line20>        if (deadWatchers.add(watcherBit)) {\n<line21>            totalDeadWatchers.incrementAndGet();\n<line22>            ServerMetrics.getMetrics().DEAD_WATCHERS_QUEUED.add(1);\n<line23>            if (deadWatchers.size() >= watcherCleanThreshold) {\n<line24>                synchronized (cleanEvent) {\n<line25>                    cleanEvent.notifyAll();\n<line26>                }\n<line27>            }\n<line28>        }\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        RATE_LOGGER.rateLimitLog(\"Waiting for dead watchers cleaning\");\n<line4>        long startTime = Time.currentElapsedTime();\n<line5>        synchronized (processingCompletedEvent) {\n<line6>            processingCompletedEvent.wait(100);\n<line7>        }\n<line8>        long latency = Time.currentElapsedTime() - startTime;\n<line9>        ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);\n<line10>    } catch (InterruptedException e) {\n<line11>        break;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    try {\n<line3>        RATE_LOGGER.rateLimitLog(\"Waiting for dead watchers cleaning\");\n<line4>        long startTime = Time.currentElapsedTime();\n<line5>        synchronized (processingCompletedEvent) {\n<line6>            processingCompletedEvent.wait(100);\n<line7>        }\n<line8>        long latency = Time.currentElapsedTime() - startTime;\n<line9>        ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);\n<line10>    } catch (InterruptedException e) {\n<line11>        LOG.info(\"Got interrupted while waiting for dead watches queue size\");\n<line12>        break;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Got interrupted while waiting for dead watches queue size\");\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    while (!stopped) {\n<line3>        synchronized (cleanEvent) {\n<line4>            try {\n<line5>                // add some jitter to avoid cleaning dead watchers at the\n<line6>                // same time in the quorum\n<line7>                if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n<line8>                    int maxWaitMs = (watcherCleanIntervalInSeconds + ThreadLocalRandom.current().nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n<line9>                    cleanEvent.wait(maxWaitMs);\n<line10>                }\n<line11>            } catch (InterruptedException e) {\n<line12>                break;\n<line13>            }\n<line14>        }\n<line15>        if (deadWatchers.isEmpty()) {\n<line16>            continue;\n<line17>        }\n<line18>        synchronized (this) {\n<line19>            // Clean the dead watchers need to go through all the current\n<line20>            // watches, which is pretty heavy and may take a second if\n<line21>            // there are millions of watches, that's why we're doing lazily\n<line22>            // batch clean up in a separate thread with a snapshot of the\n<line23>            // current dead watchers.\n<line24>            final Set<Integer> snapshot = new HashSet<>(deadWatchers);\n<line25>            deadWatchers.clear();\n<line26>            int total = snapshot.size();\n<line27>            cleaners.schedule(new WorkRequest() {\n<line28>\n<line29>                @Override\n<line30>                public void doWork() throws Exception {\n<line31>                    long startTime = Time.currentElapsedTime();\n<line32>                    listener.processDeadWatchers(snapshot);\n<line33>                    long latency = Time.currentElapsedTime() - startTime;\n<line34>                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line35>                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line36>                    totalDeadWatchers.addAndGet(-total);\n<line37>                    synchronized (processingCompletedEvent) {\n<line38>                        processingCompletedEvent.notifyAll();\n<line39>                    }\n<line40>                }\n<line41>            });\n<line42>        }\n<line43>    }\n<line44>}","output":"<line1>{\n<line2>    while (!stopped) {\n<line3>        synchronized (cleanEvent) {\n<line4>            try {\n<line5>                // add some jitter to avoid cleaning dead watchers at the\n<line6>                // same time in the quorum\n<line7>                if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n<line8>                    int maxWaitMs = (watcherCleanIntervalInSeconds + ThreadLocalRandom.current().nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n<line9>                    cleanEvent.wait(maxWaitMs);\n<line10>                }\n<line11>            } catch (InterruptedException e) {\n<line12>                LOG.info(\"Received InterruptedException while waiting for cleanEvent\");\n<line13>                break;\n<line14>            }\n<line15>        }\n<line16>        if (deadWatchers.isEmpty()) {\n<line17>            continue;\n<line18>        }\n<line19>        synchronized (this) {\n<line20>            // Clean the dead watchers need to go through all the current\n<line21>            // watches, which is pretty heavy and may take a second if\n<line22>            // there are millions of watches, that's why we're doing lazily\n<line23>            // batch clean up in a separate thread with a snapshot of the\n<line24>            // current dead watchers.\n<line25>            final Set<Integer> snapshot = new HashSet<>(deadWatchers);\n<line26>            deadWatchers.clear();\n<line27>            int total = snapshot.size();\n<line28>            LOG.info(\"Processing {} dead watchers\", total);\n<line29>            cleaners.schedule(new WorkRequest() {\n<line30>\n<line31>                @Override\n<line32>                public void doWork() throws Exception {\n<line33>                    long startTime = Time.currentElapsedTime();\n<line34>                    listener.processDeadWatchers(snapshot);\n<line35>                    long latency = Time.currentElapsedTime() - startTime;\n<line36>                    LOG.info(\"Takes {} to process {} watches\", latency, total);\n<line37>                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line38>                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line39>                    totalDeadWatchers.addAndGet(-total);\n<line40>                    synchronized (processingCompletedEvent) {\n<line41>                        processingCompletedEvent.notifyAll();\n<line42>                    }\n<line43>                }\n<line44>            });\n<line45>        }\n<line46>    }\n<line47>    LOG.info(\"WatcherCleaner thread exited\");\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (cleanEvent) {\n<line3>        try {\n<line4>            // add some jitter to avoid cleaning dead watchers at the\n<line5>            // same time in the quorum\n<line6>            if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n<line7>                int maxWaitMs = (watcherCleanIntervalInSeconds + ThreadLocalRandom.current().nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n<line8>                cleanEvent.wait(maxWaitMs);\n<line9>            }\n<line10>        } catch (InterruptedException e) {\n<line11>            break;\n<line12>        }\n<line13>    }\n<line14>    if (deadWatchers.isEmpty()) {\n<line15>        continue;\n<line16>    }\n<line17>    synchronized (this) {\n<line18>        // Clean the dead watchers need to go through all the current\n<line19>        // watches, which is pretty heavy and may take a second if\n<line20>        // there are millions of watches, that's why we're doing lazily\n<line21>        // batch clean up in a separate thread with a snapshot of the\n<line22>        // current dead watchers.\n<line23>        final Set<Integer> snapshot = new HashSet<>(deadWatchers);\n<line24>        deadWatchers.clear();\n<line25>        int total = snapshot.size();\n<line26>        cleaners.schedule(new WorkRequest() {\n<line27>\n<line28>            @Override\n<line29>            public void doWork() throws Exception {\n<line30>                long startTime = Time.currentElapsedTime();\n<line31>                listener.processDeadWatchers(snapshot);\n<line32>                long latency = Time.currentElapsedTime() - startTime;\n<line33>                ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line34>                ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line35>                totalDeadWatchers.addAndGet(-total);\n<line36>                synchronized (processingCompletedEvent) {\n<line37>                    processingCompletedEvent.notifyAll();\n<line38>                }\n<line39>            }\n<line40>        });\n<line41>    }\n<line42>}","output":"<line1>{\n<line2>    synchronized (cleanEvent) {\n<line3>        try {\n<line4>            // add some jitter to avoid cleaning dead watchers at the\n<line5>            // same time in the quorum\n<line6>            if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n<line7>                int maxWaitMs = (watcherCleanIntervalInSeconds + ThreadLocalRandom.current().nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n<line8>                cleanEvent.wait(maxWaitMs);\n<line9>            }\n<line10>        } catch (InterruptedException e) {\n<line11>            LOG.info(\"Received InterruptedException while waiting for cleanEvent\");\n<line12>            break;\n<line13>        }\n<line14>    }\n<line15>    if (deadWatchers.isEmpty()) {\n<line16>        continue;\n<line17>    }\n<line18>    synchronized (this) {\n<line19>        // Clean the dead watchers need to go through all the current\n<line20>        // watches, which is pretty heavy and may take a second if\n<line21>        // there are millions of watches, that's why we're doing lazily\n<line22>        // batch clean up in a separate thread with a snapshot of the\n<line23>        // current dead watchers.\n<line24>        final Set<Integer> snapshot = new HashSet<>(deadWatchers);\n<line25>        deadWatchers.clear();\n<line26>        int total = snapshot.size();\n<line27>        LOG.info(\"Processing {} dead watchers\", total);\n<line28>        cleaners.schedule(new WorkRequest() {\n<line29>\n<line30>            @Override\n<line31>            public void doWork() throws Exception {\n<line32>                long startTime = Time.currentElapsedTime();\n<line33>                listener.processDeadWatchers(snapshot);\n<line34>                long latency = Time.currentElapsedTime() - startTime;\n<line35>                LOG.info(\"Takes {} to process {} watches\", latency, total);\n<line36>                ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line37>                ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line38>                totalDeadWatchers.addAndGet(-total);\n<line39>                synchronized (processingCompletedEvent) {\n<line40>                    processingCompletedEvent.notifyAll();\n<line41>                }\n<line42>            }\n<line43>        });\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // add some jitter to avoid cleaning dead watchers at the\n<line4>        // same time in the quorum\n<line5>        if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n<line6>            int maxWaitMs = (watcherCleanIntervalInSeconds + ThreadLocalRandom.current().nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n<line7>            cleanEvent.wait(maxWaitMs);\n<line8>        }\n<line9>    } catch (InterruptedException e) {\n<line10>        break;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        // add some jitter to avoid cleaning dead watchers at the\n<line4>        // same time in the quorum\n<line5>        if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n<line6>            int maxWaitMs = (watcherCleanIntervalInSeconds + ThreadLocalRandom.current().nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n<line7>            cleanEvent.wait(maxWaitMs);\n<line8>        }\n<line9>    } catch (InterruptedException e) {\n<line10>        LOG.info(\"Received InterruptedException while waiting for cleanEvent\");\n<line11>        break;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Received InterruptedException while waiting for cleanEvent\");\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Clean the dead watchers need to go through all the current\n<line3>    // watches, which is pretty heavy and may take a second if\n<line4>    // there are millions of watches, that's why we're doing lazily\n<line5>    // batch clean up in a separate thread with a snapshot of the\n<line6>    // current dead watchers.\n<line7>    final Set<Integer> snapshot = new HashSet<>(deadWatchers);\n<line8>    deadWatchers.clear();\n<line9>    int total = snapshot.size();\n<line10>    cleaners.schedule(new WorkRequest() {\n<line11>\n<line12>        @Override\n<line13>        public void doWork() throws Exception {\n<line14>            long startTime = Time.currentElapsedTime();\n<line15>            listener.processDeadWatchers(snapshot);\n<line16>            long latency = Time.currentElapsedTime() - startTime;\n<line17>            ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line18>            ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line19>            totalDeadWatchers.addAndGet(-total);\n<line20>            synchronized (processingCompletedEvent) {\n<line21>                processingCompletedEvent.notifyAll();\n<line22>            }\n<line23>        }\n<line24>    });\n<line25>}","output":"<line1>{\n<line2>    // Clean the dead watchers need to go through all the current\n<line3>    // watches, which is pretty heavy and may take a second if\n<line4>    // there are millions of watches, that's why we're doing lazily\n<line5>    // batch clean up in a separate thread with a snapshot of the\n<line6>    // current dead watchers.\n<line7>    final Set<Integer> snapshot = new HashSet<>(deadWatchers);\n<line8>    deadWatchers.clear();\n<line9>    int total = snapshot.size();\n<line10>    LOG.info(\"Processing {} dead watchers\", total);\n<line11>    cleaners.schedule(new WorkRequest() {\n<line12>\n<line13>        @Override\n<line14>        public void doWork() throws Exception {\n<line15>            long startTime = Time.currentElapsedTime();\n<line16>            listener.processDeadWatchers(snapshot);\n<line17>            long latency = Time.currentElapsedTime() - startTime;\n<line18>            LOG.info(\"Takes {} to process {} watches\", latency, total);\n<line19>            ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line20>            ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line21>            totalDeadWatchers.addAndGet(-total);\n<line22>            synchronized (processingCompletedEvent) {\n<line23>                processingCompletedEvent.notifyAll();\n<line24>            }\n<line25>        }\n<line26>    });\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    long startTime = Time.currentElapsedTime();\n<line3>    listener.processDeadWatchers(snapshot);\n<line4>    long latency = Time.currentElapsedTime() - startTime;\n<line5>    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line6>    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line7>    totalDeadWatchers.addAndGet(-total);\n<line8>    synchronized (processingCompletedEvent) {\n<line9>        processingCompletedEvent.notifyAll();\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    long startTime = Time.currentElapsedTime();\n<line3>    listener.processDeadWatchers(snapshot);\n<line4>    long latency = Time.currentElapsedTime() - startTime;\n<line5>    LOG.info(\"Takes {} to process {} watches\", latency, total);\n<line6>    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);\n<line7>    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);\n<line8>    totalDeadWatchers.addAndGet(-total);\n<line9>    synchronized (processingCompletedEvent) {\n<line10>        processingCompletedEvent.notifyAll();\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    stopped = true;\n<line3>    deadWatchers.clear();\n<line4>    cleaners.stop();\n<line5>    this.interrupt();\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    stopped = true;\n<line3>    deadWatchers.clear();\n<line4>    cleaners.stop();\n<line5>    this.interrupt();\n<line6>    if (LOG.isInfoEnabled()) {\n<line7>        LOG.info(\"WatcherCleaner thread shutdown is initiated\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"WatcherCleaner thread shutdown is initiated\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (isDeadWatcher(watcher)) {\n<line3>        return false;\n<line4>    }\n<line5>    Set<Watcher> list = watchTable.get(path);\n<line6>    if (list == null) {\n<line7>        // don't waste memory if there are few watches on a node\n<line8>        // rehash when the 4th entry is added, doubling size thereafter\n<line9>        // seems like a good compromise\n<line10>        list = new HashSet<>(4);\n<line11>        watchTable.put(path, list);\n<line12>    }\n<line13>    list.add(watcher);\n<line14>    Map<String, WatchStats> paths = watch2Paths.get(watcher);\n<line15>    if (paths == null) {\n<line16>        // cnxns typically have many watches, so use default cap here\n<line17>        paths = new HashMap<>();\n<line18>        watch2Paths.put(watcher, paths);\n<line19>    }\n<line20>    WatchStats stats = paths.getOrDefault(path, WatchStats.NONE);\n<line21>    WatchStats newStats = stats.addMode(watcherMode);\n<line22>    if (newStats != stats) {\n<line23>        paths.put(path, newStats);\n<line24>        if (watcherMode.isRecursive()) {\n<line25>            ++recursiveWatchQty;\n<line26>        }\n<line27>        return true;\n<line28>    }\n<line29>    return false;\n<line30>}","output":"<line1>{\n<line2>    if (isDeadWatcher(watcher)) {\n<line3>        LOG.debug(\"Ignoring addWatch with closed cnxn\");\n<line4>        return false;\n<line5>    }\n<line6>    Set<Watcher> list = watchTable.get(path);\n<line7>    if (list == null) {\n<line8>        // don't waste memory if there are few watches on a node\n<line9>        // rehash when the 4th entry is added, doubling size thereafter\n<line10>        // seems like a good compromise\n<line11>        list = new HashSet<>(4);\n<line12>        watchTable.put(path, list);\n<line13>    }\n<line14>    list.add(watcher);\n<line15>    Map<String, WatchStats> paths = watch2Paths.get(watcher);\n<line16>    if (paths == null) {\n<line17>        // cnxns typically have many watches, so use default cap here\n<line18>        paths = new HashMap<>();\n<line19>        watch2Paths.put(watcher, paths);\n<line20>    }\n<line21>    WatchStats stats = paths.getOrDefault(path, WatchStats.NONE);\n<line22>    WatchStats newStats = stats.addMode(watcherMode);\n<line23>    if (newStats != stats) {\n<line24>        paths.put(path, newStats);\n<line25>        if (watcherMode.isRecursive()) {\n<line26>            ++recursiveWatchQty;\n<line27>        }\n<line28>        return true;\n<line29>    }\n<line30>    return false;\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring addWatch with closed cnxn\");\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String watchManagerName = System.getProperty(ZOOKEEPER_WATCH_MANAGER_NAME);\n<line3>    if (watchManagerName == null) {\n<line4>        watchManagerName = WatchManager.class.getName();\n<line5>    }\n<line6>    try {\n<line7>        IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();\n<line8>        return watchManager;\n<line9>    } catch (Exception e) {\n<line10>        IOException ioe = new IOException(\"Couldn't instantiate \" + watchManagerName, e);\n<line11>        throw ioe;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    String watchManagerName = System.getProperty(ZOOKEEPER_WATCH_MANAGER_NAME);\n<line3>    if (watchManagerName == null) {\n<line4>        watchManagerName = WatchManager.class.getName();\n<line5>    }\n<line6>    try {\n<line7>        IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();\n<line8>        LOG.info(\"Using {} as watch manager\", watchManagerName);\n<line9>        return watchManager;\n<line10>    } catch (Exception e) {\n<line11>        IOException ioe = new IOException(\"Couldn't instantiate \" + watchManagerName, e);\n<line12>        throw ioe;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();\n<line3>    return watchManager;\n<line4>}","output":"<line1>{\n<line2>    IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();\n<line3>    LOG.info(\"Using {} as watch manager\", watchManagerName);\n<line4>    return watchManager;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    this.zkDb = zkDb;\n<line3>    this.requestProcessor = requestProcessor;\n<line4>    this.checkIntervalMs = checkIntervalMs;\n<line5>    this.maxPerMinute = maxPerMinute;\n<line6>    this.maxNeverUsedIntervalMs = maxNeverUsedIntervalMs;\n<line7>    timer = new Timer(\"ContainerManagerTask\", true);\n<line8>}","output":"<line1>{\n<line2>    this.zkDb = zkDb;\n<line3>    this.requestProcessor = requestProcessor;\n<line4>    this.checkIntervalMs = checkIntervalMs;\n<line5>    this.maxPerMinute = maxPerMinute;\n<line6>    this.maxNeverUsedIntervalMs = maxNeverUsedIntervalMs;\n<line7>    timer = new Timer(\"ContainerManagerTask\", true);\n<line8>    LOG.info(\"Using checkIntervalMs={} maxPerMinute={} maxNeverUsedIntervalMs={}\", checkIntervalMs, maxPerMinute, maxNeverUsedIntervalMs);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    if (task.get() == null) {\n<line3>        TimerTask timerTask = new TimerTask() {\n<line4>\n<line5>            @Override\n<line6>            public void run() {\n<line7>                try {\n<line8>                    checkContainers();\n<line9>                } catch (InterruptedException e) {\n<line10>                    Thread.currentThread().interrupt();\n<line11>                    cancel();\n<line12>                } catch (Throwable e) {\n<line13>                }\n<line14>            }\n<line15>        };\n<line16>        if (task.compareAndSet(null, timerTask)) {\n<line17>            timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);\n<line18>        }\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    if (task.get() == null) {\n<line3>        TimerTask timerTask = new TimerTask() {\n<line4>\n<line5>            @Override\n<line6>            public void run() {\n<line7>                try {\n<line8>                    checkContainers();\n<line9>                } catch (InterruptedException e) {\n<line10>                    Thread.currentThread().interrupt();\n<line11>                    LOG.info(\"interrupted\");\n<line12>                    cancel();\n<line13>                } catch (Throwable e) {\n<line14>                    LOG.error(\"Error checking containers\", e);\n<line15>                }\n<line16>            }\n<line17>        };\n<line18>        if (task.compareAndSet(null, timerTask)) {\n<line19>            timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);\n<line20>        }\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    TimerTask timerTask = new TimerTask() {\n<line3>\n<line4>        @Override\n<line5>        public void run() {\n<line6>            try {\n<line7>                checkContainers();\n<line8>            } catch (InterruptedException e) {\n<line9>                Thread.currentThread().interrupt();\n<line10>                cancel();\n<line11>            } catch (Throwable e) {\n<line12>            }\n<line13>        }\n<line14>    };\n<line15>    if (task.compareAndSet(null, timerTask)) {\n<line16>        timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    TimerTask timerTask = new TimerTask() {\n<line3>\n<line4>        @Override\n<line5>        public void run() {\n<line6>            try {\n<line7>                checkContainers();\n<line8>            } catch (InterruptedException e) {\n<line9>                Thread.currentThread().interrupt();\n<line10>                LOG.info(\"interrupted\");\n<line11>                cancel();\n<line12>            } catch (Throwable e) {\n<line13>                LOG.error(\"Error checking containers\", e);\n<line14>            }\n<line15>        }\n<line16>    };\n<line17>    if (task.compareAndSet(null, timerTask)) {\n<line18>        timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        checkContainers();\n<line4>    } catch (InterruptedException e) {\n<line5>        Thread.currentThread().interrupt();\n<line6>        cancel();\n<line7>    } catch (Throwable e) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        checkContainers();\n<line4>    } catch (InterruptedException e) {\n<line5>        Thread.currentThread().interrupt();\n<line6>        LOG.info(\"interrupted\");\n<line7>        cancel();\n<line8>    } catch (Throwable e) {\n<line9>        LOG.error(\"Error checking containers\", e);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread.currentThread().interrupt();\n<line3>    cancel();\n<line4>}","output":"<line1>{\n<line2>    Thread.currentThread().interrupt();\n<line3>    LOG.info(\"interrupted\");\n<line4>    cancel();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error checking containers\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    long minIntervalMs = getMinIntervalMs();\n<line3>    for (String containerPath : getCandidates()) {\n<line4>        long startMs = Time.currentElapsedTime();\n<line5>        DeleteContainerRequest record = new DeleteContainerRequest(containerPath);\n<line6>        Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, RequestRecord.fromRecord(record), null);\n<line7>        try {\n<line8>            postDeleteRequest(request);\n<line9>        } catch (Exception e) {\n<line10>        }\n<line11>        long elapsedMs = Time.currentElapsedTime() - startMs;\n<line12>        long waitMs = minIntervalMs - elapsedMs;\n<line13>        if (waitMs > 0) {\n<line14>            Thread.sleep(waitMs);\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    long minIntervalMs = getMinIntervalMs();\n<line3>    for (String containerPath : getCandidates()) {\n<line4>        long startMs = Time.currentElapsedTime();\n<line5>        DeleteContainerRequest record = new DeleteContainerRequest(containerPath);\n<line6>        Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, RequestRecord.fromRecord(record), null);\n<line7>        try {\n<line8>            LOG.info(\"Attempting to delete candidate container: {}\", containerPath);\n<line9>            postDeleteRequest(request);\n<line10>        } catch (Exception e) {\n<line11>            LOG.error(\"Could not delete container: {}\", containerPath, e);\n<line12>        }\n<line13>        long elapsedMs = Time.currentElapsedTime() - startMs;\n<line14>        long waitMs = minIntervalMs - elapsedMs;\n<line15>        if (waitMs > 0) {\n<line16>            Thread.sleep(waitMs);\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    long startMs = Time.currentElapsedTime();\n<line3>    DeleteContainerRequest record = new DeleteContainerRequest(containerPath);\n<line4>    Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, RequestRecord.fromRecord(record), null);\n<line5>    try {\n<line6>        postDeleteRequest(request);\n<line7>    } catch (Exception e) {\n<line8>    }\n<line9>    long elapsedMs = Time.currentElapsedTime() - startMs;\n<line10>    long waitMs = minIntervalMs - elapsedMs;\n<line11>    if (waitMs > 0) {\n<line12>        Thread.sleep(waitMs);\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    long startMs = Time.currentElapsedTime();\n<line3>    DeleteContainerRequest record = new DeleteContainerRequest(containerPath);\n<line4>    Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, RequestRecord.fromRecord(record), null);\n<line5>    try {\n<line6>        LOG.info(\"Attempting to delete candidate container: {}\", containerPath);\n<line7>        postDeleteRequest(request);\n<line8>    } catch (Exception e) {\n<line9>        LOG.error(\"Could not delete container: {}\", containerPath, e);\n<line10>    }\n<line11>    long elapsedMs = Time.currentElapsedTime() - startMs;\n<line12>    long waitMs = minIntervalMs - elapsedMs;\n<line13>    if (waitMs > 0) {\n<line14>        Thread.sleep(waitMs);\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    postDeleteRequest(request);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Attempting to delete candidate container: {}\", containerPath);\n<line3>    postDeleteRequest(request);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Could not delete container: {}\", containerPath, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (whiteListInitialized) {\n<line3>        return whiteListedCommands.contains(command);\n<line4>    }\n<line5>    String commands = System.getProperty(ZOOKEEPER_4LW_COMMANDS_WHITELIST);\n<line6>    if (commands != null) {\n<line7>        String[] list = commands.split(\",\");\n<line8>        for (String cmd : list) {\n<line9>            if (cmd.trim().equals(\"*\")) {\n<line10>                for (Map.Entry<Integer, String> entry : cmd2String.entrySet()) {\n<line11>                    whiteListedCommands.add(entry.getValue());\n<line12>                }\n<line13>                break;\n<line14>            }\n<line15>            if (!cmd.trim().isEmpty()) {\n<line16>                whiteListedCommands.add(cmd.trim());\n<line17>            }\n<line18>        }\n<line19>    }\n<line20>    // It is sad that isro and srvr are used by ZooKeeper itself. Need fix this\n<line21>    // before deprecating 4lw.\n<line22>    if (System.getProperty(\"readonlymode.enabled\", \"false\").equals(\"true\")) {\n<line23>        whiteListedCommands.add(\"isro\");\n<line24>    }\n<line25>    // zkServer.sh depends on \"srvr\".\n<line26>    whiteListedCommands.add(\"srvr\");\n<line27>    whiteListInitialized = true;\n<line28>    return whiteListedCommands.contains(command);\n<line29>}","output":"<line1>{\n<line2>    if (whiteListInitialized) {\n<line3>        return whiteListedCommands.contains(command);\n<line4>    }\n<line5>    String commands = System.getProperty(ZOOKEEPER_4LW_COMMANDS_WHITELIST);\n<line6>    if (commands != null) {\n<line7>        String[] list = commands.split(\",\");\n<line8>        for (String cmd : list) {\n<line9>            if (cmd.trim().equals(\"*\")) {\n<line10>                for (Map.Entry<Integer, String> entry : cmd2String.entrySet()) {\n<line11>                    whiteListedCommands.add(entry.getValue());\n<line12>                }\n<line13>                break;\n<line14>            }\n<line15>            if (!cmd.trim().isEmpty()) {\n<line16>                whiteListedCommands.add(cmd.trim());\n<line17>            }\n<line18>        }\n<line19>    }\n<line20>    // It is sad that isro and srvr are used by ZooKeeper itself. Need fix this\n<line21>    // before deprecating 4lw.\n<line22>    if (System.getProperty(\"readonlymode.enabled\", \"false\").equals(\"true\")) {\n<line23>        whiteListedCommands.add(\"isro\");\n<line24>    }\n<line25>    // zkServer.sh depends on \"srvr\".\n<line26>    whiteListedCommands.add(\"srvr\");\n<line27>    whiteListInitialized = true;\n<line28>    LOG.info(\"The list of known four letter word commands is : {}\", Arrays.asList(cmd2String));\n<line29>    LOG.info(\"The list of enabled four letter word commands is : {}\", Arrays.asList(whiteListedCommands));\n<line30>    return whiteListedCommands.contains(command);\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!isZKServerRunning()) {\n<line3>        pw.println(ZK_NOT_SERVING);\n<line4>    } else {\n<line5>        pw.print(\"Zookeeper version: \");\n<line6>        pw.println(Version.getFullVersion());\n<line7>        if (zkServer instanceof ReadOnlyZooKeeperServer) {\n<line8>            pw.println(\"READ-ONLY mode; serving only read-only clients\");\n<line9>        }\n<line10>        if (len == FourLetterCommands.statCmd) {\n<line11>            pw.println(\"Clients:\");\n<line12>            for (ServerCnxn c : factory.getConnections()) {\n<line13>                c.dumpConnectionInfo(pw, true);\n<line14>                pw.println();\n<line15>            }\n<line16>            pw.println();\n<line17>        }\n<line18>        ServerStats serverStats = zkServer.serverStats();\n<line19>        pw.print(serverStats.toString());\n<line20>        pw.print(\"Node count: \");\n<line21>        pw.println(zkServer.getZKDatabase().getNodeCount());\n<line22>        if (serverStats.getServerState().equals(\"leader\")) {\n<line23>            Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();\n<line24>            BufferStats proposalStats = leader.getProposalStats();\n<line25>            pw.printf(\"Proposal sizes last/min/max: %s%n\", proposalStats.toString());\n<line26>        }\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    if (!isZKServerRunning()) {\n<line3>        pw.println(ZK_NOT_SERVING);\n<line4>    } else {\n<line5>        pw.print(\"Zookeeper version: \");\n<line6>        pw.println(Version.getFullVersion());\n<line7>        if (zkServer instanceof ReadOnlyZooKeeperServer) {\n<line8>            pw.println(\"READ-ONLY mode; serving only read-only clients\");\n<line9>        }\n<line10>        if (len == FourLetterCommands.statCmd) {\n<line11>            LOG.info(\"Stat command output\");\n<line12>            pw.println(\"Clients:\");\n<line13>            for (ServerCnxn c : factory.getConnections()) {\n<line14>                c.dumpConnectionInfo(pw, true);\n<line15>                pw.println();\n<line16>            }\n<line17>            pw.println();\n<line18>        }\n<line19>        ServerStats serverStats = zkServer.serverStats();\n<line20>        pw.print(serverStats.toString());\n<line21>        pw.print(\"Node count: \");\n<line22>        pw.println(zkServer.getZKDatabase().getNodeCount());\n<line23>        if (serverStats.getServerState().equals(\"leader\")) {\n<line24>            Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();\n<line25>            BufferStats proposalStats = leader.getProposalStats();\n<line26>            pw.printf(\"Proposal sizes last/min/max: %s%n\", proposalStats.toString());\n<line27>        }\n<line28>    }\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    pw.print(\"Zookeeper version: \");\n<line3>    pw.println(Version.getFullVersion());\n<line4>    if (zkServer instanceof ReadOnlyZooKeeperServer) {\n<line5>        pw.println(\"READ-ONLY mode; serving only read-only clients\");\n<line6>    }\n<line7>    if (len == FourLetterCommands.statCmd) {\n<line8>        pw.println(\"Clients:\");\n<line9>        for (ServerCnxn c : factory.getConnections()) {\n<line10>            c.dumpConnectionInfo(pw, true);\n<line11>            pw.println();\n<line12>        }\n<line13>        pw.println();\n<line14>    }\n<line15>    ServerStats serverStats = zkServer.serverStats();\n<line16>    pw.print(serverStats.toString());\n<line17>    pw.print(\"Node count: \");\n<line18>    pw.println(zkServer.getZKDatabase().getNodeCount());\n<line19>    if (serverStats.getServerState().equals(\"leader\")) {\n<line20>        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();\n<line21>        BufferStats proposalStats = leader.getProposalStats();\n<line22>        pw.printf(\"Proposal sizes last/min/max: %s%n\", proposalStats.toString());\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    pw.print(\"Zookeeper version: \");\n<line3>    pw.println(Version.getFullVersion());\n<line4>    if (zkServer instanceof ReadOnlyZooKeeperServer) {\n<line5>        pw.println(\"READ-ONLY mode; serving only read-only clients\");\n<line6>    }\n<line7>    if (len == FourLetterCommands.statCmd) {\n<line8>        LOG.info(\"Stat command output\");\n<line9>        pw.println(\"Clients:\");\n<line10>        for (ServerCnxn c : factory.getConnections()) {\n<line11>            c.dumpConnectionInfo(pw, true);\n<line12>            pw.println();\n<line13>        }\n<line14>        pw.println();\n<line15>    }\n<line16>    ServerStats serverStats = zkServer.serverStats();\n<line17>    pw.print(serverStats.toString());\n<line18>    pw.print(\"Node count: \");\n<line19>    pw.println(zkServer.getZKDatabase().getNodeCount());\n<line20>    if (serverStats.getServerState().equals(\"leader\")) {\n<line21>        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();\n<line22>        BufferStats proposalStats = leader.getProposalStats();\n<line23>        pw.printf(\"Proposal sizes last/min/max: %s%n\", proposalStats.toString());\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    pw.println(\"Clients:\");\n<line3>    for (ServerCnxn c : factory.getConnections()) {\n<line4>        c.dumpConnectionInfo(pw, true);\n<line5>        pw.println();\n<line6>    }\n<line7>    pw.println();\n<line8>}","output":"<line1>{\n<line2>    LOG.info(\"Stat command output\");\n<line3>    pw.println(\"Clients:\");\n<line4>    for (ServerCnxn c : factory.getConnections()) {\n<line5>        c.dumpConnectionInfo(pw, true);\n<line6>        pw.println();\n<line7>    }\n<line8>    pw.println();\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        commandRun();\n<line4>    } catch (IOException ie) {\n<line5>    } finally {\n<line6>        serverCnxn.cleanupWriterSocket(pw);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        commandRun();\n<line4>    } catch (IOException ie) {\n<line5>        LOG.error(\"Error in running command \", ie);\n<line6>    } finally {\n<line7>        serverCnxn.cleanupWriterSocket(pw);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error in running command \", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Proposal p;\n<line3>    try {\n<line4>        byte[] serializedData = Util.marshallTxnEntry(itr.getHeader(), itr.getTxn(), itr.getDigest());\n<line5>        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, itr.getHeader().getZxid(), serializedData, null);\n<line6>        p = new Proposal(pp);\n<line7>        // This is the only place that can throw IO exception\n<line8>        hasNext = itr.next();\n<line9>    } catch (IOException e) {\n<line10>        hasNext = false;\n<line11>        p = new Proposal();\n<line12>    }\n<line13>    return p;\n<line14>}","output":"<line1>{\n<line2>    Proposal p;\n<line3>    try {\n<line4>        byte[] serializedData = Util.marshallTxnEntry(itr.getHeader(), itr.getTxn(), itr.getDigest());\n<line5>        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, itr.getHeader().getZxid(), serializedData, null);\n<line6>        p = new Proposal(pp);\n<line7>        // This is the only place that can throw IO exception\n<line8>        hasNext = itr.next();\n<line9>    } catch (IOException e) {\n<line10>        LOG.error(\"Unable to read txnlog from disk\", e);\n<line11>        hasNext = false;\n<line12>        p = new Proposal();\n<line13>    }\n<line14>    return p;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    hasNext = false;\n<line3>    p = new Proposal();\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to read txnlog from disk\", e);\n<line3>    hasNext = false;\n<line4>    p = new Proposal();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    dataTree = createDataTree();\n<line3>    sessionsWithTimeouts = new ConcurrentHashMap<>();\n<line4>    this.snapLog = snapLog;\n<line5>    try {\n<line6>        snapshotSizeFactor = Double.parseDouble(System.getProperty(SNAPSHOT_SIZE_FACTOR, Double.toString(DEFAULT_SNAPSHOT_SIZE_FACTOR)));\n<line7>        if (snapshotSizeFactor > 1) {\n<line8>            snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n<line9>        }\n<line10>    } catch (NumberFormatException e) {\n<line11>        snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n<line12>    }\n<line13>    try {\n<line14>        commitLogCount = Integer.parseInt(System.getProperty(COMMIT_LOG_COUNT, Integer.toString(DEFAULT_COMMIT_LOG_COUNT)));\n<line15>        if (commitLogCount < DEFAULT_COMMIT_LOG_COUNT) {\n<line16>            commitLogCount = DEFAULT_COMMIT_LOG_COUNT;\n<line17>        }\n<line18>    } catch (NumberFormatException e) {\n<line19>        commitLogCount = DEFAULT_COMMIT_LOG_COUNT;\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    dataTree = createDataTree();\n<line3>    sessionsWithTimeouts = new ConcurrentHashMap<>();\n<line4>    this.snapLog = snapLog;\n<line5>    try {\n<line6>        snapshotSizeFactor = Double.parseDouble(System.getProperty(SNAPSHOT_SIZE_FACTOR, Double.toString(DEFAULT_SNAPSHOT_SIZE_FACTOR)));\n<line7>        if (snapshotSizeFactor > 1) {\n<line8>            snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n<line9>            LOG.warn(\"The configured {} is invalid, going to use the default {}\", SNAPSHOT_SIZE_FACTOR, DEFAULT_SNAPSHOT_SIZE_FACTOR);\n<line10>        }\n<line11>    } catch (NumberFormatException e) {\n<line12>        LOG.error(\"Error parsing {}, using default value {}\", SNAPSHOT_SIZE_FACTOR, DEFAULT_SNAPSHOT_SIZE_FACTOR);\n<line13>        snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n<line14>    }\n<line15>    LOG.info(\"{} = {}\", SNAPSHOT_SIZE_FACTOR, snapshotSizeFactor);\n<line16>    try {\n<line17>        commitLogCount = Integer.parseInt(System.getProperty(COMMIT_LOG_COUNT, Integer.toString(DEFAULT_COMMIT_LOG_COUNT)));\n<line18>        if (commitLogCount < DEFAULT_COMMIT_LOG_COUNT) {\n<line19>            commitLogCount = DEFAULT_COMMIT_LOG_COUNT;\n<line20>            LOG.warn(\"The configured commitLogCount {} is less than the recommended {}, going to use the recommended one\", COMMIT_LOG_COUNT, DEFAULT_COMMIT_LOG_COUNT);\n<line21>        }\n<line22>    } catch (NumberFormatException e) {\n<line23>        LOG.error(\"Error parsing {} - use default value {}\", COMMIT_LOG_COUNT, DEFAULT_COMMIT_LOG_COUNT);\n<line24>        commitLogCount = DEFAULT_COMMIT_LOG_COUNT;\n<line25>    }\n<line26>    LOG.info(\"{}={}\", COMMIT_LOG_COUNT, commitLogCount);\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error parsing {}, using default value {}\", SNAPSHOT_SIZE_FACTOR, DEFAULT_SNAPSHOT_SIZE_FACTOR);\n<line3>    snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    commitLogCount = DEFAULT_COMMIT_LOG_COUNT;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error parsing {} - use default value {}\", COMMIT_LOG_COUNT, DEFAULT_COMMIT_LOG_COUNT);\n<line3>    commitLogCount = DEFAULT_COMMIT_LOG_COUNT;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    long startTime = Time.currentElapsedTime();\n<line3>    long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);\n<line4>    initialized = true;\n<line5>    long loadTime = Time.currentElapsedTime() - startTime;\n<line6>    ServerMetrics.getMetrics().DB_INIT_TIME.add(loadTime);\n<line7>    return zxid;\n<line8>}","output":"<line1>{\n<line2>    long startTime = Time.currentElapsedTime();\n<line3>    long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);\n<line4>    initialized = true;\n<line5>    long loadTime = Time.currentElapsedTime() - startTime;\n<line6>    ServerMetrics.getMetrics().DB_INIT_TIME.add(loadTime);\n<line7>    LOG.info(\"Snapshot loaded in {} ms, highest zxid is 0x{}, digest is {}\", loadTime, Long.toHexString(zxid), dataTree.getTreeDigest());\n<line8>    return zxid;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean enabled = snapshotSizeFactor >= 0;\n<line3>    if (enabled) {\n<line4>    } else {\n<line5>    }\n<line6>    return enabled;\n<line7>}","output":"<line1>{\n<line2>    boolean enabled = snapshotSizeFactor >= 0;\n<line3>    if (enabled) {\n<line4>        LOG.info(\"On disk txn sync enabled with snapshotSizeFactor {}\", snapshotSizeFactor);\n<line5>    } else {\n<line6>        LOG.info(\"On disk txn sync disabled\");\n<line7>    }\n<line8>    return enabled;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"On disk txn sync enabled with snapshotSizeFactor {}\", snapshotSizeFactor);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"On disk txn sync disabled\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    long snapSize = 0;\n<line3>    try {\n<line4>        File snapFile = snapLog.findMostRecentSnapshot();\n<line5>        if (snapFile != null) {\n<line6>            snapSize = snapFile.length();\n<line7>        }\n<line8>    } catch (IOException e) {\n<line9>    }\n<line10>    return (long) (snapSize * snapshotSizeFactor);\n<line11>}","output":"<line1>{\n<line2>    long snapSize = 0;\n<line3>    try {\n<line4>        File snapFile = snapLog.findMostRecentSnapshot();\n<line5>        if (snapFile != null) {\n<line6>            snapSize = snapFile.length();\n<line7>        }\n<line8>    } catch (IOException e) {\n<line9>        LOG.error(\"Unable to get size of most recent snapshot\");\n<line10>    }\n<line11>    return (long) (snapSize * snapshotSizeFactor);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to get size of most recent snapshot\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sizeLimit < 0) {\n<line3>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line4>    }\n<line5>    TxnIterator itr = null;\n<line6>    try {\n<line7>        itr = snapLog.readTxnLog(startZxid, false);\n<line8>        // If we cannot guarantee that this is strictly the starting txn\n<line9>        // after a given zxid, we should fail.\n<line10>        if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {\n<line11>            itr.close();\n<line12>            return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line13>        }\n<line14>        if (sizeLimit > 0) {\n<line15>            long txnSize = itr.getStorageSize();\n<line16>            if (txnSize > sizeLimit) {\n<line17>                itr.close();\n<line18>                return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line19>            }\n<line20>        }\n<line21>    } catch (IOException e) {\n<line22>        try {\n<line23>            if (itr != null) {\n<line24>                itr.close();\n<line25>            }\n<line26>        } catch (IOException ioe) {\n<line27>        }\n<line28>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line29>    }\n<line30>    return new TxnLogProposalIterator(itr);\n<line31>}","output":"<line1>{\n<line2>    if (sizeLimit < 0) {\n<line3>        LOG.debug(\"Negative size limit - retrieving proposal via txnlog is disabled\");\n<line4>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line5>    }\n<line6>    TxnIterator itr = null;\n<line7>    try {\n<line8>        itr = snapLog.readTxnLog(startZxid, false);\n<line9>        // If we cannot guarantee that this is strictly the starting txn\n<line10>        // after a given zxid, we should fail.\n<line11>        if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {\n<line12>            LOG.warn(\"Unable to find proposals from txnlog for zxid: 0x{}\", Long.toHexString(startZxid));\n<line13>            itr.close();\n<line14>            return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line15>        }\n<line16>        if (sizeLimit > 0) {\n<line17>            long txnSize = itr.getStorageSize();\n<line18>            if (txnSize > sizeLimit) {\n<line19>                LOG.info(\"Txnlog size: {} exceeds sizeLimit: {}\", txnSize, sizeLimit);\n<line20>                itr.close();\n<line21>                return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line22>            }\n<line23>        }\n<line24>    } catch (IOException e) {\n<line25>        LOG.error(\"Unable to read txnlog from disk\", e);\n<line26>        try {\n<line27>            if (itr != null) {\n<line28>                itr.close();\n<line29>            }\n<line30>        } catch (IOException ioe) {\n<line31>            LOG.warn(\"Error closing file iterator\", ioe);\n<line32>        }\n<line33>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line34>    }\n<line35>    return new TxnLogProposalIterator(itr);\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Negative size limit - retrieving proposal via txnlog is disabled\");\n<line3>    return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    itr = snapLog.readTxnLog(startZxid, false);\n<line3>    // If we cannot guarantee that this is strictly the starting txn\n<line4>    // after a given zxid, we should fail.\n<line5>    if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {\n<line6>        itr.close();\n<line7>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line8>    }\n<line9>    if (sizeLimit > 0) {\n<line10>        long txnSize = itr.getStorageSize();\n<line11>        if (txnSize > sizeLimit) {\n<line12>            itr.close();\n<line13>            return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    itr = snapLog.readTxnLog(startZxid, false);\n<line3>    // If we cannot guarantee that this is strictly the starting txn\n<line4>    // after a given zxid, we should fail.\n<line5>    if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {\n<line6>        LOG.warn(\"Unable to find proposals from txnlog for zxid: 0x{}\", Long.toHexString(startZxid));\n<line7>        itr.close();\n<line8>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line9>    }\n<line10>    if (sizeLimit > 0) {\n<line11>        long txnSize = itr.getStorageSize();\n<line12>        if (txnSize > sizeLimit) {\n<line13>            LOG.info(\"Txnlog size: {} exceeds sizeLimit: {}\", txnSize, sizeLimit);\n<line14>            itr.close();\n<line15>            return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    long txnSize = itr.getStorageSize();\n<line3>    if (txnSize > sizeLimit) {\n<line4>        itr.close();\n<line5>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    long txnSize = itr.getStorageSize();\n<line3>    if (txnSize > sizeLimit) {\n<line4>        LOG.info(\"Txnlog size: {} exceeds sizeLimit: {}\", txnSize, sizeLimit);\n<line5>        itr.close();\n<line6>        return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    itr.close();\n<line3>    return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Txnlog size: {} exceeds sizeLimit: {}\", txnSize, sizeLimit);\n<line3>    itr.close();\n<line4>    return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (itr != null) {\n<line4>            itr.close();\n<line5>        }\n<line6>    } catch (IOException ioe) {\n<line7>    }\n<line8>    return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line9>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to read txnlog from disk\", e);\n<line3>    try {\n<line4>        if (itr != null) {\n<line5>            itr.close();\n<line6>        }\n<line7>    } catch (IOException ioe) {\n<line8>        LOG.warn(\"Error closing file iterator\", ioe);\n<line9>    }\n<line10>    return TxnLogProposalIterator.EMPTY_ITERATOR;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    outstandingHandshakeLimit = limit;\n<line3>    handshakeThrottlingEnabled = (secure || shouldUsePortUnification) && outstandingHandshakeLimit > 0;\n<line4>}","output":"<line1>{\n<line2>    outstandingHandshakeLimit = limit;\n<line3>    handshakeThrottlingEnabled = (secure || shouldUsePortUnification) && outstandingHandshakeLimit > 0;\n<line4>    LOG.info(\"handshakeThrottlingEnabled = {}, {} = {}\", handshakeThrottlingEnabled, OUTSTANDING_HANDSHAKE_LIMIT, outstandingHandshakeLimit);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (in.readableBytes() >= 5) {\n<line3>        super.decode(context, in, out);\n<line4>    } else if (in.readableBytes() > 0) {\n<line5>        // It requires 5 bytes to detect a proper ssl connection. In the\n<line6>        // case that the server receives fewer, check if we can fail to plaintext.\n<line7>        // This will occur when for any four letter work commands.\n<line8>        if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n<line9>            handleNonSsl(context);\n<line10>        }\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (in.readableBytes() >= 5) {\n<line3>        super.decode(context, in, out);\n<line4>    } else if (in.readableBytes() > 0) {\n<line5>        // It requires 5 bytes to detect a proper ssl connection. In the\n<line6>        // case that the server receives fewer, check if we can fail to plaintext.\n<line7>        // This will occur when for any four letter work commands.\n<line8>        if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n<line9>            LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n<line10>            handleNonSsl(context);\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    // It requires 5 bytes to detect a proper ssl connection. In the\n<line3>    // case that the server receives fewer, check if we can fail to plaintext.\n<line4>    // This will occur when for any four letter work commands.\n<line5>    if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n<line6>        handleNonSsl(context);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    // It requires 5 bytes to detect a proper ssl connection. In the\n<line3>    // case that the server receives fewer, check if we can fail to plaintext.\n<line4>    // This will occur when for any four letter work commands.\n<line5>    if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n<line6>        LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n<line7>        handleNonSsl(context);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    handleNonSsl(context);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n<line3>    handleNonSsl(context);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n<line3>    SslHandler handler = super.newSslHandler(context, sslContext);\n<line4>    Future<Channel> handshakeFuture = handler.handshakeFuture();\n<line5>    handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));\n<line6>    return handler;\n<line7>}","output":"<line1>{\n<line2>    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n<line3>    LOG.debug(\"creating ssl handler for session {}\", cnxn.getSessionId());\n<line4>    SslHandler handler = super.newSslHandler(context, sslContext);\n<line5>    Future<Channel> handshakeFuture = handler.handshakeFuture();\n<line6>    handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));\n<line7>    return handler;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n<line3>    // Mark handshake finished if it's a insecure cnxn\n<line4>    updateHandshakeCountIfStarted(cnxn);\n<line5>    allChannels.add(context.channel());\n<line6>    addCnxn(cnxn);\n<line7>    return super.newNonSslHandler(context);\n<line8>}","output":"<line1>{\n<line2>    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n<line3>    LOG.debug(\"creating plaintext handler for session {}\", cnxn.getSessionId());\n<line4>    // Mark handshake finished if it's a insecure cnxn\n<line5>    updateHandshakeCountIfStarted(cnxn);\n<line6>    allChannels.add(context.channel());\n<line7>    addCnxn(cnxn);\n<line8>    return super.newNonSslHandler(context);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    final Channel channel = ctx.channel();\n<line4>    if (limitTotalNumberOfCnxns()) {\n<line5>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line6>        channel.close();\n<line7>        return;\n<line8>    }\n<line9>    InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n<line10>    if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {\n<line11>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line12>        channel.close();\n<line13>        return;\n<line14>    }\n<line15>    NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);\n<line16>    ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);\n<line17>    // Check the zkServer assigned to the cnxn is still running,\n<line18>    // close it before starting the heavy TLS handshake\n<line19>    if (secure && !cnxn.isZKServerRunning()) {\n<line20>        boolean earlyDropSecureConnectionHandshakes = Boolean.getBoolean(EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);\n<line21>        if (earlyDropSecureConnectionHandshakes) {\n<line22>            ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n<line23>            channel.close();\n<line24>            return;\n<line25>        }\n<line26>    }\n<line27>    if (handshakeThrottlingEnabled) {\n<line28>        // Favor to check and throttling even in dual mode which\n<line29>        // accepts both secure and insecure connections, since\n<line30>        // it's more efficient than throttling when we know it's\n<line31>        // a secure connection in DualModeSslHandler.\n<line32>        //\n<line33>        // From benchmark, this reduced around 15% reconnect time.\n<line34>        int outstandingHandshakesNum = outstandingHandshake.addAndGet(1);\n<line35>        if (outstandingHandshakesNum > outstandingHandshakeLimit) {\n<line36>            outstandingHandshake.addAndGet(-1);\n<line37>            channel.close();\n<line38>            ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED.add(1);\n<line39>        } else {\n<line40>            cnxn.setHandshakeState(HandshakeState.STARTED);\n<line41>        }\n<line42>    }\n<line43>    if (secure) {\n<line44>        SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);\n<line45>        Future<Channel> handshakeFuture = sslHandler.handshakeFuture();\n<line46>        handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));\n<line47>    } else if (!shouldUsePortUnification) {\n<line48>        allChannels.add(ctx.channel());\n<line49>        addCnxn(cnxn);\n<line50>    }\n<line51>    if (ctx.channel().pipeline().get(SslHandler.class) == null) {\n<line52>        if (zkServer != null) {\n<line53>            SocketAddress remoteAddress = cnxn.getChannel().remoteAddress();\n<line54>            if (remoteAddress != null && !((InetSocketAddress) remoteAddress).getAddress().isLoopbackAddress()) {\n<line55>                zkServer.serverStats().incrementNonMTLSRemoteConnCount();\n<line56>            } else {\n<line57>                zkServer.serverStats().incrementNonMTLSLocalConnCount();\n<line58>            }\n<line59>        } else {\n<line60>        }\n<line61>    }\n<line62>}","output":"<line1>{\n<line2>    if (LOG.isTraceEnabled()) {\n<line3>        LOG.trace(\"Channel active {}\", ctx.channel());\n<line4>    }\n<line5>    final Channel channel = ctx.channel();\n<line6>    if (limitTotalNumberOfCnxns()) {\n<line7>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line8>        channel.close();\n<line9>        return;\n<line10>    }\n<line11>    InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n<line12>    if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {\n<line13>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line14>        LOG.warn(\"Too many connections from {} - max is {}\", addr, maxClientCnxns);\n<line15>        channel.close();\n<line16>        return;\n<line17>    }\n<line18>    NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);\n<line19>    ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);\n<line20>    // Check the zkServer assigned to the cnxn is still running,\n<line21>    // close it before starting the heavy TLS handshake\n<line22>    if (secure && !cnxn.isZKServerRunning()) {\n<line23>        boolean earlyDropSecureConnectionHandshakes = Boolean.getBoolean(EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);\n<line24>        if (earlyDropSecureConnectionHandshakes) {\n<line25>            LOG.info(\"Zookeeper server is not running, close the connection to {} before starting the TLS handshake\", cnxn.getChannel().remoteAddress());\n<line26>            ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n<line27>            channel.close();\n<line28>            return;\n<line29>        }\n<line30>    }\n<line31>    if (handshakeThrottlingEnabled) {\n<line32>        // Favor to check and throttling even in dual mode which\n<line33>        // accepts both secure and insecure connections, since\n<line34>        // it's more efficient than throttling when we know it's\n<line35>        // a secure connection in DualModeSslHandler.\n<line36>        //\n<line37>        // From benchmark, this reduced around 15% reconnect time.\n<line38>        int outstandingHandshakesNum = outstandingHandshake.addAndGet(1);\n<line39>        if (outstandingHandshakesNum > outstandingHandshakeLimit) {\n<line40>            outstandingHandshake.addAndGet(-1);\n<line41>            channel.close();\n<line42>            ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED.add(1);\n<line43>        } else {\n<line44>            cnxn.setHandshakeState(HandshakeState.STARTED);\n<line45>        }\n<line46>    }\n<line47>    if (secure) {\n<line48>        SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);\n<line49>        Future<Channel> handshakeFuture = sslHandler.handshakeFuture();\n<line50>        handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));\n<line51>    } else if (!shouldUsePortUnification) {\n<line52>        allChannels.add(ctx.channel());\n<line53>        addCnxn(cnxn);\n<line54>    }\n<line55>    if (ctx.channel().pipeline().get(SslHandler.class) == null) {\n<line56>        if (zkServer != null) {\n<line57>            SocketAddress remoteAddress = cnxn.getChannel().remoteAddress();\n<line58>            if (remoteAddress != null && !((InetSocketAddress) remoteAddress).getAddress().isLoopbackAddress()) {\n<line59>                LOG.trace(\"NettyChannelHandler channelActive: remote={} local={}\", remoteAddress, cnxn.getChannel().localAddress());\n<line60>                zkServer.serverStats().incrementNonMTLSRemoteConnCount();\n<line61>            } else {\n<line62>                zkServer.serverStats().incrementNonMTLSLocalConnCount();\n<line63>            }\n<line64>        } else {\n<line65>            LOG.trace(\"Opened non-TLS connection from {} but zkServer is not running\", cnxn.getChannel().remoteAddress());\n<line66>        }\n<line67>    }\n<line68>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean earlyDropSecureConnectionHandshakes = Boolean.getBoolean(EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);\n<line3>    if (earlyDropSecureConnectionHandshakes) {\n<line4>        ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n<line5>        channel.close();\n<line6>        return;\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    boolean earlyDropSecureConnectionHandshakes = Boolean.getBoolean(EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);\n<line3>    if (earlyDropSecureConnectionHandshakes) {\n<line4>        LOG.info(\"Zookeeper server is not running, close the connection to {} before starting the TLS handshake\", cnxn.getChannel().remoteAddress());\n<line5>        ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n<line6>        channel.close();\n<line7>        return;\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n<line3>    channel.close();\n<line4>    return;\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Zookeeper server is not running, close the connection to {} before starting the TLS handshake\", cnxn.getChannel().remoteAddress());\n<line3>    ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n<line4>    channel.close();\n<line5>    return;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);\n<line3>    if (cnxn != null) {\n<line4>        updateHandshakeCountIfStarted(cnxn);\n<line5>        cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.warn(\"Exception caught\", cause);\n<line3>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);\n<line4>    if (cnxn != null) {\n<line5>        LOG.debug(\"Closing {}\", cnxn);\n<line6>        updateHandshakeCountIfStarted(cnxn);\n<line7>        cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    updateHandshakeCountIfStarted(cnxn);\n<line3>    cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"Closing {}\", cnxn);\n<line3>    updateHandshakeCountIfStarted(cnxn);\n<line4>    cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (evt == NettyServerCnxn.ReadEvent.ENABLE) {\n<line4>            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line5>            // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n<line6>            // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n<line7>            // after either of those. Check for null just to be safe ...\n<line8>            if (cnxn != null) {\n<line9>                if (cnxn.getQueuedReadableBytes() > 0) {\n<line10>                    cnxn.processQueuedBuffer();\n<line11>                    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line12>                        // trigger a read if we have consumed all\n<line13>                        // backlog\n<line14>                        ctx.read();\n<line15>                    }\n<line16>                }\n<line17>            }\n<line18>            if (!advancedFlowControlEnabled) {\n<line19>                ctx.channel().config().setAutoRead(true);\n<line20>            }\n<line21>        } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {\n<line22>            ctx.channel().config().setAutoRead(false);\n<line23>        }\n<line24>    } finally {\n<line25>        ReferenceCountUtil.release(evt);\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    try {\n<line3>        if (evt == NettyServerCnxn.ReadEvent.ENABLE) {\n<line4>            LOG.debug(\"Received ReadEvent.ENABLE\");\n<line5>            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line6>            // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n<line7>            // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n<line8>            // after either of those. Check for null just to be safe ...\n<line9>            if (cnxn != null) {\n<line10>                if (cnxn.getQueuedReadableBytes() > 0) {\n<line11>                    cnxn.processQueuedBuffer();\n<line12>                    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line13>                        // trigger a read if we have consumed all\n<line14>                        // backlog\n<line15>                        ctx.read();\n<line16>                        LOG.debug(\"Issued a read after queuedBuffer drained\");\n<line17>                    }\n<line18>                }\n<line19>            }\n<line20>            if (!advancedFlowControlEnabled) {\n<line21>                ctx.channel().config().setAutoRead(true);\n<line22>            }\n<line23>        } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {\n<line24>            LOG.debug(\"Received ReadEvent.DISABLE\");\n<line25>            ctx.channel().config().setAutoRead(false);\n<line26>        }\n<line27>    } finally {\n<line28>        ReferenceCountUtil.release(evt);\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    if (evt == NettyServerCnxn.ReadEvent.ENABLE) {\n<line3>        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line4>        // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n<line5>        // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n<line6>        // after either of those. Check for null just to be safe ...\n<line7>        if (cnxn != null) {\n<line8>            if (cnxn.getQueuedReadableBytes() > 0) {\n<line9>                cnxn.processQueuedBuffer();\n<line10>                if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line11>                    // trigger a read if we have consumed all\n<line12>                    // backlog\n<line13>                    ctx.read();\n<line14>                }\n<line15>            }\n<line16>        }\n<line17>        if (!advancedFlowControlEnabled) {\n<line18>            ctx.channel().config().setAutoRead(true);\n<line19>        }\n<line20>    } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {\n<line21>        ctx.channel().config().setAutoRead(false);\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    if (evt == NettyServerCnxn.ReadEvent.ENABLE) {\n<line3>        LOG.debug(\"Received ReadEvent.ENABLE\");\n<line4>        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line5>        // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n<line6>        // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n<line7>        // after either of those. Check for null just to be safe ...\n<line8>        if (cnxn != null) {\n<line9>            if (cnxn.getQueuedReadableBytes() > 0) {\n<line10>                cnxn.processQueuedBuffer();\n<line11>                if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line12>                    // trigger a read if we have consumed all\n<line13>                    // backlog\n<line14>                    ctx.read();\n<line15>                    LOG.debug(\"Issued a read after queuedBuffer drained\");\n<line16>                }\n<line17>            }\n<line18>        }\n<line19>        if (!advancedFlowControlEnabled) {\n<line20>            ctx.channel().config().setAutoRead(true);\n<line21>        }\n<line22>    } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {\n<line23>        LOG.debug(\"Received ReadEvent.DISABLE\");\n<line24>        ctx.channel().config().setAutoRead(false);\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line3>    // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n<line4>    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n<line5>    // after either of those. Check for null just to be safe ...\n<line6>    if (cnxn != null) {\n<line7>        if (cnxn.getQueuedReadableBytes() > 0) {\n<line8>            cnxn.processQueuedBuffer();\n<line9>            if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line10>                // trigger a read if we have consumed all\n<line11>                // backlog\n<line12>                ctx.read();\n<line13>            }\n<line14>        }\n<line15>    }\n<line16>    if (!advancedFlowControlEnabled) {\n<line17>        ctx.channel().config().setAutoRead(true);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    LOG.debug(\"Received ReadEvent.ENABLE\");\n<line3>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line4>    // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n<line5>    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n<line6>    // after either of those. Check for null just to be safe ...\n<line7>    if (cnxn != null) {\n<line8>        if (cnxn.getQueuedReadableBytes() > 0) {\n<line9>            cnxn.processQueuedBuffer();\n<line10>            if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line11>                // trigger a read if we have consumed all\n<line12>                // backlog\n<line13>                ctx.read();\n<line14>                LOG.debug(\"Issued a read after queuedBuffer drained\");\n<line15>            }\n<line16>        }\n<line17>    }\n<line18>    if (!advancedFlowControlEnabled) {\n<line19>        ctx.channel().config().setAutoRead(true);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    if (cnxn.getQueuedReadableBytes() > 0) {\n<line3>        cnxn.processQueuedBuffer();\n<line4>        if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line5>            // trigger a read if we have consumed all\n<line6>            // backlog\n<line7>            ctx.read();\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (cnxn.getQueuedReadableBytes() > 0) {\n<line3>        cnxn.processQueuedBuffer();\n<line4>        if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line5>            // trigger a read if we have consumed all\n<line6>            // backlog\n<line7>            ctx.read();\n<line8>            LOG.debug(\"Issued a read after queuedBuffer drained\");\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    cnxn.processQueuedBuffer();\n<line3>    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line4>        // trigger a read if we have consumed all\n<line5>        // backlog\n<line6>        ctx.read();\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    cnxn.processQueuedBuffer();\n<line3>    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n<line4>        // trigger a read if we have consumed all\n<line5>        // backlog\n<line6>        ctx.read();\n<line7>        LOG.debug(\"Issued a read after queuedBuffer drained\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    // trigger a read if we have consumed all\n<line3>    // backlog\n<line4>    ctx.read();\n<line5>}","output":"<line1>{\n<line2>    // trigger a read if we have consumed all\n<line3>    // backlog\n<line4>    ctx.read();\n<line5>    LOG.debug(\"Issued a read after queuedBuffer drained\");\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    ctx.channel().config().setAutoRead(false);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Received ReadEvent.DISABLE\");\n<line3>    ctx.channel().config().setAutoRead(false);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        }\n<line4>        try {\n<line5>            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line6>            if (cnxn == null) {\n<line7>            } else {\n<line8>                cnxn.processMessage((ByteBuf) msg);\n<line9>            }\n<line10>        } catch (Exception ex) {\n<line11>            throw ex;\n<line12>        }\n<line13>    } finally {\n<line14>        ReferenceCountUtil.release(msg);\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    try {\n<line3>        if (LOG.isTraceEnabled()) {\n<line4>            LOG.trace(\"message received called {}\", msg);\n<line5>        }\n<line6>        try {\n<line7>            LOG.debug(\"New message {} from {}\", msg, ctx.channel());\n<line8>            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line9>            if (cnxn == null) {\n<line10>                LOG.error(\"channelRead() on a closed or closing NettyServerCnxn\");\n<line11>            } else {\n<line12>                cnxn.processMessage((ByteBuf) msg);\n<line13>            }\n<line14>        } catch (Exception ex) {\n<line15>            LOG.error(\"Unexpected exception in receive\", ex);\n<line16>            throw ex;\n<line17>        }\n<line18>    } finally {\n<line19>        ReferenceCountUtil.release(msg);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    try {\n<line4>        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line5>        if (cnxn == null) {\n<line6>        } else {\n<line7>            cnxn.processMessage((ByteBuf) msg);\n<line8>        }\n<line9>    } catch (Exception ex) {\n<line10>        throw ex;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (LOG.isTraceEnabled()) {\n<line3>        LOG.trace(\"message received called {}\", msg);\n<line4>    }\n<line5>    try {\n<line6>        LOG.debug(\"New message {} from {}\", msg, ctx.channel());\n<line7>        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line8>        if (cnxn == null) {\n<line9>            LOG.error(\"channelRead() on a closed or closing NettyServerCnxn\");\n<line10>        } else {\n<line11>            cnxn.processMessage((ByteBuf) msg);\n<line12>        }\n<line13>    } catch (Exception ex) {\n<line14>        LOG.error(\"Unexpected exception in receive\", ex);\n<line15>        throw ex;\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line3>    if (cnxn == null) {\n<line4>    } else {\n<line5>        cnxn.processMessage((ByteBuf) msg);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.debug(\"New message {} from {}\", msg, ctx.channel());\n<line3>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line4>    if (cnxn == null) {\n<line5>        LOG.error(\"channelRead() on a closed or closing NettyServerCnxn\");\n<line6>    } else {\n<line7>        cnxn.processMessage((ByteBuf) msg);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"channelRead() on a closed or closing NettyServerCnxn\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    throw ex;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception in receive\", ex);\n<line3>    throw ex;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (advancedFlowControlEnabled) {\n<line3>        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line4>        if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {\n<line5>            ctx.read();\n<line6>        }\n<line7>    }\n<line8>    ctx.fireChannelReadComplete();\n<line9>}","output":"<line1>{\n<line2>    if (advancedFlowControlEnabled) {\n<line3>        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line4>        if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {\n<line5>            ctx.read();\n<line6>            LOG.debug(\"Issued a read since we do not have anything to consume after channelReadComplete\");\n<line7>        }\n<line8>    }\n<line9>    ctx.fireChannelReadComplete();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line3>    if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {\n<line4>        ctx.read();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n<line3>    if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {\n<line4>        ctx.read();\n<line5>        LOG.debug(\"Issued a read since we do not have anything to consume after channelReadComplete\");\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ctx.read();\n<line3>}","output":"<line1>{\n<line2>    ctx.read();\n<line3>    LOG.debug(\"Issued a read since we do not have anything to consume after channelReadComplete\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    updateHandshakeCountIfStarted(cnxn);\n<line3>    if (future.isSuccess()) {\n<line4>        SSLEngine eng = sslHandler.engine();\n<line5>        // Don't try to verify certificate if we didn't ask client to present one\n<line6>        if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {\n<line7>            SSLSession session = eng.getSession();\n<line8>            try {\n<line9>                cnxn.setClientCertificateChain(session.getPeerCertificates());\n<line10>            } catch (SSLPeerUnverifiedException e) {\n<line11>                if (eng.getNeedClientAuth()) {\n<line12>                    // Certificate was requested but not present\n<line13>                    cnxn.close();\n<line14>                    return;\n<line15>                } else {\n<line16>                    // Certificate was requested but was optional\n<line17>                    // TODO: what auth info should we set on the connection?\n<line18>                    final Channel futureChannel = future.getNow();\n<line19>                    allChannels.add(Objects.requireNonNull(futureChannel));\n<line20>                    addCnxn(cnxn);\n<line21>                    return;\n<line22>                }\n<line23>            } catch (Exception e) {\n<line24>                cnxn.close();\n<line25>                return;\n<line26>            }\n<line27>            String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n<line28>            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n<line29>            if (authProvider == null) {\n<line30>                cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line31>                return;\n<line32>            }\n<line33>            KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n<line34>            if (KeeperException.Code.OK != code) {\n<line35>                zkServer.serverStats().incrementAuthFailedCount();\n<line36>                cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line37>                return;\n<line38>            }\n<line39>        }\n<line40>        final Channel futureChannel = future.getNow();\n<line41>        allChannels.add(Objects.requireNonNull(futureChannel));\n<line42>        addCnxn(cnxn);\n<line43>    } else {\n<line44>        zkServer.serverStats().incrementAuthFailedCount();\n<line45>        ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);\n<line46>        cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);\n<line47>    }\n<line48>}","output":"<line1>{\n<line2>    updateHandshakeCountIfStarted(cnxn);\n<line3>    if (future.isSuccess()) {\n<line4>        LOG.debug(\"Successful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line5>        SSLEngine eng = sslHandler.engine();\n<line6>        // Don't try to verify certificate if we didn't ask client to present one\n<line7>        if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {\n<line8>            SSLSession session = eng.getSession();\n<line9>            try {\n<line10>                cnxn.setClientCertificateChain(session.getPeerCertificates());\n<line11>            } catch (SSLPeerUnverifiedException e) {\n<line12>                if (eng.getNeedClientAuth()) {\n<line13>                    // Certificate was requested but not present\n<line14>                    LOG.error(\"Error getting peer certificates\", e);\n<line15>                    cnxn.close();\n<line16>                    return;\n<line17>                } else {\n<line18>                    // Certificate was requested but was optional\n<line19>                    // TODO: what auth info should we set on the connection?\n<line20>                    final Channel futureChannel = future.getNow();\n<line21>                    allChannels.add(Objects.requireNonNull(futureChannel));\n<line22>                    addCnxn(cnxn);\n<line23>                    return;\n<line24>                }\n<line25>            } catch (Exception e) {\n<line26>                LOG.error(\"Error getting peer certificates\", e);\n<line27>                cnxn.close();\n<line28>                return;\n<line29>            }\n<line30>            String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n<line31>            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n<line32>            if (authProvider == null) {\n<line33>                LOG.error(\"X509 Auth provider not found: {}\", authProviderProp);\n<line34>                cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line35>                return;\n<line36>            }\n<line37>            KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n<line38>            if (KeeperException.Code.OK != code) {\n<line39>                zkServer.serverStats().incrementAuthFailedCount();\n<line40>                LOG.error(\"Authentication failed for session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line41>                cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line42>                return;\n<line43>            }\n<line44>        }\n<line45>        final Channel futureChannel = future.getNow();\n<line46>        allChannels.add(Objects.requireNonNull(futureChannel));\n<line47>        addCnxn(cnxn);\n<line48>    } else {\n<line49>        zkServer.serverStats().incrementAuthFailedCount();\n<line50>        LOG.error(\"Unsuccessful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line51>        ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);\n<line52>        cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);\n<line53>    }\n<line54>}"},{"input":"","instruction":"<line1>{\n<line2>    SSLEngine eng = sslHandler.engine();\n<line3>    // Don't try to verify certificate if we didn't ask client to present one\n<line4>    if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {\n<line5>        SSLSession session = eng.getSession();\n<line6>        try {\n<line7>            cnxn.setClientCertificateChain(session.getPeerCertificates());\n<line8>        } catch (SSLPeerUnverifiedException e) {\n<line9>            if (eng.getNeedClientAuth()) {\n<line10>                // Certificate was requested but not present\n<line11>                cnxn.close();\n<line12>                return;\n<line13>            } else {\n<line14>                // Certificate was requested but was optional\n<line15>                // TODO: what auth info should we set on the connection?\n<line16>                final Channel futureChannel = future.getNow();\n<line17>                allChannels.add(Objects.requireNonNull(futureChannel));\n<line18>                addCnxn(cnxn);\n<line19>                return;\n<line20>            }\n<line21>        } catch (Exception e) {\n<line22>            cnxn.close();\n<line23>            return;\n<line24>        }\n<line25>        String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n<line26>        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n<line27>        if (authProvider == null) {\n<line28>            cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line29>            return;\n<line30>        }\n<line31>        KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n<line32>        if (KeeperException.Code.OK != code) {\n<line33>            zkServer.serverStats().incrementAuthFailedCount();\n<line34>            cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line35>            return;\n<line36>        }\n<line37>    }\n<line38>    final Channel futureChannel = future.getNow();\n<line39>    allChannels.add(Objects.requireNonNull(futureChannel));\n<line40>    addCnxn(cnxn);\n<line41>}","output":"<line1>{\n<line2>    LOG.debug(\"Successful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line3>    SSLEngine eng = sslHandler.engine();\n<line4>    // Don't try to verify certificate if we didn't ask client to present one\n<line5>    if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {\n<line6>        SSLSession session = eng.getSession();\n<line7>        try {\n<line8>            cnxn.setClientCertificateChain(session.getPeerCertificates());\n<line9>        } catch (SSLPeerUnverifiedException e) {\n<line10>            if (eng.getNeedClientAuth()) {\n<line11>                // Certificate was requested but not present\n<line12>                LOG.error(\"Error getting peer certificates\", e);\n<line13>                cnxn.close();\n<line14>                return;\n<line15>            } else {\n<line16>                // Certificate was requested but was optional\n<line17>                // TODO: what auth info should we set on the connection?\n<line18>                final Channel futureChannel = future.getNow();\n<line19>                allChannels.add(Objects.requireNonNull(futureChannel));\n<line20>                addCnxn(cnxn);\n<line21>                return;\n<line22>            }\n<line23>        } catch (Exception e) {\n<line24>            LOG.error(\"Error getting peer certificates\", e);\n<line25>            cnxn.close();\n<line26>            return;\n<line27>        }\n<line28>        String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n<line29>        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n<line30>        if (authProvider == null) {\n<line31>            LOG.error(\"X509 Auth provider not found: {}\", authProviderProp);\n<line32>            cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line33>            return;\n<line34>        }\n<line35>        KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n<line36>        if (KeeperException.Code.OK != code) {\n<line37>            zkServer.serverStats().incrementAuthFailedCount();\n<line38>            LOG.error(\"Authentication failed for session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line39>            cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line40>            return;\n<line41>        }\n<line42>    }\n<line43>    final Channel futureChannel = future.getNow();\n<line44>    allChannels.add(Objects.requireNonNull(futureChannel));\n<line45>    addCnxn(cnxn);\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    SSLSession session = eng.getSession();\n<line3>    try {\n<line4>        cnxn.setClientCertificateChain(session.getPeerCertificates());\n<line5>    } catch (SSLPeerUnverifiedException e) {\n<line6>        if (eng.getNeedClientAuth()) {\n<line7>            // Certificate was requested but not present\n<line8>            cnxn.close();\n<line9>            return;\n<line10>        } else {\n<line11>            // Certificate was requested but was optional\n<line12>            // TODO: what auth info should we set on the connection?\n<line13>            final Channel futureChannel = future.getNow();\n<line14>            allChannels.add(Objects.requireNonNull(futureChannel));\n<line15>            addCnxn(cnxn);\n<line16>            return;\n<line17>        }\n<line18>    } catch (Exception e) {\n<line19>        cnxn.close();\n<line20>        return;\n<line21>    }\n<line22>    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n<line23>    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n<line24>    if (authProvider == null) {\n<line25>        cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line26>        return;\n<line27>    }\n<line28>    KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n<line29>    if (KeeperException.Code.OK != code) {\n<line30>        zkServer.serverStats().incrementAuthFailedCount();\n<line31>        cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line32>        return;\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    SSLSession session = eng.getSession();\n<line3>    try {\n<line4>        cnxn.setClientCertificateChain(session.getPeerCertificates());\n<line5>    } catch (SSLPeerUnverifiedException e) {\n<line6>        if (eng.getNeedClientAuth()) {\n<line7>            // Certificate was requested but not present\n<line8>            LOG.error(\"Error getting peer certificates\", e);\n<line9>            cnxn.close();\n<line10>            return;\n<line11>        } else {\n<line12>            // Certificate was requested but was optional\n<line13>            // TODO: what auth info should we set on the connection?\n<line14>            final Channel futureChannel = future.getNow();\n<line15>            allChannels.add(Objects.requireNonNull(futureChannel));\n<line16>            addCnxn(cnxn);\n<line17>            return;\n<line18>        }\n<line19>    } catch (Exception e) {\n<line20>        LOG.error(\"Error getting peer certificates\", e);\n<line21>        cnxn.close();\n<line22>        return;\n<line23>    }\n<line24>    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n<line25>    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n<line26>    if (authProvider == null) {\n<line27>        LOG.error(\"X509 Auth provider not found: {}\", authProviderProp);\n<line28>        cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line29>        return;\n<line30>    }\n<line31>    KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n<line32>    if (KeeperException.Code.OK != code) {\n<line33>        zkServer.serverStats().incrementAuthFailedCount();\n<line34>        LOG.error(\"Authentication failed for session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line35>        cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line36>        return;\n<line37>    }\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    if (eng.getNeedClientAuth()) {\n<line3>        // Certificate was requested but not present\n<line4>        cnxn.close();\n<line5>        return;\n<line6>    } else {\n<line7>        // Certificate was requested but was optional\n<line8>        // TODO: what auth info should we set on the connection?\n<line9>        final Channel futureChannel = future.getNow();\n<line10>        allChannels.add(Objects.requireNonNull(futureChannel));\n<line11>        addCnxn(cnxn);\n<line12>        return;\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    if (eng.getNeedClientAuth()) {\n<line3>        // Certificate was requested but not present\n<line4>        LOG.error(\"Error getting peer certificates\", e);\n<line5>        cnxn.close();\n<line6>        return;\n<line7>    } else {\n<line8>        // Certificate was requested but was optional\n<line9>        // TODO: what auth info should we set on the connection?\n<line10>        final Channel futureChannel = future.getNow();\n<line11>        allChannels.add(Objects.requireNonNull(futureChannel));\n<line12>        addCnxn(cnxn);\n<line13>        return;\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    // Certificate was requested but not present\n<line3>    cnxn.close();\n<line4>    return;\n<line5>}","output":"<line1>{\n<line2>    // Certificate was requested but not present\n<line3>    LOG.error(\"Error getting peer certificates\", e);\n<line4>    cnxn.close();\n<line5>    return;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    cnxn.close();\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Error getting peer certificates\", e);\n<line3>    cnxn.close();\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"X509 Auth provider not found: {}\", authProviderProp);\n<line3>    cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    zkServer.serverStats().incrementAuthFailedCount();\n<line3>    cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line4>    return;\n<line5>}","output":"<line1>{\n<line2>    zkServer.serverStats().incrementAuthFailedCount();\n<line3>    LOG.error(\"Authentication failed for session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line4>    cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n<line5>    return;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    zkServer.serverStats().incrementAuthFailedCount();\n<line3>    ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);\n<line4>    cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);\n<line5>}","output":"<line1>{\n<line2>    zkServer.serverStats().incrementAuthFailedCount();\n<line3>    LOG.error(\"Unsuccessful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n<line4>    ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);\n<line5>    cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    x509Util = new ClientX509Util();\n<line3>    boolean useClientReload = Boolean.getBoolean(CLIENT_CERT_RELOAD_KEY);\n<line4>    if (useClientReload) {\n<line5>        try {\n<line6>            x509Util.enableCertFileReloading();\n<line7>        } catch (IOException e) {\n<line8>            useClientReload = false;\n<line9>        }\n<line10>    }\n<line11>    boolean usePortUnification = Boolean.getBoolean(PORT_UNIFICATION_KEY);\n<line12>    if (usePortUnification) {\n<line13>        try {\n<line14>            QuorumPeerConfig.configureSSLAuth();\n<line15>        } catch (QuorumPeerConfig.ConfigException e) {\n<line16>            usePortUnification = false;\n<line17>        }\n<line18>    }\n<line19>    this.shouldUsePortUnification = usePortUnification;\n<line20>    this.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);\n<line21>    setOutstandingHandshakeLimit(Integer.getInteger(OUTSTANDING_HANDSHAKE_LIMIT, -1));\n<line22>    EventLoopGroup bossGroup = NettyUtils.newNioOrEpollEventLoopGroup(NettyUtils.getClientReachableLocalInetAddressCount());\n<line23>    EventLoopGroup workerGroup = NettyUtils.newNioOrEpollEventLoopGroup();\n<line24>    ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workerGroup).channel(NettyUtils.nioOrEpollServerSocketChannel()).// parent channel options\n<line25>    option(ChannelOption.SO_REUSEADDR, true).// child channels options\n<line26>    childOption(ChannelOption.TCP_NODELAY, true).childOption(ChannelOption.SO_LINGER, -1).childHandler(new ChannelInitializer<SocketChannel>() {\n<line27>\n<line28>        @Override\n<line29>        protected void initChannel(SocketChannel ch) throws Exception {\n<line30>            ChannelPipeline pipeline = ch.pipeline();\n<line31>            if (advancedFlowControlEnabled) {\n<line32>                pipeline.addLast(readIssuedTrackingHandler);\n<line33>            }\n<line34>            if (secure) {\n<line35>                initSSL(pipeline, false);\n<line36>            } else if (shouldUsePortUnification) {\n<line37>                initSSL(pipeline, true);\n<line38>            }\n<line39>            pipeline.addLast(\"servercnxnfactory\", channelHandler);\n<line40>        }\n<line41>    });\n<line42>    this.bootstrap = configureBootstrapAllocator(bootstrap);\n<line43>    this.bootstrap.validate();\n<line44>}","output":"<line1>{\n<line2>    x509Util = new ClientX509Util();\n<line3>    boolean useClientReload = Boolean.getBoolean(CLIENT_CERT_RELOAD_KEY);\n<line4>    LOG.info(\"{}={}\", CLIENT_CERT_RELOAD_KEY, useClientReload);\n<line5>    if (useClientReload) {\n<line6>        try {\n<line7>            x509Util.enableCertFileReloading();\n<line8>        } catch (IOException e) {\n<line9>            LOG.error(\"unable to set up client certificate reload filewatcher\", e);\n<line10>            useClientReload = false;\n<line11>        }\n<line12>    }\n<line13>    boolean usePortUnification = Boolean.getBoolean(PORT_UNIFICATION_KEY);\n<line14>    LOG.info(\"{}={}\", PORT_UNIFICATION_KEY, usePortUnification);\n<line15>    if (usePortUnification) {\n<line16>        try {\n<line17>            QuorumPeerConfig.configureSSLAuth();\n<line18>        } catch (QuorumPeerConfig.ConfigException e) {\n<line19>            LOG.error(\"unable to set up SslAuthProvider, turning off client port unification\", e);\n<line20>            usePortUnification = false;\n<line21>        }\n<line22>    }\n<line23>    this.shouldUsePortUnification = usePortUnification;\n<line24>    this.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);\n<line25>    LOG.info(\"{} = {}\", NETTY_ADVANCED_FLOW_CONTROL, this.advancedFlowControlEnabled);\n<line26>    setOutstandingHandshakeLimit(Integer.getInteger(OUTSTANDING_HANDSHAKE_LIMIT, -1));\n<line27>    EventLoopGroup bossGroup = NettyUtils.newNioOrEpollEventLoopGroup(NettyUtils.getClientReachableLocalInetAddressCount());\n<line28>    EventLoopGroup workerGroup = NettyUtils.newNioOrEpollEventLoopGroup();\n<line29>    ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workerGroup).channel(NettyUtils.nioOrEpollServerSocketChannel()).// parent channel options\n<line30>    option(ChannelOption.SO_REUSEADDR, true).// child channels options\n<line31>    childOption(ChannelOption.TCP_NODELAY, true).childOption(ChannelOption.SO_LINGER, -1).childHandler(new ChannelInitializer<SocketChannel>() {\n<line32>\n<line33>        @Override\n<line34>        protected void initChannel(SocketChannel ch) throws Exception {\n<line35>            ChannelPipeline pipeline = ch.pipeline();\n<line36>            if (advancedFlowControlEnabled) {\n<line37>                pipeline.addLast(readIssuedTrackingHandler);\n<line38>            }\n<line39>            if (secure) {\n<line40>                initSSL(pipeline, false);\n<line41>            } else if (shouldUsePortUnification) {\n<line42>                initSSL(pipeline, true);\n<line43>            }\n<line44>            pipeline.addLast(\"servercnxnfactory\", channelHandler);\n<line45>        }\n<line46>    });\n<line47>    this.bootstrap = configureBootstrapAllocator(bootstrap);\n<line48>    this.bootstrap.validate();\n<line49>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        x509Util.enableCertFileReloading();\n<line4>    } catch (IOException e) {\n<line5>        useClientReload = false;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        x509Util.enableCertFileReloading();\n<line4>    } catch (IOException e) {\n<line5>        LOG.error(\"unable to set up client certificate reload filewatcher\", e);\n<line6>        useClientReload = false;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    useClientReload = false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"unable to set up client certificate reload filewatcher\", e);\n<line3>    useClientReload = false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        QuorumPeerConfig.configureSSLAuth();\n<line4>    } catch (QuorumPeerConfig.ConfigException e) {\n<line5>        usePortUnification = false;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        QuorumPeerConfig.configureSSLAuth();\n<line4>    } catch (QuorumPeerConfig.ConfigException e) {\n<line5>        LOG.error(\"unable to set up SslAuthProvider, turning off client port unification\", e);\n<line6>        usePortUnification = false;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    usePortUnification = false;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"unable to set up SslAuthProvider, turning off client port unification\", e);\n<line3>    usePortUnification = false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());\n<line3>    SslContext nettySslContext;\n<line4>    if (authProviderProp == null) {\n<line5>        nettySslContext = x509Util.createNettySslContextForServer(new ZKConfig());\n<line6>    } else {\n<line7>        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\"));\n<line8>        if (authProvider == null) {\n<line9>            throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n<line10>        }\n<line11>        nettySslContext = x509Util.createNettySslContextForServer(new ZKConfig(), authProvider.getKeyManager(), authProvider.getTrustManager());\n<line12>    }\n<line13>    if (supportPlaintext) {\n<line14>        p.addLast(\"ssl\", new DualModeSslHandler(nettySslContext));\n<line15>    } else {\n<line16>        p.addLast(\"ssl\", nettySslContext.newHandler(p.channel().alloc()));\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());\n<line3>    SslContext nettySslContext;\n<line4>    if (authProviderProp == null) {\n<line5>        nettySslContext = x509Util.createNettySslContextForServer(new ZKConfig());\n<line6>    } else {\n<line7>        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\"));\n<line8>        if (authProvider == null) {\n<line9>            LOG.error(\"Auth provider not found: {}\", authProviderProp);\n<line10>            throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n<line11>        }\n<line12>        nettySslContext = x509Util.createNettySslContextForServer(new ZKConfig(), authProvider.getKeyManager(), authProvider.getTrustManager());\n<line13>    }\n<line14>    if (supportPlaintext) {\n<line15>        p.addLast(\"ssl\", new DualModeSslHandler(nettySslContext));\n<line16>        LOG.debug(\"dual mode SSL handler added for channel: {}\", p.channel());\n<line17>    } else {\n<line18>        p.addLast(\"ssl\", nettySslContext.newHandler(p.channel().alloc()));\n<line19>        LOG.debug(\"SSL handler added for channel: {}\", p.channel());\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\"));\n<line3>    if (authProvider == null) {\n<line4>        throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n<line5>    }\n<line6>    nettySslContext = x509Util.createNettySslContextForServer(new ZKConfig(), authProvider.getKeyManager(), authProvider.getTrustManager());\n<line7>}","output":"<line1>{\n<line2>    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\"));\n<line3>    if (authProvider == null) {\n<line4>        LOG.error(\"Auth provider not found: {}\", authProviderProp);\n<line5>        throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n<line6>    }\n<line7>    nettySslContext = x509Util.createNettySslContextForServer(new ZKConfig(), authProvider.getKeyManager(), authProvider.getTrustManager());\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Auth provider not found: {}\", authProviderProp);\n<line3>    throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    p.addLast(\"ssl\", new DualModeSslHandler(nettySslContext));\n<line3>}","output":"<line1>{\n<line2>    p.addLast(\"ssl\", new DualModeSslHandler(nettySslContext));\n<line3>    LOG.debug(\"dual mode SSL handler added for channel: {}\", p.channel());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    p.addLast(\"ssl\", nettySslContext.newHandler(p.channel().alloc()));\n<line3>}","output":"<line1>{\n<line2>    p.addLast(\"ssl\", nettySslContext.newHandler(p.channel().alloc()));\n<line3>    LOG.debug(\"SSL handler added for channel: {}\", p.channel());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // clear all the connections on which we are selecting\n<line3>    int length = cnxns.size();\n<line4>    for (ServerCnxn cnxn : cnxns) {\n<line5>        try {\n<line6>            // This will remove the cnxn from cnxns\n<line7>            cnxn.close(reason);\n<line8>        } catch (Exception e) {\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.debug(\"closeAll()\");\n<line3>    // clear all the connections on which we are selecting\n<line4>    int length = cnxns.size();\n<line5>    for (ServerCnxn cnxn : cnxns) {\n<line6>        try {\n<line7>            // This will remove the cnxn from cnxns\n<line8>            cnxn.close(reason);\n<line9>        } catch (Exception e) {\n<line10>            LOG.warn(\"Ignoring exception closing cnxn sessionid 0x{}\", Long.toHexString(cnxn.getSessionId()), e);\n<line11>        }\n<line12>    }\n<line13>    LOG.debug(\"allChannels size: {} cnxns size: {}\", allChannels.size(), length);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    configureSaslLogin();\n<line3>    initMaxCnxns();\n<line4>    localAddress = addr;\n<line5>    this.maxClientCnxns = maxClientCnxns;\n<line6>    this.secure = secure;\n<line7>    this.listenBacklog = backlog;\n<line8>}","output":"<line1>{\n<line2>    configureSaslLogin();\n<line3>    initMaxCnxns();\n<line4>    localAddress = addr;\n<line5>    this.maxClientCnxns = maxClientCnxns;\n<line6>    this.secure = secure;\n<line7>    this.listenBacklog = backlog;\n<line8>    LOG.info(\"configure {} secure: {} on addr {}\", this, secure, addr);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (this) {\n<line3>        if (killed) {\n<line4>            return;\n<line5>        }\n<line6>    }\n<line7>    x509Util.close();\n<line8>    if (login != null) {\n<line9>        login.shutdown();\n<line10>    }\n<line11>    final EventLoopGroup bossGroup = bootstrap.config().group();\n<line12>    final EventLoopGroup workerGroup = bootstrap.config().childGroup();\n<line13>    // null if factory never started\n<line14>    if (parentChannel != null) {\n<line15>        ChannelFuture parentCloseFuture = parentChannel.close();\n<line16>        if (bossGroup != null) {\n<line17>            parentCloseFuture.addListener(future -> {\n<line18>                bossGroup.shutdownGracefully();\n<line19>            });\n<line20>        }\n<line21>        closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n<line22>        ChannelGroupFuture allChannelsCloseFuture = allChannels.close();\n<line23>        if (workerGroup != null) {\n<line24>            allChannelsCloseFuture.addListener(future -> {\n<line25>                workerGroup.shutdownGracefully();\n<line26>            });\n<line27>        }\n<line28>    } else {\n<line29>        if (bossGroup != null) {\n<line30>            bossGroup.shutdownGracefully();\n<line31>        }\n<line32>        if (workerGroup != null) {\n<line33>            workerGroup.shutdownGracefully();\n<line34>        }\n<line35>    }\n<line36>    if (zkServer != null) {\n<line37>        zkServer.shutdown();\n<line38>    }\n<line39>    synchronized (this) {\n<line40>        killed = true;\n<line41>        notifyAll();\n<line42>    }\n<line43>}","output":"<line1>{\n<line2>    synchronized (this) {\n<line3>        if (killed) {\n<line4>            LOG.info(\"already shutdown {}\", localAddress);\n<line5>            return;\n<line6>        }\n<line7>    }\n<line8>    LOG.info(\"shutdown called {}\", localAddress);\n<line9>    x509Util.close();\n<line10>    if (login != null) {\n<line11>        login.shutdown();\n<line12>    }\n<line13>    final EventLoopGroup bossGroup = bootstrap.config().group();\n<line14>    final EventLoopGroup workerGroup = bootstrap.config().childGroup();\n<line15>    // null if factory never started\n<line16>    if (parentChannel != null) {\n<line17>        ChannelFuture parentCloseFuture = parentChannel.close();\n<line18>        if (bossGroup != null) {\n<line19>            parentCloseFuture.addListener(future -> {\n<line20>                bossGroup.shutdownGracefully();\n<line21>            });\n<line22>        }\n<line23>        closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n<line24>        ChannelGroupFuture allChannelsCloseFuture = allChannels.close();\n<line25>        if (workerGroup != null) {\n<line26>            allChannelsCloseFuture.addListener(future -> {\n<line27>                workerGroup.shutdownGracefully();\n<line28>            });\n<line29>        }\n<line30>    } else {\n<line31>        if (bossGroup != null) {\n<line32>            bossGroup.shutdownGracefully();\n<line33>        }\n<line34>        if (workerGroup != null) {\n<line35>            workerGroup.shutdownGracefully();\n<line36>        }\n<line37>    }\n<line38>    if (zkServer != null) {\n<line39>        zkServer.shutdown();\n<line40>    }\n<line41>    synchronized (this) {\n<line42>        killed = true;\n<line43>        notifyAll();\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    if (killed) {\n<line3>        return;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (killed) {\n<line3>        LOG.info(\"already shutdown {}\", localAddress);\n<line4>        return;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"already shutdown {}\", localAddress);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (listenBacklog != -1) {\n<line3>        bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);\n<line4>    }\n<line5>    parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();\n<line6>    // Port changes after bind() if the original port was 0, update\n<line7>    // localAddress to get the real port.\n<line8>    localAddress = (InetSocketAddress) parentChannel.localAddress();\n<line9>}","output":"<line1>{\n<line2>    if (listenBacklog != -1) {\n<line3>        bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);\n<line4>    }\n<line5>    LOG.info(\"binding to port {}\", localAddress);\n<line6>    parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();\n<line7>    // Port changes after bind() if the original port was 0, update\n<line8>    // localAddress to get the real port.\n<line9>    localAddress = (InetSocketAddress) parentChannel.localAddress();\n<line10>    LOG.info(\"bound to port {}\", getLocalPort());\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (addr != null && localAddress != null) {\n<line3>        if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {\n<line4>            return;\n<line5>        }\n<line6>    }\n<line7>    Channel oldChannel = parentChannel;\n<line8>    try {\n<line9>        parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();\n<line10>        // Port changes after bind() if the original port was 0, update\n<line11>        // localAddress to get the real port.\n<line12>        localAddress = (InetSocketAddress) parentChannel.localAddress();\n<line13>    } catch (Exception e) {\n<line14>    } finally {\n<line15>        oldChannel.close();\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    LOG.info(\"binding to port {}, {}\", addr, localAddress);\n<line3>    if (addr != null && localAddress != null) {\n<line4>        if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {\n<line5>            LOG.info(\"address is the same, skip rebinding\");\n<line6>            return;\n<line7>        }\n<line8>    }\n<line9>    Channel oldChannel = parentChannel;\n<line10>    try {\n<line11>        parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();\n<line12>        // Port changes after bind() if the original port was 0, update\n<line13>        // localAddress to get the real port.\n<line14>        localAddress = (InetSocketAddress) parentChannel.localAddress();\n<line15>        LOG.info(\"bound to port {}\", getLocalPort());\n<line16>    } catch (Exception e) {\n<line17>        LOG.error(\"Error while reconfiguring\", e);\n<line18>    } finally {\n<line19>        oldChannel.close();\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {\n<line3>        return;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {\n<line3>        LOG.info(\"address is the same, skip rebinding\");\n<line4>        return;\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"address is the same, skip rebinding\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();\n<line3>    // Port changes after bind() if the original port was 0, update\n<line4>    // localAddress to get the real port.\n<line5>    localAddress = (InetSocketAddress) parentChannel.localAddress();\n<line6>}","output":"<line1>{\n<line2>    parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();\n<line3>    // Port changes after bind() if the original port was 0, update\n<line4>    // localAddress to get the real port.\n<line5>    localAddress = (InetSocketAddress) parentChannel.localAddress();\n<line6>    LOG.info(\"bound to port {}\", getLocalPort());\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error while reconfiguring\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ipMap.compute(remoteAddress, (addr, cnxnCount) -> {\n<line3>        if (cnxnCount == null) {\n<line4>            return null;\n<line5>        }\n<line6>        final int newValue = cnxnCount.decrementAndGet();\n<line7>        return newValue == 0 ? null : cnxnCount;\n<line8>    });\n<line9>}","output":"<line1>{\n<line2>    ipMap.compute(remoteAddress, (addr, cnxnCount) -> {\n<line3>        if (cnxnCount == null) {\n<line4>            LOG.error(\"Unexpected remote address {} when removing cnxn {}\", remoteAddress, cnxn);\n<line5>            return null;\n<line6>        }\n<line7>        final int newValue = cnxnCount.decrementAndGet();\n<line8>        return newValue == 0 ? null : cnxnCount;\n<line9>    });\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (cnxnCount == null) {\n<line3>        return null;\n<line4>    }\n<line5>    final int newValue = cnxnCount.decrementAndGet();\n<line6>    return newValue == 0 ? null : cnxnCount;\n<line7>}","output":"<line1>{\n<line2>    if (cnxnCount == null) {\n<line3>        LOG.error(\"Unexpected remote address {} when removing cnxn {}\", remoteAddress, cnxn);\n<line4>        return null;\n<line5>    }\n<line6>    final int newValue = cnxnCount.decrementAndGet();\n<line7>    return newValue == 0 ? null : cnxnCount;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected remote address {} when removing cnxn {}\", remoteAddress, cnxn);\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    listener.notifyStopping(threadName, ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>    ServerMetrics.getMetrics().UNRECOVERABLE_ERROR_COUNT.add(1);\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Severe unrecoverable error, from thread : {}\", threadName, e);\n<line3>    listener.notifyStopping(threadName, ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>    ServerMetrics.getMetrics().UNRECOVERABLE_ERROR_COUNT.add(1);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        /* configure socket to be blocking\n<line4>             * so that we dont have to do write in\n<line5>             * a tight while loop\n<line6>             */\n<line7>        if (bb != ServerCnxnFactory.closeConn) {\n<line8>            if (sock.isOpen()) {\n<line9>                sock.configureBlocking(true);\n<line10>                sock.write(bb);\n<line11>            }\n<line12>            packetSent();\n<line13>        }\n<line14>    } catch (IOException ie) {\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    try {\n<line3>        /* configure socket to be blocking\n<line4>             * so that we dont have to do write in\n<line5>             * a tight while loop\n<line6>             */\n<line7>        if (bb != ServerCnxnFactory.closeConn) {\n<line8>            if (sock.isOpen()) {\n<line9>                sock.configureBlocking(true);\n<line10>                sock.write(bb);\n<line11>            }\n<line12>            packetSent();\n<line13>        }\n<line14>    } catch (IOException ie) {\n<line15>        LOG.error(\"Error sending data synchronously \", ie);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error sending data synchronously \", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!isSocketOpen()) {\n<line4>            return;\n<line5>        }\n<line6>        if (k.isReadable()) {\n<line7>            int rc = sock.read(incomingBuffer);\n<line8>            if (rc < 0) {\n<line9>                try {\n<line10>                    handleFailedRead();\n<line11>                } catch (EndOfStreamException e) {\n<line12>                    // no stacktrace. this case is very common, and it is usually not a problem.\n<line13>                    // expecting close to log session closure\n<line14>                    close(e.getReason());\n<line15>                    return;\n<line16>                }\n<line17>            }\n<line18>            if (incomingBuffer.remaining() == 0) {\n<line19>                boolean isPayload;\n<line20>                if (incomingBuffer == lenBuffer) {\n<line21>                    // start of next request\n<line22>                    incomingBuffer.flip();\n<line23>                    isPayload = readLength(k);\n<line24>                    incomingBuffer.clear();\n<line25>                } else {\n<line26>                    // continuation\n<line27>                    isPayload = true;\n<line28>                }\n<line29>                if (isPayload) {\n<line30>                    // not the case for 4letterword\n<line31>                    readPayload();\n<line32>                } else {\n<line33>                    // four letter words take care\n<line34>                    // need not do anything else\n<line35>                    return;\n<line36>                }\n<line37>            }\n<line38>        }\n<line39>        if (k.isWritable()) {\n<line40>            handleWrite(k);\n<line41>            if (!initialized && !getReadInterest() && !getWriteInterest()) {\n<line42>                throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n<line43>            }\n<line44>        }\n<line45>    } catch (CancelledKeyException e) {\n<line46>        close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n<line47>    } catch (CloseRequestException e) {\n<line48>        // expecting close to log session closure\n<line49>        close();\n<line50>    } catch (EndOfStreamException e) {\n<line51>        // expecting close to log session closure\n<line52>        close(e.getReason());\n<line53>    } catch (ClientCnxnLimitException e) {\n<line54>        // Common case exception, print at debug level\n<line55>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line56>        close(DisconnectReason.CLIENT_CNX_LIMIT);\n<line57>    } catch (IOException e) {\n<line58>        close(DisconnectReason.IO_EXCEPTION);\n<line59>    }\n<line60>}","output":"<line1>{\n<line2>    try {\n<line3>        if (!isSocketOpen()) {\n<line4>            LOG.warn(\"trying to do i/o on a null socket for session: 0x{}\", Long.toHexString(sessionId));\n<line5>            return;\n<line6>        }\n<line7>        if (k.isReadable()) {\n<line8>            int rc = sock.read(incomingBuffer);\n<line9>            if (rc < 0) {\n<line10>                try {\n<line11>                    handleFailedRead();\n<line12>                } catch (EndOfStreamException e) {\n<line13>                    // no stacktrace. this case is very common, and it is usually not a problem.\n<line14>                    LOG.info(\"{}\", e.getMessage());\n<line15>                    // expecting close to log session closure\n<line16>                    close(e.getReason());\n<line17>                    return;\n<line18>                }\n<line19>            }\n<line20>            if (incomingBuffer.remaining() == 0) {\n<line21>                boolean isPayload;\n<line22>                if (incomingBuffer == lenBuffer) {\n<line23>                    // start of next request\n<line24>                    incomingBuffer.flip();\n<line25>                    isPayload = readLength(k);\n<line26>                    incomingBuffer.clear();\n<line27>                } else {\n<line28>                    // continuation\n<line29>                    isPayload = true;\n<line30>                }\n<line31>                if (isPayload) {\n<line32>                    // not the case for 4letterword\n<line33>                    readPayload();\n<line34>                } else {\n<line35>                    // four letter words take care\n<line36>                    // need not do anything else\n<line37>                    return;\n<line38>                }\n<line39>            }\n<line40>        }\n<line41>        if (k.isWritable()) {\n<line42>            handleWrite(k);\n<line43>            if (!initialized && !getReadInterest() && !getWriteInterest()) {\n<line44>                throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n<line45>            }\n<line46>        }\n<line47>    } catch (CancelledKeyException e) {\n<line48>        LOG.warn(\"CancelledKeyException causing close of session: 0x{}\", Long.toHexString(sessionId));\n<line49>        LOG.debug(\"CancelledKeyException stack trace\", e);\n<line50>        close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n<line51>    } catch (CloseRequestException e) {\n<line52>        // expecting close to log session closure\n<line53>        close();\n<line54>    } catch (EndOfStreamException e) {\n<line55>        LOG.warn(\"Unexpected exception\", e);\n<line56>        // expecting close to log session closure\n<line57>        close(e.getReason());\n<line58>    } catch (ClientCnxnLimitException e) {\n<line59>        // Common case exception, print at debug level\n<line60>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n<line61>        LOG.warn(\"Closing session 0x{}\", Long.toHexString(sessionId), e);\n<line62>        close(DisconnectReason.CLIENT_CNX_LIMIT);\n<line63>    } catch (IOException e) {\n<line64>        LOG.warn(\"Close of session 0x{}\", Long.toHexString(sessionId), e);\n<line65>        close(DisconnectReason.IO_EXCEPTION);\n<line66>    }\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!isSocketOpen()) {\n<line3>        return;\n<line4>    }\n<line5>    if (k.isReadable()) {\n<line6>        int rc = sock.read(incomingBuffer);\n<line7>        if (rc < 0) {\n<line8>            try {\n<line9>                handleFailedRead();\n<line10>            } catch (EndOfStreamException e) {\n<line11>                // no stacktrace. this case is very common, and it is usually not a problem.\n<line12>                // expecting close to log session closure\n<line13>                close(e.getReason());\n<line14>                return;\n<line15>            }\n<line16>        }\n<line17>        if (incomingBuffer.remaining() == 0) {\n<line18>            boolean isPayload;\n<line19>            if (incomingBuffer == lenBuffer) {\n<line20>                // start of next request\n<line21>                incomingBuffer.flip();\n<line22>                isPayload = readLength(k);\n<line23>                incomingBuffer.clear();\n<line24>            } else {\n<line25>                // continuation\n<line26>                isPayload = true;\n<line27>            }\n<line28>            if (isPayload) {\n<line29>                // not the case for 4letterword\n<line30>                readPayload();\n<line31>            } else {\n<line32>                // four letter words take care\n<line33>                // need not do anything else\n<line34>                return;\n<line35>            }\n<line36>        }\n<line37>    }\n<line38>    if (k.isWritable()) {\n<line39>        handleWrite(k);\n<line40>        if (!initialized && !getReadInterest() && !getWriteInterest()) {\n<line41>            throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n<line42>        }\n<line43>    }\n<line44>}","output":"<line1>{\n<line2>    if (!isSocketOpen()) {\n<line3>        LOG.warn(\"trying to do i/o on a null socket for session: 0x{}\", Long.toHexString(sessionId));\n<line4>        return;\n<line5>    }\n<line6>    if (k.isReadable()) {\n<line7>        int rc = sock.read(incomingBuffer);\n<line8>        if (rc < 0) {\n<line9>            try {\n<line10>                handleFailedRead();\n<line11>            } catch (EndOfStreamException e) {\n<line12>                // no stacktrace. this case is very common, and it is usually not a problem.\n<line13>                LOG.info(\"{}\", e.getMessage());\n<line14>                // expecting close to log session closure\n<line15>                close(e.getReason());\n<line16>                return;\n<line17>            }\n<line18>        }\n<line19>        if (incomingBuffer.remaining() == 0) {\n<line20>            boolean isPayload;\n<line21>            if (incomingBuffer == lenBuffer) {\n<line22>                // start of next request\n<line23>                incomingBuffer.flip();\n<line24>                isPayload = readLength(k);\n<line25>                incomingBuffer.clear();\n<line26>            } else {\n<line27>                // continuation\n<line28>                isPayload = true;\n<line29>            }\n<line30>            if (isPayload) {\n<line31>                // not the case for 4letterword\n<line32>                readPayload();\n<line33>            } else {\n<line34>                // four letter words take care\n<line35>                // need not do anything else\n<line36>                return;\n<line37>            }\n<line38>        }\n<line39>    }\n<line40>    if (k.isWritable()) {\n<line41>        handleWrite(k);\n<line42>        if (!initialized && !getReadInterest() && !getWriteInterest()) {\n<line43>            throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n<line44>        }\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    int rc = sock.read(incomingBuffer);\n<line3>    if (rc < 0) {\n<line4>        try {\n<line5>            handleFailedRead();\n<line6>        } catch (EndOfStreamException e) {\n<line7>            // no stacktrace. this case is very common, and it is usually not a problem.\n<line8>            // expecting close to log session closure\n<line9>            close(e.getReason());\n<line10>            return;\n<line11>        }\n<line12>    }\n<line13>    if (incomingBuffer.remaining() == 0) {\n<line14>        boolean isPayload;\n<line15>        if (incomingBuffer == lenBuffer) {\n<line16>            // start of next request\n<line17>            incomingBuffer.flip();\n<line18>            isPayload = readLength(k);\n<line19>            incomingBuffer.clear();\n<line20>        } else {\n<line21>            // continuation\n<line22>            isPayload = true;\n<line23>        }\n<line24>        if (isPayload) {\n<line25>            // not the case for 4letterword\n<line26>            readPayload();\n<line27>        } else {\n<line28>            // four letter words take care\n<line29>            // need not do anything else\n<line30>            return;\n<line31>        }\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    int rc = sock.read(incomingBuffer);\n<line3>    if (rc < 0) {\n<line4>        try {\n<line5>            handleFailedRead();\n<line6>        } catch (EndOfStreamException e) {\n<line7>            // no stacktrace. this case is very common, and it is usually not a problem.\n<line8>            LOG.info(\"{}\", e.getMessage());\n<line9>            // expecting close to log session closure\n<line10>            close(e.getReason());\n<line11>            return;\n<line12>        }\n<line13>    }\n<line14>    if (incomingBuffer.remaining() == 0) {\n<line15>        boolean isPayload;\n<line16>        if (incomingBuffer == lenBuffer) {\n<line17>            // start of next request\n<line18>            incomingBuffer.flip();\n<line19>            isPayload = readLength(k);\n<line20>            incomingBuffer.clear();\n<line21>        } else {\n<line22>            // continuation\n<line23>            isPayload = true;\n<line24>        }\n<line25>        if (isPayload) {\n<line26>            // not the case for 4letterword\n<line27>            readPayload();\n<line28>        } else {\n<line29>            // four letter words take care\n<line30>            // need not do anything else\n<line31>            return;\n<line32>        }\n<line33>    }\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        handleFailedRead();\n<line4>    } catch (EndOfStreamException e) {\n<line5>        // no stacktrace. this case is very common, and it is usually not a problem.\n<line6>        // expecting close to log session closure\n<line7>        close(e.getReason());\n<line8>        return;\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    try {\n<line3>        handleFailedRead();\n<line4>    } catch (EndOfStreamException e) {\n<line5>        // no stacktrace. this case is very common, and it is usually not a problem.\n<line6>        LOG.info(\"{}\", e.getMessage());\n<line7>        // expecting close to log session closure\n<line8>        close(e.getReason());\n<line9>        return;\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // no stacktrace. this case is very common, and it is usually not a problem.\n<line3>    // expecting close to log session closure\n<line4>    close(e.getReason());\n<line5>    return;\n<line6>}","output":"<line1>{\n<line2>    // no stacktrace. this case is very common, and it is usually not a problem.\n<line3>    LOG.info(\"{}\", e.getMessage());\n<line4>    // expecting close to log session closure\n<line5>    close(e.getReason());\n<line6>    return;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n<line3>}","output":"<line1>{\n<line2>    LOG.warn(\"CancelledKeyException causing close of session: 0x{}\", Long.toHexString(sessionId));\n<line3>    LOG.debug(\"CancelledKeyException stack trace\", e);\n<line4>    close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // We take advantage of the limited size of the length to look\n<line3>    // for cmds. They are all 4-bytes which fits inside of an int\n<line4>    if (!FourLetterCommands.isKnown(len)) {\n<line5>        return false;\n<line6>    }\n<line7>    String cmd = FourLetterCommands.getCommandString(len);\n<line8>    packetReceived(4);\n<line9>    /**\n<line10>     * cancel the selection key to remove the socket handling\n<line11>     * from selector. This is to prevent netcat problem wherein\n<line12>     * netcat immediately closes the sending side after sending the\n<line13>     * commands and still keeps the receiving channel open.\n<line14>     * The idea is to remove the selectionkey from the selector\n<line15>     * so that the selector does not notice the closed read on the\n<line16>     * socket channel and keep the socket alive to write the data to\n<line17>     * and makes sure to close the socket after its done writing the data\n<line18>     */\n<line19>    if (k != null) {\n<line20>        try {\n<line21>            k.cancel();\n<line22>        } catch (Exception e) {\n<line23>        }\n<line24>    }\n<line25>    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n<line26>    // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n<line27>    if (!FourLetterCommands.isEnabled(cmd)) {\n<line28>        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line29>        nopCmd.start();\n<line30>        return true;\n<line31>    }\n<line32>    if (len == FourLetterCommands.setTraceMaskCmd) {\n<line33>        incomingBuffer = ByteBuffer.allocate(8);\n<line34>        int rc = sock.read(incomingBuffer);\n<line35>        if (rc < 0) {\n<line36>            throw new IOException(\"Read error\");\n<line37>        }\n<line38>        incomingBuffer.flip();\n<line39>        long traceMask = incomingBuffer.getLong();\n<line40>        ZooTrace.setTextTraceLevel(traceMask);\n<line41>        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n<line42>        setMask.start();\n<line43>        return true;\n<line44>    } else {\n<line45>        CommandExecutor commandExecutor = new CommandExecutor();\n<line46>        return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n<line47>    }\n<line48>}","output":"<line1>{\n<line2>    // We take advantage of the limited size of the length to look\n<line3>    // for cmds. They are all 4-bytes which fits inside of an int\n<line4>    if (!FourLetterCommands.isKnown(len)) {\n<line5>        return false;\n<line6>    }\n<line7>    String cmd = FourLetterCommands.getCommandString(len);\n<line8>    packetReceived(4);\n<line9>    /**\n<line10>     * cancel the selection key to remove the socket handling\n<line11>     * from selector. This is to prevent netcat problem wherein\n<line12>     * netcat immediately closes the sending side after sending the\n<line13>     * commands and still keeps the receiving channel open.\n<line14>     * The idea is to remove the selectionkey from the selector\n<line15>     * so that the selector does not notice the closed read on the\n<line16>     * socket channel and keep the socket alive to write the data to\n<line17>     * and makes sure to close the socket after its done writing the data\n<line18>     */\n<line19>    if (k != null) {\n<line20>        try {\n<line21>            k.cancel();\n<line22>        } catch (Exception e) {\n<line23>            LOG.error(\"Error cancelling command selection key\", e);\n<line24>        }\n<line25>    }\n<line26>    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n<line27>    // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n<line28>    if (!FourLetterCommands.isEnabled(cmd)) {\n<line29>        LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n<line30>        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line31>        nopCmd.start();\n<line32>        return true;\n<line33>    }\n<line34>    LOG.info(\"Processing {} command from {}\", cmd, sock.socket().getRemoteSocketAddress());\n<line35>    if (len == FourLetterCommands.setTraceMaskCmd) {\n<line36>        incomingBuffer = ByteBuffer.allocate(8);\n<line37>        int rc = sock.read(incomingBuffer);\n<line38>        if (rc < 0) {\n<line39>            throw new IOException(\"Read error\");\n<line40>        }\n<line41>        incomingBuffer.flip();\n<line42>        long traceMask = incomingBuffer.getLong();\n<line43>        ZooTrace.setTextTraceLevel(traceMask);\n<line44>        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n<line45>        setMask.start();\n<line46>        return true;\n<line47>    } else {\n<line48>        CommandExecutor commandExecutor = new CommandExecutor();\n<line49>        return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n<line50>    }\n<line51>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        k.cancel();\n<line4>    } catch (Exception e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        k.cancel();\n<line4>    } catch (Exception e) {\n<line5>        LOG.error(\"Error cancelling command selection key\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error cancelling command selection key\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line3>    nopCmd.start();\n<line4>    return true;\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n<line3>    NopCommand nopCmd = new NopCommand(pwriter, this, cmd + \" is not executed because it is not in the whitelist.\");\n<line4>    nopCmd.start();\n<line5>    return true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    setStale();\n<line3>    if (!factory.removeCnxn(this)) {\n<line4>        return;\n<line5>    }\n<line6>    if (zkServer != null) {\n<line7>        zkServer.removeCnxn(this);\n<line8>    }\n<line9>    if (sk != null) {\n<line10>        try {\n<line11>            // need to cancel this selection key from the selector\n<line12>            sk.cancel();\n<line13>        } catch (Exception e) {\n<line14>        }\n<line15>    }\n<line16>    closeSock();\n<line17>}","output":"<line1>{\n<line2>    setStale();\n<line3>    if (!factory.removeCnxn(this)) {\n<line4>        return;\n<line5>    }\n<line6>    if (zkServer != null) {\n<line7>        zkServer.removeCnxn(this);\n<line8>    }\n<line9>    if (sk != null) {\n<line10>        try {\n<line11>            // need to cancel this selection key from the selector\n<line12>            sk.cancel();\n<line13>        } catch (Exception e) {\n<line14>            LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n<line15>        }\n<line16>    }\n<line17>    closeSock();\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // need to cancel this selection key from the selector\n<line4>        sk.cancel();\n<line5>    } catch (Exception e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        // need to cancel this selection key from the selector\n<line4>        sk.cancel();\n<line5>    } catch (Exception e) {\n<line6>        LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!sock.isOpen()) {\n<line3>        return;\n<line4>    }\n<line5>    String logMsg = String.format(\"Closed socket connection for client %s %s\", sock.socket().getRemoteSocketAddress(), sessionId != 0 ? \"which had sessionid 0x\" + Long.toHexString(sessionId) : \"(no session established for client)\");\n<line6>    closeSock(sock);\n<line7>}","output":"<line1>{\n<line2>    if (!sock.isOpen()) {\n<line3>        return;\n<line4>    }\n<line5>    String logMsg = String.format(\"Closed socket connection for client %s %s\", sock.socket().getRemoteSocketAddress(), sessionId != 0 ? \"which had sessionid 0x\" + Long.toHexString(sessionId) : \"(no session established for client)\");\n<line6>    LOG.debug(logMsg);\n<line7>    closeSock(sock);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!sock.isOpen()) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        /*\n<line7>             * The following sequence of code is stupid! You would think that\n<line8>             * only sock.close() is needed, but alas, it doesn't work that way.\n<line9>             * If you just do sock.close() there are cases where the socket\n<line10>             * doesn't actually close...\n<line11>             */\n<line12>        sock.socket().shutdownOutput();\n<line13>    } catch (IOException e) {\n<line14>        // This is a relatively common exception that we can't avoid\n<line15>    }\n<line16>    try {\n<line17>        sock.socket().shutdownInput();\n<line18>    } catch (IOException e) {\n<line19>        // This is a relatively common exception that we can't avoid\n<line20>    }\n<line21>    try {\n<line22>        sock.socket().close();\n<line23>    } catch (IOException e) {\n<line24>    }\n<line25>    try {\n<line26>        sock.close();\n<line27>    } catch (IOException e) {\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    if (!sock.isOpen()) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        /*\n<line7>             * The following sequence of code is stupid! You would think that\n<line8>             * only sock.close() is needed, but alas, it doesn't work that way.\n<line9>             * If you just do sock.close() there are cases where the socket\n<line10>             * doesn't actually close...\n<line11>             */\n<line12>        sock.socket().shutdownOutput();\n<line13>    } catch (IOException e) {\n<line14>        // This is a relatively common exception that we can't avoid\n<line15>        LOG.debug(\"ignoring exception during output shutdown\", e);\n<line16>    }\n<line17>    try {\n<line18>        sock.socket().shutdownInput();\n<line19>    } catch (IOException e) {\n<line20>        // This is a relatively common exception that we can't avoid\n<line21>        LOG.debug(\"ignoring exception during input shutdown\", e);\n<line22>    }\n<line23>    try {\n<line24>        sock.socket().close();\n<line25>    } catch (IOException e) {\n<line26>        LOG.debug(\"ignoring exception during socket close\", e);\n<line27>    }\n<line28>    try {\n<line29>        sock.close();\n<line30>    } catch (IOException e) {\n<line31>        LOG.debug(\"ignoring exception during socketchannel close\", e);\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    // This is a relatively common exception that we can't avoid\n<line3>}","output":"<line1>{\n<line2>    // This is a relatively common exception that we can't avoid\n<line3>    LOG.debug(\"ignoring exception during output shutdown\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // This is a relatively common exception that we can't avoid\n<line3>}","output":"<line1>{\n<line2>    // This is a relatively common exception that we can't avoid\n<line3>    LOG.debug(\"ignoring exception during input shutdown\", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ignoring exception during socket close\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ignoring exception during socketchannel close\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (localSessionsWithTimeouts == null) {\n<line3>        return -1;\n<line4>    }\n<line5>    // We won't race another upgrade attempt because only one thread\n<line6>    // will get the timeout from the map\n<line7>    Integer timeout = localSessionsWithTimeouts.remove(sessionId);\n<line8>    if (timeout != null) {\n<line9>        // Track global session, which will add to global session tracker\n<line10>        // on leader and do nothing on learner. Need to start track global\n<line11>        // session in leader now to update the session expire between\n<line12>        // LeaderRequestProcessor and PrepRequestProcessor.\n<line13>        trackSession(sessionId, timeout);\n<line14>        // Track ongoing upgrading sessions, learner will use it to find\n<line15>        // other sessions it has which are not in local and global sessions\n<line16>        upgradingSessions.put(sessionId, timeout);\n<line17>        localSessionTracker.removeSession(sessionId);\n<line18>        return timeout;\n<line19>    }\n<line20>    return -1;\n<line21>}","output":"<line1>{\n<line2>    if (localSessionsWithTimeouts == null) {\n<line3>        return -1;\n<line4>    }\n<line5>    // We won't race another upgrade attempt because only one thread\n<line6>    // will get the timeout from the map\n<line7>    Integer timeout = localSessionsWithTimeouts.remove(sessionId);\n<line8>    if (timeout != null) {\n<line9>        LOG.info(\"Upgrading session 0x{}\", Long.toHexString(sessionId));\n<line10>        // Track global session, which will add to global session tracker\n<line11>        // on leader and do nothing on learner. Need to start track global\n<line12>        // session in leader now to update the session expire between\n<line13>        // LeaderRequestProcessor and PrepRequestProcessor.\n<line14>        trackSession(sessionId, timeout);\n<line15>        // Track ongoing upgrading sessions, learner will use it to find\n<line16>        // other sessions it has which are not in local and global sessions\n<line17>        upgradingSessions.put(sessionId, timeout);\n<line18>        localSessionTracker.removeSession(sessionId);\n<line19>        return timeout;\n<line20>    }\n<line21>    return -1;\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    // Track global session, which will add to global session tracker\n<line3>    // on leader and do nothing on learner. Need to start track global\n<line4>    // session in leader now to update the session expire between\n<line5>    // LeaderRequestProcessor and PrepRequestProcessor.\n<line6>    trackSession(sessionId, timeout);\n<line7>    // Track ongoing upgrading sessions, learner will use it to find\n<line8>    // other sessions it has which are not in local and global sessions\n<line9>    upgradingSessions.put(sessionId, timeout);\n<line10>    localSessionTracker.removeSession(sessionId);\n<line11>    return timeout;\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Upgrading session 0x{}\", Long.toHexString(sessionId));\n<line3>    // Track global session, which will add to global session tracker\n<line4>    // on leader and do nothing on learner. Need to start track global\n<line5>    // session in leader now to update the session expire between\n<line6>    // LeaderRequestProcessor and PrepRequestProcessor.\n<line7>    trackSession(sessionId, timeout);\n<line8>    // Track ongoing upgrading sessions, learner will use it to find\n<line9>    // other sessions it has which are not in local and global sessions\n<line10>    upgradingSessions.put(sessionId, timeout);\n<line11>    localSessionTracker.removeSession(sessionId);\n<line12>    return timeout;\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    initiateConnection(self.getVotingView().get(sid).electionAddr, sid);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Opening channel to server {}\", sid);\n<line3>    initiateConnection(self.getVotingView().get(sid).electionAddr, sid);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket sock = null;\n<line3>    try {\n<line4>        if (self.isSslQuorum()) {\n<line5>            sock = self.getX509Util().createSSLSocket();\n<line6>        } else {\n<line7>            sock = SOCKET_FACTORY.get();\n<line8>        }\n<line9>        setSockOpts(sock);\n<line10>        sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n<line11>        if (sock instanceof SSLSocket) {\n<line12>            SSLSocket sslSock = (SSLSocket) sock;\n<line13>            sslSock.startHandshake();\n<line14>        }\n<line15>    } catch (X509Exception e) {\n<line16>        closeSocket(sock);\n<line17>        return;\n<line18>    } catch (UnresolvedAddressException | IOException e) {\n<line19>        closeSocket(sock);\n<line20>        return;\n<line21>    }\n<line22>    try {\n<line23>        startConnection(sock, sid);\n<line24>    } catch (IOException e) {\n<line25>        closeSocket(sock);\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    Socket sock = null;\n<line3>    try {\n<line4>        LOG.debug(\"Opening channel to server {}\", sid);\n<line5>        if (self.isSslQuorum()) {\n<line6>            sock = self.getX509Util().createSSLSocket();\n<line7>        } else {\n<line8>            sock = SOCKET_FACTORY.get();\n<line9>        }\n<line10>        setSockOpts(sock);\n<line11>        sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n<line12>        if (sock instanceof SSLSocket) {\n<line13>            SSLSocket sslSock = (SSLSocket) sock;\n<line14>            sslSock.startHandshake();\n<line15>            LOG.info(\"SSL handshake complete with {} - {} - {}\", sslSock.getRemoteSocketAddress(), sslSock.getSession().getProtocol(), sslSock.getSession().getCipherSuite());\n<line16>        }\n<line17>        LOG.debug(\"Connected to server {} using election address: {}:{}\", sid, sock.getInetAddress(), sock.getPort());\n<line18>    } catch (X509Exception e) {\n<line19>        LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n<line20>        closeSocket(sock);\n<line21>        return;\n<line22>    } catch (UnresolvedAddressException | IOException e) {\n<line23>        LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n<line24>        closeSocket(sock);\n<line25>        return;\n<line26>    }\n<line27>    try {\n<line28>        startConnection(sock, sid);\n<line29>    } catch (IOException e) {\n<line30>        LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\", sid, sock.getRemoteSocketAddress(), e);\n<line31>        closeSocket(sock);\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.isSslQuorum()) {\n<line3>        sock = self.getX509Util().createSSLSocket();\n<line4>    } else {\n<line5>        sock = SOCKET_FACTORY.get();\n<line6>    }\n<line7>    setSockOpts(sock);\n<line8>    sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n<line9>    if (sock instanceof SSLSocket) {\n<line10>        SSLSocket sslSock = (SSLSocket) sock;\n<line11>        sslSock.startHandshake();\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    LOG.debug(\"Opening channel to server {}\", sid);\n<line3>    if (self.isSslQuorum()) {\n<line4>        sock = self.getX509Util().createSSLSocket();\n<line5>    } else {\n<line6>        sock = SOCKET_FACTORY.get();\n<line7>    }\n<line8>    setSockOpts(sock);\n<line9>    sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n<line10>    if (sock instanceof SSLSocket) {\n<line11>        SSLSocket sslSock = (SSLSocket) sock;\n<line12>        sslSock.startHandshake();\n<line13>        LOG.info(\"SSL handshake complete with {} - {} - {}\", sslSock.getRemoteSocketAddress(), sslSock.getSession().getProtocol(), sslSock.getSession().getCipherSuite());\n<line14>    }\n<line15>    LOG.debug(\"Connected to server {} using election address: {}:{}\", sid, sock.getInetAddress(), sock.getPort());\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    SSLSocket sslSock = (SSLSocket) sock;\n<line3>    sslSock.startHandshake();\n<line4>}","output":"<line1>{\n<line2>    SSLSocket sslSock = (SSLSocket) sock;\n<line3>    sslSock.startHandshake();\n<line4>    LOG.info(\"SSL handshake complete with {} - {} - {}\", sslSock.getRemoteSocketAddress(), sslSock.getSession().getProtocol(), sslSock.getSession().getCipherSuite());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\", sid, sock.getRemoteSocketAddress(), e);\n<line3>    closeSocket(sock);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!inprogressConnections.add(sid)) {\n<line3>        // simply return as there is a connection request to\n<line4>        // server 'sid' already in progress.\n<line5>        return true;\n<line6>    }\n<line7>    try {\n<line8>        connectionExecutor.execute(new QuorumConnectionReqThread(electionAddr, sid));\n<line9>        connectionThreadCnt.incrementAndGet();\n<line10>    } catch (Throwable e) {\n<line11>        // Imp: Safer side catching all type of exceptions and remove 'sid'\n<line12>        // from inprogress connections. This is to avoid blocking further\n<line13>        // connection requests from this 'sid' in case of errors.\n<line14>        inprogressConnections.remove(sid);\n<line15>        return false;\n<line16>    }\n<line17>    return true;\n<line18>}","output":"<line1>{\n<line2>    if (!inprogressConnections.add(sid)) {\n<line3>        // simply return as there is a connection request to\n<line4>        // server 'sid' already in progress.\n<line5>        LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\", sid);\n<line6>        return true;\n<line7>    }\n<line8>    try {\n<line9>        connectionExecutor.execute(new QuorumConnectionReqThread(electionAddr, sid));\n<line10>        connectionThreadCnt.incrementAndGet();\n<line11>    } catch (Throwable e) {\n<line12>        // Imp: Safer side catching all type of exceptions and remove 'sid'\n<line13>        // from inprogress connections. This is to avoid blocking further\n<line14>        // connection requests from this 'sid' in case of errors.\n<line15>        inprogressConnections.remove(sid);\n<line16>        LOG.error(\"Exception while submitting quorum connection request\", e);\n<line17>        return false;\n<line18>    }\n<line19>    return true;\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    // simply return as there is a connection request to\n<line3>    // server 'sid' already in progress.\n<line4>    return true;\n<line5>}","output":"<line1>{\n<line2>    // simply return as there is a connection request to\n<line3>    // server 'sid' already in progress.\n<line4>    LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\", sid);\n<line5>    return true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    // Imp: Safer side catching all type of exceptions and remove 'sid'\n<line3>    // from inprogress connections. This is to avoid blocking further\n<line4>    // connection requests from this 'sid' in case of errors.\n<line5>    inprogressConnections.remove(sid);\n<line6>    return false;\n<line7>}","output":"<line1>{\n<line2>    // Imp: Safer side catching all type of exceptions and remove 'sid'\n<line3>    // from inprogress connections. This is to avoid blocking further\n<line4>    // connection requests from this 'sid' in case of errors.\n<line5>    inprogressConnections.remove(sid);\n<line6>    LOG.error(\"Exception while submitting quorum connection request\", e);\n<line7>    return false;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    DataOutputStream dout = null;\n<line3>    DataInputStream din = null;\n<line4>    try {\n<line5>        // Use BufferedOutputStream to reduce the number of IP packets. This is\n<line6>        // important for x-DC scenarios.\n<line7>        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());\n<line8>        dout = new DataOutputStream(buf);\n<line9>        // Sending id and challenge\n<line10>        // First sending the protocol version (in other words - message type).\n<line11>        // For backward compatibility reasons we stick to the old protocol version, unless the MultiAddress\n<line12>        // feature is enabled. During rolling upgrade, we must make sure that all the servers can\n<line13>        // understand the protocol version we use to avoid multiple partitions. see ZOOKEEPER-3720\n<line14>        long protocolVersion = self.isMultiAddressEnabled() ? PROTOCOL_VERSION_V2 : PROTOCOL_VERSION_V1;\n<line15>        dout.writeLong(protocolVersion);\n<line16>        dout.writeLong(self.getMyId());\n<line17>        // now we send our election address. For the new protocol version, we can send multiple addresses.\n<line18>        Collection<InetSocketAddress> addressesToSend = protocolVersion == PROTOCOL_VERSION_V2 ? self.getElectionAddress().getAllAddresses() : Arrays.asList(self.getElectionAddress().getOne());\n<line19>        String addr = addressesToSend.stream().map(NetUtils::formatInetAddr).collect(Collectors.joining(\"|\"));\n<line20>        byte[] addr_bytes = addr.getBytes();\n<line21>        dout.writeInt(addr_bytes.length);\n<line22>        dout.write(addr_bytes);\n<line23>        dout.flush();\n<line24>        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n<line25>    } catch (IOException e) {\n<line26>        closeSocket(sock);\n<line27>        return false;\n<line28>    }\n<line29>    // authenticate learner\n<line30>    QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);\n<line31>    if (qps != null) {\n<line32>        // TODO - investigate why reconfig makes qps null.\n<line33>        authLearner.authenticate(sock, qps.hostname);\n<line34>    }\n<line35>    // If lost the challenge, then drop the new connection\n<line36>    if (sid > self.getMyId()) {\n<line37>        closeSocket(sock);\n<line38>        // Otherwise proceed with the connection\n<line39>    } else {\n<line40>        SendWorker sw = new SendWorker(sock, sid);\n<line41>        RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n<line42>        sw.setRecv(rw);\n<line43>        SendWorker vsw = senderWorkerMap.get(sid);\n<line44>        if (vsw != null) {\n<line45>            vsw.finish();\n<line46>        }\n<line47>        senderWorkerMap.put(sid, sw);\n<line48>        queueSendMap.putIfAbsent(sid, new CircularBlockingQueue<>(SEND_CAPACITY));\n<line49>        sw.start();\n<line50>        rw.start();\n<line51>        return true;\n<line52>    }\n<line53>    return false;\n<line54>}","output":"<line1>{\n<line2>    DataOutputStream dout = null;\n<line3>    DataInputStream din = null;\n<line4>    LOG.debug(\"startConnection (myId:{} --> sid:{})\", self.getMyId(), sid);\n<line5>    try {\n<line6>        // Use BufferedOutputStream to reduce the number of IP packets. This is\n<line7>        // important for x-DC scenarios.\n<line8>        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());\n<line9>        dout = new DataOutputStream(buf);\n<line10>        // Sending id and challenge\n<line11>        // First sending the protocol version (in other words - message type).\n<line12>        // For backward compatibility reasons we stick to the old protocol version, unless the MultiAddress\n<line13>        // feature is enabled. During rolling upgrade, we must make sure that all the servers can\n<line14>        // understand the protocol version we use to avoid multiple partitions. see ZOOKEEPER-3720\n<line15>        long protocolVersion = self.isMultiAddressEnabled() ? PROTOCOL_VERSION_V2 : PROTOCOL_VERSION_V1;\n<line16>        dout.writeLong(protocolVersion);\n<line17>        dout.writeLong(self.getMyId());\n<line18>        // now we send our election address. For the new protocol version, we can send multiple addresses.\n<line19>        Collection<InetSocketAddress> addressesToSend = protocolVersion == PROTOCOL_VERSION_V2 ? self.getElectionAddress().getAllAddresses() : Arrays.asList(self.getElectionAddress().getOne());\n<line20>        String addr = addressesToSend.stream().map(NetUtils::formatInetAddr).collect(Collectors.joining(\"|\"));\n<line21>        byte[] addr_bytes = addr.getBytes();\n<line22>        dout.writeInt(addr_bytes.length);\n<line23>        dout.write(addr_bytes);\n<line24>        dout.flush();\n<line25>        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n<line26>    } catch (IOException e) {\n<line27>        LOG.warn(\"Ignoring exception reading or writing challenge: \", e);\n<line28>        closeSocket(sock);\n<line29>        return false;\n<line30>    }\n<line31>    // authenticate learner\n<line32>    QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);\n<line33>    if (qps != null) {\n<line34>        // TODO - investigate why reconfig makes qps null.\n<line35>        authLearner.authenticate(sock, qps.hostname);\n<line36>    }\n<line37>    // If lost the challenge, then drop the new connection\n<line38>    if (sid > self.getMyId()) {\n<line39>        LOG.info(\"Have smaller server identifier, so dropping the connection: (myId:{} --> sid:{})\", self.getMyId(), sid);\n<line40>        closeSocket(sock);\n<line41>        // Otherwise proceed with the connection\n<line42>    } else {\n<line43>        LOG.debug(\"Have larger server identifier, so keeping the connection: (myId:{} --> sid:{})\", self.getMyId(), sid);\n<line44>        SendWorker sw = new SendWorker(sock, sid);\n<line45>        RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n<line46>        sw.setRecv(rw);\n<line47>        SendWorker vsw = senderWorkerMap.get(sid);\n<line48>        if (vsw != null) {\n<line49>            vsw.finish();\n<line50>        }\n<line51>        senderWorkerMap.put(sid, sw);\n<line52>        queueSendMap.putIfAbsent(sid, new CircularBlockingQueue<>(SEND_CAPACITY));\n<line53>        sw.start();\n<line54>        rw.start();\n<line55>        return true;\n<line56>    }\n<line57>    return false;\n<line58>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>    // Otherwise proceed with the connection\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Have smaller server identifier, so dropping the connection: (myId:{} --> sid:{})\", self.getMyId(), sid);\n<line3>    closeSocket(sock);\n<line4>    // Otherwise proceed with the connection\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    SendWorker sw = new SendWorker(sock, sid);\n<line3>    RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n<line4>    sw.setRecv(rw);\n<line5>    SendWorker vsw = senderWorkerMap.get(sid);\n<line6>    if (vsw != null) {\n<line7>        vsw.finish();\n<line8>    }\n<line9>    senderWorkerMap.put(sid, sw);\n<line10>    queueSendMap.putIfAbsent(sid, new CircularBlockingQueue<>(SEND_CAPACITY));\n<line11>    sw.start();\n<line12>    rw.start();\n<line13>    return true;\n<line14>}","output":"<line1>{\n<line2>    LOG.debug(\"Have larger server identifier, so keeping the connection: (myId:{} --> sid:{})\", self.getMyId(), sid);\n<line3>    SendWorker sw = new SendWorker(sock, sid);\n<line4>    RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n<line5>    sw.setRecv(rw);\n<line6>    SendWorker vsw = senderWorkerMap.get(sid);\n<line7>    if (vsw != null) {\n<line8>        vsw.finish();\n<line9>    }\n<line10>    senderWorkerMap.put(sid, sw);\n<line11>    queueSendMap.putIfAbsent(sid, new CircularBlockingQueue<>(SEND_CAPACITY));\n<line12>    sw.start();\n<line13>    rw.start();\n<line14>    return true;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    DataInputStream din = null;\n<line3>    try {\n<line4>        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n<line5>        handleConnection(sock, din);\n<line6>    } catch (IOException e) {\n<line7>        closeSocket(sock);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    DataInputStream din = null;\n<line3>    try {\n<line4>        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n<line5>        LOG.debug(\"Sync handling of connection request received from: {}\", sock.getRemoteSocketAddress());\n<line6>        handleConnection(sock, din);\n<line7>    } catch (IOException e) {\n<line8>        LOG.error(\"Exception handling connection, addr: {}, closing server connection\", sock.getRemoteSocketAddress());\n<line9>        LOG.debug(\"Exception details: \", e);\n<line10>        closeSocket(sock);\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n<line3>    handleConnection(sock, din);\n<line4>}","output":"<line1>{\n<line2>    din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n<line3>    LOG.debug(\"Sync handling of connection request received from: {}\", sock.getRemoteSocketAddress());\n<line4>    handleConnection(sock, din);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception handling connection, addr: {}, closing server connection\", sock.getRemoteSocketAddress());\n<line3>    LOG.debug(\"Exception details: \", e);\n<line4>    closeSocket(sock);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));\n<line4>        connectionThreadCnt.incrementAndGet();\n<line5>    } catch (Throwable e) {\n<line6>        closeSocket(sock);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.debug(\"Async handling of connection request received from: {}\", sock.getRemoteSocketAddress());\n<line4>        connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));\n<line5>        connectionThreadCnt.incrementAndGet();\n<line6>    } catch (Throwable e) {\n<line7>        LOG.error(\"Exception handling connection, addr: {}, closing server connection\", sock.getRemoteSocketAddress());\n<line8>        LOG.debug(\"Exception details: \", e);\n<line9>        closeSocket(sock);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));\n<line3>    connectionThreadCnt.incrementAndGet();\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"Async handling of connection request received from: {}\", sock.getRemoteSocketAddress());\n<line3>    connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));\n<line4>    connectionThreadCnt.incrementAndGet();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception handling connection, addr: {}, closing server connection\", sock.getRemoteSocketAddress());\n<line3>    LOG.debug(\"Exception details: \", e);\n<line4>    closeSocket(sock);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    Long sid = null, protocolVersion = null;\n<line3>    MultipleAddresses electionAddr = null;\n<line4>    try {\n<line5>        protocolVersion = din.readLong();\n<line6>        if (protocolVersion >= 0) {\n<line7>            // this is a server id and not a protocol version\n<line8>            sid = protocolVersion;\n<line9>        } else {\n<line10>            try {\n<line11>                InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line12>                sid = init.sid;\n<line13>                if (!init.electionAddr.isEmpty()) {\n<line14>                    electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line15>                }\n<line16>            } catch (InitialMessage.InitialMessageException ex) {\n<line17>                closeSocket(sock);\n<line18>                return;\n<line19>            }\n<line20>        }\n<line21>        if (sid == QuorumPeer.OBSERVER_ID) {\n<line22>            /*\n<line23>                 * Choose identifier at random. We need a value to identify\n<line24>                 * the connection.\n<line25>                 */\n<line26>            sid = observerCounter.getAndDecrement();\n<line27>        }\n<line28>    } catch (IOException e) {\n<line29>        closeSocket(sock);\n<line30>        return;\n<line31>    }\n<line32>    // do authenticating learner\n<line33>    authServer.authenticate(sock, din);\n<line34>    //If wins the challenge, then close the new connection.\n<line35>    if (sid < self.getMyId()) {\n<line36>        /*\n<line37>             * This replica might still believe that the connection to sid is\n<line38>             * up, so we have to shut down the workers before trying to open a\n<line39>             * new connection.\n<line40>             */\n<line41>        SendWorker sw = senderWorkerMap.get(sid);\n<line42>        if (sw != null) {\n<line43>            sw.finish();\n<line44>        }\n<line45>        /*\n<line46>             * Now we start a new connection\n<line47>             */\n<line48>        closeSocket(sock);\n<line49>        if (electionAddr != null) {\n<line50>            connectOne(sid, electionAddr);\n<line51>        } else {\n<line52>            connectOne(sid);\n<line53>        }\n<line54>    } else if (sid == self.getMyId()) {\n<line55>        // we saw this case in ZOOKEEPER-2164\n<line56>    } else {\n<line57>        // Otherwise start worker threads to receive data.\n<line58>        SendWorker sw = new SendWorker(sock, sid);\n<line59>        RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n<line60>        sw.setRecv(rw);\n<line61>        SendWorker vsw = senderWorkerMap.get(sid);\n<line62>        if (vsw != null) {\n<line63>            vsw.finish();\n<line64>        }\n<line65>        senderWorkerMap.put(sid, sw);\n<line66>        queueSendMap.putIfAbsent(sid, new CircularBlockingQueue<>(SEND_CAPACITY));\n<line67>        sw.start();\n<line68>        rw.start();\n<line69>    }\n<line70>}","output":"<line1>{\n<line2>    Long sid = null, protocolVersion = null;\n<line3>    MultipleAddresses electionAddr = null;\n<line4>    try {\n<line5>        protocolVersion = din.readLong();\n<line6>        if (protocolVersion >= 0) {\n<line7>            // this is a server id and not a protocol version\n<line8>            sid = protocolVersion;\n<line9>        } else {\n<line10>            try {\n<line11>                InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line12>                sid = init.sid;\n<line13>                if (!init.electionAddr.isEmpty()) {\n<line14>                    electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line15>                }\n<line16>                LOG.debug(\"Initial message parsed by {}: {}\", self.getMyId(), init.toString());\n<line17>            } catch (InitialMessage.InitialMessageException ex) {\n<line18>                LOG.error(\"Initial message parsing error!\", ex);\n<line19>                closeSocket(sock);\n<line20>                return;\n<line21>            }\n<line22>        }\n<line23>        if (sid == QuorumPeer.OBSERVER_ID) {\n<line24>            /*\n<line25>                 * Choose identifier at random. We need a value to identify\n<line26>                 * the connection.\n<line27>                 */\n<line28>            sid = observerCounter.getAndDecrement();\n<line29>            LOG.info(\"Setting arbitrary identifier to observer: {}\", sid);\n<line30>        }\n<line31>    } catch (IOException e) {\n<line32>        LOG.warn(\"Exception reading or writing challenge\", e);\n<line33>        closeSocket(sock);\n<line34>        return;\n<line35>    }\n<line36>    // do authenticating learner\n<line37>    authServer.authenticate(sock, din);\n<line38>    //If wins the challenge, then close the new connection.\n<line39>    if (sid < self.getMyId()) {\n<line40>        /*\n<line41>             * This replica might still believe that the connection to sid is\n<line42>             * up, so we have to shut down the workers before trying to open a\n<line43>             * new connection.\n<line44>             */\n<line45>        SendWorker sw = senderWorkerMap.get(sid);\n<line46>        if (sw != null) {\n<line47>            sw.finish();\n<line48>        }\n<line49>        /*\n<line50>             * Now we start a new connection\n<line51>             */\n<line52>        LOG.debug(\"Create new connection to server: {}\", sid);\n<line53>        closeSocket(sock);\n<line54>        if (electionAddr != null) {\n<line55>            connectOne(sid, electionAddr);\n<line56>        } else {\n<line57>            connectOne(sid);\n<line58>        }\n<line59>    } else if (sid == self.getMyId()) {\n<line60>        // we saw this case in ZOOKEEPER-2164\n<line61>        LOG.warn(\"We got a connection request from a server with our own ID. \" + \"This should be either a configuration error, or a bug.\");\n<line62>    } else {\n<line63>        // Otherwise start worker threads to receive data.\n<line64>        SendWorker sw = new SendWorker(sock, sid);\n<line65>        RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n<line66>        sw.setRecv(rw);\n<line67>        SendWorker vsw = senderWorkerMap.get(sid);\n<line68>        if (vsw != null) {\n<line69>            vsw.finish();\n<line70>        }\n<line71>        senderWorkerMap.put(sid, sw);\n<line72>        queueSendMap.putIfAbsent(sid, new CircularBlockingQueue<>(SEND_CAPACITY));\n<line73>        sw.start();\n<line74>        rw.start();\n<line75>    }\n<line76>}"},{"input":"","instruction":"<line1>{\n<line2>    protocolVersion = din.readLong();\n<line3>    if (protocolVersion >= 0) {\n<line4>        // this is a server id and not a protocol version\n<line5>        sid = protocolVersion;\n<line6>    } else {\n<line7>        try {\n<line8>            InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line9>            sid = init.sid;\n<line10>            if (!init.electionAddr.isEmpty()) {\n<line11>                electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line12>            }\n<line13>        } catch (InitialMessage.InitialMessageException ex) {\n<line14>            closeSocket(sock);\n<line15>            return;\n<line16>        }\n<line17>    }\n<line18>    if (sid == QuorumPeer.OBSERVER_ID) {\n<line19>        /*\n<line20>                 * Choose identifier at random. We need a value to identify\n<line21>                 * the connection.\n<line22>                 */\n<line23>        sid = observerCounter.getAndDecrement();\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    protocolVersion = din.readLong();\n<line3>    if (protocolVersion >= 0) {\n<line4>        // this is a server id and not a protocol version\n<line5>        sid = protocolVersion;\n<line6>    } else {\n<line7>        try {\n<line8>            InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line9>            sid = init.sid;\n<line10>            if (!init.electionAddr.isEmpty()) {\n<line11>                electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line12>            }\n<line13>            LOG.debug(\"Initial message parsed by {}: {}\", self.getMyId(), init.toString());\n<line14>        } catch (InitialMessage.InitialMessageException ex) {\n<line15>            LOG.error(\"Initial message parsing error!\", ex);\n<line16>            closeSocket(sock);\n<line17>            return;\n<line18>        }\n<line19>    }\n<line20>    if (sid == QuorumPeer.OBSERVER_ID) {\n<line21>        /*\n<line22>                 * Choose identifier at random. We need a value to identify\n<line23>                 * the connection.\n<line24>                 */\n<line25>        sid = observerCounter.getAndDecrement();\n<line26>        LOG.info(\"Setting arbitrary identifier to observer: {}\", sid);\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line4>        sid = init.sid;\n<line5>        if (!init.electionAddr.isEmpty()) {\n<line6>            electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line7>        }\n<line8>    } catch (InitialMessage.InitialMessageException ex) {\n<line9>        closeSocket(sock);\n<line10>        return;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line4>        sid = init.sid;\n<line5>        if (!init.electionAddr.isEmpty()) {\n<line6>            electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line7>        }\n<line8>        LOG.debug(\"Initial message parsed by {}: {}\", self.getMyId(), init.toString());\n<line9>    } catch (InitialMessage.InitialMessageException ex) {\n<line10>        LOG.error(\"Initial message parsing error!\", ex);\n<line11>        closeSocket(sock);\n<line12>        return;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line3>    sid = init.sid;\n<line4>    if (!init.electionAddr.isEmpty()) {\n<line5>        electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    InitialMessage init = InitialMessage.parse(protocolVersion, din);\n<line3>    sid = init.sid;\n<line4>    if (!init.electionAddr.isEmpty()) {\n<line5>        electionAddr = new MultipleAddresses(init.electionAddr, Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));\n<line6>    }\n<line7>    LOG.debug(\"Initial message parsed by {}: {}\", self.getMyId(), init.toString());\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Initial message parsing error!\", ex);\n<line3>    closeSocket(sock);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                 * Choose identifier at random. We need a value to identify\n<line4>                 * the connection.\n<line5>                 */\n<line6>    sid = observerCounter.getAndDecrement();\n<line7>}","output":"<line1>{\n<line2>    /*\n<line3>                 * Choose identifier at random. We need a value to identify\n<line4>                 * the connection.\n<line5>                 */\n<line6>    sid = observerCounter.getAndDecrement();\n<line7>    LOG.info(\"Setting arbitrary identifier to observer: {}\", sid);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>             * This replica might still believe that the connection to sid is\n<line4>             * up, so we have to shut down the workers before trying to open a\n<line5>             * new connection.\n<line6>             */\n<line7>    SendWorker sw = senderWorkerMap.get(sid);\n<line8>    if (sw != null) {\n<line9>        sw.finish();\n<line10>    }\n<line11>    /*\n<line12>             * Now we start a new connection\n<line13>             */\n<line14>    closeSocket(sock);\n<line15>    if (electionAddr != null) {\n<line16>        connectOne(sid, electionAddr);\n<line17>    } else {\n<line18>        connectOne(sid);\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    /*\n<line3>             * This replica might still believe that the connection to sid is\n<line4>             * up, so we have to shut down the workers before trying to open a\n<line5>             * new connection.\n<line6>             */\n<line7>    SendWorker sw = senderWorkerMap.get(sid);\n<line8>    if (sw != null) {\n<line9>        sw.finish();\n<line10>    }\n<line11>    /*\n<line12>             * Now we start a new connection\n<line13>             */\n<line14>    LOG.debug(\"Create new connection to server: {}\", sid);\n<line15>    closeSocket(sock);\n<line16>    if (electionAddr != null) {\n<line17>        connectOne(sid, electionAddr);\n<line18>    } else {\n<line19>        connectOne(sid);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    if (senderWorkerMap.get(sid) != null) {\n<line3>        if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n<line4>            // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line5>            // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line6>            // then we will choose an other one, which is actually reachable\n<line7>            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line8>        }\n<line9>        return true;\n<line10>    }\n<line11>    // we are doing connection initiation always asynchronously, since it is possible that\n<line12>    // the socket connection timeouts or the SSL handshake takes too long and don't want\n<line13>    // to keep the rest of the connections to wait\n<line14>    return initiateConnectionAsync(electionAddr, sid);\n<line15>}","output":"<line1>{\n<line2>    if (senderWorkerMap.get(sid) != null) {\n<line3>        LOG.debug(\"There is a connection already for server {}\", sid);\n<line4>        if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n<line5>            // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line6>            // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line7>            // then we will choose an other one, which is actually reachable\n<line8>            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line9>        }\n<line10>        return true;\n<line11>    }\n<line12>    // we are doing connection initiation always asynchronously, since it is possible that\n<line13>    // the socket connection timeouts or the SSL handshake takes too long and don't want\n<line14>    // to keep the rest of the connections to wait\n<line15>    return initiateConnectionAsync(electionAddr, sid);\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n<line3>        // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line4>        // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line5>        // then we will choose an other one, which is actually reachable\n<line6>        senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line7>    }\n<line8>    return true;\n<line9>}","output":"<line1>{\n<line2>    LOG.debug(\"There is a connection already for server {}\", sid);\n<line3>    if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n<line4>        // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line5>        // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line6>        // then we will choose an other one, which is actually reachable\n<line7>        senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line8>    }\n<line9>    return true;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (senderWorkerMap.get(sid) != null) {\n<line3>        if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n<line4>            // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line5>            // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line6>            // then we will choose an other one, which is actually reachable\n<line7>            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line8>        }\n<line9>        return;\n<line10>    }\n<line11>    synchronized (self.QV_LOCK) {\n<line12>        boolean knownId = false;\n<line13>        // Resolve hostname for the remote server before attempting to\n<line14>        // connect in case the underlying ip address has changed.\n<line15>        self.recreateSocketAddresses(sid);\n<line16>        Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n<line17>        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line18>        Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n<line19>        if (lastCommittedView.containsKey(sid)) {\n<line20>            knownId = true;\n<line21>            if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n<line22>                return;\n<line23>            }\n<line24>        }\n<line25>        if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {\n<line26>            knownId = true;\n<line27>            if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n<line28>                return;\n<line29>            }\n<line30>        }\n<line31>        if (!knownId) {\n<line32>        }\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    if (senderWorkerMap.get(sid) != null) {\n<line3>        LOG.debug(\"There is a connection already for server {}\", sid);\n<line4>        if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n<line5>            // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line6>            // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line7>            // then we will choose an other one, which is actually reachable\n<line8>            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line9>        }\n<line10>        return;\n<line11>    }\n<line12>    synchronized (self.QV_LOCK) {\n<line13>        boolean knownId = false;\n<line14>        // Resolve hostname for the remote server before attempting to\n<line15>        // connect in case the underlying ip address has changed.\n<line16>        self.recreateSocketAddresses(sid);\n<line17>        Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n<line18>        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line19>        Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n<line20>        if (lastCommittedView.containsKey(sid)) {\n<line21>            knownId = true;\n<line22>            LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getMyId(), sid);\n<line23>            if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n<line24>                return;\n<line25>            }\n<line26>        }\n<line27>        if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {\n<line28>            knownId = true;\n<line29>            LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getMyId(), sid);\n<line30>            if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n<line31>                return;\n<line32>            }\n<line33>        }\n<line34>        if (!knownId) {\n<line35>            LOG.warn(\"Invalid server id: {} \", sid);\n<line36>        }\n<line37>    }\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n<line3>        // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line4>        // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line5>        // then we will choose an other one, which is actually reachable\n<line6>        senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line7>    }\n<line8>    return;\n<line9>}","output":"<line1>{\n<line2>    LOG.debug(\"There is a connection already for server {}\", sid);\n<line3>    if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n<line4>        // since ZOOKEEPER-3188 we can use multiple election addresses to reach a server. It is possible, that the\n<line5>        // one we are using is already dead and we need to clean-up, so when we will create a new connection\n<line6>        // then we will choose an other one, which is actually reachable\n<line7>        senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n<line8>    }\n<line9>    return;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean knownId = false;\n<line3>    // Resolve hostname for the remote server before attempting to\n<line4>    // connect in case the underlying ip address has changed.\n<line5>    self.recreateSocketAddresses(sid);\n<line6>    Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n<line7>    QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line8>    Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n<line9>    if (lastCommittedView.containsKey(sid)) {\n<line10>        knownId = true;\n<line11>        if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n<line12>            return;\n<line13>        }\n<line14>    }\n<line15>    if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {\n<line16>        knownId = true;\n<line17>        if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n<line18>            return;\n<line19>        }\n<line20>    }\n<line21>    if (!knownId) {\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    boolean knownId = false;\n<line3>    // Resolve hostname for the remote server before attempting to\n<line4>    // connect in case the underlying ip address has changed.\n<line5>    self.recreateSocketAddresses(sid);\n<line6>    Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n<line7>    QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line8>    Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n<line9>    if (lastCommittedView.containsKey(sid)) {\n<line10>        knownId = true;\n<line11>        LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getMyId(), sid);\n<line12>        if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n<line13>            return;\n<line14>        }\n<line15>    }\n<line16>    if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {\n<line17>        knownId = true;\n<line18>        LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getMyId(), sid);\n<line19>        if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n<line20>            return;\n<line21>        }\n<line22>    }\n<line23>    if (!knownId) {\n<line24>        LOG.warn(\"Invalid server id: {} \", sid);\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    knownId = true;\n<line3>    if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n<line4>        return;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    knownId = true;\n<line3>    LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getMyId(), sid);\n<line4>    if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n<line5>        return;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    knownId = true;\n<line3>    if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n<line4>        return;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    knownId = true;\n<line3>    LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getMyId(), sid);\n<line4>    if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n<line5>        return;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    for (BlockingQueue<ByteBuffer> queue : queueSendMap.values()) {\n<line3>        final int queueSize = queue.size();\n<line4>        if (queueSize == 0) {\n<line5>            return true;\n<line6>        }\n<line7>    }\n<line8>    return false;\n<line9>}","output":"<line1>{\n<line2>    for (BlockingQueue<ByteBuffer> queue : queueSendMap.values()) {\n<line3>        final int queueSize = queue.size();\n<line4>        LOG.debug(\"Queue size: {}\", queueSize);\n<line5>        if (queueSize == 0) {\n<line6>            return true;\n<line7>        }\n<line8>    }\n<line9>    return false;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    final int queueSize = queue.size();\n<line3>    if (queueSize == 0) {\n<line4>        return true;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    final int queueSize = queue.size();\n<line3>    LOG.debug(\"Queue size: {}\", queueSize);\n<line4>    if (queueSize == 0) {\n<line5>        return true;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    shutdown = true;\n<line3>    listener.halt();\n<line4>    // Wait for the listener to terminate.\n<line5>    try {\n<line6>        listener.join();\n<line7>    } catch (InterruptedException ex) {\n<line8>    }\n<line9>    softHalt();\n<line10>    // clear data structures used for auth\n<line11>    if (connectionExecutor != null) {\n<line12>        connectionExecutor.shutdown();\n<line13>    }\n<line14>    inprogressConnections.clear();\n<line15>    resetConnectionThreadCount();\n<line16>}","output":"<line1>{\n<line2>    shutdown = true;\n<line3>    LOG.debug(\"Halting listener\");\n<line4>    listener.halt();\n<line5>    // Wait for the listener to terminate.\n<line6>    try {\n<line7>        listener.join();\n<line8>    } catch (InterruptedException ex) {\n<line9>        LOG.warn(\"Got interrupted before joining the listener\", ex);\n<line10>    }\n<line11>    softHalt();\n<line12>    // clear data structures used for auth\n<line13>    if (connectionExecutor != null) {\n<line14>        connectionExecutor.shutdown();\n<line15>    }\n<line16>    inprogressConnections.clear();\n<line17>    resetConnectionThreadCount();\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    for (SendWorker sw : senderWorkerMap.values()) {\n<line3>        sw.finish();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    for (SendWorker sw : senderWorkerMap.values()) {\n<line3>        LOG.debug(\"Server {} is soft-halting sender towards: {}\", self.getMyId(), sw);\n<line4>        sw.finish();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    sw.finish();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Server {} is soft-halting sender towards: {}\", self.getMyId(), sw);\n<line3>    sw.finish();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sock == null) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        sock.close();\n<line7>    } catch (IOException ie) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (sock == null) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        sock.close();\n<line7>    } catch (IOException ie) {\n<line8>        LOG.error(\"Exception while closing\", ie);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while closing\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // During startup of thread, thread name will be overridden to\n<line3>    // specific election address\n<line4>    super(\"ListenerThread\");\n<line5>    socketException = new AtomicBoolean(false);\n<line6>    // maximum retry count while trying to bind to election port\n<line7>    // see ZOOKEEPER-3320 for more details\n<line8>    final Integer maxRetry = Integer.getInteger(ELECTION_PORT_BIND_RETRY, DEFAULT_PORT_BIND_MAX_RETRY);\n<line9>    if (maxRetry >= 0) {\n<line10>        portBindMaxRetry = maxRetry;\n<line11>    } else {\n<line12>        portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    // During startup of thread, thread name will be overridden to\n<line3>    // specific election address\n<line4>    super(\"ListenerThread\");\n<line5>    socketException = new AtomicBoolean(false);\n<line6>    // maximum retry count while trying to bind to election port\n<line7>    // see ZOOKEEPER-3320 for more details\n<line8>    final Integer maxRetry = Integer.getInteger(ELECTION_PORT_BIND_RETRY, DEFAULT_PORT_BIND_MAX_RETRY);\n<line9>    if (maxRetry >= 0) {\n<line10>        LOG.info(\"Election port bind maximum retries is {}\", maxRetry == 0 ? \"infinite\" : maxRetry);\n<line11>        portBindMaxRetry = maxRetry;\n<line12>    } else {\n<line13>        LOG.info(\"'{}' contains invalid value: {}(must be >= 0). Use default value of {} instead.\", ELECTION_PORT_BIND_RETRY, maxRetry, DEFAULT_PORT_BIND_MAX_RETRY);\n<line14>        portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    portBindMaxRetry = maxRetry;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Election port bind maximum retries is {}\", maxRetry == 0 ? \"infinite\" : maxRetry);\n<line3>    portBindMaxRetry = maxRetry;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"'{}' contains invalid value: {}(must be >= 0). Use default value of {} instead.\", ELECTION_PORT_BIND_RETRY, maxRetry, DEFAULT_PORT_BIND_MAX_RETRY);\n<line3>    portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!shutdown) {\n<line3>        Set<InetSocketAddress> addresses;\n<line4>        if (self.getQuorumListenOnAllIPs()) {\n<line5>            addresses = self.getElectionAddress().getWildcardAddresses();\n<line6>        } else {\n<line7>            addresses = self.getElectionAddress().getAllAddresses();\n<line8>        }\n<line9>        CountDownLatch latch = new CountDownLatch(addresses.size());\n<line10>        listenerHandlers = addresses.stream().map(address -> new ListenerHandler(address, self.shouldUsePortUnification(), self.isSslQuorum(), latch)).collect(Collectors.toList());\n<line11>        final ExecutorService executor = Executors.newFixedThreadPool(addresses.size());\n<line12>        try {\n<line13>            listenerHandlers.forEach(executor::submit);\n<line14>        } finally {\n<line15>            // prevent executor's threads to leak after ListenerHandler tasks complete\n<line16>            executor.shutdown();\n<line17>        }\n<line18>        try {\n<line19>            latch.await();\n<line20>        } catch (InterruptedException ie) {\n<line21>        } finally {\n<line22>            // Clean up for shutdown.\n<line23>            for (ListenerHandler handler : listenerHandlers) {\n<line24>                try {\n<line25>                    handler.close();\n<line26>                } catch (IOException ie) {\n<line27>                    // Don't log an error for shutdown.\n<line28>                }\n<line29>            }\n<line30>        }\n<line31>    }\n<line32>    if (!shutdown) {\n<line33>        if (socketException.get()) {\n<line34>            // After leaving listener thread, the host cannot join the quorum anymore,\n<line35>            // this is a severe error that we cannot recover from, so we need to exit\n<line36>            socketBindErrorHandler.run();\n<line37>        }\n<line38>    }\n<line39>}","output":"<line1>{\n<line2>    if (!shutdown) {\n<line3>        LOG.debug(\"Listener thread started, myId: {}\", self.getMyId());\n<line4>        Set<InetSocketAddress> addresses;\n<line5>        if (self.getQuorumListenOnAllIPs()) {\n<line6>            addresses = self.getElectionAddress().getWildcardAddresses();\n<line7>        } else {\n<line8>            addresses = self.getElectionAddress().getAllAddresses();\n<line9>        }\n<line10>        CountDownLatch latch = new CountDownLatch(addresses.size());\n<line11>        listenerHandlers = addresses.stream().map(address -> new ListenerHandler(address, self.shouldUsePortUnification(), self.isSslQuorum(), latch)).collect(Collectors.toList());\n<line12>        final ExecutorService executor = Executors.newFixedThreadPool(addresses.size());\n<line13>        try {\n<line14>            listenerHandlers.forEach(executor::submit);\n<line15>        } finally {\n<line16>            // prevent executor's threads to leak after ListenerHandler tasks complete\n<line17>            executor.shutdown();\n<line18>        }\n<line19>        try {\n<line20>            latch.await();\n<line21>        } catch (InterruptedException ie) {\n<line22>            LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line23>        } finally {\n<line24>            // Clean up for shutdown.\n<line25>            for (ListenerHandler handler : listenerHandlers) {\n<line26>                try {\n<line27>                    handler.close();\n<line28>                } catch (IOException ie) {\n<line29>                    // Don't log an error for shutdown.\n<line30>                    LOG.debug(\"Error closing server socket\", ie);\n<line31>                }\n<line32>            }\n<line33>        }\n<line34>    }\n<line35>    LOG.info(\"Leaving listener\");\n<line36>    if (!shutdown) {\n<line37>        LOG.error(\"As I'm leaving the listener thread, I won't be able to participate in leader election any longer: {}\", self.getElectionAddress().getAllAddresses().stream().map(NetUtils::formatInetAddr).collect(Collectors.joining(\"|\")));\n<line38>        if (socketException.get()) {\n<line39>            // After leaving listener thread, the host cannot join the quorum anymore,\n<line40>            // this is a severe error that we cannot recover from, so we need to exit\n<line41>            socketBindErrorHandler.run();\n<line42>        }\n<line43>    }\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<InetSocketAddress> addresses;\n<line3>    if (self.getQuorumListenOnAllIPs()) {\n<line4>        addresses = self.getElectionAddress().getWildcardAddresses();\n<line5>    } else {\n<line6>        addresses = self.getElectionAddress().getAllAddresses();\n<line7>    }\n<line8>    CountDownLatch latch = new CountDownLatch(addresses.size());\n<line9>    listenerHandlers = addresses.stream().map(address -> new ListenerHandler(address, self.shouldUsePortUnification(), self.isSslQuorum(), latch)).collect(Collectors.toList());\n<line10>    final ExecutorService executor = Executors.newFixedThreadPool(addresses.size());\n<line11>    try {\n<line12>        listenerHandlers.forEach(executor::submit);\n<line13>    } finally {\n<line14>        // prevent executor's threads to leak after ListenerHandler tasks complete\n<line15>        executor.shutdown();\n<line16>    }\n<line17>    try {\n<line18>        latch.await();\n<line19>    } catch (InterruptedException ie) {\n<line20>    } finally {\n<line21>        // Clean up for shutdown.\n<line22>        for (ListenerHandler handler : listenerHandlers) {\n<line23>            try {\n<line24>                handler.close();\n<line25>            } catch (IOException ie) {\n<line26>                // Don't log an error for shutdown.\n<line27>            }\n<line28>        }\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    LOG.debug(\"Listener thread started, myId: {}\", self.getMyId());\n<line3>    Set<InetSocketAddress> addresses;\n<line4>    if (self.getQuorumListenOnAllIPs()) {\n<line5>        addresses = self.getElectionAddress().getWildcardAddresses();\n<line6>    } else {\n<line7>        addresses = self.getElectionAddress().getAllAddresses();\n<line8>    }\n<line9>    CountDownLatch latch = new CountDownLatch(addresses.size());\n<line10>    listenerHandlers = addresses.stream().map(address -> new ListenerHandler(address, self.shouldUsePortUnification(), self.isSslQuorum(), latch)).collect(Collectors.toList());\n<line11>    final ExecutorService executor = Executors.newFixedThreadPool(addresses.size());\n<line12>    try {\n<line13>        listenerHandlers.forEach(executor::submit);\n<line14>    } finally {\n<line15>        // prevent executor's threads to leak after ListenerHandler tasks complete\n<line16>        executor.shutdown();\n<line17>    }\n<line18>    try {\n<line19>        latch.await();\n<line20>    } catch (InterruptedException ie) {\n<line21>        LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line22>    } finally {\n<line23>        // Clean up for shutdown.\n<line24>        for (ListenerHandler handler : listenerHandlers) {\n<line25>            try {\n<line26>                handler.close();\n<line27>            } catch (IOException ie) {\n<line28>                // Don't log an error for shutdown.\n<line29>                LOG.debug(\"Error closing server socket\", ie);\n<line30>            }\n<line31>        }\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // Clean up for shutdown.\n<line3>    for (ListenerHandler handler : listenerHandlers) {\n<line4>        try {\n<line5>            handler.close();\n<line6>        } catch (IOException ie) {\n<line7>            // Don't log an error for shutdown.\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    // Clean up for shutdown.\n<line3>    for (ListenerHandler handler : listenerHandlers) {\n<line4>        try {\n<line5>            handler.close();\n<line6>        } catch (IOException ie) {\n<line7>            // Don't log an error for shutdown.\n<line8>            LOG.debug(\"Error closing server socket\", ie);\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        handler.close();\n<line4>    } catch (IOException ie) {\n<line5>        // Don't log an error for shutdown.\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        handler.close();\n<line4>    } catch (IOException ie) {\n<line5>        // Don't log an error for shutdown.\n<line6>        LOG.debug(\"Error closing server socket\", ie);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    // Don't log an error for shutdown.\n<line3>}","output":"<line1>{\n<line2>    // Don't log an error for shutdown.\n<line3>    LOG.debug(\"Error closing server socket\", ie);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (socketException.get()) {\n<line3>        // After leaving listener thread, the host cannot join the quorum anymore,\n<line4>        // this is a severe error that we cannot recover from, so we need to exit\n<line5>        socketBindErrorHandler.run();\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.error(\"As I'm leaving the listener thread, I won't be able to participate in leader election any longer: {}\", self.getElectionAddress().getAllAddresses().stream().map(NetUtils::formatInetAddr).collect(Collectors.joining(\"|\")));\n<line3>    if (socketException.get()) {\n<line4>        // After leaving listener thread, the host cannot join the quorum anymore,\n<line5>        // this is a severe error that we cannot recover from, so we need to exit\n<line6>        socketBindErrorHandler.run();\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    if (listenerHandlers != null) {\n<line3>        for (ListenerHandler handler : listenerHandlers) {\n<line4>            try {\n<line5>                handler.close();\n<line6>            } catch (IOException e) {\n<line7>            }\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.debug(\"Halt called: Trying to close listeners\");\n<line3>    if (listenerHandlers != null) {\n<line4>        LOG.debug(\"Closing listener: {}\", QuorumCnxManager.this.mySid);\n<line5>        for (ListenerHandler handler : listenerHandlers) {\n<line6>            try {\n<line7>                handler.close();\n<line8>            } catch (IOException e) {\n<line9>                LOG.warn(\"Exception when shutting down listener: \", e);\n<line10>            }\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    for (ListenerHandler handler : listenerHandlers) {\n<line3>        try {\n<line4>            handler.close();\n<line5>        } catch (IOException e) {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.debug(\"Closing listener: {}\", QuorumCnxManager.this.mySid);\n<line3>    for (ListenerHandler handler : listenerHandlers) {\n<line4>        try {\n<line5>            handler.close();\n<line6>        } catch (IOException e) {\n<line7>            LOG.warn(\"Exception when shutting down listener: \", e);\n<line8>        }\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Thread.currentThread().setName(\"ListenerHandler-\" + address);\n<line4>        acceptConnections();\n<line5>        try {\n<line6>            close();\n<line7>        } catch (IOException e) {\n<line8>        }\n<line9>    } catch (Exception e) {\n<line10>        // Output of unexpected exception, should never happen\n<line11>    } finally {\n<line12>        latch.countDown();\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    try {\n<line3>        Thread.currentThread().setName(\"ListenerHandler-\" + address);\n<line4>        acceptConnections();\n<line5>        try {\n<line6>            close();\n<line7>        } catch (IOException e) {\n<line8>            LOG.warn(\"Exception when shutting down listener: \", e);\n<line9>        }\n<line10>    } catch (Exception e) {\n<line11>        // Output of unexpected exception, should never happen\n<line12>        LOG.error(\"Unexpected error \", e);\n<line13>    } finally {\n<line14>        latch.countDown();\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    // Output of unexpected exception, should never happen\n<line3>}","output":"<line1>{\n<line2>    // Output of unexpected exception, should never happen\n<line3>    LOG.error(\"Unexpected error \", e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (serverSocket != null && !serverSocket.isClosed()) {\n<line3>        serverSocket.close();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (serverSocket != null && !serverSocket.isClosed()) {\n<line3>        LOG.debug(\"Trying to close listeners: {}\", serverSocket);\n<line4>        serverSocket.close();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    serverSocket.close();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Trying to close listeners: {}\", serverSocket);\n<line3>    serverSocket.close();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int numRetries = 0;\n<line3>    Socket client = null;\n<line4>    while ((!shutdown) && (portBindMaxRetry == 0 || numRetries < portBindMaxRetry)) {\n<line5>        try {\n<line6>            serverSocket = createNewServerSocket();\n<line7>            while (!shutdown) {\n<line8>                try {\n<line9>                    client = serverSocket.accept();\n<line10>                    setSockOpts(client);\n<line11>                    // Receive and handle the connection request\n<line12>                    // asynchronously if the quorum sasl authentication is\n<line13>                    // enabled. This is required because sasl server\n<line14>                    // authentication process may take few seconds to finish,\n<line15>                    // this may delay next peer connection requests.\n<line16>                    if (quorumSaslAuthEnabled) {\n<line17>                        receiveConnectionAsync(client);\n<line18>                    } else {\n<line19>                        receiveConnection(client);\n<line20>                    }\n<line21>                    numRetries = 0;\n<line22>                } catch (SocketTimeoutException e) {\n<line23>                }\n<line24>            }\n<line25>        } catch (IOException e) {\n<line26>            if (shutdown) {\n<line27>                break;\n<line28>            }\n<line29>            if (e instanceof SocketException) {\n<line30>                socketException.set(true);\n<line31>            }\n<line32>            numRetries++;\n<line33>            try {\n<line34>                close();\n<line35>                Thread.sleep(1000);\n<line36>            } catch (IOException ie) {\n<line37>            } catch (InterruptedException ie) {\n<line38>            }\n<line39>            closeSocket(client);\n<line40>        }\n<line41>    }\n<line42>    if (!shutdown) {\n<line43>    }\n<line44>}","output":"<line1>{\n<line2>    int numRetries = 0;\n<line3>    Socket client = null;\n<line4>    while ((!shutdown) && (portBindMaxRetry == 0 || numRetries < portBindMaxRetry)) {\n<line5>        try {\n<line6>            serverSocket = createNewServerSocket();\n<line7>            LOG.info(\"{} is accepting connections now, my election bind port: {}\", QuorumCnxManager.this.mySid, address.toString());\n<line8>            while (!shutdown) {\n<line9>                try {\n<line10>                    client = serverSocket.accept();\n<line11>                    setSockOpts(client);\n<line12>                    LOG.info(\"Received connection request from {}\", client.getRemoteSocketAddress());\n<line13>                    // Receive and handle the connection request\n<line14>                    // asynchronously if the quorum sasl authentication is\n<line15>                    // enabled. This is required because sasl server\n<line16>                    // authentication process may take few seconds to finish,\n<line17>                    // this may delay next peer connection requests.\n<line18>                    if (quorumSaslAuthEnabled) {\n<line19>                        receiveConnectionAsync(client);\n<line20>                    } else {\n<line21>                        receiveConnection(client);\n<line22>                    }\n<line23>                    numRetries = 0;\n<line24>                } catch (SocketTimeoutException e) {\n<line25>                    LOG.warn(\"The socket is listening for the election accepted \" + \"and it timed out unexpectedly, but will retry.\" + \"see ZOOKEEPER-2836\");\n<line26>                }\n<line27>            }\n<line28>        } catch (IOException e) {\n<line29>            if (shutdown) {\n<line30>                break;\n<line31>            }\n<line32>            LOG.error(\"Exception while listening to address {}\", address, e);\n<line33>            if (e instanceof SocketException) {\n<line34>                socketException.set(true);\n<line35>            }\n<line36>            numRetries++;\n<line37>            try {\n<line38>                close();\n<line39>                Thread.sleep(1000);\n<line40>            } catch (IOException ie) {\n<line41>                LOG.error(\"Error closing server socket\", ie);\n<line42>            } catch (InterruptedException ie) {\n<line43>                LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line44>            }\n<line45>            closeSocket(client);\n<line46>        }\n<line47>    }\n<line48>    if (!shutdown) {\n<line49>        LOG.error(\"Leaving listener thread for address {} after {} errors. Use {} property to increase retry count.\", formatInetAddr(address), numRetries, ELECTION_PORT_BIND_RETRY);\n<line50>    }\n<line51>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        serverSocket = createNewServerSocket();\n<line4>        while (!shutdown) {\n<line5>            try {\n<line6>                client = serverSocket.accept();\n<line7>                setSockOpts(client);\n<line8>                // Receive and handle the connection request\n<line9>                // asynchronously if the quorum sasl authentication is\n<line10>                // enabled. This is required because sasl server\n<line11>                // authentication process may take few seconds to finish,\n<line12>                // this may delay next peer connection requests.\n<line13>                if (quorumSaslAuthEnabled) {\n<line14>                    receiveConnectionAsync(client);\n<line15>                } else {\n<line16>                    receiveConnection(client);\n<line17>                }\n<line18>                numRetries = 0;\n<line19>            } catch (SocketTimeoutException e) {\n<line20>            }\n<line21>        }\n<line22>    } catch (IOException e) {\n<line23>        if (shutdown) {\n<line24>            break;\n<line25>        }\n<line26>        if (e instanceof SocketException) {\n<line27>            socketException.set(true);\n<line28>        }\n<line29>        numRetries++;\n<line30>        try {\n<line31>            close();\n<line32>            Thread.sleep(1000);\n<line33>        } catch (IOException ie) {\n<line34>        } catch (InterruptedException ie) {\n<line35>        }\n<line36>        closeSocket(client);\n<line37>    }\n<line38>}","output":"<line1>{\n<line2>    try {\n<line3>        serverSocket = createNewServerSocket();\n<line4>        LOG.info(\"{} is accepting connections now, my election bind port: {}\", QuorumCnxManager.this.mySid, address.toString());\n<line5>        while (!shutdown) {\n<line6>            try {\n<line7>                client = serverSocket.accept();\n<line8>                setSockOpts(client);\n<line9>                LOG.info(\"Received connection request from {}\", client.getRemoteSocketAddress());\n<line10>                // Receive and handle the connection request\n<line11>                // asynchronously if the quorum sasl authentication is\n<line12>                // enabled. This is required because sasl server\n<line13>                // authentication process may take few seconds to finish,\n<line14>                // this may delay next peer connection requests.\n<line15>                if (quorumSaslAuthEnabled) {\n<line16>                    receiveConnectionAsync(client);\n<line17>                } else {\n<line18>                    receiveConnection(client);\n<line19>                }\n<line20>                numRetries = 0;\n<line21>            } catch (SocketTimeoutException e) {\n<line22>                LOG.warn(\"The socket is listening for the election accepted \" + \"and it timed out unexpectedly, but will retry.\" + \"see ZOOKEEPER-2836\");\n<line23>            }\n<line24>        }\n<line25>    } catch (IOException e) {\n<line26>        if (shutdown) {\n<line27>            break;\n<line28>        }\n<line29>        LOG.error(\"Exception while listening to address {}\", address, e);\n<line30>        if (e instanceof SocketException) {\n<line31>            socketException.set(true);\n<line32>        }\n<line33>        numRetries++;\n<line34>        try {\n<line35>            close();\n<line36>            Thread.sleep(1000);\n<line37>        } catch (IOException ie) {\n<line38>            LOG.error(\"Error closing server socket\", ie);\n<line39>        } catch (InterruptedException ie) {\n<line40>            LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line41>        }\n<line42>        closeSocket(client);\n<line43>    }\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    serverSocket = createNewServerSocket();\n<line3>    while (!shutdown) {\n<line4>        try {\n<line5>            client = serverSocket.accept();\n<line6>            setSockOpts(client);\n<line7>            // Receive and handle the connection request\n<line8>            // asynchronously if the quorum sasl authentication is\n<line9>            // enabled. This is required because sasl server\n<line10>            // authentication process may take few seconds to finish,\n<line11>            // this may delay next peer connection requests.\n<line12>            if (quorumSaslAuthEnabled) {\n<line13>                receiveConnectionAsync(client);\n<line14>            } else {\n<line15>                receiveConnection(client);\n<line16>            }\n<line17>            numRetries = 0;\n<line18>        } catch (SocketTimeoutException e) {\n<line19>        }\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    serverSocket = createNewServerSocket();\n<line3>    LOG.info(\"{} is accepting connections now, my election bind port: {}\", QuorumCnxManager.this.mySid, address.toString());\n<line4>    while (!shutdown) {\n<line5>        try {\n<line6>            client = serverSocket.accept();\n<line7>            setSockOpts(client);\n<line8>            LOG.info(\"Received connection request from {}\", client.getRemoteSocketAddress());\n<line9>            // Receive and handle the connection request\n<line10>            // asynchronously if the quorum sasl authentication is\n<line11>            // enabled. This is required because sasl server\n<line12>            // authentication process may take few seconds to finish,\n<line13>            // this may delay next peer connection requests.\n<line14>            if (quorumSaslAuthEnabled) {\n<line15>                receiveConnectionAsync(client);\n<line16>            } else {\n<line17>                receiveConnection(client);\n<line18>            }\n<line19>            numRetries = 0;\n<line20>        } catch (SocketTimeoutException e) {\n<line21>            LOG.warn(\"The socket is listening for the election accepted \" + \"and it timed out unexpectedly, but will retry.\" + \"see ZOOKEEPER-2836\");\n<line22>        }\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        client = serverSocket.accept();\n<line4>        setSockOpts(client);\n<line5>        // Receive and handle the connection request\n<line6>        // asynchronously if the quorum sasl authentication is\n<line7>        // enabled. This is required because sasl server\n<line8>        // authentication process may take few seconds to finish,\n<line9>        // this may delay next peer connection requests.\n<line10>        if (quorumSaslAuthEnabled) {\n<line11>            receiveConnectionAsync(client);\n<line12>        } else {\n<line13>            receiveConnection(client);\n<line14>        }\n<line15>        numRetries = 0;\n<line16>    } catch (SocketTimeoutException e) {\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        client = serverSocket.accept();\n<line4>        setSockOpts(client);\n<line5>        LOG.info(\"Received connection request from {}\", client.getRemoteSocketAddress());\n<line6>        // Receive and handle the connection request\n<line7>        // asynchronously if the quorum sasl authentication is\n<line8>        // enabled. This is required because sasl server\n<line9>        // authentication process may take few seconds to finish,\n<line10>        // this may delay next peer connection requests.\n<line11>        if (quorumSaslAuthEnabled) {\n<line12>            receiveConnectionAsync(client);\n<line13>        } else {\n<line14>            receiveConnection(client);\n<line15>        }\n<line16>        numRetries = 0;\n<line17>    } catch (SocketTimeoutException e) {\n<line18>        LOG.warn(\"The socket is listening for the election accepted \" + \"and it timed out unexpectedly, but will retry.\" + \"see ZOOKEEPER-2836\");\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    client = serverSocket.accept();\n<line3>    setSockOpts(client);\n<line4>    // Receive and handle the connection request\n<line5>    // asynchronously if the quorum sasl authentication is\n<line6>    // enabled. This is required because sasl server\n<line7>    // authentication process may take few seconds to finish,\n<line8>    // this may delay next peer connection requests.\n<line9>    if (quorumSaslAuthEnabled) {\n<line10>        receiveConnectionAsync(client);\n<line11>    } else {\n<line12>        receiveConnection(client);\n<line13>    }\n<line14>    numRetries = 0;\n<line15>}","output":"<line1>{\n<line2>    client = serverSocket.accept();\n<line3>    setSockOpts(client);\n<line4>    LOG.info(\"Received connection request from {}\", client.getRemoteSocketAddress());\n<line5>    // Receive and handle the connection request\n<line6>    // asynchronously if the quorum sasl authentication is\n<line7>    // enabled. This is required because sasl server\n<line8>    // authentication process may take few seconds to finish,\n<line9>    // this may delay next peer connection requests.\n<line10>    if (quorumSaslAuthEnabled) {\n<line11>        receiveConnectionAsync(client);\n<line12>    } else {\n<line13>        receiveConnection(client);\n<line14>    }\n<line15>    numRetries = 0;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (shutdown) {\n<line3>        break;\n<line4>    }\n<line5>    if (e instanceof SocketException) {\n<line6>        socketException.set(true);\n<line7>    }\n<line8>    numRetries++;\n<line9>    try {\n<line10>        close();\n<line11>        Thread.sleep(1000);\n<line12>    } catch (IOException ie) {\n<line13>    } catch (InterruptedException ie) {\n<line14>    }\n<line15>    closeSocket(client);\n<line16>}","output":"<line1>{\n<line2>    if (shutdown) {\n<line3>        break;\n<line4>    }\n<line5>    LOG.error(\"Exception while listening to address {}\", address, e);\n<line6>    if (e instanceof SocketException) {\n<line7>        socketException.set(true);\n<line8>    }\n<line9>    numRetries++;\n<line10>    try {\n<line11>        close();\n<line12>        Thread.sleep(1000);\n<line13>    } catch (IOException ie) {\n<line14>        LOG.error(\"Error closing server socket\", ie);\n<line15>    } catch (InterruptedException ie) {\n<line16>        LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line17>    }\n<line18>    closeSocket(client);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error closing server socket\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while sleeping. Ignoring exception\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Leaving listener thread for address {} after {} errors. Use {} property to increase retry count.\", formatInetAddr(address), numRetries, ELECTION_PORT_BIND_RETRY);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerSocket socket;\n<line3>    if (portUnification) {\n<line4>        socket = new UnifiedServerSocket(self.getX509Util(), true);\n<line5>    } else if (sslQuorum) {\n<line6>        socket = new UnifiedServerSocket(self.getX509Util(), false);\n<line7>    } else {\n<line8>        socket = new ServerSocket();\n<line9>    }\n<line10>    socket.setReuseAddress(true);\n<line11>    address = new InetSocketAddress(address.getHostString(), address.getPort());\n<line12>    socket.bind(address);\n<line13>    return socket;\n<line14>}","output":"<line1>{\n<line2>    ServerSocket socket;\n<line3>    if (portUnification) {\n<line4>        LOG.info(\"Creating TLS-enabled quorum server socket\");\n<line5>        socket = new UnifiedServerSocket(self.getX509Util(), true);\n<line6>    } else if (sslQuorum) {\n<line7>        LOG.info(\"Creating TLS-only quorum server socket\");\n<line8>        socket = new UnifiedServerSocket(self.getX509Util(), false);\n<line9>    } else {\n<line10>        socket = new ServerSocket();\n<line11>    }\n<line12>    socket.setReuseAddress(true);\n<line13>    address = new InetSocketAddress(address.getHostString(), address.getPort());\n<line14>    socket.bind(address);\n<line15>    return socket;\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    socket = new UnifiedServerSocket(self.getX509Util(), true);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Creating TLS-enabled quorum server socket\");\n<line3>    socket = new UnifiedServerSocket(self.getX509Util(), true);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    socket = new UnifiedServerSocket(self.getX509Util(), false);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Creating TLS-only quorum server socket\");\n<line3>    socket = new UnifiedServerSocket(self.getX509Util(), false);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    super(\"SendWorker:\" + sid);\n<line3>    this.sid = sid;\n<line4>    this.sock = sock;\n<line5>    recvWorker = null;\n<line6>    try {\n<line7>        dout = new DataOutputStream(sock.getOutputStream());\n<line8>    } catch (IOException e) {\n<line9>        closeSocket(sock);\n<line10>        running = false;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    super(\"SendWorker:\" + sid);\n<line3>    this.sid = sid;\n<line4>    this.sock = sock;\n<line5>    recvWorker = null;\n<line6>    try {\n<line7>        dout = new DataOutputStream(sock.getOutputStream());\n<line8>    } catch (IOException e) {\n<line9>        LOG.error(\"Unable to access socket output stream\", e);\n<line10>        closeSocket(sock);\n<line11>        running = false;\n<line12>    }\n<line13>    LOG.debug(\"Address of remote peer: {}\", this.sid);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>    running = false;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to access socket output stream\", e);\n<line3>    closeSocket(sock);\n<line4>    running = false;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!running) {\n<line3>        /*\n<line4>                 * Avoids running finish() twice.\n<line5>                 */\n<line6>        return running;\n<line7>    }\n<line8>    running = false;\n<line9>    closeSocket(sock);\n<line10>    this.interrupt();\n<line11>    if (recvWorker != null) {\n<line12>        recvWorker.finish();\n<line13>    }\n<line14>    senderWorkerMap.remove(sid, this);\n<line15>    threadCnt.decrementAndGet();\n<line16>    return running;\n<line17>}","output":"<line1>{\n<line2>    LOG.debug(\"Calling SendWorker.finish for {}\", sid);\n<line3>    if (!running) {\n<line4>        /*\n<line5>                 * Avoids running finish() twice.\n<line6>                 */\n<line7>        return running;\n<line8>    }\n<line9>    running = false;\n<line10>    closeSocket(sock);\n<line11>    this.interrupt();\n<line12>    if (recvWorker != null) {\n<line13>        recvWorker.finish();\n<line14>    }\n<line15>    LOG.debug(\"Removing entry from senderWorkerMap sid={}\", sid);\n<line16>    senderWorkerMap.remove(sid, this);\n<line17>    threadCnt.decrementAndGet();\n<line18>    return running;\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] msgBytes = new byte[b.capacity()];\n<line3>    try {\n<line4>        b.position(0);\n<line5>        b.get(msgBytes);\n<line6>    } catch (BufferUnderflowException be) {\n<line7>        return;\n<line8>    }\n<line9>    dout.writeInt(b.capacity());\n<line10>    dout.write(b.array());\n<line11>    dout.flush();\n<line12>}","output":"<line1>{\n<line2>    byte[] msgBytes = new byte[b.capacity()];\n<line3>    try {\n<line4>        b.position(0);\n<line5>        b.get(msgBytes);\n<line6>    } catch (BufferUnderflowException be) {\n<line7>        LOG.error(\"BufferUnderflowException \", be);\n<line8>        return;\n<line9>    }\n<line10>    dout.writeInt(b.capacity());\n<line11>    dout.write(b.array());\n<line12>    dout.flush();\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"BufferUnderflowException \", be);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    threadCnt.incrementAndGet();\n<line3>    try {\n<line4>        /**\n<line5>         * If there is nothing in the queue to send, then we\n<line6>         * send the lastMessage to ensure that the last message\n<line7>         * was received by the peer. The message could be dropped\n<line8>         * in case self or the peer shutdown their connection\n<line9>         * (and exit the thread) prior to reading/processing\n<line10>         * the last message. Duplicate messages are handled correctly\n<line11>         * by the peer.\n<line12>         *\n<line13>         * If the send queue is non-empty, then we have a recent\n<line14>         * message than that stored in lastMessage. To avoid sending\n<line15>         * stale message, we should send the message in the send queue.\n<line16>         */\n<line17>        BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line18>        if (bq == null || isSendQueueEmpty(bq)) {\n<line19>            ByteBuffer b = lastMessageSent.get(sid);\n<line20>            if (b != null) {\n<line21>                send(b);\n<line22>            }\n<line23>        }\n<line24>    } catch (IOException e) {\n<line25>        this.finish();\n<line26>    }\n<line27>    try {\n<line28>        while (running && !shutdown && sock != null) {\n<line29>            ByteBuffer b = null;\n<line30>            try {\n<line31>                BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line32>                if (bq != null) {\n<line33>                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line34>                } else {\n<line35>                    break;\n<line36>                }\n<line37>                if (b != null) {\n<line38>                    lastMessageSent.put(sid, b);\n<line39>                    send(b);\n<line40>                }\n<line41>            } catch (InterruptedException e) {\n<line42>            }\n<line43>        }\n<line44>    } catch (Exception e) {\n<line45>    }\n<line46>    this.finish();\n<line47>}","output":"<line1>{\n<line2>    threadCnt.incrementAndGet();\n<line3>    try {\n<line4>        /**\n<line5>         * If there is nothing in the queue to send, then we\n<line6>         * send the lastMessage to ensure that the last message\n<line7>         * was received by the peer. The message could be dropped\n<line8>         * in case self or the peer shutdown their connection\n<line9>         * (and exit the thread) prior to reading/processing\n<line10>         * the last message. Duplicate messages are handled correctly\n<line11>         * by the peer.\n<line12>         *\n<line13>         * If the send queue is non-empty, then we have a recent\n<line14>         * message than that stored in lastMessage. To avoid sending\n<line15>         * stale message, we should send the message in the send queue.\n<line16>         */\n<line17>        BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line18>        if (bq == null || isSendQueueEmpty(bq)) {\n<line19>            ByteBuffer b = lastMessageSent.get(sid);\n<line20>            if (b != null) {\n<line21>                LOG.debug(\"Attempting to send lastMessage to sid={}\", sid);\n<line22>                send(b);\n<line23>            }\n<line24>        }\n<line25>    } catch (IOException e) {\n<line26>        LOG.error(\"Failed to send last message. Shutting down thread.\", e);\n<line27>        this.finish();\n<line28>    }\n<line29>    LOG.debug(\"SendWorker thread started towards {}. myId: {}\", sid, QuorumCnxManager.this.mySid);\n<line30>    try {\n<line31>        while (running && !shutdown && sock != null) {\n<line32>            ByteBuffer b = null;\n<line33>            try {\n<line34>                BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line35>                if (bq != null) {\n<line36>                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line37>                } else {\n<line38>                    LOG.error(\"No queue of incoming messages for server {}\", sid);\n<line39>                    break;\n<line40>                }\n<line41>                if (b != null) {\n<line42>                    lastMessageSent.put(sid, b);\n<line43>                    send(b);\n<line44>                }\n<line45>            } catch (InterruptedException e) {\n<line46>                LOG.warn(\"Interrupted while waiting for message on queue\", e);\n<line47>            }\n<line48>        }\n<line49>    } catch (Exception e) {\n<line50>        LOG.warn(\"Exception when using channel: for id {} my id = {}\", sid, QuorumCnxManager.this.mySid, e);\n<line51>    }\n<line52>    this.finish();\n<line53>    LOG.warn(\"Send worker leaving thread id {} my id = {}\", sid, self.getMyId());\n<line54>}"},{"input":"","instruction":"<line1>{\n<line2>    /**\n<line3>     * If there is nothing in the queue to send, then we\n<line4>     * send the lastMessage to ensure that the last message\n<line5>     * was received by the peer. The message could be dropped\n<line6>     * in case self or the peer shutdown their connection\n<line7>     * (and exit the thread) prior to reading/processing\n<line8>     * the last message. Duplicate messages are handled correctly\n<line9>     * by the peer.\n<line10>     *\n<line11>     * If the send queue is non-empty, then we have a recent\n<line12>     * message than that stored in lastMessage. To avoid sending\n<line13>     * stale message, we should send the message in the send queue.\n<line14>     */\n<line15>    BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line16>    if (bq == null || isSendQueueEmpty(bq)) {\n<line17>        ByteBuffer b = lastMessageSent.get(sid);\n<line18>        if (b != null) {\n<line19>            send(b);\n<line20>        }\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    /**\n<line3>     * If there is nothing in the queue to send, then we\n<line4>     * send the lastMessage to ensure that the last message\n<line5>     * was received by the peer. The message could be dropped\n<line6>     * in case self or the peer shutdown their connection\n<line7>     * (and exit the thread) prior to reading/processing\n<line8>     * the last message. Duplicate messages are handled correctly\n<line9>     * by the peer.\n<line10>     *\n<line11>     * If the send queue is non-empty, then we have a recent\n<line12>     * message than that stored in lastMessage. To avoid sending\n<line13>     * stale message, we should send the message in the send queue.\n<line14>     */\n<line15>    BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line16>    if (bq == null || isSendQueueEmpty(bq)) {\n<line17>        ByteBuffer b = lastMessageSent.get(sid);\n<line18>        if (b != null) {\n<line19>            LOG.debug(\"Attempting to send lastMessage to sid={}\", sid);\n<line20>            send(b);\n<line21>        }\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    ByteBuffer b = lastMessageSent.get(sid);\n<line3>    if (b != null) {\n<line4>        send(b);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    ByteBuffer b = lastMessageSent.get(sid);\n<line3>    if (b != null) {\n<line4>        LOG.debug(\"Attempting to send lastMessage to sid={}\", sid);\n<line5>        send(b);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    send(b);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Attempting to send lastMessage to sid={}\", sid);\n<line3>    send(b);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.finish();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to send last message. Shutting down thread.\", e);\n<line3>    this.finish();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    while (running && !shutdown && sock != null) {\n<line3>        ByteBuffer b = null;\n<line4>        try {\n<line5>            BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line6>            if (bq != null) {\n<line7>                b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line8>            } else {\n<line9>                break;\n<line10>            }\n<line11>            if (b != null) {\n<line12>                lastMessageSent.put(sid, b);\n<line13>                send(b);\n<line14>            }\n<line15>        } catch (InterruptedException e) {\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    while (running && !shutdown && sock != null) {\n<line3>        ByteBuffer b = null;\n<line4>        try {\n<line5>            BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line6>            if (bq != null) {\n<line7>                b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line8>            } else {\n<line9>                LOG.error(\"No queue of incoming messages for server {}\", sid);\n<line10>                break;\n<line11>            }\n<line12>            if (b != null) {\n<line13>                lastMessageSent.put(sid, b);\n<line14>                send(b);\n<line15>            }\n<line16>        } catch (InterruptedException e) {\n<line17>            LOG.warn(\"Interrupted while waiting for message on queue\", e);\n<line18>        }\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    ByteBuffer b = null;\n<line3>    try {\n<line4>        BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line5>        if (bq != null) {\n<line6>            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line7>        } else {\n<line8>            break;\n<line9>        }\n<line10>        if (b != null) {\n<line11>            lastMessageSent.put(sid, b);\n<line12>            send(b);\n<line13>        }\n<line14>    } catch (InterruptedException e) {\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    ByteBuffer b = null;\n<line3>    try {\n<line4>        BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line5>        if (bq != null) {\n<line6>            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line7>        } else {\n<line8>            LOG.error(\"No queue of incoming messages for server {}\", sid);\n<line9>            break;\n<line10>        }\n<line11>        if (b != null) {\n<line12>            lastMessageSent.put(sid, b);\n<line13>            send(b);\n<line14>        }\n<line15>    } catch (InterruptedException e) {\n<line16>        LOG.warn(\"Interrupted while waiting for message on queue\", e);\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line3>    if (bq != null) {\n<line4>        b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line5>    } else {\n<line6>        break;\n<line7>    }\n<line8>    if (b != null) {\n<line9>        lastMessageSent.put(sid, b);\n<line10>        send(b);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    BlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);\n<line3>    if (bq != null) {\n<line4>        b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n<line5>    } else {\n<line6>        LOG.error(\"No queue of incoming messages for server {}\", sid);\n<line7>        break;\n<line8>    }\n<line9>    if (b != null) {\n<line10>        lastMessageSent.put(sid, b);\n<line11>        send(b);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"No queue of incoming messages for server {}\", sid);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (ongoingAsyncValidation.compareAndSet(false, true)) {\n<line3>        new Thread(() -> {\n<line4>            if (sock != null) {\n<line5>                InetAddress address = sock.getInetAddress();\n<line6>                try {\n<line7>                    if (address.isReachable(500)) {\n<line8>                        ongoingAsyncValidation.set(false);\n<line9>                        return;\n<line10>                    }\n<line11>                } catch (NullPointerException | IOException ignored) {\n<line12>                }\n<line13>                this.finish();\n<line14>            }\n<line15>        }).start();\n<line16>    } else {\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    if (ongoingAsyncValidation.compareAndSet(false, true)) {\n<line3>        new Thread(() -> {\n<line4>            LOG.debug(\"validate if destination address is reachable for sid {}\", sid);\n<line5>            if (sock != null) {\n<line6>                InetAddress address = sock.getInetAddress();\n<line7>                try {\n<line8>                    if (address.isReachable(500)) {\n<line9>                        LOG.debug(\"destination address {} is reachable for sid {}\", address.toString(), sid);\n<line10>                        ongoingAsyncValidation.set(false);\n<line11>                        return;\n<line12>                    }\n<line13>                } catch (NullPointerException | IOException ignored) {\n<line14>                }\n<line15>                LOG.warn(\"destination address {} not reachable anymore, shutting down the SendWorker for sid {}\", address.toString(), sid);\n<line16>                this.finish();\n<line17>            }\n<line18>        }).start();\n<line19>    } else {\n<line20>        LOG.debug(\"validation of destination address for sid {} is skipped (it is already running)\", sid);\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    new Thread(() -> {\n<line3>        if (sock != null) {\n<line4>            InetAddress address = sock.getInetAddress();\n<line5>            try {\n<line6>                if (address.isReachable(500)) {\n<line7>                    ongoingAsyncValidation.set(false);\n<line8>                    return;\n<line9>                }\n<line10>            } catch (NullPointerException | IOException ignored) {\n<line11>            }\n<line12>            this.finish();\n<line13>        }\n<line14>    }).start();\n<line15>}","output":"<line1>{\n<line2>    new Thread(() -> {\n<line3>        LOG.debug(\"validate if destination address is reachable for sid {}\", sid);\n<line4>        if (sock != null) {\n<line5>            InetAddress address = sock.getInetAddress();\n<line6>            try {\n<line7>                if (address.isReachable(500)) {\n<line8>                    LOG.debug(\"destination address {} is reachable for sid {}\", address.toString(), sid);\n<line9>                    ongoingAsyncValidation.set(false);\n<line10>                    return;\n<line11>                }\n<line12>            } catch (NullPointerException | IOException ignored) {\n<line13>            }\n<line14>            LOG.warn(\"destination address {} not reachable anymore, shutting down the SendWorker for sid {}\", address.toString(), sid);\n<line15>            this.finish();\n<line16>        }\n<line17>    }).start();\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sock != null) {\n<line3>        InetAddress address = sock.getInetAddress();\n<line4>        try {\n<line5>            if (address.isReachable(500)) {\n<line6>                ongoingAsyncValidation.set(false);\n<line7>                return;\n<line8>            }\n<line9>        } catch (NullPointerException | IOException ignored) {\n<line10>        }\n<line11>        this.finish();\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    LOG.debug(\"validate if destination address is reachable for sid {}\", sid);\n<line3>    if (sock != null) {\n<line4>        InetAddress address = sock.getInetAddress();\n<line5>        try {\n<line6>            if (address.isReachable(500)) {\n<line7>                LOG.debug(\"destination address {} is reachable for sid {}\", address.toString(), sid);\n<line8>                ongoingAsyncValidation.set(false);\n<line9>                return;\n<line10>            }\n<line11>        } catch (NullPointerException | IOException ignored) {\n<line12>        }\n<line13>        LOG.warn(\"destination address {} not reachable anymore, shutting down the SendWorker for sid {}\", address.toString(), sid);\n<line14>        this.finish();\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    InetAddress address = sock.getInetAddress();\n<line3>    try {\n<line4>        if (address.isReachable(500)) {\n<line5>            ongoingAsyncValidation.set(false);\n<line6>            return;\n<line7>        }\n<line8>    } catch (NullPointerException | IOException ignored) {\n<line9>    }\n<line10>    this.finish();\n<line11>}","output":"<line1>{\n<line2>    InetAddress address = sock.getInetAddress();\n<line3>    try {\n<line4>        if (address.isReachable(500)) {\n<line5>            LOG.debug(\"destination address {} is reachable for sid {}\", address.toString(), sid);\n<line6>            ongoingAsyncValidation.set(false);\n<line7>            return;\n<line8>        }\n<line9>    } catch (NullPointerException | IOException ignored) {\n<line10>    }\n<line11>    LOG.warn(\"destination address {} not reachable anymore, shutting down the SendWorker for sid {}\", address.toString(), sid);\n<line12>    this.finish();\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (address.isReachable(500)) {\n<line3>        ongoingAsyncValidation.set(false);\n<line4>        return;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (address.isReachable(500)) {\n<line3>        LOG.debug(\"destination address {} is reachable for sid {}\", address.toString(), sid);\n<line4>        ongoingAsyncValidation.set(false);\n<line5>        return;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ongoingAsyncValidation.set(false);\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"destination address {} is reachable for sid {}\", address.toString(), sid);\n<line3>    ongoingAsyncValidation.set(false);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"validation of destination address for sid {} is skipped (it is already running)\", sid);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    super(\"RecvWorker:\" + sid);\n<line3>    this.sid = sid;\n<line4>    this.sock = sock;\n<line5>    this.sw = sw;\n<line6>    this.din = din;\n<line7>    try {\n<line8>        // OK to wait until socket disconnects while reading.\n<line9>        sock.setSoTimeout(0);\n<line10>    } catch (IOException e) {\n<line11>        closeSocket(sock);\n<line12>        running = false;\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    super(\"RecvWorker:\" + sid);\n<line3>    this.sid = sid;\n<line4>    this.sock = sock;\n<line5>    this.sw = sw;\n<line6>    this.din = din;\n<line7>    try {\n<line8>        // OK to wait until socket disconnects while reading.\n<line9>        sock.setSoTimeout(0);\n<line10>    } catch (IOException e) {\n<line11>        LOG.error(\"Error while accessing socket for {}\", sid, e);\n<line12>        closeSocket(sock);\n<line13>        running = false;\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket(sock);\n<line3>    running = false;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Error while accessing socket for {}\", sid, e);\n<line3>    closeSocket(sock);\n<line4>    running = false;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!running) {\n<line3>        /*\n<line4>                 * Avoids running finish() twice.\n<line5>                 */\n<line6>        return running;\n<line7>    }\n<line8>    running = false;\n<line9>    this.interrupt();\n<line10>    threadCnt.decrementAndGet();\n<line11>    return running;\n<line12>}","output":"<line1>{\n<line2>    LOG.debug(\"RecvWorker.finish called. sid: {}. myId: {}\", sid, QuorumCnxManager.this.mySid);\n<line3>    if (!running) {\n<line4>        /*\n<line5>                 * Avoids running finish() twice.\n<line6>                 */\n<line7>        return running;\n<line8>    }\n<line9>    running = false;\n<line10>    this.interrupt();\n<line11>    threadCnt.decrementAndGet();\n<line12>    return running;\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    threadCnt.incrementAndGet();\n<line3>    try {\n<line4>        while (running && !shutdown && sock != null) {\n<line5>            /**\n<line6>             * Reads the first int to determine the length of the\n<line7>             * message\n<line8>             */\n<line9>            int length = din.readInt();\n<line10>            if (length <= 0 || length > PACKETMAXSIZE) {\n<line11>                throw new IOException(\"Received packet with invalid packet: \" + length);\n<line12>            }\n<line13>            /**\n<line14>             * Allocates a new ByteBuffer to receive the message\n<line15>             */\n<line16>            final byte[] msgArray = new byte[length];\n<line17>            din.readFully(msgArray, 0, length);\n<line18>            addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));\n<line19>        }\n<line20>    } catch (Exception e) {\n<line21>    } finally {\n<line22>        sw.finish();\n<line23>        closeSocket(sock);\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    threadCnt.incrementAndGet();\n<line3>    try {\n<line4>        LOG.debug(\"RecvWorker thread towards {} started. myId: {}\", sid, QuorumCnxManager.this.mySid);\n<line5>        while (running && !shutdown && sock != null) {\n<line6>            /**\n<line7>             * Reads the first int to determine the length of the\n<line8>             * message\n<line9>             */\n<line10>            int length = din.readInt();\n<line11>            if (length <= 0 || length > PACKETMAXSIZE) {\n<line12>                throw new IOException(\"Received packet with invalid packet: \" + length);\n<line13>            }\n<line14>            /**\n<line15>             * Allocates a new ByteBuffer to receive the message\n<line16>             */\n<line17>            final byte[] msgArray = new byte[length];\n<line18>            din.readFully(msgArray, 0, length);\n<line19>            addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));\n<line20>        }\n<line21>    } catch (Exception e) {\n<line22>        LOG.warn(\"Connection broken for id {}, my id = {}\", sid, QuorumCnxManager.this.mySid, e);\n<line23>    } finally {\n<line24>        LOG.warn(\"Interrupting SendWorker thread from RecvWorker. sid: {}. myId: {}\", sid, QuorumCnxManager.this.mySid);\n<line25>        sw.finish();\n<line26>        closeSocket(sock);\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    while (running && !shutdown && sock != null) {\n<line3>        /**\n<line4>         * Reads the first int to determine the length of the\n<line5>         * message\n<line6>         */\n<line7>        int length = din.readInt();\n<line8>        if (length <= 0 || length > PACKETMAXSIZE) {\n<line9>            throw new IOException(\"Received packet with invalid packet: \" + length);\n<line10>        }\n<line11>        /**\n<line12>         * Allocates a new ByteBuffer to receive the message\n<line13>         */\n<line14>        final byte[] msgArray = new byte[length];\n<line15>        din.readFully(msgArray, 0, length);\n<line16>        addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    LOG.debug(\"RecvWorker thread towards {} started. myId: {}\", sid, QuorumCnxManager.this.mySid);\n<line3>    while (running && !shutdown && sock != null) {\n<line4>        /**\n<line5>         * Reads the first int to determine the length of the\n<line6>         * message\n<line7>         */\n<line8>        int length = din.readInt();\n<line9>        if (length <= 0 || length > PACKETMAXSIZE) {\n<line10>            throw new IOException(\"Received packet with invalid packet: \" + length);\n<line11>        }\n<line12>        /**\n<line13>         * Allocates a new ByteBuffer to receive the message\n<line14>         */\n<line15>        final byte[] msgArray = new byte[length];\n<line16>        din.readFully(msgArray, 0, length);\n<line17>        addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!finished) {\n<line4>            ServerMetrics.getMetrics().LEARNER_REQUEST_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n<line5>            Request request = queuedRequests.take();\n<line6>                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, \"\");\n<line7>            }\n<line8>            if (request == Request.requestOfDeath) {\n<line9>                break;\n<line10>            }\n<line11>            // Screen quorum requests against ACLs first\n<line12>            if (!zks.authWriteRequest(request)) {\n<line13>                continue;\n<line14>            }\n<line15>            // We want to queue the request to be processed before we submit\n<line16>            // the request to the leader so that we are ready to receive\n<line17>            // the response\n<line18>            nextProcessor.processRequest(request);\n<line19>            if (request.isThrottled()) {\n<line20>                continue;\n<line21>            }\n<line22>            // We now ship the request to the leader. As with all\n<line23>            // other quorum operations, sync also follows this code\n<line24>            // path, but different from others, we need to keep track\n<line25>            // of the sync operations this Observer has pending, so we\n<line26>            // add it to pendingSyncs.\n<line27>            switch(request.type) {\n<line28>                case OpCode.sync:\n<line29>                    zks.pendingSyncs.add(request);\n<line30>                    zks.getObserver().request(request);\n<line31>                    break;\n<line32>                case OpCode.create:\n<line33>                case OpCode.create2:\n<line34>                case OpCode.createTTL:\n<line35>                case OpCode.createContainer:\n<line36>                case OpCode.delete:\n<line37>                case OpCode.deleteContainer:\n<line38>                case OpCode.setData:\n<line39>                case OpCode.reconfig:\n<line40>                case OpCode.setACL:\n<line41>                case OpCode.multi:\n<line42>                case OpCode.check:\n<line43>                    zks.getObserver().request(request);\n<line44>                    break;\n<line45>                case OpCode.createSession:\n<line46>                case OpCode.closeSession:\n<line47>                    // Don't forward local sessions to the leader.\n<line48>                    if (!request.isLocalSession()) {\n<line49>                        zks.getObserver().request(request);\n<line50>                    }\n<line51>                    break;\n<line52>            }\n<line53>        }\n<line54>    } catch (RuntimeException e) {\n<line55>        // spotbugs require explicit catch of RuntimeException\n<line56>        handleException(this.getName(), e);\n<line57>    } catch (Exception e) {\n<line58>        handleException(this.getName(), e);\n<line59>    }\n<line60>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!finished) {\n<line4>            ServerMetrics.getMetrics().LEARNER_REQUEST_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n<line5>            Request request = queuedRequests.take();\n<line6>            if (LOG.isTraceEnabled()) {\n<line7>                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, \"\");\n<line8>            }\n<line9>            if (request == Request.requestOfDeath) {\n<line10>                break;\n<line11>            }\n<line12>            // Screen quorum requests against ACLs first\n<line13>            if (!zks.authWriteRequest(request)) {\n<line14>                continue;\n<line15>            }\n<line16>            // We want to queue the request to be processed before we submit\n<line17>            // the request to the leader so that we are ready to receive\n<line18>            // the response\n<line19>            nextProcessor.processRequest(request);\n<line20>            if (request.isThrottled()) {\n<line21>                continue;\n<line22>            }\n<line23>            // We now ship the request to the leader. As with all\n<line24>            // other quorum operations, sync also follows this code\n<line25>            // path, but different from others, we need to keep track\n<line26>            // of the sync operations this Observer has pending, so we\n<line27>            // add it to pendingSyncs.\n<line28>            switch(request.type) {\n<line29>                case OpCode.sync:\n<line30>                    zks.pendingSyncs.add(request);\n<line31>                    zks.getObserver().request(request);\n<line32>                    break;\n<line33>                case OpCode.create:\n<line34>                case OpCode.create2:\n<line35>                case OpCode.createTTL:\n<line36>                case OpCode.createContainer:\n<line37>                case OpCode.delete:\n<line38>                case OpCode.deleteContainer:\n<line39>                case OpCode.setData:\n<line40>                case OpCode.reconfig:\n<line41>                case OpCode.setACL:\n<line42>                case OpCode.multi:\n<line43>                case OpCode.check:\n<line44>                    zks.getObserver().request(request);\n<line45>                    break;\n<line46>                case OpCode.createSession:\n<line47>                case OpCode.closeSession:\n<line48>                    // Don't forward local sessions to the leader.\n<line49>                    if (!request.isLocalSession()) {\n<line50>                        zks.getObserver().request(request);\n<line51>                    }\n<line52>                    break;\n<line53>            }\n<line54>        }\n<line55>    } catch (RuntimeException e) {\n<line56>        // spotbugs require explicit catch of RuntimeException\n<line57>        handleException(this.getName(), e);\n<line58>    } catch (Exception e) {\n<line59>        handleException(this.getName(), e);\n<line60>    }\n<line61>    LOG.info(\"ObserverRequestProcessor exited loop!\");\n<line62>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!finished) {\n<line3>        Request upgradeRequest = null;\n<line4>        try {\n<line5>            upgradeRequest = zks.checkUpgradeSession(request);\n<line6>        } catch (KeeperException ke) {\n<line7>            if (request.getHdr() != null) {\n<line8>                request.getHdr().setType(OpCode.error);\n<line9>                request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line10>            }\n<line11>            request.setException(ke);\n<line12>        } catch (IOException ie) {\n<line13>        }\n<line14>        if (upgradeRequest != null) {\n<line15>            queuedRequests.add(upgradeRequest);\n<line16>        }\n<line17>        queuedRequests.add(request);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    if (!finished) {\n<line3>        Request upgradeRequest = null;\n<line4>        try {\n<line5>            upgradeRequest = zks.checkUpgradeSession(request);\n<line6>        } catch (KeeperException ke) {\n<line7>            if (request.getHdr() != null) {\n<line8>                request.getHdr().setType(OpCode.error);\n<line9>                request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line10>            }\n<line11>            request.setException(ke);\n<line12>            LOG.info(\"Error creating upgrade request\", ke);\n<line13>        } catch (IOException ie) {\n<line14>            LOG.error(\"Unexpected error in upgrade\", ie);\n<line15>        }\n<line16>        if (upgradeRequest != null) {\n<line17>            queuedRequests.add(upgradeRequest);\n<line18>        }\n<line19>        queuedRequests.add(request);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    Request upgradeRequest = null;\n<line3>    try {\n<line4>        upgradeRequest = zks.checkUpgradeSession(request);\n<line5>    } catch (KeeperException ke) {\n<line6>        if (request.getHdr() != null) {\n<line7>            request.getHdr().setType(OpCode.error);\n<line8>            request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line9>        }\n<line10>        request.setException(ke);\n<line11>    } catch (IOException ie) {\n<line12>    }\n<line13>    if (upgradeRequest != null) {\n<line14>        queuedRequests.add(upgradeRequest);\n<line15>    }\n<line16>    queuedRequests.add(request);\n<line17>}","output":"<line1>{\n<line2>    Request upgradeRequest = null;\n<line3>    try {\n<line4>        upgradeRequest = zks.checkUpgradeSession(request);\n<line5>    } catch (KeeperException ke) {\n<line6>        if (request.getHdr() != null) {\n<line7>            request.getHdr().setType(OpCode.error);\n<line8>            request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line9>        }\n<line10>        request.setException(ke);\n<line11>        LOG.info(\"Error creating upgrade request\", ke);\n<line12>    } catch (IOException ie) {\n<line13>        LOG.error(\"Unexpected error in upgrade\", ie);\n<line14>    }\n<line15>    if (upgradeRequest != null) {\n<line16>        queuedRequests.add(upgradeRequest);\n<line17>    }\n<line18>    queuedRequests.add(request);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.getHdr() != null) {\n<line3>        request.getHdr().setType(OpCode.error);\n<line4>        request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line5>    }\n<line6>    request.setException(ke);\n<line7>}","output":"<line1>{\n<line2>    if (request.getHdr() != null) {\n<line3>        request.getHdr().setType(OpCode.error);\n<line4>        request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line5>    }\n<line6>    request.setException(ke);\n<line7>    LOG.info(\"Error creating upgrade request\", ke);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected error in upgrade\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    finished = true;\n<line3>    queuedRequests.clear();\n<line4>    queuedRequests.add(Request.requestOfDeath);\n<line5>    nextProcessor.shutdown();\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    finished = true;\n<line4>    queuedRequests.clear();\n<line5>    queuedRequests.add(Request.requestOfDeath);\n<line6>    nextProcessor.shutdown();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    super(logFactory, self.tickTime, self.minSessionTimeout, self.maxSessionTimeout, self.clientPortListenBacklog, zkDb, self);\n<line3>}","output":"<line1>{\n<line2>    super(logFactory, self.tickTime, self.minSessionTimeout, self.maxSessionTimeout, self.clientPortListenBacklog, zkDb, self);\n<line3>    LOG.info(\"syncEnabled ={}\", syncRequestProcessorEnabled);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        return;\n<line4>    }\n<line5>    super.shutdown();\n<line6>    if (syncRequestProcessorEnabled && syncProcessor != null) {\n<line7>        syncProcessor.shutdown();\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line4>        return;\n<line5>    }\n<line6>    super.shutdown();\n<line7>    if (syncRequestProcessorEnabled && syncProcessor != null) {\n<line8>        syncProcessor.shutdown();\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    while (true) {\n<line3>        try {\n<line4>            QuorumPacket p = queuedPackets.poll();\n<line5>            if (p == null) {\n<line6>                learner.bufferedOutput.flush();\n<line7>                p = queuedPackets.take();\n<line8>            }\n<line9>            if (p == proposalOfDeath) {\n<line10>                // Packet of death!\n<line11>                break;\n<line12>            }\n<line13>            learner.messageTracker.trackSent(p.getType());\n<line14>            learner.leaderOs.writeRecord(p, \"packet\");\n<line15>        } catch (IOException e) {\n<line16>            handleException(this.getName(), e);\n<line17>            break;\n<line18>        } catch (InterruptedException e) {\n<line19>            handleException(this.getName(), e);\n<line20>            break;\n<line21>        }\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    while (true) {\n<line3>        try {\n<line4>            QuorumPacket p = queuedPackets.poll();\n<line5>            if (p == null) {\n<line6>                learner.bufferedOutput.flush();\n<line7>                p = queuedPackets.take();\n<line8>            }\n<line9>            if (p == proposalOfDeath) {\n<line10>                // Packet of death!\n<line11>                break;\n<line12>            }\n<line13>            learner.messageTracker.trackSent(p.getType());\n<line14>            learner.leaderOs.writeRecord(p, \"packet\");\n<line15>        } catch (IOException e) {\n<line16>            handleException(this.getName(), e);\n<line17>            break;\n<line18>        } catch (InterruptedException e) {\n<line19>            handleException(this.getName(), e);\n<line20>            break;\n<line21>        }\n<line22>    }\n<line23>    LOG.info(\"LearnerSender exited\");\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    queuedPackets.clear();\n<line3>    queuedPackets.add(proposalOfDeath);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down LearnerSender\");\n<line3>    queuedPackets.clear();\n<line4>    queuedPackets.add(proposalOfDeath);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    this.multiAddressEnabled = multiAddressEnabled;\n<line3>}","output":"<line1>{\n<line2>    this.multiAddressEnabled = multiAddressEnabled;\n<line3>    LOG.info(\"multiAddress.enabled set to {}\", multiAddressEnabled);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.multiAddressReachabilityCheckTimeoutMs = multiAddressReachabilityCheckTimeoutMs;\n<line3>}","output":"<line1>{\n<line2>    this.multiAddressReachabilityCheckTimeoutMs = multiAddressReachabilityCheckTimeoutMs;\n<line3>    LOG.info(\"multiAddress.reachabilityCheckTimeoutMs set to {}\", multiAddressReachabilityCheckTimeoutMs);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.multiAddressReachabilityCheckEnabled = multiAddressReachabilityCheckEnabled;\n<line3>}","output":"<line1>{\n<line2>    this.multiAddressReachabilityCheckEnabled = multiAddressReachabilityCheckEnabled;\n<line3>    LOG.info(\"multiAddress.reachabilityCheckEnabled set to {}\", multiAddressReachabilityCheckEnabled);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    LearnerType newType = null;\n<line3>    String[] serverClientParts = addressStr.split(\";\");\n<line4>    String[] serverAddresses = serverClientParts[0].split(\"\\\\|\");\n<line5>    if (serverClientParts.length == 2) {\n<line6>        String[] clientParts = ConfigUtils.getHostAndPort(serverClientParts[1]);\n<line7>        if (clientParts.length > 2) {\n<line8>            throw new ConfigException(addressStr + wrongFormat);\n<line9>        }\n<line10>        // is client_config a host:port or just a port\n<line11>        String clientHostName = (clientParts.length == 2) ? clientParts[0] : \"0.0.0.0\";\n<line12>        try {\n<line13>            clientAddr = new InetSocketAddress(clientHostName, Integer.parseInt(clientParts[clientParts.length - 1]));\n<line14>        } catch (NumberFormatException e) {\n<line15>            throw new ConfigException(\"Address unresolved: \" + hostname + \":\" + clientParts[clientParts.length - 1]);\n<line16>        }\n<line17>    }\n<line18>    boolean multiAddressEnabled = Boolean.parseBoolean(System.getProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, QuorumPeer.CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED));\n<line19>    if (!multiAddressEnabled && serverAddresses.length > 1) {\n<line20>        throw new ConfigException(\"Multiple address feature is disabled, but multiple addresses were specified for sid \" + this.id);\n<line21>    }\n<line22>    boolean canonicalize = Boolean.parseBoolean(System.getProperty(CONFIG_KEY_KERBEROS_CANONICALIZE_HOST_NAMES, CONFIG_DEFAULT_KERBEROS_CANONICALIZE_HOST_NAMES));\n<line23>    for (String serverAddress : serverAddresses) {\n<line24>        String[] serverParts = ConfigUtils.getHostAndPort(serverAddress);\n<line25>        if ((serverClientParts.length > 2) || (serverParts.length < 3) || (serverParts.length > 4)) {\n<line26>            throw new ConfigException(addressStr + wrongFormat);\n<line27>        }\n<line28>        String serverHostName = serverParts[0];\n<line29>        // server_config should be either host:port:port or host:port:port:type\n<line30>        InetSocketAddress tempAddress;\n<line31>        InetSocketAddress tempElectionAddress;\n<line32>        try {\n<line33>            tempAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[1]));\n<line34>            addr.addAddress(tempAddress);\n<line35>        } catch (NumberFormatException e) {\n<line36>            throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[1]);\n<line37>        }\n<line38>        try {\n<line39>            tempElectionAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[2]));\n<line40>            electionAddr.addAddress(tempElectionAddress);\n<line41>        } catch (NumberFormatException e) {\n<line42>            throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[2]);\n<line43>        }\n<line44>        if (tempAddress.getPort() == tempElectionAddress.getPort()) {\n<line45>            throw new ConfigException(\"Client and election port must be different! Please update the \" + \"configuration file on server.\" + this.id);\n<line46>        }\n<line47>        if (canonicalize) {\n<line48>            InetAddress ia = getInetAddress.apply(tempAddress);\n<line49>            if (ia == null) {\n<line50>                throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n<line51>            }\n<line52>            String canonicalHostName = ia.getCanonicalHostName();\n<line53>            if (!canonicalHostName.equals(serverHostName) && // Avoid using literal IP address when\n<line54>            // security check fails\n<line55>            !canonicalHostName.equals(ia.getHostAddress())) {\n<line56>                serverHostName = canonicalHostName;\n<line57>            }\n<line58>        }\n<line59>        if (serverParts.length == 4) {\n<line60>            LearnerType tempType = getType(serverParts[3]);\n<line61>            if (newType == null) {\n<line62>                newType = tempType;\n<line63>            }\n<line64>            if (newType != tempType) {\n<line65>                throw new ConfigException(\"Multiple addresses should have similar roles: \" + type + \" vs \" + tempType);\n<line66>            }\n<line67>        }\n<line68>        this.hostname = serverHostName;\n<line69>    }\n<line70>    if (newType != null) {\n<line71>        type = newType;\n<line72>    }\n<line73>    setMyAddrs();\n<line74>}","output":"<line1>{\n<line2>    LearnerType newType = null;\n<line3>    String[] serverClientParts = addressStr.split(\";\");\n<line4>    String[] serverAddresses = serverClientParts[0].split(\"\\\\|\");\n<line5>    if (serverClientParts.length == 2) {\n<line6>        String[] clientParts = ConfigUtils.getHostAndPort(serverClientParts[1]);\n<line7>        if (clientParts.length > 2) {\n<line8>            throw new ConfigException(addressStr + wrongFormat);\n<line9>        }\n<line10>        // is client_config a host:port or just a port\n<line11>        String clientHostName = (clientParts.length == 2) ? clientParts[0] : \"0.0.0.0\";\n<line12>        try {\n<line13>            clientAddr = new InetSocketAddress(clientHostName, Integer.parseInt(clientParts[clientParts.length - 1]));\n<line14>        } catch (NumberFormatException e) {\n<line15>            throw new ConfigException(\"Address unresolved: \" + hostname + \":\" + clientParts[clientParts.length - 1]);\n<line16>        }\n<line17>    }\n<line18>    boolean multiAddressEnabled = Boolean.parseBoolean(System.getProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, QuorumPeer.CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED));\n<line19>    if (!multiAddressEnabled && serverAddresses.length > 1) {\n<line20>        throw new ConfigException(\"Multiple address feature is disabled, but multiple addresses were specified for sid \" + this.id);\n<line21>    }\n<line22>    boolean canonicalize = Boolean.parseBoolean(System.getProperty(CONFIG_KEY_KERBEROS_CANONICALIZE_HOST_NAMES, CONFIG_DEFAULT_KERBEROS_CANONICALIZE_HOST_NAMES));\n<line23>    for (String serverAddress : serverAddresses) {\n<line24>        String[] serverParts = ConfigUtils.getHostAndPort(serverAddress);\n<line25>        if ((serverClientParts.length > 2) || (serverParts.length < 3) || (serverParts.length > 4)) {\n<line26>            throw new ConfigException(addressStr + wrongFormat);\n<line27>        }\n<line28>        String serverHostName = serverParts[0];\n<line29>        // server_config should be either host:port:port or host:port:port:type\n<line30>        InetSocketAddress tempAddress;\n<line31>        InetSocketAddress tempElectionAddress;\n<line32>        try {\n<line33>            tempAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[1]));\n<line34>            addr.addAddress(tempAddress);\n<line35>        } catch (NumberFormatException e) {\n<line36>            throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[1]);\n<line37>        }\n<line38>        try {\n<line39>            tempElectionAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[2]));\n<line40>            electionAddr.addAddress(tempElectionAddress);\n<line41>        } catch (NumberFormatException e) {\n<line42>            throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[2]);\n<line43>        }\n<line44>        if (tempAddress.getPort() == tempElectionAddress.getPort()) {\n<line45>            throw new ConfigException(\"Client and election port must be different! Please update the \" + \"configuration file on server.\" + this.id);\n<line46>        }\n<line47>        if (canonicalize) {\n<line48>            InetAddress ia = getInetAddress.apply(tempAddress);\n<line49>            if (ia == null) {\n<line50>                throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n<line51>            }\n<line52>            String canonicalHostName = ia.getCanonicalHostName();\n<line53>            if (!canonicalHostName.equals(serverHostName) && // Avoid using literal IP address when\n<line54>            // security check fails\n<line55>            !canonicalHostName.equals(ia.getHostAddress())) {\n<line56>                LOG.info(\"Host name for quorum server {} \" + \"canonicalized from {} to {}\", this.id, serverHostName, canonicalHostName);\n<line57>                serverHostName = canonicalHostName;\n<line58>            }\n<line59>        }\n<line60>        if (serverParts.length == 4) {\n<line61>            LearnerType tempType = getType(serverParts[3]);\n<line62>            if (newType == null) {\n<line63>                newType = tempType;\n<line64>            }\n<line65>            if (newType != tempType) {\n<line66>                throw new ConfigException(\"Multiple addresses should have similar roles: \" + type + \" vs \" + tempType);\n<line67>            }\n<line68>        }\n<line69>        this.hostname = serverHostName;\n<line70>    }\n<line71>    if (newType != null) {\n<line72>        type = newType;\n<line73>    }\n<line74>    setMyAddrs();\n<line75>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] serverParts = ConfigUtils.getHostAndPort(serverAddress);\n<line3>    if ((serverClientParts.length > 2) || (serverParts.length < 3) || (serverParts.length > 4)) {\n<line4>        throw new ConfigException(addressStr + wrongFormat);\n<line5>    }\n<line6>    String serverHostName = serverParts[0];\n<line7>    // server_config should be either host:port:port or host:port:port:type\n<line8>    InetSocketAddress tempAddress;\n<line9>    InetSocketAddress tempElectionAddress;\n<line10>    try {\n<line11>        tempAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[1]));\n<line12>        addr.addAddress(tempAddress);\n<line13>    } catch (NumberFormatException e) {\n<line14>        throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[1]);\n<line15>    }\n<line16>    try {\n<line17>        tempElectionAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[2]));\n<line18>        electionAddr.addAddress(tempElectionAddress);\n<line19>    } catch (NumberFormatException e) {\n<line20>        throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[2]);\n<line21>    }\n<line22>    if (tempAddress.getPort() == tempElectionAddress.getPort()) {\n<line23>        throw new ConfigException(\"Client and election port must be different! Please update the \" + \"configuration file on server.\" + this.id);\n<line24>    }\n<line25>    if (canonicalize) {\n<line26>        InetAddress ia = getInetAddress.apply(tempAddress);\n<line27>        if (ia == null) {\n<line28>            throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n<line29>        }\n<line30>        String canonicalHostName = ia.getCanonicalHostName();\n<line31>        if (!canonicalHostName.equals(serverHostName) && // Avoid using literal IP address when\n<line32>        // security check fails\n<line33>        !canonicalHostName.equals(ia.getHostAddress())) {\n<line34>            serverHostName = canonicalHostName;\n<line35>        }\n<line36>    }\n<line37>    if (serverParts.length == 4) {\n<line38>        LearnerType tempType = getType(serverParts[3]);\n<line39>        if (newType == null) {\n<line40>            newType = tempType;\n<line41>        }\n<line42>        if (newType != tempType) {\n<line43>            throw new ConfigException(\"Multiple addresses should have similar roles: \" + type + \" vs \" + tempType);\n<line44>        }\n<line45>    }\n<line46>    this.hostname = serverHostName;\n<line47>}","output":"<line1>{\n<line2>    String[] serverParts = ConfigUtils.getHostAndPort(serverAddress);\n<line3>    if ((serverClientParts.length > 2) || (serverParts.length < 3) || (serverParts.length > 4)) {\n<line4>        throw new ConfigException(addressStr + wrongFormat);\n<line5>    }\n<line6>    String serverHostName = serverParts[0];\n<line7>    // server_config should be either host:port:port or host:port:port:type\n<line8>    InetSocketAddress tempAddress;\n<line9>    InetSocketAddress tempElectionAddress;\n<line10>    try {\n<line11>        tempAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[1]));\n<line12>        addr.addAddress(tempAddress);\n<line13>    } catch (NumberFormatException e) {\n<line14>        throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[1]);\n<line15>    }\n<line16>    try {\n<line17>        tempElectionAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[2]));\n<line18>        electionAddr.addAddress(tempElectionAddress);\n<line19>    } catch (NumberFormatException e) {\n<line20>        throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[2]);\n<line21>    }\n<line22>    if (tempAddress.getPort() == tempElectionAddress.getPort()) {\n<line23>        throw new ConfigException(\"Client and election port must be different! Please update the \" + \"configuration file on server.\" + this.id);\n<line24>    }\n<line25>    if (canonicalize) {\n<line26>        InetAddress ia = getInetAddress.apply(tempAddress);\n<line27>        if (ia == null) {\n<line28>            throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n<line29>        }\n<line30>        String canonicalHostName = ia.getCanonicalHostName();\n<line31>        if (!canonicalHostName.equals(serverHostName) && // Avoid using literal IP address when\n<line32>        // security check fails\n<line33>        !canonicalHostName.equals(ia.getHostAddress())) {\n<line34>            LOG.info(\"Host name for quorum server {} \" + \"canonicalized from {} to {}\", this.id, serverHostName, canonicalHostName);\n<line35>            serverHostName = canonicalHostName;\n<line36>        }\n<line37>    }\n<line38>    if (serverParts.length == 4) {\n<line39>        LearnerType tempType = getType(serverParts[3]);\n<line40>        if (newType == null) {\n<line41>            newType = tempType;\n<line42>        }\n<line43>        if (newType != tempType) {\n<line44>            throw new ConfigException(\"Multiple addresses should have similar roles: \" + type + \" vs \" + tempType);\n<line45>        }\n<line46>    }\n<line47>    this.hostname = serverHostName;\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>    InetAddress ia = getInetAddress.apply(tempAddress);\n<line3>    if (ia == null) {\n<line4>        throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n<line5>    }\n<line6>    String canonicalHostName = ia.getCanonicalHostName();\n<line7>    if (!canonicalHostName.equals(serverHostName) && // Avoid using literal IP address when\n<line8>    // security check fails\n<line9>    !canonicalHostName.equals(ia.getHostAddress())) {\n<line10>        serverHostName = canonicalHostName;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    InetAddress ia = getInetAddress.apply(tempAddress);\n<line3>    if (ia == null) {\n<line4>        throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n<line5>    }\n<line6>    String canonicalHostName = ia.getCanonicalHostName();\n<line7>    if (!canonicalHostName.equals(serverHostName) && // Avoid using literal IP address when\n<line8>    // security check fails\n<line9>    !canonicalHostName.equals(ia.getHostAddress())) {\n<line10>        LOG.info(\"Host name for quorum server {} \" + \"canonicalized from {} to {}\", this.id, serverHostName, canonicalHostName);\n<line11>        serverHostName = canonicalHostName;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    serverHostName = canonicalHostName;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Host name for quorum server {} \" + \"canonicalized from {} to {}\", this.id, serverHostName, canonicalHostName);\n<line3>    serverHostName = canonicalHostName;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumCnxnTimeoutMs = Integer.getInteger(QUORUM_CNXN_TIMEOUT_MS, -1);\n<line3>}","output":"<line1>{\n<line2>    quorumCnxnTimeoutMs = Integer.getInteger(QUORUM_CNXN_TIMEOUT_MS, -1);\n<line3>    LOG.info(\"{}={}\", QUORUM_CNXN_TIMEOUT_MS, quorumCnxnTimeoutMs);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    state = newState;\n<line3>    if (newState == ServerState.LOOKING) {\n<line4>        setLeaderAddressAndId(null, -1);\n<line5>        setZabState(ZabState.ELECTION);\n<line6>    } else {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    state = newState;\n<line3>    if (newState == ServerState.LOOKING) {\n<line4>        setLeaderAddressAndId(null, -1);\n<line5>        setZabState(ZabState.ELECTION);\n<line6>    } else {\n<line7>        LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if ((zabState == ZabState.BROADCAST) && (unavailableStartTime != 0)) {\n<line3>        long unavailableTime = Time.currentElapsedTime() - unavailableStartTime;\n<line4>        ServerMetrics.getMetrics().UNAVAILABLE_TIME.add(unavailableTime);\n<line5>        if (getPeerState() == ServerState.LEADING) {\n<line6>            ServerMetrics.getMetrics().LEADER_UNAVAILABLE_TIME.add(unavailableTime);\n<line7>        }\n<line8>        unavailableStartTime = 0;\n<line9>    }\n<line10>    this.zabState.set(zabState);\n<line11>}","output":"<line1>{\n<line2>    if ((zabState == ZabState.BROADCAST) && (unavailableStartTime != 0)) {\n<line3>        long unavailableTime = Time.currentElapsedTime() - unavailableStartTime;\n<line4>        ServerMetrics.getMetrics().UNAVAILABLE_TIME.add(unavailableTime);\n<line5>        if (getPeerState() == ServerState.LEADING) {\n<line6>            ServerMetrics.getMetrics().LEADER_UNAVAILABLE_TIME.add(unavailableTime);\n<line7>        }\n<line8>        unavailableStartTime = 0;\n<line9>    }\n<line10>    this.zabState.set(zabState);\n<line11>    LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    this.syncMode.set(syncMode);\n<line3>}","output":"<line1>{\n<line2>    this.syncMode.set(syncMode);\n<line3>    LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zkDb.loadDataBase();\n<line4>        // load the epochs\n<line5>        long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n<line6>        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n<line7>        try {\n<line8>            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n<line9>        } catch (FileNotFoundException e) {\n<line10>            // pick a reasonable epoch number\n<line11>            // this should only happen once when moving to a\n<line12>            // new code version\n<line13>            currentEpoch = epochOfZxid;\n<line14>            writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n<line15>        }\n<line16>        if (epochOfZxid > currentEpoch) {\n<line17>            // acceptedEpoch.tmp file in snapshot directory\n<line18>            File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n<line19>            if (currentTmp.exists()) {\n<line20>                long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line21>                setCurrentEpoch(epochOfTmp);\n<line22>            } else {\n<line23>                throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n<line24>            }\n<line25>        }\n<line26>        try {\n<line27>            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n<line28>        } catch (FileNotFoundException e) {\n<line29>            // pick a reasonable epoch number\n<line30>            // this should only happen once when moving to a\n<line31>            // new code version\n<line32>            acceptedEpoch = epochOfZxid;\n<line33>            writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line34>        }\n<line35>        if (acceptedEpoch < currentEpoch) {\n<line36>            throw new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch));\n<line37>        }\n<line38>    } catch (IOException ie) {\n<line39>        throw new RuntimeException(\"Unable to run quorum server \", ie);\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    try {\n<line3>        zkDb.loadDataBase();\n<line4>        // load the epochs\n<line5>        long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n<line6>        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n<line7>        try {\n<line8>            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n<line9>        } catch (FileNotFoundException e) {\n<line10>            // pick a reasonable epoch number\n<line11>            // this should only happen once when moving to a\n<line12>            // new code version\n<line13>            currentEpoch = epochOfZxid;\n<line14>            LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", CURRENT_EPOCH_FILENAME, currentEpoch);\n<line15>            writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n<line16>        }\n<line17>        if (epochOfZxid > currentEpoch) {\n<line18>            // acceptedEpoch.tmp file in snapshot directory\n<line19>            File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n<line20>            if (currentTmp.exists()) {\n<line21>                long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line22>                LOG.info(\"{} found. Setting current epoch to {}.\", currentTmp, epochOfTmp);\n<line23>                setCurrentEpoch(epochOfTmp);\n<line24>            } else {\n<line25>                throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n<line26>            }\n<line27>        }\n<line28>        try {\n<line29>            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n<line30>        } catch (FileNotFoundException e) {\n<line31>            // pick a reasonable epoch number\n<line32>            // this should only happen once when moving to a\n<line33>            // new code version\n<line34>            acceptedEpoch = epochOfZxid;\n<line35>            LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line36>            writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line37>        }\n<line38>        if (acceptedEpoch < currentEpoch) {\n<line39>            throw new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch));\n<line40>        }\n<line41>    } catch (IOException ie) {\n<line42>        LOG.error(\"Unable to load database on disk\", ie);\n<line43>        throw new RuntimeException(\"Unable to run quorum server \", ie);\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    zkDb.loadDataBase();\n<line3>    // load the epochs\n<line4>    long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n<line5>    long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n<line6>    try {\n<line7>        currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n<line8>    } catch (FileNotFoundException e) {\n<line9>        // pick a reasonable epoch number\n<line10>        // this should only happen once when moving to a\n<line11>        // new code version\n<line12>        currentEpoch = epochOfZxid;\n<line13>        writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n<line14>    }\n<line15>    if (epochOfZxid > currentEpoch) {\n<line16>        // acceptedEpoch.tmp file in snapshot directory\n<line17>        File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n<line18>        if (currentTmp.exists()) {\n<line19>            long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line20>            setCurrentEpoch(epochOfTmp);\n<line21>        } else {\n<line22>            throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n<line23>        }\n<line24>    }\n<line25>    try {\n<line26>        acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n<line27>    } catch (FileNotFoundException e) {\n<line28>        // pick a reasonable epoch number\n<line29>        // this should only happen once when moving to a\n<line30>        // new code version\n<line31>        acceptedEpoch = epochOfZxid;\n<line32>        writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line33>    }\n<line34>    if (acceptedEpoch < currentEpoch) {\n<line35>        throw new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch));\n<line36>    }\n<line37>}","output":"<line1>{\n<line2>    zkDb.loadDataBase();\n<line3>    // load the epochs\n<line4>    long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n<line5>    long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n<line6>    try {\n<line7>        currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n<line8>    } catch (FileNotFoundException e) {\n<line9>        // pick a reasonable epoch number\n<line10>        // this should only happen once when moving to a\n<line11>        // new code version\n<line12>        currentEpoch = epochOfZxid;\n<line13>        LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", CURRENT_EPOCH_FILENAME, currentEpoch);\n<line14>        writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n<line15>    }\n<line16>    if (epochOfZxid > currentEpoch) {\n<line17>        // acceptedEpoch.tmp file in snapshot directory\n<line18>        File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n<line19>        if (currentTmp.exists()) {\n<line20>            long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line21>            LOG.info(\"{} found. Setting current epoch to {}.\", currentTmp, epochOfTmp);\n<line22>            setCurrentEpoch(epochOfTmp);\n<line23>        } else {\n<line24>            throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n<line25>        }\n<line26>    }\n<line27>    try {\n<line28>        acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n<line29>    } catch (FileNotFoundException e) {\n<line30>        // pick a reasonable epoch number\n<line31>        // this should only happen once when moving to a\n<line32>        // new code version\n<line33>        acceptedEpoch = epochOfZxid;\n<line34>        LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line35>        writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line36>    }\n<line37>    if (acceptedEpoch < currentEpoch) {\n<line38>        throw new IOException(\"The accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch) + \" is less than the current epoch, \" + ZxidUtils.zxidToString(currentEpoch));\n<line39>    }\n<line40>}"},{"input":"","instruction":"<line1>{\n<line2>    // pick a reasonable epoch number\n<line3>    // this should only happen once when moving to a\n<line4>    // new code version\n<line5>    currentEpoch = epochOfZxid;\n<line6>    writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n<line7>}","output":"<line1>{\n<line2>    // pick a reasonable epoch number\n<line3>    // this should only happen once when moving to a\n<line4>    // new code version\n<line5>    currentEpoch = epochOfZxid;\n<line6>    LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", CURRENT_EPOCH_FILENAME, currentEpoch);\n<line7>    writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    // acceptedEpoch.tmp file in snapshot directory\n<line3>    File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n<line4>    if (currentTmp.exists()) {\n<line5>        long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line6>        setCurrentEpoch(epochOfTmp);\n<line7>    } else {\n<line8>        throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    // acceptedEpoch.tmp file in snapshot directory\n<line3>    File currentTmp = new File(getTxnFactory().getSnapDir(), CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);\n<line4>    if (currentTmp.exists()) {\n<line5>        long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line6>        LOG.info(\"{} found. Setting current epoch to {}.\", currentTmp, epochOfTmp);\n<line7>        setCurrentEpoch(epochOfTmp);\n<line8>    } else {\n<line9>        throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line3>    setCurrentEpoch(epochOfTmp);\n<line4>}","output":"<line1>{\n<line2>    long epochOfTmp = readLongFromFile(currentTmp.getName());\n<line3>    LOG.info(\"{} found. Setting current epoch to {}.\", currentTmp, epochOfTmp);\n<line4>    setCurrentEpoch(epochOfTmp);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // pick a reasonable epoch number\n<line3>    // this should only happen once when moving to a\n<line4>    // new code version\n<line5>    acceptedEpoch = epochOfZxid;\n<line6>    writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line7>}","output":"<line1>{\n<line2>    // pick a reasonable epoch number\n<line3>    // this should only happen once when moving to a\n<line4>    // new code version\n<line5>    acceptedEpoch = epochOfZxid;\n<line6>    LOG.info(\"{} not found! Creating with a reasonable default of {}. \" + \"This should only happen when you are upgrading your installation\", ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line7>    writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new RuntimeException(\"Unable to run quorum server \", ie);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to load database on disk\", ie);\n<line3>    throw new RuntimeException(\"Unable to run quorum server \", ie);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    Election le = null;\n<line3>    //TODO: use a factory rather than a switch\n<line4>    switch(electionAlgorithm) {\n<line5>        case 1:\n<line6>            throw new UnsupportedOperationException(\"Election Algorithm 1 is not supported.\");\n<line7>        case 2:\n<line8>            throw new UnsupportedOperationException(\"Election Algorithm 2 is not supported.\");\n<line9>        case 3:\n<line10>            QuorumCnxManager qcm = createCnxnManager();\n<line11>            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);\n<line12>            if (oldQcm != null) {\n<line13>                oldQcm.halt();\n<line14>            }\n<line15>            QuorumCnxManager.Listener listener = qcm.listener;\n<line16>            if (listener != null) {\n<line17>                listener.start();\n<line18>                FastLeaderElection fle = new FastLeaderElection(this, qcm);\n<line19>                fle.start();\n<line20>                le = fle;\n<line21>            } else {\n<line22>            }\n<line23>            break;\n<line24>        default:\n<line25>            assert false;\n<line26>    }\n<line27>    return le;\n<line28>}","output":"<line1>{\n<line2>    Election le = null;\n<line3>    //TODO: use a factory rather than a switch\n<line4>    switch(electionAlgorithm) {\n<line5>        case 1:\n<line6>            throw new UnsupportedOperationException(\"Election Algorithm 1 is not supported.\");\n<line7>        case 2:\n<line8>            throw new UnsupportedOperationException(\"Election Algorithm 2 is not supported.\");\n<line9>        case 3:\n<line10>            QuorumCnxManager qcm = createCnxnManager();\n<line11>            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);\n<line12>            if (oldQcm != null) {\n<line13>                LOG.warn(\"Clobbering already-set QuorumCnxManager (restarting leader election?)\");\n<line14>                oldQcm.halt();\n<line15>            }\n<line16>            QuorumCnxManager.Listener listener = qcm.listener;\n<line17>            if (listener != null) {\n<line18>                listener.start();\n<line19>                FastLeaderElection fle = new FastLeaderElection(this, qcm);\n<line20>                fle.start();\n<line21>                le = fle;\n<line22>            } else {\n<line23>                LOG.error(\"Null listener when initializing cnx manager\");\n<line24>            }\n<line25>            break;\n<line26>        default:\n<line27>            assert false;\n<line28>    }\n<line29>    return le;\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null listener when initializing cnx manager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    return electionAlg;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Initializing leader election protocol...\");\n<line3>    return electionAlg;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    updateThreadName();\n<line3>    try {\n<line4>        jmxQuorumBean = new QuorumBean(this);\n<line5>        MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n<line6>        for (QuorumServer s : getView().values()) {\n<line7>            ZKMBeanInfo p;\n<line8>            if (getMyId() == s.id) {\n<line9>                p = jmxLocalPeerBean = new LocalPeerBean(this);\n<line10>                try {\n<line11>                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n<line12>                } catch (Exception e) {\n<line13>                    jmxLocalPeerBean = null;\n<line14>                }\n<line15>            } else {\n<line16>                RemotePeerBean rBean = new RemotePeerBean(this, s);\n<line17>                try {\n<line18>                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n<line19>                    jmxRemotePeerBean.put(s.id, rBean);\n<line20>                } catch (Exception e) {\n<line21>                }\n<line22>            }\n<line23>        }\n<line24>    } catch (Exception e) {\n<line25>        jmxQuorumBean = null;\n<line26>    }\n<line27>    try {\n<line28>        /*\n<line29>             * Main loop\n<line30>             */\n<line31>        while (running) {\n<line32>            if (unavailableStartTime == 0) {\n<line33>                unavailableStartTime = Time.currentElapsedTime();\n<line34>            }\n<line35>            switch(getPeerState()) {\n<line36>                case LOOKING:\n<line37>                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n<line38>                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n<line39>                        // Create read-only server but don't start it immediately\n<line40>                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line41>                        // Instead of starting roZk immediately, wait some grace\n<line42>                        // period before we decide we're partitioned.\n<line43>                        //\n<line44>                        // Thread is used here because otherwise it would require\n<line45>                        // changes in each of election strategy classes which is\n<line46>                        // unnecessary code coupling.\n<line47>                        Thread roZkMgr = new Thread() {\n<line48>\n<line49>                            public void run() {\n<line50>                                try {\n<line51>                                    // lower-bound grace period to 2 secs\n<line52>                                    sleep(Math.max(2000, tickTime));\n<line53>                                    if (ServerState.LOOKING.equals(getPeerState())) {\n<line54>                                        roZk.startup();\n<line55>                                    }\n<line56>                                } catch (InterruptedException e) {\n<line57>                                } catch (Exception e) {\n<line58>                                }\n<line59>                            }\n<line60>                        };\n<line61>                        try {\n<line62>                            roZkMgr.start();\n<line63>                            reconfigFlagClear();\n<line64>                            if (shuttingDownLE) {\n<line65>                                shuttingDownLE = false;\n<line66>                                startLeaderElection();\n<line67>                            }\n<line68>                            setCurrentVote(makeLEStrategy().lookForLeader());\n<line69>                            checkSuspended();\n<line70>                        } catch (Exception e) {\n<line71>                            setPeerState(ServerState.LOOKING);\n<line72>                        } finally {\n<line73>                            // If the thread is in the the grace period, interrupt\n<line74>                            // to come out of waiting.\n<line75>                            roZkMgr.interrupt();\n<line76>                            roZk.shutdown();\n<line77>                        }\n<line78>                    } else {\n<line79>                        try {\n<line80>                            reconfigFlagClear();\n<line81>                            if (shuttingDownLE) {\n<line82>                                shuttingDownLE = false;\n<line83>                                startLeaderElection();\n<line84>                            }\n<line85>                            setCurrentVote(makeLEStrategy().lookForLeader());\n<line86>                        } catch (Exception e) {\n<line87>                            setPeerState(ServerState.LOOKING);\n<line88>                        }\n<line89>                    }\n<line90>                    break;\n<line91>                case OBSERVING:\n<line92>                    try {\n<line93>                        setObserver(makeObserver(logFactory));\n<line94>                        observer.observeLeader();\n<line95>                    } catch (Exception e) {\n<line96>                    } finally {\n<line97>                        observer.shutdown();\n<line98>                        setObserver(null);\n<line99>                        updateServerState();\n<line100>                        // Add delay jitter before we switch to LOOKING\n<line101>                        // state to reduce the load of ObserverMaster\n<line102>                        if (isRunning()) {\n<line103>                            Observer.waitForObserverElectionDelay();\n<line104>                        }\n<line105>                    }\n<line106>                    break;\n<line107>                case FOLLOWING:\n<line108>                    try {\n<line109>                        setFollower(makeFollower(logFactory));\n<line110>                        follower.followLeader();\n<line111>                    } catch (Exception e) {\n<line112>                    } finally {\n<line113>                        follower.shutdown();\n<line114>                        setFollower(null);\n<line115>                        updateServerState();\n<line116>                    }\n<line117>                    break;\n<line118>                case LEADING:\n<line119>                    try {\n<line120>                        setLeader(makeLeader(logFactory));\n<line121>                        leader.lead();\n<line122>                        setLeader(null);\n<line123>                    } catch (Exception e) {\n<line124>                    } finally {\n<line125>                        if (leader != null) {\n<line126>                            leader.shutdown(\"Forcing shutdown\");\n<line127>                            setLeader(null);\n<line128>                        }\n<line129>                        updateServerState();\n<line130>                    }\n<line131>                    break;\n<line132>            }\n<line133>        }\n<line134>    } finally {\n<line135>        MBeanRegistry instance = MBeanRegistry.getInstance();\n<line136>        instance.unregister(jmxQuorumBean);\n<line137>        instance.unregister(jmxLocalPeerBean);\n<line138>        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n<line139>            instance.unregister(remotePeerBean);\n<line140>        }\n<line141>        jmxQuorumBean = null;\n<line142>        jmxLocalPeerBean = null;\n<line143>        jmxRemotePeerBean = null;\n<line144>    }\n<line145>}","output":"<line1>{\n<line2>    updateThreadName();\n<line3>    LOG.debug(\"Starting quorum peer\");\n<line4>    try {\n<line5>        jmxQuorumBean = new QuorumBean(this);\n<line6>        MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n<line7>        for (QuorumServer s : getView().values()) {\n<line8>            ZKMBeanInfo p;\n<line9>            if (getMyId() == s.id) {\n<line10>                p = jmxLocalPeerBean = new LocalPeerBean(this);\n<line11>                try {\n<line12>                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n<line13>                } catch (Exception e) {\n<line14>                    LOG.warn(\"Failed to register with JMX\", e);\n<line15>                    jmxLocalPeerBean = null;\n<line16>                }\n<line17>            } else {\n<line18>                RemotePeerBean rBean = new RemotePeerBean(this, s);\n<line19>                try {\n<line20>                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n<line21>                    jmxRemotePeerBean.put(s.id, rBean);\n<line22>                } catch (Exception e) {\n<line23>                    LOG.warn(\"Failed to register with JMX\", e);\n<line24>                }\n<line25>            }\n<line26>        }\n<line27>    } catch (Exception e) {\n<line28>        LOG.warn(\"Failed to register with JMX\", e);\n<line29>        jmxQuorumBean = null;\n<line30>    }\n<line31>    try {\n<line32>        /*\n<line33>             * Main loop\n<line34>             */\n<line35>        while (running) {\n<line36>            if (unavailableStartTime == 0) {\n<line37>                unavailableStartTime = Time.currentElapsedTime();\n<line38>            }\n<line39>            switch(getPeerState()) {\n<line40>                case LOOKING:\n<line41>                    LOG.info(\"LOOKING\");\n<line42>                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n<line43>                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n<line44>                        LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n<line45>                        // Create read-only server but don't start it immediately\n<line46>                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line47>                        // Instead of starting roZk immediately, wait some grace\n<line48>                        // period before we decide we're partitioned.\n<line49>                        //\n<line50>                        // Thread is used here because otherwise it would require\n<line51>                        // changes in each of election strategy classes which is\n<line52>                        // unnecessary code coupling.\n<line53>                        Thread roZkMgr = new Thread() {\n<line54>\n<line55>                            public void run() {\n<line56>                                try {\n<line57>                                    // lower-bound grace period to 2 secs\n<line58>                                    sleep(Math.max(2000, tickTime));\n<line59>                                    if (ServerState.LOOKING.equals(getPeerState())) {\n<line60>                                        roZk.startup();\n<line61>                                    }\n<line62>                                } catch (InterruptedException e) {\n<line63>                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n<line64>                                } catch (Exception e) {\n<line65>                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n<line66>                                }\n<line67>                            }\n<line68>                        };\n<line69>                        try {\n<line70>                            roZkMgr.start();\n<line71>                            reconfigFlagClear();\n<line72>                            if (shuttingDownLE) {\n<line73>                                shuttingDownLE = false;\n<line74>                                startLeaderElection();\n<line75>                            }\n<line76>                            setCurrentVote(makeLEStrategy().lookForLeader());\n<line77>                            checkSuspended();\n<line78>                        } catch (Exception e) {\n<line79>                            LOG.warn(\"Unexpected exception\", e);\n<line80>                            setPeerState(ServerState.LOOKING);\n<line81>                        } finally {\n<line82>                            // If the thread is in the the grace period, interrupt\n<line83>                            // to come out of waiting.\n<line84>                            roZkMgr.interrupt();\n<line85>                            roZk.shutdown();\n<line86>                        }\n<line87>                    } else {\n<line88>                        try {\n<line89>                            reconfigFlagClear();\n<line90>                            if (shuttingDownLE) {\n<line91>                                shuttingDownLE = false;\n<line92>                                startLeaderElection();\n<line93>                            }\n<line94>                            setCurrentVote(makeLEStrategy().lookForLeader());\n<line95>                        } catch (Exception e) {\n<line96>                            LOG.warn(\"Unexpected exception\", e);\n<line97>                            setPeerState(ServerState.LOOKING);\n<line98>                        }\n<line99>                    }\n<line100>                    break;\n<line101>                case OBSERVING:\n<line102>                    try {\n<line103>                        LOG.info(\"OBSERVING\");\n<line104>                        setObserver(makeObserver(logFactory));\n<line105>                        observer.observeLeader();\n<line106>                    } catch (Exception e) {\n<line107>                        LOG.warn(\"Unexpected exception\", e);\n<line108>                    } finally {\n<line109>                        observer.shutdown();\n<line110>                        setObserver(null);\n<line111>                        updateServerState();\n<line112>                        // Add delay jitter before we switch to LOOKING\n<line113>                        // state to reduce the load of ObserverMaster\n<line114>                        if (isRunning()) {\n<line115>                            Observer.waitForObserverElectionDelay();\n<line116>                        }\n<line117>                    }\n<line118>                    break;\n<line119>                case FOLLOWING:\n<line120>                    try {\n<line121>                        LOG.info(\"FOLLOWING\");\n<line122>                        setFollower(makeFollower(logFactory));\n<line123>                        follower.followLeader();\n<line124>                    } catch (Exception e) {\n<line125>                        LOG.warn(\"Unexpected exception\", e);\n<line126>                    } finally {\n<line127>                        follower.shutdown();\n<line128>                        setFollower(null);\n<line129>                        updateServerState();\n<line130>                    }\n<line131>                    break;\n<line132>                case LEADING:\n<line133>                    LOG.info(\"LEADING\");\n<line134>                    try {\n<line135>                        setLeader(makeLeader(logFactory));\n<line136>                        leader.lead();\n<line137>                        setLeader(null);\n<line138>                    } catch (Exception e) {\n<line139>                        LOG.warn(\"Unexpected exception\", e);\n<line140>                    } finally {\n<line141>                        if (leader != null) {\n<line142>                            leader.shutdown(\"Forcing shutdown\");\n<line143>                            setLeader(null);\n<line144>                        }\n<line145>                        updateServerState();\n<line146>                    }\n<line147>                    break;\n<line148>            }\n<line149>        }\n<line150>    } finally {\n<line151>        LOG.warn(\"QuorumPeer main thread exited\");\n<line152>        MBeanRegistry instance = MBeanRegistry.getInstance();\n<line153>        instance.unregister(jmxQuorumBean);\n<line154>        instance.unregister(jmxLocalPeerBean);\n<line155>        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n<line156>            instance.unregister(remotePeerBean);\n<line157>        }\n<line158>        jmxQuorumBean = null;\n<line159>        jmxLocalPeerBean = null;\n<line160>        jmxRemotePeerBean = null;\n<line161>    }\n<line162>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>             * Main loop\n<line4>             */\n<line5>    while (running) {\n<line6>        if (unavailableStartTime == 0) {\n<line7>            unavailableStartTime = Time.currentElapsedTime();\n<line8>        }\n<line9>        switch(getPeerState()) {\n<line10>            case LOOKING:\n<line11>                ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n<line12>                if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n<line13>                    // Create read-only server but don't start it immediately\n<line14>                    final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line15>                    // Instead of starting roZk immediately, wait some grace\n<line16>                    // period before we decide we're partitioned.\n<line17>                    //\n<line18>                    // Thread is used here because otherwise it would require\n<line19>                    // changes in each of election strategy classes which is\n<line20>                    // unnecessary code coupling.\n<line21>                    Thread roZkMgr = new Thread() {\n<line22>\n<line23>                        public void run() {\n<line24>                            try {\n<line25>                                // lower-bound grace period to 2 secs\n<line26>                                sleep(Math.max(2000, tickTime));\n<line27>                                if (ServerState.LOOKING.equals(getPeerState())) {\n<line28>                                    roZk.startup();\n<line29>                                }\n<line30>                            } catch (InterruptedException e) {\n<line31>                            } catch (Exception e) {\n<line32>                            }\n<line33>                        }\n<line34>                    };\n<line35>                    try {\n<line36>                        roZkMgr.start();\n<line37>                        reconfigFlagClear();\n<line38>                        if (shuttingDownLE) {\n<line39>                            shuttingDownLE = false;\n<line40>                            startLeaderElection();\n<line41>                        }\n<line42>                        setCurrentVote(makeLEStrategy().lookForLeader());\n<line43>                        checkSuspended();\n<line44>                    } catch (Exception e) {\n<line45>                        setPeerState(ServerState.LOOKING);\n<line46>                    } finally {\n<line47>                        // If the thread is in the the grace period, interrupt\n<line48>                        // to come out of waiting.\n<line49>                        roZkMgr.interrupt();\n<line50>                        roZk.shutdown();\n<line51>                    }\n<line52>                } else {\n<line53>                    try {\n<line54>                        reconfigFlagClear();\n<line55>                        if (shuttingDownLE) {\n<line56>                            shuttingDownLE = false;\n<line57>                            startLeaderElection();\n<line58>                        }\n<line59>                        setCurrentVote(makeLEStrategy().lookForLeader());\n<line60>                    } catch (Exception e) {\n<line61>                        setPeerState(ServerState.LOOKING);\n<line62>                    }\n<line63>                }\n<line64>                break;\n<line65>            case OBSERVING:\n<line66>                try {\n<line67>                    setObserver(makeObserver(logFactory));\n<line68>                    observer.observeLeader();\n<line69>                } catch (Exception e) {\n<line70>                } finally {\n<line71>                    observer.shutdown();\n<line72>                    setObserver(null);\n<line73>                    updateServerState();\n<line74>                    // Add delay jitter before we switch to LOOKING\n<line75>                    // state to reduce the load of ObserverMaster\n<line76>                    if (isRunning()) {\n<line77>                        Observer.waitForObserverElectionDelay();\n<line78>                    }\n<line79>                }\n<line80>                break;\n<line81>            case FOLLOWING:\n<line82>                try {\n<line83>                    setFollower(makeFollower(logFactory));\n<line84>                    follower.followLeader();\n<line85>                } catch (Exception e) {\n<line86>                } finally {\n<line87>                    follower.shutdown();\n<line88>                    setFollower(null);\n<line89>                    updateServerState();\n<line90>                }\n<line91>                break;\n<line92>            case LEADING:\n<line93>                try {\n<line94>                    setLeader(makeLeader(logFactory));\n<line95>                    leader.lead();\n<line96>                    setLeader(null);\n<line97>                } catch (Exception e) {\n<line98>                } finally {\n<line99>                    if (leader != null) {\n<line100>                        leader.shutdown(\"Forcing shutdown\");\n<line101>                        setLeader(null);\n<line102>                    }\n<line103>                    updateServerState();\n<line104>                }\n<line105>                break;\n<line106>        }\n<line107>    }\n<line108>}","output":"<line1>{\n<line2>    /*\n<line3>             * Main loop\n<line4>             */\n<line5>    while (running) {\n<line6>        if (unavailableStartTime == 0) {\n<line7>            unavailableStartTime = Time.currentElapsedTime();\n<line8>        }\n<line9>        switch(getPeerState()) {\n<line10>            case LOOKING:\n<line11>                LOG.info(\"LOOKING\");\n<line12>                ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n<line13>                if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n<line14>                    LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n<line15>                    // Create read-only server but don't start it immediately\n<line16>                    final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line17>                    // Instead of starting roZk immediately, wait some grace\n<line18>                    // period before we decide we're partitioned.\n<line19>                    //\n<line20>                    // Thread is used here because otherwise it would require\n<line21>                    // changes in each of election strategy classes which is\n<line22>                    // unnecessary code coupling.\n<line23>                    Thread roZkMgr = new Thread() {\n<line24>\n<line25>                        public void run() {\n<line26>                            try {\n<line27>                                // lower-bound grace period to 2 secs\n<line28>                                sleep(Math.max(2000, tickTime));\n<line29>                                if (ServerState.LOOKING.equals(getPeerState())) {\n<line30>                                    roZk.startup();\n<line31>                                }\n<line32>                            } catch (InterruptedException e) {\n<line33>                                LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n<line34>                            } catch (Exception e) {\n<line35>                                LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n<line36>                            }\n<line37>                        }\n<line38>                    };\n<line39>                    try {\n<line40>                        roZkMgr.start();\n<line41>                        reconfigFlagClear();\n<line42>                        if (shuttingDownLE) {\n<line43>                            shuttingDownLE = false;\n<line44>                            startLeaderElection();\n<line45>                        }\n<line46>                        setCurrentVote(makeLEStrategy().lookForLeader());\n<line47>                        checkSuspended();\n<line48>                    } catch (Exception e) {\n<line49>                        LOG.warn(\"Unexpected exception\", e);\n<line50>                        setPeerState(ServerState.LOOKING);\n<line51>                    } finally {\n<line52>                        // If the thread is in the the grace period, interrupt\n<line53>                        // to come out of waiting.\n<line54>                        roZkMgr.interrupt();\n<line55>                        roZk.shutdown();\n<line56>                    }\n<line57>                } else {\n<line58>                    try {\n<line59>                        reconfigFlagClear();\n<line60>                        if (shuttingDownLE) {\n<line61>                            shuttingDownLE = false;\n<line62>                            startLeaderElection();\n<line63>                        }\n<line64>                        setCurrentVote(makeLEStrategy().lookForLeader());\n<line65>                    } catch (Exception e) {\n<line66>                        LOG.warn(\"Unexpected exception\", e);\n<line67>                        setPeerState(ServerState.LOOKING);\n<line68>                    }\n<line69>                }\n<line70>                break;\n<line71>            case OBSERVING:\n<line72>                try {\n<line73>                    LOG.info(\"OBSERVING\");\n<line74>                    setObserver(makeObserver(logFactory));\n<line75>                    observer.observeLeader();\n<line76>                } catch (Exception e) {\n<line77>                    LOG.warn(\"Unexpected exception\", e);\n<line78>                } finally {\n<line79>                    observer.shutdown();\n<line80>                    setObserver(null);\n<line81>                    updateServerState();\n<line82>                    // Add delay jitter before we switch to LOOKING\n<line83>                    // state to reduce the load of ObserverMaster\n<line84>                    if (isRunning()) {\n<line85>                        Observer.waitForObserverElectionDelay();\n<line86>                    }\n<line87>                }\n<line88>                break;\n<line89>            case FOLLOWING:\n<line90>                try {\n<line91>                    LOG.info(\"FOLLOWING\");\n<line92>                    setFollower(makeFollower(logFactory));\n<line93>                    follower.followLeader();\n<line94>                } catch (Exception e) {\n<line95>                    LOG.warn(\"Unexpected exception\", e);\n<line96>                } finally {\n<line97>                    follower.shutdown();\n<line98>                    setFollower(null);\n<line99>                    updateServerState();\n<line100>                }\n<line101>                break;\n<line102>            case LEADING:\n<line103>                LOG.info(\"LEADING\");\n<line104>                try {\n<line105>                    setLeader(makeLeader(logFactory));\n<line106>                    leader.lead();\n<line107>                    setLeader(null);\n<line108>                } catch (Exception e) {\n<line109>                    LOG.warn(\"Unexpected exception\", e);\n<line110>                } finally {\n<line111>                    if (leader != null) {\n<line112>                        leader.shutdown(\"Forcing shutdown\");\n<line113>                        setLeader(null);\n<line114>                    }\n<line115>                    updateServerState();\n<line116>                }\n<line117>                break;\n<line118>        }\n<line119>    }\n<line120>}"},{"input":"","instruction":"<line1>{\n<line2>    if (unavailableStartTime == 0) {\n<line3>        unavailableStartTime = Time.currentElapsedTime();\n<line4>    }\n<line5>    switch(getPeerState()) {\n<line6>        case LOOKING:\n<line7>            ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n<line8>            if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n<line9>                // Create read-only server but don't start it immediately\n<line10>                final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line11>                // Instead of starting roZk immediately, wait some grace\n<line12>                // period before we decide we're partitioned.\n<line13>                //\n<line14>                // Thread is used here because otherwise it would require\n<line15>                // changes in each of election strategy classes which is\n<line16>                // unnecessary code coupling.\n<line17>                Thread roZkMgr = new Thread() {\n<line18>\n<line19>                    public void run() {\n<line20>                        try {\n<line21>                            // lower-bound grace period to 2 secs\n<line22>                            sleep(Math.max(2000, tickTime));\n<line23>                            if (ServerState.LOOKING.equals(getPeerState())) {\n<line24>                                roZk.startup();\n<line25>                            }\n<line26>                        } catch (InterruptedException e) {\n<line27>                        } catch (Exception e) {\n<line28>                        }\n<line29>                    }\n<line30>                };\n<line31>                try {\n<line32>                    roZkMgr.start();\n<line33>                    reconfigFlagClear();\n<line34>                    if (shuttingDownLE) {\n<line35>                        shuttingDownLE = false;\n<line36>                        startLeaderElection();\n<line37>                    }\n<line38>                    setCurrentVote(makeLEStrategy().lookForLeader());\n<line39>                    checkSuspended();\n<line40>                } catch (Exception e) {\n<line41>                    setPeerState(ServerState.LOOKING);\n<line42>                } finally {\n<line43>                    // If the thread is in the the grace period, interrupt\n<line44>                    // to come out of waiting.\n<line45>                    roZkMgr.interrupt();\n<line46>                    roZk.shutdown();\n<line47>                }\n<line48>            } else {\n<line49>                try {\n<line50>                    reconfigFlagClear();\n<line51>                    if (shuttingDownLE) {\n<line52>                        shuttingDownLE = false;\n<line53>                        startLeaderElection();\n<line54>                    }\n<line55>                    setCurrentVote(makeLEStrategy().lookForLeader());\n<line56>                } catch (Exception e) {\n<line57>                    setPeerState(ServerState.LOOKING);\n<line58>                }\n<line59>            }\n<line60>            break;\n<line61>        case OBSERVING:\n<line62>            try {\n<line63>                setObserver(makeObserver(logFactory));\n<line64>                observer.observeLeader();\n<line65>            } catch (Exception e) {\n<line66>            } finally {\n<line67>                observer.shutdown();\n<line68>                setObserver(null);\n<line69>                updateServerState();\n<line70>                // Add delay jitter before we switch to LOOKING\n<line71>                // state to reduce the load of ObserverMaster\n<line72>                if (isRunning()) {\n<line73>                    Observer.waitForObserverElectionDelay();\n<line74>                }\n<line75>            }\n<line76>            break;\n<line77>        case FOLLOWING:\n<line78>            try {\n<line79>                setFollower(makeFollower(logFactory));\n<line80>                follower.followLeader();\n<line81>            } catch (Exception e) {\n<line82>            } finally {\n<line83>                follower.shutdown();\n<line84>                setFollower(null);\n<line85>                updateServerState();\n<line86>            }\n<line87>            break;\n<line88>        case LEADING:\n<line89>            try {\n<line90>                setLeader(makeLeader(logFactory));\n<line91>                leader.lead();\n<line92>                setLeader(null);\n<line93>            } catch (Exception e) {\n<line94>            } finally {\n<line95>                if (leader != null) {\n<line96>                    leader.shutdown(\"Forcing shutdown\");\n<line97>                    setLeader(null);\n<line98>                }\n<line99>                updateServerState();\n<line100>            }\n<line101>            break;\n<line102>    }\n<line103>}","output":"<line1>{\n<line2>    if (unavailableStartTime == 0) {\n<line3>        unavailableStartTime = Time.currentElapsedTime();\n<line4>    }\n<line5>    switch(getPeerState()) {\n<line6>        case LOOKING:\n<line7>            LOG.info(\"LOOKING\");\n<line8>            ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n<line9>            if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n<line10>                LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n<line11>                // Create read-only server but don't start it immediately\n<line12>                final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line13>                // Instead of starting roZk immediately, wait some grace\n<line14>                // period before we decide we're partitioned.\n<line15>                //\n<line16>                // Thread is used here because otherwise it would require\n<line17>                // changes in each of election strategy classes which is\n<line18>                // unnecessary code coupling.\n<line19>                Thread roZkMgr = new Thread() {\n<line20>\n<line21>                    public void run() {\n<line22>                        try {\n<line23>                            // lower-bound grace period to 2 secs\n<line24>                            sleep(Math.max(2000, tickTime));\n<line25>                            if (ServerState.LOOKING.equals(getPeerState())) {\n<line26>                                roZk.startup();\n<line27>                            }\n<line28>                        } catch (InterruptedException e) {\n<line29>                            LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n<line30>                        } catch (Exception e) {\n<line31>                            LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n<line32>                        }\n<line33>                    }\n<line34>                };\n<line35>                try {\n<line36>                    roZkMgr.start();\n<line37>                    reconfigFlagClear();\n<line38>                    if (shuttingDownLE) {\n<line39>                        shuttingDownLE = false;\n<line40>                        startLeaderElection();\n<line41>                    }\n<line42>                    setCurrentVote(makeLEStrategy().lookForLeader());\n<line43>                    checkSuspended();\n<line44>                } catch (Exception e) {\n<line45>                    LOG.warn(\"Unexpected exception\", e);\n<line46>                    setPeerState(ServerState.LOOKING);\n<line47>                } finally {\n<line48>                    // If the thread is in the the grace period, interrupt\n<line49>                    // to come out of waiting.\n<line50>                    roZkMgr.interrupt();\n<line51>                    roZk.shutdown();\n<line52>                }\n<line53>            } else {\n<line54>                try {\n<line55>                    reconfigFlagClear();\n<line56>                    if (shuttingDownLE) {\n<line57>                        shuttingDownLE = false;\n<line58>                        startLeaderElection();\n<line59>                    }\n<line60>                    setCurrentVote(makeLEStrategy().lookForLeader());\n<line61>                } catch (Exception e) {\n<line62>                    LOG.warn(\"Unexpected exception\", e);\n<line63>                    setPeerState(ServerState.LOOKING);\n<line64>                }\n<line65>            }\n<line66>            break;\n<line67>        case OBSERVING:\n<line68>            try {\n<line69>                LOG.info(\"OBSERVING\");\n<line70>                setObserver(makeObserver(logFactory));\n<line71>                observer.observeLeader();\n<line72>            } catch (Exception e) {\n<line73>                LOG.warn(\"Unexpected exception\", e);\n<line74>            } finally {\n<line75>                observer.shutdown();\n<line76>                setObserver(null);\n<line77>                updateServerState();\n<line78>                // Add delay jitter before we switch to LOOKING\n<line79>                // state to reduce the load of ObserverMaster\n<line80>                if (isRunning()) {\n<line81>                    Observer.waitForObserverElectionDelay();\n<line82>                }\n<line83>            }\n<line84>            break;\n<line85>        case FOLLOWING:\n<line86>            try {\n<line87>                LOG.info(\"FOLLOWING\");\n<line88>                setFollower(makeFollower(logFactory));\n<line89>                follower.followLeader();\n<line90>            } catch (Exception e) {\n<line91>                LOG.warn(\"Unexpected exception\", e);\n<line92>            } finally {\n<line93>                follower.shutdown();\n<line94>                setFollower(null);\n<line95>                updateServerState();\n<line96>            }\n<line97>            break;\n<line98>        case LEADING:\n<line99>            LOG.info(\"LEADING\");\n<line100>            try {\n<line101>                setLeader(makeLeader(logFactory));\n<line102>                leader.lead();\n<line103>                setLeader(null);\n<line104>            } catch (Exception e) {\n<line105>                LOG.warn(\"Unexpected exception\", e);\n<line106>            } finally {\n<line107>                if (leader != null) {\n<line108>                    leader.shutdown(\"Forcing shutdown\");\n<line109>                    setLeader(null);\n<line110>                }\n<line111>                updateServerState();\n<line112>            }\n<line113>            break;\n<line114>    }\n<line115>}"},{"input":"","instruction":"<line1>{\n<line2>    // Create read-only server but don't start it immediately\n<line3>    final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line4>    // Instead of starting roZk immediately, wait some grace\n<line5>    // period before we decide we're partitioned.\n<line6>    //\n<line7>    // Thread is used here because otherwise it would require\n<line8>    // changes in each of election strategy classes which is\n<line9>    // unnecessary code coupling.\n<line10>    Thread roZkMgr = new Thread() {\n<line11>\n<line12>        public void run() {\n<line13>            try {\n<line14>                // lower-bound grace period to 2 secs\n<line15>                sleep(Math.max(2000, tickTime));\n<line16>                if (ServerState.LOOKING.equals(getPeerState())) {\n<line17>                    roZk.startup();\n<line18>                }\n<line19>            } catch (InterruptedException e) {\n<line20>            } catch (Exception e) {\n<line21>            }\n<line22>        }\n<line23>    };\n<line24>    try {\n<line25>        roZkMgr.start();\n<line26>        reconfigFlagClear();\n<line27>        if (shuttingDownLE) {\n<line28>            shuttingDownLE = false;\n<line29>            startLeaderElection();\n<line30>        }\n<line31>        setCurrentVote(makeLEStrategy().lookForLeader());\n<line32>        checkSuspended();\n<line33>    } catch (Exception e) {\n<line34>        setPeerState(ServerState.LOOKING);\n<line35>    } finally {\n<line36>        // If the thread is in the the grace period, interrupt\n<line37>        // to come out of waiting.\n<line38>        roZkMgr.interrupt();\n<line39>        roZk.shutdown();\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n<line3>    // Create read-only server but don't start it immediately\n<line4>    final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n<line5>    // Instead of starting roZk immediately, wait some grace\n<line6>    // period before we decide we're partitioned.\n<line7>    //\n<line8>    // Thread is used here because otherwise it would require\n<line9>    // changes in each of election strategy classes which is\n<line10>    // unnecessary code coupling.\n<line11>    Thread roZkMgr = new Thread() {\n<line12>\n<line13>        public void run() {\n<line14>            try {\n<line15>                // lower-bound grace period to 2 secs\n<line16>                sleep(Math.max(2000, tickTime));\n<line17>                if (ServerState.LOOKING.equals(getPeerState())) {\n<line18>                    roZk.startup();\n<line19>                }\n<line20>            } catch (InterruptedException e) {\n<line21>                LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n<line22>            } catch (Exception e) {\n<line23>                LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n<line24>            }\n<line25>        }\n<line26>    };\n<line27>    try {\n<line28>        roZkMgr.start();\n<line29>        reconfigFlagClear();\n<line30>        if (shuttingDownLE) {\n<line31>            shuttingDownLE = false;\n<line32>            startLeaderElection();\n<line33>        }\n<line34>        setCurrentVote(makeLEStrategy().lookForLeader());\n<line35>        checkSuspended();\n<line36>    } catch (Exception e) {\n<line37>        LOG.warn(\"Unexpected exception\", e);\n<line38>        setPeerState(ServerState.LOOKING);\n<line39>    } finally {\n<line40>        // If the thread is in the the grace period, interrupt\n<line41>        // to come out of waiting.\n<line42>        roZkMgr.interrupt();\n<line43>        roZk.shutdown();\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // lower-bound grace period to 2 secs\n<line4>        sleep(Math.max(2000, tickTime));\n<line5>        if (ServerState.LOOKING.equals(getPeerState())) {\n<line6>            roZk.startup();\n<line7>        }\n<line8>    } catch (InterruptedException e) {\n<line9>    } catch (Exception e) {\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    try {\n<line3>        // lower-bound grace period to 2 secs\n<line4>        sleep(Math.max(2000, tickTime));\n<line5>        if (ServerState.LOOKING.equals(getPeerState())) {\n<line6>            roZk.startup();\n<line7>        }\n<line8>    } catch (InterruptedException e) {\n<line9>        LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n<line10>    } catch (Exception e) {\n<line11>        LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    setObserver(makeObserver(logFactory));\n<line3>    observer.observeLeader();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"OBSERVING\");\n<line3>    setObserver(makeObserver(logFactory));\n<line4>    observer.observeLeader();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    setFollower(makeFollower(logFactory));\n<line3>    follower.followLeader();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"FOLLOWING\");\n<line3>    setFollower(makeFollower(logFactory));\n<line4>    follower.followLeader();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!reconfigFlag) {\n<line3>        setPeerState(ServerState.LOOKING);\n<line4>        return;\n<line5>    }\n<line6>    if (getMyId() == getCurrentVote().getId()) {\n<line7>        setPeerState(ServerState.LEADING);\n<line8>    } else if (getLearnerType() == LearnerType.PARTICIPANT) {\n<line9>        setPeerState(ServerState.FOLLOWING);\n<line10>    } else if (getLearnerType() == LearnerType.OBSERVER) {\n<line11>        setPeerState(ServerState.OBSERVING);\n<line12>    } else {\n<line13>        // currently shouldn't happen since there are only 2 learner types\n<line14>        setPeerState(ServerState.LOOKING);\n<line15>    }\n<line16>    reconfigFlag = false;\n<line17>}","output":"<line1>{\n<line2>    if (!reconfigFlag) {\n<line3>        setPeerState(ServerState.LOOKING);\n<line4>        LOG.warn(\"PeerState set to LOOKING\");\n<line5>        return;\n<line6>    }\n<line7>    if (getMyId() == getCurrentVote().getId()) {\n<line8>        setPeerState(ServerState.LEADING);\n<line9>        LOG.debug(\"PeerState set to LEADING\");\n<line10>    } else if (getLearnerType() == LearnerType.PARTICIPANT) {\n<line11>        setPeerState(ServerState.FOLLOWING);\n<line12>        LOG.debug(\"PeerState set to FOLLOWING\");\n<line13>    } else if (getLearnerType() == LearnerType.OBSERVER) {\n<line14>        setPeerState(ServerState.OBSERVING);\n<line15>        LOG.debug(\"PeerState set to OBSERVER\");\n<line16>    } else {\n<line17>        // currently shouldn't happen since there are only 2 learner types\n<line18>        setPeerState(ServerState.LOOKING);\n<line19>        LOG.debug(\"Should not be here\");\n<line20>    }\n<line21>    reconfigFlag = false;\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    setPeerState(ServerState.LEADING);\n<line3>}","output":"<line1>{\n<line2>    setPeerState(ServerState.LEADING);\n<line3>    LOG.debug(\"PeerState set to LEADING\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    setPeerState(ServerState.FOLLOWING);\n<line3>}","output":"<line1>{\n<line2>    setPeerState(ServerState.FOLLOWING);\n<line3>    LOG.debug(\"PeerState set to FOLLOWING\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    setPeerState(ServerState.OBSERVING);\n<line3>}","output":"<line1>{\n<line2>    setPeerState(ServerState.OBSERVING);\n<line3>    LOG.debug(\"PeerState set to OBSERVER\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // currently shouldn't happen since there are only 2 learner types\n<line3>    setPeerState(ServerState.LOOKING);\n<line4>}","output":"<line1>{\n<line2>    // currently shouldn't happen since there are only 2 learner types\n<line3>    setPeerState(ServerState.LOOKING);\n<line4>    LOG.debug(\"Should not be here\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    this.tickTime = tickTime;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"tickTime set to {}\", tickTime);\n<line3>    this.tickTime = tickTime;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    localSessionsEnabled = flag;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Local sessions {}\", (flag ? \"enabled\" : \"disabled\"));\n<line3>    localSessionsEnabled = flag;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    localSessionsUpgradingEnabled = flag;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Local session upgrading {}\", (flag ? \"enabled\" : \"disabled\"));\n<line3>    localSessionsUpgradingEnabled = flag;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.minSessionTimeout = min;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"minSessionTimeout set to {}\", min);\n<line3>    this.minSessionTimeout = min;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.maxSessionTimeout = max;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"maxSessionTimeout set to {}\", max);\n<line3>    this.maxSessionTimeout = max;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.initLimit = initLimit;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"initLimit set to {}\", initLimit);\n<line3>    this.initLimit = initLimit;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!isReconfigEnabled()) {\n<line3>        return;\n<line4>    }\n<line5>    // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm\n<line6>    // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't\n<line7>    // deadlock against other callers of connectOne().  If qcmRef gets set in another\n<line8>    // thread while we're inside the synchronized block, that does no harm; if we didn't\n<line9>    // take a lock on qcm (because it was null when we sampled it), we won't call\n<line10>    // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility\n<line11>    // of updates that provably happen in another thread before entering this method.)\n<line12>    QuorumCnxManager qcm = qcmRef.get();\n<line13>    Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;\n<line14>    synchronized (outerLockObject) {\n<line15>        synchronized (QV_LOCK) {\n<line16>            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n<line17>            }\n<line18>            // assuming that a version uniquely identifies a configuration, so if\n<line19>            // version is the same, nothing to do here.\n<line20>            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n<line21>                return;\n<line22>            }\n<line23>            lastSeenQuorumVerifier = qv;\n<line24>            if (qcm != null) {\n<line25>                connectNewPeers(qcm);\n<line26>            }\n<line27>            if (writeToDisk) {\n<line28>                try {\n<line29>                    String fileName = getNextDynamicConfigFilename();\n<line30>                    if (fileName != null) {\n<line31>                        QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line32>                    }\n<line33>                } catch (IOException e) {\n<line34>                }\n<line35>            }\n<line36>        }\n<line37>    }\n<line38>}","output":"<line1>{\n<line2>    if (!isReconfigEnabled()) {\n<line3>        LOG.info(\"Dynamic reconfig is disabled, we don't store the last seen config.\");\n<line4>        return;\n<line5>    }\n<line6>    // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm\n<line7>    // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't\n<line8>    // deadlock against other callers of connectOne().  If qcmRef gets set in another\n<line9>    // thread while we're inside the synchronized block, that does no harm; if we didn't\n<line10>    // take a lock on qcm (because it was null when we sampled it), we won't call\n<line11>    // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility\n<line12>    // of updates that provably happen in another thread before entering this method.)\n<line13>    QuorumCnxManager qcm = qcmRef.get();\n<line14>    Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;\n<line15>    synchronized (outerLockObject) {\n<line16>        synchronized (QV_LOCK) {\n<line17>            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n<line18>                LOG.error(\"setLastSeenQuorumVerifier called with stale config \" + qv.getVersion() + \". Current version: \" + quorumVerifier.getVersion());\n<line19>            }\n<line20>            // assuming that a version uniquely identifies a configuration, so if\n<line21>            // version is the same, nothing to do here.\n<line22>            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n<line23>                return;\n<line24>            }\n<line25>            lastSeenQuorumVerifier = qv;\n<line26>            if (qcm != null) {\n<line27>                connectNewPeers(qcm);\n<line28>            }\n<line29>            if (writeToDisk) {\n<line30>                try {\n<line31>                    String fileName = getNextDynamicConfigFilename();\n<line32>                    if (fileName != null) {\n<line33>                        QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line34>                    }\n<line35>                } catch (IOException e) {\n<line36>                    LOG.error(\"Error writing next dynamic config file to disk\", e);\n<line37>                }\n<line38>            }\n<line39>        }\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Dynamic reconfig is disabled, we don't store the last seen config.\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (QV_LOCK) {\n<line3>        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n<line4>        }\n<line5>        // assuming that a version uniquely identifies a configuration, so if\n<line6>        // version is the same, nothing to do here.\n<line7>        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n<line8>            return;\n<line9>        }\n<line10>        lastSeenQuorumVerifier = qv;\n<line11>        if (qcm != null) {\n<line12>            connectNewPeers(qcm);\n<line13>        }\n<line14>        if (writeToDisk) {\n<line15>            try {\n<line16>                String fileName = getNextDynamicConfigFilename();\n<line17>                if (fileName != null) {\n<line18>                    QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line19>                }\n<line20>            } catch (IOException e) {\n<line21>            }\n<line22>        }\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    synchronized (QV_LOCK) {\n<line3>        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n<line4>            LOG.error(\"setLastSeenQuorumVerifier called with stale config \" + qv.getVersion() + \". Current version: \" + quorumVerifier.getVersion());\n<line5>        }\n<line6>        // assuming that a version uniquely identifies a configuration, so if\n<line7>        // version is the same, nothing to do here.\n<line8>        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n<line9>            return;\n<line10>        }\n<line11>        lastSeenQuorumVerifier = qv;\n<line12>        if (qcm != null) {\n<line13>            connectNewPeers(qcm);\n<line14>        }\n<line15>        if (writeToDisk) {\n<line16>            try {\n<line17>                String fileName = getNextDynamicConfigFilename();\n<line18>                if (fileName != null) {\n<line19>                    QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line20>                }\n<line21>            } catch (IOException e) {\n<line22>                LOG.error(\"Error writing next dynamic config file to disk\", e);\n<line23>            }\n<line24>        }\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n<line3>    }\n<line4>    // assuming that a version uniquely identifies a configuration, so if\n<line5>    // version is the same, nothing to do here.\n<line6>    if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n<line7>        return;\n<line8>    }\n<line9>    lastSeenQuorumVerifier = qv;\n<line10>    if (qcm != null) {\n<line11>        connectNewPeers(qcm);\n<line12>    }\n<line13>    if (writeToDisk) {\n<line14>        try {\n<line15>            String fileName = getNextDynamicConfigFilename();\n<line16>            if (fileName != null) {\n<line17>                QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line18>            }\n<line19>        } catch (IOException e) {\n<line20>        }\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n<line3>        LOG.error(\"setLastSeenQuorumVerifier called with stale config \" + qv.getVersion() + \". Current version: \" + quorumVerifier.getVersion());\n<line4>    }\n<line5>    // assuming that a version uniquely identifies a configuration, so if\n<line6>    // version is the same, nothing to do here.\n<line7>    if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n<line8>        return;\n<line9>    }\n<line10>    lastSeenQuorumVerifier = qv;\n<line11>    if (qcm != null) {\n<line12>        connectNewPeers(qcm);\n<line13>    }\n<line14>    if (writeToDisk) {\n<line15>        try {\n<line16>            String fileName = getNextDynamicConfigFilename();\n<line17>            if (fileName != null) {\n<line18>                QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line19>            }\n<line20>        } catch (IOException e) {\n<line21>            LOG.error(\"Error writing next dynamic config file to disk\", e);\n<line22>        }\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"setLastSeenQuorumVerifier called with stale config \" + qv.getVersion() + \". Current version: \" + quorumVerifier.getVersion());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String fileName = getNextDynamicConfigFilename();\n<line4>        if (fileName != null) {\n<line5>            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line6>        }\n<line7>    } catch (IOException e) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        String fileName = getNextDynamicConfigFilename();\n<line4>        if (fileName != null) {\n<line5>            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n<line6>        }\n<line7>    } catch (IOException e) {\n<line8>        LOG.error(\"Error writing next dynamic config file to disk\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error writing next dynamic config file to disk\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (QV_LOCK) {\n<line3>        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n<line4>            // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n<line5>            // and then got the same config in UPTODATE message so its already known\n<line6>            return quorumVerifier;\n<line7>        }\n<line8>        QuorumVerifier prevQV = quorumVerifier;\n<line9>        quorumVerifier = qv;\n<line10>        if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {\n<line11>            lastSeenQuorumVerifier = qv;\n<line12>        }\n<line13>        if (writeToDisk) {\n<line14>            // some tests initialize QuorumPeer without a static config file\n<line15>            if (configFilename != null) {\n<line16>                try {\n<line17>                    String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line18>                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line19>                    QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line20>                } catch (IOException e) {\n<line21>                }\n<line22>            } else {\n<line23>            }\n<line24>        }\n<line25>        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {\n<line26>            QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());\n<line27>        }\n<line28>        QuorumServer qs = qv.getAllMembers().get(getMyId());\n<line29>        if (qs != null) {\n<line30>            setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n<line31>        }\n<line32>        updateObserverMasterList();\n<line33>        return prevQV;\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    synchronized (QV_LOCK) {\n<line3>        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n<line4>            // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n<line5>            // and then got the same config in UPTODATE message so its already known\n<line6>            LOG.debug(\"{} setQuorumVerifier called with known or old config {}. Current version: {}\", getMyId(), qv.getVersion(), quorumVerifier.getVersion());\n<line7>            return quorumVerifier;\n<line8>        }\n<line9>        QuorumVerifier prevQV = quorumVerifier;\n<line10>        quorumVerifier = qv;\n<line11>        if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {\n<line12>            lastSeenQuorumVerifier = qv;\n<line13>        }\n<line14>        if (writeToDisk) {\n<line15>            // some tests initialize QuorumPeer without a static config file\n<line16>            if (configFilename != null) {\n<line17>                try {\n<line18>                    String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line19>                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line20>                    QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line21>                } catch (IOException e) {\n<line22>                    LOG.error(\"Error closing file\", e);\n<line23>                }\n<line24>            } else {\n<line25>                LOG.info(\"writeToDisk == true but configFilename == null\");\n<line26>            }\n<line27>        }\n<line28>        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {\n<line29>            QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());\n<line30>        }\n<line31>        QuorumServer qs = qv.getAllMembers().get(getMyId());\n<line32>        if (qs != null) {\n<line33>            setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n<line34>        }\n<line35>        updateObserverMasterList();\n<line36>        return prevQV;\n<line37>    }\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n<line3>        // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n<line4>        // and then got the same config in UPTODATE message so its already known\n<line5>        return quorumVerifier;\n<line6>    }\n<line7>    QuorumVerifier prevQV = quorumVerifier;\n<line8>    quorumVerifier = qv;\n<line9>    if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {\n<line10>        lastSeenQuorumVerifier = qv;\n<line11>    }\n<line12>    if (writeToDisk) {\n<line13>        // some tests initialize QuorumPeer without a static config file\n<line14>        if (configFilename != null) {\n<line15>            try {\n<line16>                String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line17>                QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line18>                QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line19>            } catch (IOException e) {\n<line20>            }\n<line21>        } else {\n<line22>        }\n<line23>    }\n<line24>    if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {\n<line25>        QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());\n<line26>    }\n<line27>    QuorumServer qs = qv.getAllMembers().get(getMyId());\n<line28>    if (qs != null) {\n<line29>        setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n<line30>    }\n<line31>    updateObserverMasterList();\n<line32>    return prevQV;\n<line33>}","output":"<line1>{\n<line2>    if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n<line3>        // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n<line4>        // and then got the same config in UPTODATE message so its already known\n<line5>        LOG.debug(\"{} setQuorumVerifier called with known or old config {}. Current version: {}\", getMyId(), qv.getVersion(), quorumVerifier.getVersion());\n<line6>        return quorumVerifier;\n<line7>    }\n<line8>    QuorumVerifier prevQV = quorumVerifier;\n<line9>    quorumVerifier = qv;\n<line10>    if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {\n<line11>        lastSeenQuorumVerifier = qv;\n<line12>    }\n<line13>    if (writeToDisk) {\n<line14>        // some tests initialize QuorumPeer without a static config file\n<line15>        if (configFilename != null) {\n<line16>            try {\n<line17>                String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line18>                QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line19>                QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line20>            } catch (IOException e) {\n<line21>                LOG.error(\"Error closing file\", e);\n<line22>            }\n<line23>        } else {\n<line24>            LOG.info(\"writeToDisk == true but configFilename == null\");\n<line25>        }\n<line26>    }\n<line27>    if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {\n<line28>        QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());\n<line29>    }\n<line30>    QuorumServer qs = qv.getAllMembers().get(getMyId());\n<line31>    if (qs != null) {\n<line32>        setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n<line33>    }\n<line34>    updateObserverMasterList();\n<line35>    return prevQV;\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n<line3>    // and then got the same config in UPTODATE message so its already known\n<line4>    return quorumVerifier;\n<line5>}","output":"<line1>{\n<line2>    // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n<line3>    // and then got the same config in UPTODATE message so its already known\n<line4>    LOG.debug(\"{} setQuorumVerifier called with known or old config {}. Current version: {}\", getMyId(), qv.getVersion(), quorumVerifier.getVersion());\n<line5>    return quorumVerifier;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    // some tests initialize QuorumPeer without a static config file\n<line3>    if (configFilename != null) {\n<line4>        try {\n<line5>            String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line6>            QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line7>            QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line8>        } catch (IOException e) {\n<line9>        }\n<line10>    } else {\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    // some tests initialize QuorumPeer without a static config file\n<line3>    if (configFilename != null) {\n<line4>        try {\n<line5>            String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line6>            QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line7>            QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line8>        } catch (IOException e) {\n<line9>            LOG.error(\"Error closing file\", e);\n<line10>        }\n<line11>    } else {\n<line12>        LOG.info(\"writeToDisk == true but configFilename == null\");\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line4>        QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line5>        QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line6>    } catch (IOException e) {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n<line4>        QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n<line5>        QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n<line6>    } catch (IOException e) {\n<line7>        LOG.error(\"Error closing file\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error closing file\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"writeToDisk == true but configFilename == null\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    this.syncLimit = syncLimit;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"syncLimit set to {}\", syncLimit);\n<line3>    this.syncLimit = syncLimit;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"connectToLearnerMasterLimit set to {}\", connectToLearnerMasterLimit);\n<line3>    this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (System.getProperty(SYNC_ENABLED) != null) {\n<line3>        return Boolean.getBoolean(SYNC_ENABLED);\n<line4>    } else {\n<line5>        return syncEnabled;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (System.getProperty(SYNC_ENABLED) != null) {\n<line3>        LOG.info(\"{}={}\", SYNC_ENABLED, Boolean.getBoolean(SYNC_ENABLED));\n<line4>        return Boolean.getBoolean(SYNC_ENABLED);\n<line5>    } else {\n<line6>        return syncEnabled;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return Boolean.getBoolean(SYNC_ENABLED);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"{}={}\", SYNC_ENABLED, Boolean.getBoolean(SYNC_ENABLED));\n<line3>    return Boolean.getBoolean(SYNC_ENABLED);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sslQuorum) {\n<line3>    } else {\n<line4>    }\n<line5>    this.sslQuorum = sslQuorum;\n<line6>}","output":"<line1>{\n<line2>    if (sslQuorum) {\n<line3>        LOG.info(\"Using TLS encrypted quorum communication\");\n<line4>    } else {\n<line5>        LOG.info(\"Using insecure (non-TLS) quorum communication\");\n<line6>    }\n<line7>    this.sslQuorum = sslQuorum;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Using TLS encrypted quorum communication\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Using insecure (non-TLS) quorum communication\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    this.shouldUsePortUnification = shouldUsePortUnification;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Port unification {}\", shouldUsePortUnification ? \"enabled\" : \"disabled\");\n<line3>    this.shouldUsePortUnification = shouldUsePortUnification;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!isReconfigEnabled()) {\n<line3>        return false;\n<line4>    }\n<line5>    InetSocketAddress oldClientAddr = getClientAddress();\n<line6>    // update last committed quorum verifier, write the new config to disk\n<line7>    // and restart leader election if config changed.\n<line8>    QuorumVerifier prevQV = setQuorumVerifier(qv, true);\n<line9>    // There is no log record for the initial config, thus after syncing\n<line10>    // with leader\n<line11>    // /zookeeper/config is empty! it is also possible that last committed\n<line12>    // config is propagated during leader election\n<line13>    // without the propagation the corresponding log records.\n<line14>    // so we should explicitly do this (this is not necessary when we're\n<line15>    // already a Follower/Observer, only\n<line16>    // for Learner):\n<line17>    initConfigInZKDatabase();\n<line18>    if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {\n<line19>        Map<Long, QuorumServer> newMembers = qv.getAllMembers();\n<line20>        updateRemotePeerMXBeans(newMembers);\n<line21>        if (restartLE) {\n<line22>            restartLeaderElection(prevQV, qv);\n<line23>        }\n<line24>        QuorumServer myNewQS = newMembers.get(getMyId());\n<line25>        if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {\n<line26>            cnxnFactory.reconfigure(myNewQS.clientAddr);\n<line27>            updateThreadName();\n<line28>        }\n<line29>        boolean roleChange = updateLearnerType(qv);\n<line30>        boolean leaderChange = false;\n<line31>        if (suggestedLeaderId != null) {\n<line32>            // zxid should be non-null too\n<line33>            leaderChange = updateVote(suggestedLeaderId, zxid);\n<line34>        } else {\n<line35>            long currentLeaderId = getCurrentVote().getId();\n<line36>            QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);\n<line37>            QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);\n<line38>            leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));\n<line39>            // we don't have a designated leader - need to go into leader\n<line40>            // election\n<line41>            reconfigFlagClear();\n<line42>        }\n<line43>        return roleChange || leaderChange;\n<line44>    }\n<line45>    return false;\n<line46>}","output":"<line1>{\n<line2>    if (!isReconfigEnabled()) {\n<line3>        LOG.debug(\"Reconfig feature is disabled, skip reconfig processing.\");\n<line4>        return false;\n<line5>    }\n<line6>    InetSocketAddress oldClientAddr = getClientAddress();\n<line7>    // update last committed quorum verifier, write the new config to disk\n<line8>    // and restart leader election if config changed.\n<line9>    QuorumVerifier prevQV = setQuorumVerifier(qv, true);\n<line10>    // There is no log record for the initial config, thus after syncing\n<line11>    // with leader\n<line12>    // /zookeeper/config is empty! it is also possible that last committed\n<line13>    // config is propagated during leader election\n<line14>    // without the propagation the corresponding log records.\n<line15>    // so we should explicitly do this (this is not necessary when we're\n<line16>    // already a Follower/Observer, only\n<line17>    // for Learner):\n<line18>    initConfigInZKDatabase();\n<line19>    if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {\n<line20>        Map<Long, QuorumServer> newMembers = qv.getAllMembers();\n<line21>        updateRemotePeerMXBeans(newMembers);\n<line22>        if (restartLE) {\n<line23>            restartLeaderElection(prevQV, qv);\n<line24>        }\n<line25>        QuorumServer myNewQS = newMembers.get(getMyId());\n<line26>        if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {\n<line27>            cnxnFactory.reconfigure(myNewQS.clientAddr);\n<line28>            updateThreadName();\n<line29>        }\n<line30>        boolean roleChange = updateLearnerType(qv);\n<line31>        boolean leaderChange = false;\n<line32>        if (suggestedLeaderId != null) {\n<line33>            // zxid should be non-null too\n<line34>            leaderChange = updateVote(suggestedLeaderId, zxid);\n<line35>        } else {\n<line36>            long currentLeaderId = getCurrentVote().getId();\n<line37>            QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);\n<line38>            QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);\n<line39>            leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));\n<line40>            // we don't have a designated leader - need to go into leader\n<line41>            // election\n<line42>            reconfigFlagClear();\n<line43>        }\n<line44>        return roleChange || leaderChange;\n<line45>    }\n<line46>    return false;\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Reconfig feature is disabled, skip reconfig processing.\");\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (observerMasterPort <= 0) {\n<line3>        // observer masters not enabled\n<line4>        return;\n<line5>    }\n<line6>    observerMasters.clear();\n<line7>    StringBuilder sb = new StringBuilder();\n<line8>    for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {\n<line9>        InetAddress address = server.addr.getReachableOrOne().getAddress();\n<line10>        InetSocketAddress addr = new InetSocketAddress(address, observerMasterPort);\n<line11>        observerMasters.add(new QuorumServer(server.id, addr));\n<line12>        sb.append(addr).append(\",\");\n<line13>    }\n<line14>    Collections.shuffle(observerMasters);\n<line15>    // Reset the internal index of the observerMaster when\n<line16>    // the observerMaster List is refreshed\n<line17>    nextObserverMaster = 0;\n<line18>}","output":"<line1>{\n<line2>    if (observerMasterPort <= 0) {\n<line3>        // observer masters not enabled\n<line4>        return;\n<line5>    }\n<line6>    observerMasters.clear();\n<line7>    StringBuilder sb = new StringBuilder();\n<line8>    for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {\n<line9>        InetAddress address = server.addr.getReachableOrOne().getAddress();\n<line10>        InetSocketAddress addr = new InetSocketAddress(address, observerMasterPort);\n<line11>        observerMasters.add(new QuorumServer(server.id, addr));\n<line12>        sb.append(addr).append(\",\");\n<line13>    }\n<line14>    LOG.info(\"Updated learner master list to be {}\", sb.toString());\n<line15>    Collections.shuffle(observerMasters);\n<line16>    // Reset the internal index of the observerMaster when\n<line17>    // the observerMaster List is refreshed\n<line18>    nextObserverMaster = 0;\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (useObserverMasters()) {\n<line3>        Long sid;\n<line4>        try {\n<line5>            sid = Long.parseLong(desiredMaster);\n<line6>        } catch (NumberFormatException e) {\n<line7>            sid = null;\n<line8>        }\n<line9>        for (QuorumServer server : observerMasters) {\n<line10>            if (sid == null) {\n<line11>                for (InetSocketAddress address : server.addr.getAllAddresses()) {\n<line12>                    String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();\n<line13>                    if (serverAddr.startsWith(desiredMaster)) {\n<line14>                        return server;\n<line15>                    }\n<line16>                }\n<line17>            } else {\n<line18>                if (sid.equals(server.id)) {\n<line19>                    return server;\n<line20>                }\n<line21>            }\n<line22>        }\n<line23>        if (sid == null) {\n<line24>        } else {\n<line25>        }\n<line26>    } else {\n<line27>    }\n<line28>    return null;\n<line29>}","output":"<line1>{\n<line2>    if (useObserverMasters()) {\n<line3>        Long sid;\n<line4>        try {\n<line5>            sid = Long.parseLong(desiredMaster);\n<line6>        } catch (NumberFormatException e) {\n<line7>            sid = null;\n<line8>        }\n<line9>        for (QuorumServer server : observerMasters) {\n<line10>            if (sid == null) {\n<line11>                for (InetSocketAddress address : server.addr.getAllAddresses()) {\n<line12>                    String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();\n<line13>                    if (serverAddr.startsWith(desiredMaster)) {\n<line14>                        return server;\n<line15>                    }\n<line16>                }\n<line17>            } else {\n<line18>                if (sid.equals(server.id)) {\n<line19>                    return server;\n<line20>                }\n<line21>            }\n<line22>        }\n<line23>        if (sid == null) {\n<line24>            LOG.info(\"could not find learner master address={}\", desiredMaster);\n<line25>        } else {\n<line26>            LOG.warn(\"could not find learner master sid={}\", sid);\n<line27>        }\n<line28>    } else {\n<line29>        LOG.info(\"cannot validate request, observer masters not enabled\");\n<line30>    }\n<line31>    return null;\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    Long sid;\n<line3>    try {\n<line4>        sid = Long.parseLong(desiredMaster);\n<line5>    } catch (NumberFormatException e) {\n<line6>        sid = null;\n<line7>    }\n<line8>    for (QuorumServer server : observerMasters) {\n<line9>        if (sid == null) {\n<line10>            for (InetSocketAddress address : server.addr.getAllAddresses()) {\n<line11>                String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();\n<line12>                if (serverAddr.startsWith(desiredMaster)) {\n<line13>                    return server;\n<line14>                }\n<line15>            }\n<line16>        } else {\n<line17>            if (sid.equals(server.id)) {\n<line18>                return server;\n<line19>            }\n<line20>        }\n<line21>    }\n<line22>    if (sid == null) {\n<line23>    } else {\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    Long sid;\n<line3>    try {\n<line4>        sid = Long.parseLong(desiredMaster);\n<line5>    } catch (NumberFormatException e) {\n<line6>        sid = null;\n<line7>    }\n<line8>    for (QuorumServer server : observerMasters) {\n<line9>        if (sid == null) {\n<line10>            for (InetSocketAddress address : server.addr.getAllAddresses()) {\n<line11>                String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();\n<line12>                if (serverAddr.startsWith(desiredMaster)) {\n<line13>                    return server;\n<line14>                }\n<line15>            }\n<line16>        } else {\n<line17>            if (sid.equals(server.id)) {\n<line18>                return server;\n<line19>            }\n<line20>        }\n<line21>    }\n<line22>    if (sid == null) {\n<line23>        LOG.info(\"could not find learner master address={}\", desiredMaster);\n<line24>    } else {\n<line25>        LOG.warn(\"could not find learner master sid={}\", sid);\n<line26>    }\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"could not find learner master address={}\", desiredMaster);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"cannot validate request, observer masters not enabled\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    //check if I'm an observer in new config\n<line3>    if (newQV.getObservingMembers().containsKey(getMyId())) {\n<line4>        if (getLearnerType() != LearnerType.OBSERVER) {\n<line5>            setLearnerType(LearnerType.OBSERVER);\n<line6>            reconfigFlagSet();\n<line7>            return true;\n<line8>        } else {\n<line9>            return false;\n<line10>        }\n<line11>    } else if (newQV.getVotingMembers().containsKey(getMyId())) {\n<line12>        if (getLearnerType() != LearnerType.PARTICIPANT) {\n<line13>            setLearnerType(LearnerType.PARTICIPANT);\n<line14>            reconfigFlagSet();\n<line15>            return true;\n<line16>        } else {\n<line17>            return false;\n<line18>        }\n<line19>    }\n<line20>    // I'm not in the view\n<line21>    if (getLearnerType() != LearnerType.PARTICIPANT) {\n<line22>        setLearnerType(LearnerType.PARTICIPANT);\n<line23>        reconfigFlagSet();\n<line24>        return true;\n<line25>    }\n<line26>    return false;\n<line27>}","output":"<line1>{\n<line2>    //check if I'm an observer in new config\n<line3>    if (newQV.getObservingMembers().containsKey(getMyId())) {\n<line4>        if (getLearnerType() != LearnerType.OBSERVER) {\n<line5>            setLearnerType(LearnerType.OBSERVER);\n<line6>            LOG.info(\"Becoming an observer\");\n<line7>            reconfigFlagSet();\n<line8>            return true;\n<line9>        } else {\n<line10>            return false;\n<line11>        }\n<line12>    } else if (newQV.getVotingMembers().containsKey(getMyId())) {\n<line13>        if (getLearnerType() != LearnerType.PARTICIPANT) {\n<line14>            setLearnerType(LearnerType.PARTICIPANT);\n<line15>            LOG.info(\"Becoming a voting participant\");\n<line16>            reconfigFlagSet();\n<line17>            return true;\n<line18>        } else {\n<line19>            return false;\n<line20>        }\n<line21>    }\n<line22>    // I'm not in the view\n<line23>    if (getLearnerType() != LearnerType.PARTICIPANT) {\n<line24>        setLearnerType(LearnerType.PARTICIPANT);\n<line25>        LOG.info(\"Becoming a non-voting participant\");\n<line26>        reconfigFlagSet();\n<line27>        return true;\n<line28>    }\n<line29>    return false;\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    if (getLearnerType() != LearnerType.OBSERVER) {\n<line3>        setLearnerType(LearnerType.OBSERVER);\n<line4>        reconfigFlagSet();\n<line5>        return true;\n<line6>    } else {\n<line7>        return false;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (getLearnerType() != LearnerType.OBSERVER) {\n<line3>        setLearnerType(LearnerType.OBSERVER);\n<line4>        LOG.info(\"Becoming an observer\");\n<line5>        reconfigFlagSet();\n<line6>        return true;\n<line7>    } else {\n<line8>        return false;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    setLearnerType(LearnerType.OBSERVER);\n<line3>    reconfigFlagSet();\n<line4>    return true;\n<line5>}","output":"<line1>{\n<line2>    setLearnerType(LearnerType.OBSERVER);\n<line3>    LOG.info(\"Becoming an observer\");\n<line4>    reconfigFlagSet();\n<line5>    return true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (getLearnerType() != LearnerType.PARTICIPANT) {\n<line3>        setLearnerType(LearnerType.PARTICIPANT);\n<line4>        reconfigFlagSet();\n<line5>        return true;\n<line6>    } else {\n<line7>        return false;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (getLearnerType() != LearnerType.PARTICIPANT) {\n<line3>        setLearnerType(LearnerType.PARTICIPANT);\n<line4>        LOG.info(\"Becoming a voting participant\");\n<line5>        reconfigFlagSet();\n<line6>        return true;\n<line7>    } else {\n<line8>        return false;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    setLearnerType(LearnerType.PARTICIPANT);\n<line3>    reconfigFlagSet();\n<line4>    return true;\n<line5>}","output":"<line1>{\n<line2>    setLearnerType(LearnerType.PARTICIPANT);\n<line3>    LOG.info(\"Becoming a voting participant\");\n<line4>    reconfigFlagSet();\n<line5>    return true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    setLearnerType(LearnerType.PARTICIPANT);\n<line3>    reconfigFlagSet();\n<line4>    return true;\n<line5>}","output":"<line1>{\n<line2>    setLearnerType(LearnerType.PARTICIPANT);\n<line3>    LOG.info(\"Becoming a non-voting participant\");\n<line4>    reconfigFlagSet();\n<line5>    return true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumServerSaslAuthRequired = serverSaslRequired;\n<line3>}","output":"<line1>{\n<line2>    quorumServerSaslAuthRequired = serverSaslRequired;\n<line3>    LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, serverSaslRequired);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumLearnerSaslAuthRequired = learnerSaslRequired;\n<line3>}","output":"<line1>{\n<line2>    quorumLearnerSaslAuthRequired = learnerSaslRequired;\n<line3>    LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, learnerSaslRequired);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumSaslEnableAuth = enableAuth;\n<line3>    if (!quorumSaslEnableAuth) {\n<line4>    } else {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    quorumSaslEnableAuth = enableAuth;\n<line3>    if (!quorumSaslEnableAuth) {\n<line4>        LOG.info(\"QuorumPeer communication is not secured! (SASL auth disabled)\");\n<line5>    } else {\n<line6>        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"QuorumPeer communication is not secured! (SASL auth disabled)\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumServicePrincipal = servicePrincipal;\n<line3>}","output":"<line1>{\n<line2>    quorumServicePrincipal = servicePrincipal;\n<line3>    LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, quorumServicePrincipal);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumLearnerLoginContext = learnerContext;\n<line3>}","output":"<line1>{\n<line2>    quorumLearnerLoginContext = learnerContext;\n<line3>    LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, quorumLearnerLoginContext);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    quorumServerLoginContext = serverContext;\n<line3>}","output":"<line1>{\n<line2>    quorumServerLoginContext = serverContext;\n<line3>    LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT, quorumServerLoginContext);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {\n<line3>        quorumCnxnThreadsSize = qCnxnThreadsSize;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {\n<line3>        quorumCnxnThreadsSize = qCnxnThreadsSize;\n<line4>    }\n<line5>    LOG.info(\"quorum.cnxn.threads.size set to {}\", quorumCnxnThreadsSize);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;\n<line3>    return new QuorumCnxManager(this, this.getMyId(), this.getView(), this.authServer, this.authLearner, timeout, this.getQuorumListenOnAllIPs(), this.quorumCnxnThreadsSize, this.isQuorumSaslAuthEnabled());\n<line4>}","output":"<line1>{\n<line2>    int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;\n<line3>    LOG.info(\"Using {}ms as the quorum cnxn socket timeout\", timeout);\n<line4>    return new QuorumCnxManager(this, this.getMyId(), this.getView(), this.authServer, this.authLearner, timeout, this.getQuorumListenOnAllIPs(), this.quorumCnxnThreadsSize, this.isQuorumSaslAuthEnabled());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (si.type != OpCode.sync) {\n<line3>        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);\n<line4>        try {\n<line5>            si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n<line6>            learner.writePacket(qp, false);\n<line7>        } catch (IOException e) {\n<line8>            try {\n<line9>                if (!learner.sock.isClosed()) {\n<line10>                    learner.sock.close();\n<line11>                }\n<line12>            } catch (IOException e1) {\n<line13>                // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line14>            }\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    if (si.type != OpCode.sync) {\n<line3>        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);\n<line4>        try {\n<line5>            si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n<line6>            learner.writePacket(qp, false);\n<line7>        } catch (IOException e) {\n<line8>            LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n<line9>            try {\n<line10>                if (!learner.sock.isClosed()) {\n<line11>                    learner.sock.close();\n<line12>                }\n<line13>            } catch (IOException e1) {\n<line14>                // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line15>                LOG.debug(\"Ignoring error closing the connection\", e1);\n<line16>            }\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);\n<line3>    try {\n<line4>        si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n<line5>        learner.writePacket(qp, false);\n<line6>    } catch (IOException e) {\n<line7>        try {\n<line8>            if (!learner.sock.isClosed()) {\n<line9>                learner.sock.close();\n<line10>            }\n<line11>        } catch (IOException e1) {\n<line12>            // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line13>        }\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);\n<line3>    try {\n<line4>        si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n<line5>        learner.writePacket(qp, false);\n<line6>    } catch (IOException e) {\n<line7>        LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n<line8>        try {\n<line9>            if (!learner.sock.isClosed()) {\n<line10>                learner.sock.close();\n<line11>            }\n<line12>        } catch (IOException e1) {\n<line13>            // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line14>            LOG.debug(\"Ignoring error closing the connection\", e1);\n<line15>        }\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!learner.sock.isClosed()) {\n<line4>            learner.sock.close();\n<line5>        }\n<line6>    } catch (IOException e1) {\n<line7>        // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n<line3>    try {\n<line4>        if (!learner.sock.isClosed()) {\n<line5>            learner.sock.close();\n<line6>        }\n<line7>    } catch (IOException e1) {\n<line8>        // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line9>        LOG.debug(\"Ignoring error closing the connection\", e1);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line3>}","output":"<line1>{\n<line2>    // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line3>    LOG.debug(\"Ignoring error closing the connection\", e1);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        learner.writePacket(null, true);\n<line4>    } catch (IOException e) {\n<line5>        try {\n<line6>            if (!learner.sock.isClosed()) {\n<line7>                learner.sock.close();\n<line8>            }\n<line9>        } catch (IOException e1) {\n<line10>            // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line11>        }\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    try {\n<line3>        learner.writePacket(null, true);\n<line4>    } catch (IOException e) {\n<line5>        LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n<line6>        try {\n<line7>            if (!learner.sock.isClosed()) {\n<line8>                learner.sock.close();\n<line9>            }\n<line10>        } catch (IOException e1) {\n<line11>            // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line12>            LOG.debug(\"Ignoring error closing the connection\", e1);\n<line13>        }\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!learner.sock.isClosed()) {\n<line4>            learner.sock.close();\n<line5>        }\n<line6>    } catch (IOException e1) {\n<line7>        // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n<line3>    try {\n<line4>        if (!learner.sock.isClosed()) {\n<line5>            learner.sock.close();\n<line6>        }\n<line7>    } catch (IOException e1) {\n<line8>        // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line9>        LOG.debug(\"Ignoring error closing the connection\", e1);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line3>}","output":"<line1>{\n<line2>    // Nothing to do, we are shutting things down, so an exception here is irrelevant\n<line3>    LOG.debug(\"Ignoring error closing the connection\", e1);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Screen quorum requests against ACLs first\n<line3>    if (!lzks.authWriteRequest(request)) {\n<line4>        return;\n<line5>    }\n<line6>    // Check if this is a local session and we are trying to create\n<line7>    // an ephemeral node, in which case we upgrade the session\n<line8>    Request upgradeRequest = null;\n<line9>    try {\n<line10>        upgradeRequest = lzks.checkUpgradeSession(request);\n<line11>    } catch (KeeperException ke) {\n<line12>        if (request.getHdr() != null) {\n<line13>            request.getHdr().setType(OpCode.error);\n<line14>            request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line15>        }\n<line16>        request.setException(ke);\n<line17>    } catch (IOException ie) {\n<line18>    }\n<line19>    if (upgradeRequest != null) {\n<line20>        nextProcessor.processRequest(upgradeRequest);\n<line21>    }\n<line22>    nextProcessor.processRequest(request);\n<line23>}","output":"<line1>{\n<line2>    // Screen quorum requests against ACLs first\n<line3>    if (!lzks.authWriteRequest(request)) {\n<line4>        return;\n<line5>    }\n<line6>    // Check if this is a local session and we are trying to create\n<line7>    // an ephemeral node, in which case we upgrade the session\n<line8>    Request upgradeRequest = null;\n<line9>    try {\n<line10>        upgradeRequest = lzks.checkUpgradeSession(request);\n<line11>    } catch (KeeperException ke) {\n<line12>        if (request.getHdr() != null) {\n<line13>            LOG.debug(\"Updating header\");\n<line14>            request.getHdr().setType(OpCode.error);\n<line15>            request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line16>        }\n<line17>        request.setException(ke);\n<line18>        LOG.warn(\"Error creating upgrade request\", ke);\n<line19>    } catch (IOException ie) {\n<line20>        LOG.error(\"Unexpected error in upgrade\", ie);\n<line21>    }\n<line22>    if (upgradeRequest != null) {\n<line23>        nextProcessor.processRequest(upgradeRequest);\n<line24>    }\n<line25>    nextProcessor.processRequest(request);\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.getHdr() != null) {\n<line3>        request.getHdr().setType(OpCode.error);\n<line4>        request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line5>    }\n<line6>    request.setException(ke);\n<line7>}","output":"<line1>{\n<line2>    if (request.getHdr() != null) {\n<line3>        LOG.debug(\"Updating header\");\n<line4>        request.getHdr().setType(OpCode.error);\n<line5>        request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line6>    }\n<line7>    request.setException(ke);\n<line8>    LOG.warn(\"Error creating upgrade request\", ke);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    request.getHdr().setType(OpCode.error);\n<line3>    request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"Updating header\");\n<line3>    request.getHdr().setType(OpCode.error);\n<line4>    request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected error in upgrade\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    nextProcessor.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    nextProcessor.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer self = leader.self;\n<line3>    if (self != null) {\n<line4>        request.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n<line5>        leader.processAck(self.getMyId(), request.zxid, null);\n<line6>    } else {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    QuorumPeer self = leader.self;\n<line3>    if (self != null) {\n<line4>        request.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);\n<line5>        leader.processAck(self.getMyId(), request.zxid, null);\n<line6>    } else {\n<line7>        LOG.error(\"Null QuorumPeer\");\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Null QuorumPeer\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    DataOutputStream dout = null;\n<line3>    SaslServer ss = null;\n<line4>    try {\n<line5>        if (!QuorumAuth.nextPacketIsAuth(din)) {\n<line6>            if (quorumRequireSasl) {\n<line7>                throw new SaslException(\"Learner not trying to authenticate\" + \" and authentication is required\");\n<line8>            } else {\n<line9>                // let it through, we don't require auth\n<line10>                return;\n<line11>            }\n<line12>        }\n<line13>        byte[] token = receive(din);\n<line14>        int tries = 0;\n<line15>        dout = new DataOutputStream(sock.getOutputStream());\n<line16>        byte[] challenge = null;\n<line17>        ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);\n<line18>        while (!ss.isComplete()) {\n<line19>            challenge = ss.evaluateResponse(token);\n<line20>            if (!ss.isComplete()) {\n<line21>                // limited number of retries.\n<line22>                if (++tries > MAX_RETRIES) {\n<line23>                    send(dout, challenge, QuorumAuth.Status.ERROR);\n<line24>                    break;\n<line25>                }\n<line26>                send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);\n<line27>                token = receive(din);\n<line28>            }\n<line29>        }\n<line30>        // Authentication exchange has completed\n<line31>        if (ss.isComplete()) {\n<line32>            send(dout, challenge, QuorumAuth.Status.SUCCESS);\n<line33>        }\n<line34>    } catch (Exception e) {\n<line35>        try {\n<line36>            if (dout != null) {\n<line37>                // send error message to the learner\n<line38>                send(dout, new byte[0], QuorumAuth.Status.ERROR);\n<line39>            }\n<line40>        } catch (IOException ioe) {\n<line41>        }\n<line42>        // If sasl is not required, when a server initializes a\n<line43>        // connection it will try to log in, but it will also\n<line44>        // accept connections that do not start with a sasl\n<line45>        // handshake.\n<line46>        if (quorumRequireSasl) {\n<line47>            throw new SaslException(\"Failed to authenticate using SASL: \" + e.getMessage());\n<line48>        } else {\n<line49>            // let it through, we don't require auth\n<line50>        }\n<line51>    } finally {\n<line52>        if (ss != null) {\n<line53>            try {\n<line54>                ss.dispose();\n<line55>            } catch (SaslException e) {\n<line56>            }\n<line57>        }\n<line58>    }\n<line59>}","output":"<line1>{\n<line2>    DataOutputStream dout = null;\n<line3>    SaslServer ss = null;\n<line4>    try {\n<line5>        if (!QuorumAuth.nextPacketIsAuth(din)) {\n<line6>            if (quorumRequireSasl) {\n<line7>                throw new SaslException(\"Learner not trying to authenticate\" + \" and authentication is required\");\n<line8>            } else {\n<line9>                // let it through, we don't require auth\n<line10>                return;\n<line11>            }\n<line12>        }\n<line13>        byte[] token = receive(din);\n<line14>        int tries = 0;\n<line15>        dout = new DataOutputStream(sock.getOutputStream());\n<line16>        byte[] challenge = null;\n<line17>        ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);\n<line18>        while (!ss.isComplete()) {\n<line19>            challenge = ss.evaluateResponse(token);\n<line20>            if (!ss.isComplete()) {\n<line21>                // limited number of retries.\n<line22>                if (++tries > MAX_RETRIES) {\n<line23>                    send(dout, challenge, QuorumAuth.Status.ERROR);\n<line24>                    LOG.warn(\"Failed to authenticate using SASL, server addr: {}, retries={} exceeded.\", sock.getRemoteSocketAddress(), tries);\n<line25>                    break;\n<line26>                }\n<line27>                send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);\n<line28>                token = receive(din);\n<line29>            }\n<line30>        }\n<line31>        // Authentication exchange has completed\n<line32>        if (ss.isComplete()) {\n<line33>            send(dout, challenge, QuorumAuth.Status.SUCCESS);\n<line34>            LOG.info(\"Successfully completed the authentication using SASL. learner addr: {}\", sock.getRemoteSocketAddress());\n<line35>        }\n<line36>    } catch (Exception e) {\n<line37>        try {\n<line38>            if (dout != null) {\n<line39>                // send error message to the learner\n<line40>                send(dout, new byte[0], QuorumAuth.Status.ERROR);\n<line41>            }\n<line42>        } catch (IOException ioe) {\n<line43>            LOG.warn(\"Exception while sending failed status\", ioe);\n<line44>        }\n<line45>        // If sasl is not required, when a server initializes a\n<line46>        // connection it will try to log in, but it will also\n<line47>        // accept connections that do not start with a sasl\n<line48>        // handshake.\n<line49>        if (quorumRequireSasl) {\n<line50>            LOG.error(\"Failed to authenticate using SASL\", e);\n<line51>            throw new SaslException(\"Failed to authenticate using SASL: \" + e.getMessage());\n<line52>        } else {\n<line53>            LOG.warn(\"Failed to authenticate using SASL\", e);\n<line54>            LOG.warn(\"Maintaining learner connection despite SASL authentication failure. server addr: {}, {}: {}\", sock.getRemoteSocketAddress(), QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, quorumRequireSasl);\n<line55>            // let it through, we don't require auth\n<line56>        }\n<line57>    } finally {\n<line58>        if (ss != null) {\n<line59>            try {\n<line60>                ss.dispose();\n<line61>            } catch (SaslException e) {\n<line62>                LOG.error(\"SaslServer dispose() failed\", e);\n<line63>            }\n<line64>        }\n<line65>    }\n<line66>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!QuorumAuth.nextPacketIsAuth(din)) {\n<line3>        if (quorumRequireSasl) {\n<line4>            throw new SaslException(\"Learner not trying to authenticate\" + \" and authentication is required\");\n<line5>        } else {\n<line6>            // let it through, we don't require auth\n<line7>            return;\n<line8>        }\n<line9>    }\n<line10>    byte[] token = receive(din);\n<line11>    int tries = 0;\n<line12>    dout = new DataOutputStream(sock.getOutputStream());\n<line13>    byte[] challenge = null;\n<line14>    ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);\n<line15>    while (!ss.isComplete()) {\n<line16>        challenge = ss.evaluateResponse(token);\n<line17>        if (!ss.isComplete()) {\n<line18>            // limited number of retries.\n<line19>            if (++tries > MAX_RETRIES) {\n<line20>                send(dout, challenge, QuorumAuth.Status.ERROR);\n<line21>                break;\n<line22>            }\n<line23>            send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);\n<line24>            token = receive(din);\n<line25>        }\n<line26>    }\n<line27>    // Authentication exchange has completed\n<line28>    if (ss.isComplete()) {\n<line29>        send(dout, challenge, QuorumAuth.Status.SUCCESS);\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    if (!QuorumAuth.nextPacketIsAuth(din)) {\n<line3>        if (quorumRequireSasl) {\n<line4>            throw new SaslException(\"Learner not trying to authenticate\" + \" and authentication is required\");\n<line5>        } else {\n<line6>            // let it through, we don't require auth\n<line7>            return;\n<line8>        }\n<line9>    }\n<line10>    byte[] token = receive(din);\n<line11>    int tries = 0;\n<line12>    dout = new DataOutputStream(sock.getOutputStream());\n<line13>    byte[] challenge = null;\n<line14>    ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);\n<line15>    while (!ss.isComplete()) {\n<line16>        challenge = ss.evaluateResponse(token);\n<line17>        if (!ss.isComplete()) {\n<line18>            // limited number of retries.\n<line19>            if (++tries > MAX_RETRIES) {\n<line20>                send(dout, challenge, QuorumAuth.Status.ERROR);\n<line21>                LOG.warn(\"Failed to authenticate using SASL, server addr: {}, retries={} exceeded.\", sock.getRemoteSocketAddress(), tries);\n<line22>                break;\n<line23>            }\n<line24>            send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);\n<line25>            token = receive(din);\n<line26>        }\n<line27>    }\n<line28>    // Authentication exchange has completed\n<line29>    if (ss.isComplete()) {\n<line30>        send(dout, challenge, QuorumAuth.Status.SUCCESS);\n<line31>        LOG.info(\"Successfully completed the authentication using SASL. learner addr: {}\", sock.getRemoteSocketAddress());\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    send(dout, challenge, QuorumAuth.Status.SUCCESS);\n<line3>}","output":"<line1>{\n<line2>    send(dout, challenge, QuorumAuth.Status.SUCCESS);\n<line3>    LOG.info(\"Successfully completed the authentication using SASL. learner addr: {}\", sock.getRemoteSocketAddress());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (dout != null) {\n<line4>            // send error message to the learner\n<line5>            send(dout, new byte[0], QuorumAuth.Status.ERROR);\n<line6>        }\n<line7>    } catch (IOException ioe) {\n<line8>    }\n<line9>    // If sasl is not required, when a server initializes a\n<line10>    // connection it will try to log in, but it will also\n<line11>    // accept connections that do not start with a sasl\n<line12>    // handshake.\n<line13>    if (quorumRequireSasl) {\n<line14>        throw new SaslException(\"Failed to authenticate using SASL: \" + e.getMessage());\n<line15>    } else {\n<line16>        // let it through, we don't require auth\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        if (dout != null) {\n<line4>            // send error message to the learner\n<line5>            send(dout, new byte[0], QuorumAuth.Status.ERROR);\n<line6>        }\n<line7>    } catch (IOException ioe) {\n<line8>        LOG.warn(\"Exception while sending failed status\", ioe);\n<line9>    }\n<line10>    // If sasl is not required, when a server initializes a\n<line11>    // connection it will try to log in, but it will also\n<line12>    // accept connections that do not start with a sasl\n<line13>    // handshake.\n<line14>    if (quorumRequireSasl) {\n<line15>        LOG.error(\"Failed to authenticate using SASL\", e);\n<line16>        throw new SaslException(\"Failed to authenticate using SASL: \" + e.getMessage());\n<line17>    } else {\n<line18>        LOG.warn(\"Failed to authenticate using SASL\", e);\n<line19>        LOG.warn(\"Maintaining learner connection despite SASL authentication failure. server addr: {}, {}: {}\", sock.getRemoteSocketAddress(), QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, quorumRequireSasl);\n<line20>        // let it through, we don't require auth\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new SaslException(\"Failed to authenticate using SASL: \" + e.getMessage());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to authenticate using SASL\", e);\n<line3>    throw new SaslException(\"Failed to authenticate using SASL: \" + e.getMessage());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (ss != null) {\n<line3>        try {\n<line4>            ss.dispose();\n<line5>        } catch (SaslException e) {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    if (ss != null) {\n<line3>        try {\n<line4>            ss.dispose();\n<line5>        } catch (SaslException e) {\n<line6>            LOG.error(\"SaslServer dispose() failed\", e);\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        ss.dispose();\n<line4>    } catch (SaslException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        ss.dispose();\n<line4>    } catch (SaslException e) {\n<line5>        LOG.error(\"SaslServer dispose() failed\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"SaslServer dispose() failed\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!quorumRequireSasl) {\n<line3>        // let it through, we don't require auth\n<line4>        return;\n<line5>    }\n<line6>    SaslClient sc = null;\n<line7>    String principalConfig = SecurityUtils.getServerPrincipal(quorumServicePrincipal, hostName);\n<line8>    try {\n<line9>        DataOutputStream dout = new DataOutputStream(sock.getOutputStream());\n<line10>        DataInputStream din = new DataInputStream(sock.getInputStream());\n<line11>        byte[] responseToken = new byte[0];\n<line12>        sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(), principalConfig, QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, \"QuorumLearner\");\n<line13>        if (sc.hasInitialResponse()) {\n<line14>            responseToken = createSaslToken(new byte[0], sc, learnerLogin);\n<line15>        }\n<line16>        send(dout, responseToken);\n<line17>        QuorumAuthPacket authPacket = receive(din);\n<line18>        QuorumAuth.Status qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());\n<line19>        while (!sc.isComplete()) {\n<line20>            switch(qpStatus) {\n<line21>                case SUCCESS:\n<line22>                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);\n<line23>                    // we're done; don't expect to send another BIND\n<line24>                    if (responseToken != null) {\n<line25>                        throw new SaslException(\"Protocol error: attempting to send response after completion\");\n<line26>                    }\n<line27>                    break;\n<line28>                case IN_PROGRESS:\n<line29>                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);\n<line30>                    send(dout, responseToken);\n<line31>                    authPacket = receive(din);\n<line32>                    qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());\n<line33>                    break;\n<line34>                case ERROR:\n<line35>                    throw new SaslException(\"Authentication failed against server addr: \" + sock.getRemoteSocketAddress());\n<line36>                default:\n<line37>                    throw new SaslException(\"Authentication failed against server addr: \" + sock.getRemoteSocketAddress());\n<line38>            }\n<line39>        }\n<line40>        // Validate status code at the end of authentication exchange.\n<line41>        checkAuthStatus(sock, qpStatus);\n<line42>    } finally {\n<line43>        if (sc != null) {\n<line44>            try {\n<line45>                sc.dispose();\n<line46>            } catch (SaslException e) {\n<line47>            }\n<line48>        }\n<line49>    }\n<line50>}","output":"<line1>{\n<line2>    if (!quorumRequireSasl) {\n<line3>        // let it through, we don't require auth\n<line4>        LOG.info(\"Skipping SASL authentication as {}={}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, quorumRequireSasl);\n<line5>        return;\n<line6>    }\n<line7>    SaslClient sc = null;\n<line8>    String principalConfig = SecurityUtils.getServerPrincipal(quorumServicePrincipal, hostName);\n<line9>    try {\n<line10>        DataOutputStream dout = new DataOutputStream(sock.getOutputStream());\n<line11>        DataInputStream din = new DataInputStream(sock.getInputStream());\n<line12>        byte[] responseToken = new byte[0];\n<line13>        sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(), principalConfig, QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, \"QuorumLearner\");\n<line14>        if (sc.hasInitialResponse()) {\n<line15>            responseToken = createSaslToken(new byte[0], sc, learnerLogin);\n<line16>        }\n<line17>        send(dout, responseToken);\n<line18>        QuorumAuthPacket authPacket = receive(din);\n<line19>        QuorumAuth.Status qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());\n<line20>        while (!sc.isComplete()) {\n<line21>            switch(qpStatus) {\n<line22>                case SUCCESS:\n<line23>                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);\n<line24>                    // we're done; don't expect to send another BIND\n<line25>                    if (responseToken != null) {\n<line26>                        throw new SaslException(\"Protocol error: attempting to send response after completion\");\n<line27>                    }\n<line28>                    break;\n<line29>                case IN_PROGRESS:\n<line30>                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);\n<line31>                    send(dout, responseToken);\n<line32>                    authPacket = receive(din);\n<line33>                    qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());\n<line34>                    break;\n<line35>                case ERROR:\n<line36>                    throw new SaslException(\"Authentication failed against server addr: \" + sock.getRemoteSocketAddress());\n<line37>                default:\n<line38>                    LOG.warn(\"Unknown status:{}!\", qpStatus);\n<line39>                    throw new SaslException(\"Authentication failed against server addr: \" + sock.getRemoteSocketAddress());\n<line40>            }\n<line41>        }\n<line42>        // Validate status code at the end of authentication exchange.\n<line43>        checkAuthStatus(sock, qpStatus);\n<line44>    } finally {\n<line45>        if (sc != null) {\n<line46>            try {\n<line47>                sc.dispose();\n<line48>            } catch (SaslException e) {\n<line49>                LOG.error(\"SaslClient dispose() failed\", e);\n<line50>            }\n<line51>        }\n<line52>    }\n<line53>}"},{"input":"","instruction":"<line1>{\n<line2>    // let it through, we don't require auth\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    // let it through, we don't require auth\n<line3>    LOG.info(\"Skipping SASL authentication as {}={}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, quorumRequireSasl);\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sc != null) {\n<line3>        try {\n<line4>            sc.dispose();\n<line5>        } catch (SaslException e) {\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    if (sc != null) {\n<line3>        try {\n<line4>            sc.dispose();\n<line5>        } catch (SaslException e) {\n<line6>            LOG.error(\"SaslClient dispose() failed\", e);\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        sc.dispose();\n<line4>    } catch (SaslException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        sc.dispose();\n<line4>    } catch (SaslException e) {\n<line5>        LOG.error(\"SaslClient dispose() failed\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"SaslClient dispose() failed\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (qpStatus == QuorumAuth.Status.SUCCESS) {\n<line3>    } else {\n<line4>        throw new SaslException(\"Authentication failed against server addr: \" + sock.getRemoteSocketAddress() + \", qpStatus: \" + qpStatus);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (qpStatus == QuorumAuth.Status.SUCCESS) {\n<line3>        LOG.info(\"Successfully completed the authentication using SASL. server addr: {}, status: {}\", sock.getRemoteSocketAddress(), qpStatus);\n<line4>    } else {\n<line5>        throw new SaslException(\"Authentication failed against server addr: \" + sock.getRemoteSocketAddress() + \", qpStatus: \" + qpStatus);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Successfully completed the authentication using SASL. server addr: {}, status: {}\", sock.getRemoteSocketAddress(), qpStatus);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (saslToken == null) {\n<line3>        throw new SaslException(\"Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.\");\n<line4>    }\n<line5>    if (login.getSubject() != null) {\n<line6>        synchronized (login) {\n<line7>            try {\n<line8>                final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line9>\n<line10>                    public byte[] run() throws SaslException {\n<line11>                        return saslClient.evaluateChallenge(saslToken);\n<line12>                    }\n<line13>                });\n<line14>                return retval;\n<line15>            } catch (PrivilegedActionException e) {\n<line16>                String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line17>                // Try to provide hints to use about what went wrong so they\n<line18>                // can fix their configuration.\n<line19>                // TODO: introspect about e: look for GSS information.\n<line20>                final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line21>                if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line22>                    error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line23>                }\n<line24>                throw new SaslException(error, e);\n<line25>            }\n<line26>        }\n<line27>    } else {\n<line28>        throw new SaslException(\"Cannot make SASL token without subject defined. \" + \"For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.\");\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    if (saslToken == null) {\n<line3>        throw new SaslException(\"Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.\");\n<line4>    }\n<line5>    if (login.getSubject() != null) {\n<line6>        synchronized (login) {\n<line7>            try {\n<line8>                final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line9>\n<line10>                    public byte[] run() throws SaslException {\n<line11>                        LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line12>                        return saslClient.evaluateChallenge(saslToken);\n<line13>                    }\n<line14>                });\n<line15>                return retval;\n<line16>            } catch (PrivilegedActionException e) {\n<line17>                String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line18>                // Try to provide hints to use about what went wrong so they\n<line19>                // can fix their configuration.\n<line20>                // TODO: introspect about e: look for GSS information.\n<line21>                final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line22>                if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line23>                    error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line24>                }\n<line25>                LOG.error(error);\n<line26>                throw new SaslException(error, e);\n<line27>            }\n<line28>        }\n<line29>    } else {\n<line30>        throw new SaslException(\"Cannot make SASL token without subject defined. \" + \"For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.\");\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (login) {\n<line3>        try {\n<line4>            final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line5>\n<line6>                public byte[] run() throws SaslException {\n<line7>                    return saslClient.evaluateChallenge(saslToken);\n<line8>                }\n<line9>            });\n<line10>            return retval;\n<line11>        } catch (PrivilegedActionException e) {\n<line12>            String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line13>            // Try to provide hints to use about what went wrong so they\n<line14>            // can fix their configuration.\n<line15>            // TODO: introspect about e: look for GSS information.\n<line16>            final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line17>            if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line18>                error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line19>            }\n<line20>            throw new SaslException(error, e);\n<line21>        }\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    synchronized (login) {\n<line3>        try {\n<line4>            final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line5>\n<line6>                public byte[] run() throws SaslException {\n<line7>                    LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line8>                    return saslClient.evaluateChallenge(saslToken);\n<line9>                }\n<line10>            });\n<line11>            return retval;\n<line12>        } catch (PrivilegedActionException e) {\n<line13>            String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line14>            // Try to provide hints to use about what went wrong so they\n<line15>            // can fix their configuration.\n<line16>            // TODO: introspect about e: look for GSS information.\n<line17>            final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line18>            if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line19>                error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line20>            }\n<line21>            LOG.error(error);\n<line22>            throw new SaslException(error, e);\n<line23>        }\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line4>\n<line5>            public byte[] run() throws SaslException {\n<line6>                return saslClient.evaluateChallenge(saslToken);\n<line7>            }\n<line8>        });\n<line9>        return retval;\n<line10>    } catch (PrivilegedActionException e) {\n<line11>        String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line12>        // Try to provide hints to use about what went wrong so they\n<line13>        // can fix their configuration.\n<line14>        // TODO: introspect about e: look for GSS information.\n<line15>        final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line16>        if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line17>            error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line18>        }\n<line19>        throw new SaslException(error, e);\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    try {\n<line3>        final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line4>\n<line5>            public byte[] run() throws SaslException {\n<line6>                LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line7>                return saslClient.evaluateChallenge(saslToken);\n<line8>            }\n<line9>        });\n<line10>        return retval;\n<line11>    } catch (PrivilegedActionException e) {\n<line12>        String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line13>        // Try to provide hints to use about what went wrong so they\n<line14>        // can fix their configuration.\n<line15>        // TODO: introspect about e: look for GSS information.\n<line16>        final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line17>        if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line18>            error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line19>        }\n<line20>        LOG.error(error);\n<line21>        throw new SaslException(error, e);\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line3>\n<line4>        public byte[] run() throws SaslException {\n<line5>            return saslClient.evaluateChallenge(saslToken);\n<line6>        }\n<line7>    });\n<line8>    return retval;\n<line9>}","output":"<line1>{\n<line2>    final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {\n<line3>\n<line4>        public byte[] run() throws SaslException {\n<line5>            LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line6>            return saslClient.evaluateChallenge(saslToken);\n<line7>        }\n<line8>    });\n<line9>    return retval;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return saslClient.evaluateChallenge(saslToken);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line3>    return saslClient.evaluateChallenge(saslToken);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line3>    // Try to provide hints to use about what went wrong so they\n<line4>    // can fix their configuration.\n<line5>    // TODO: introspect about e: look for GSS information.\n<line6>    final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line7>    if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line8>        error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line9>    }\n<line10>    throw new SaslException(error, e);\n<line11>}","output":"<line1>{\n<line2>    String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's received SASL token.\";\n<line3>    // Try to provide hints to use about what went wrong so they\n<line4>    // can fix their configuration.\n<line5>    // TODO: introspect about e: look for GSS information.\n<line6>    final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line7>    if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n<line8>        error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n<line9>    }\n<line10>    LOG.error(error);\n<line11>    throw new SaslException(error, e);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    switch(status) {\n<line3>        case 0:\n<line4>            return IN_PROGRESS;\n<line5>        case 1:\n<line6>            return SUCCESS;\n<line7>        case -1:\n<line8>            return ERROR;\n<line9>        default:\n<line10>            assert false : \"Unknown status!\";\n<line11>            return ERROR;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    switch(status) {\n<line3>        case 0:\n<line4>            return IN_PROGRESS;\n<line5>        case 1:\n<line6>            return SUCCESS;\n<line7>        case -1:\n<line8>            return ERROR;\n<line9>        default:\n<line10>            LOG.error(\"Unknown status:{}!\", status);\n<line11>            assert false : \"Unknown status!\";\n<line12>            return ERROR;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    AppConfigurationEntry[] configurationEntries = configuration.getAppConfigurationEntry(serverSection);\n<line3>    if (configurationEntries == null) {\n<line4>        String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line5>        throw new IOException(errorMessage);\n<line6>    }\n<line7>    Map<String, String> credentials = new HashMap<>();\n<line8>    boolean isDigestAuthn = true;\n<line9>    for (AppConfigurationEntry entry : configurationEntries) {\n<line10>        if (entry.getLoginModuleName().equals(DigestLoginModule.class.getName())) {\n<line11>            Map<String, ?> options = entry.getOptions();\n<line12>            // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"QuorumServer\" section.\n<line13>            // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n<line14>            for (Map.Entry<String, ?> pair : options.entrySet()) {\n<line15>                String key = pair.getKey();\n<line16>                if (key.startsWith(USER_PREFIX)) {\n<line17>                    String userName = key.substring(USER_PREFIX.length());\n<line18>                    credentials.put(userName, (String) pair.getValue());\n<line19>                }\n<line20>            }\n<line21>        } else {\n<line22>            isDigestAuthn = false;\n<line23>        }\n<line24>    }\n<line25>    this.isDigestAuthn = isDigestAuthn;\n<line26>    if (isDigestAuthn) {\n<line27>        this.credentials = Collections.unmodifiableMap(credentials);\n<line28>    } else {\n<line29>        this.credentials = Collections.emptyMap();\n<line30>    }\n<line31>    // authorized host lists\n<line32>    this.authzHosts = authzHosts;\n<line33>}","output":"<line1>{\n<line2>    AppConfigurationEntry[] configurationEntries = configuration.getAppConfigurationEntry(serverSection);\n<line3>    if (configurationEntries == null) {\n<line4>        String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line5>        LOG.error(errorMessage);\n<line6>        throw new IOException(errorMessage);\n<line7>    }\n<line8>    Map<String, String> credentials = new HashMap<>();\n<line9>    boolean isDigestAuthn = true;\n<line10>    for (AppConfigurationEntry entry : configurationEntries) {\n<line11>        if (entry.getLoginModuleName().equals(DigestLoginModule.class.getName())) {\n<line12>            Map<String, ?> options = entry.getOptions();\n<line13>            // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"QuorumServer\" section.\n<line14>            // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n<line15>            for (Map.Entry<String, ?> pair : options.entrySet()) {\n<line16>                String key = pair.getKey();\n<line17>                if (key.startsWith(USER_PREFIX)) {\n<line18>                    String userName = key.substring(USER_PREFIX.length());\n<line19>                    credentials.put(userName, (String) pair.getValue());\n<line20>                }\n<line21>            }\n<line22>        } else {\n<line23>            isDigestAuthn = false;\n<line24>        }\n<line25>    }\n<line26>    this.isDigestAuthn = isDigestAuthn;\n<line27>    if (isDigestAuthn) {\n<line28>        this.credentials = Collections.unmodifiableMap(credentials);\n<line29>        LOG.warn(\"Using DIGEST-MD5 for quorum authorization\");\n<line30>    } else {\n<line31>        this.credentials = Collections.emptyMap();\n<line32>    }\n<line33>    // authorized host lists\n<line34>    this.authzHosts = authzHosts;\n<line35>}"},{"input":"","instruction":"<line1>{\n<line2>    String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line3>    throw new IOException(errorMessage);\n<line4>}","output":"<line1>{\n<line2>    String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n<line3>    LOG.error(errorMessage);\n<line4>    throw new IOException(errorMessage);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    rc.setText(rc.getDefaultText());\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"QuorumLearner supplied realm: {}\", rc.getDefaultText());\n<line3>    rc.setText(rc.getDefaultText());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String authenticationID = ac.getAuthenticationID();\n<line3>    String authorizationID = ac.getAuthorizationID();\n<line4>    boolean authzFlag = false;\n<line5>    // 1. Matches authenticationID and authorizationID\n<line6>    authzFlag = authenticationID.equals(authorizationID);\n<line7>    // 2. Verify whether the connecting host is present in authorized hosts.\n<line8>    // If not exists, then connecting peer is not authorized to join the\n<line9>    // ensemble and will reject it.\n<line10>    if (!isDigestAuthn && authzFlag) {\n<line11>        String[] components = authorizationID.split(\"[/@]\");\n<line12>        if (components.length == 3) {\n<line13>            authzFlag = authzHosts.contains(components[1]);\n<line14>        } else {\n<line15>            authzFlag = false;\n<line16>        }\n<line17>        if (!authzFlag) {\n<line18>        }\n<line19>    }\n<line20>    // Sets authorization flag\n<line21>    ac.setAuthorized(authzFlag);\n<line22>    if (ac.isAuthorized()) {\n<line23>        ac.setAuthorizedID(authorizationID);\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    String authenticationID = ac.getAuthenticationID();\n<line3>    String authorizationID = ac.getAuthorizationID();\n<line4>    boolean authzFlag = false;\n<line5>    // 1. Matches authenticationID and authorizationID\n<line6>    authzFlag = authenticationID.equals(authorizationID);\n<line7>    // 2. Verify whether the connecting host is present in authorized hosts.\n<line8>    // If not exists, then connecting peer is not authorized to join the\n<line9>    // ensemble and will reject it.\n<line10>    if (!isDigestAuthn && authzFlag) {\n<line11>        String[] components = authorizationID.split(\"[/@]\");\n<line12>        if (components.length == 3) {\n<line13>            authzFlag = authzHosts.contains(components[1]);\n<line14>        } else {\n<line15>            authzFlag = false;\n<line16>        }\n<line17>        if (!authzFlag) {\n<line18>            LOG.error(\"SASL authorization completed, {} is not authorized to connect\", authorizationID);\n<line19>        }\n<line20>    }\n<line21>    // Sets authorization flag\n<line22>    ac.setAuthorized(authzFlag);\n<line23>    if (ac.isAuthorized()) {\n<line24>        ac.setAuthorizedID(authorizationID);\n<line25>        LOG.info(\"Successfully authenticated learner: authenticationID={};  authorizationID={}.\", authenticationID, authorizationID);\n<line26>    }\n<line27>    LOG.debug(\"SASL authorization completed, authorized flag set to {}\", ac.isAuthorized());\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] components = authorizationID.split(\"[/@]\");\n<line3>    if (components.length == 3) {\n<line4>        authzFlag = authzHosts.contains(components[1]);\n<line5>    } else {\n<line6>        authzFlag = false;\n<line7>    }\n<line8>    if (!authzFlag) {\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    String[] components = authorizationID.split(\"[/@]\");\n<line3>    if (components.length == 3) {\n<line4>        authzFlag = authzHosts.contains(components[1]);\n<line5>    } else {\n<line6>        authzFlag = false;\n<line7>    }\n<line8>    if (!authzFlag) {\n<line9>        LOG.error(\"SASL authorization completed, {} is not authorized to connect\", authorizationID);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"SASL authorization completed, {} is not authorized to connect\", authorizationID);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ac.setAuthorizedID(authorizationID);\n<line3>}","output":"<line1>{\n<line2>    ac.setAuthorizedID(authorizationID);\n<line3>    LOG.info(\"Successfully authenticated learner: authenticationID={};  authorizationID={}.\", authenticationID, authorizationID);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"TCP NoDelay set to: {}\", nodelay);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ackLoggingFrequency = Integer.getInteger(ACK_LOGGING_FREQUENCY, 1000);\n<line3>}","output":"<line1>{\n<line2>    ackLoggingFrequency = Integer.getInteger(ACK_LOGGING_FREQUENCY, 1000);\n<line3>    LOG.info(\"{} = {}\", ACK_LOGGING_FREQUENCY, ackLoggingFrequency);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerSocket serverSocket;\n<line3>    try {\n<line4>        if (portUnification || sslQuorum) {\n<line5>            serverSocket = new UnifiedServerSocket(self.getX509Util(), portUnification);\n<line6>        } else {\n<line7>            serverSocket = new ServerSocket();\n<line8>        }\n<line9>        serverSocket.setReuseAddress(true);\n<line10>        serverSocket.bind(recreateInetSocketAddr(address.getHostString(), address.getPort()));\n<line11>        return Optional.of(serverSocket);\n<line12>    } catch (IOException e) {\n<line13>    }\n<line14>    return Optional.empty();\n<line15>}","output":"<line1>{\n<line2>    ServerSocket serverSocket;\n<line3>    try {\n<line4>        if (portUnification || sslQuorum) {\n<line5>            serverSocket = new UnifiedServerSocket(self.getX509Util(), portUnification);\n<line6>        } else {\n<line7>            serverSocket = new ServerSocket();\n<line8>        }\n<line9>        serverSocket.setReuseAddress(true);\n<line10>        serverSocket.bind(recreateInetSocketAddr(address.getHostString(), address.getPort()));\n<line11>        return Optional.of(serverSocket);\n<line12>    } catch (IOException e) {\n<line13>        LOG.error(\"Couldn't bind to {}\", address.toString(), e);\n<line14>    }\n<line15>    return Optional.empty();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Couldn't bind to {}\", address.toString(), e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!stop.get() && !serverSockets.isEmpty()) {\n<line3>        ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());\n<line4>        CountDownLatch latch = new CountDownLatch(serverSockets.size());\n<line5>        serverSockets.forEach(serverSocket -> executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));\n<line6>        try {\n<line7>            latch.await();\n<line8>        } catch (InterruptedException ie) {\n<line9>        } finally {\n<line10>            closeSockets();\n<line11>            executor.shutdown();\n<line12>            try {\n<line13>                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line14>                }\n<line15>            } catch (InterruptedException ie) {\n<line16>            }\n<line17>        }\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    if (!stop.get() && !serverSockets.isEmpty()) {\n<line3>        ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());\n<line4>        CountDownLatch latch = new CountDownLatch(serverSockets.size());\n<line5>        serverSockets.forEach(serverSocket -> executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));\n<line6>        try {\n<line7>            latch.await();\n<line8>        } catch (InterruptedException ie) {\n<line9>            LOG.error(\"Interrupted while sleeping in LearnerCnxAcceptor.\", ie);\n<line10>        } finally {\n<line11>            closeSockets();\n<line12>            executor.shutdown();\n<line13>            try {\n<line14>                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line15>                    LOG.error(\"not all the LearnerCnxAcceptorHandler terminated properly\");\n<line16>                }\n<line17>            } catch (InterruptedException ie) {\n<line18>                LOG.error(\"Interrupted while terminating LearnerCnxAcceptor.\", ie);\n<line19>            }\n<line20>        }\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());\n<line3>    CountDownLatch latch = new CountDownLatch(serverSockets.size());\n<line4>    serverSockets.forEach(serverSocket -> executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));\n<line5>    try {\n<line6>        latch.await();\n<line7>    } catch (InterruptedException ie) {\n<line8>    } finally {\n<line9>        closeSockets();\n<line10>        executor.shutdown();\n<line11>        try {\n<line12>            if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line13>            }\n<line14>        } catch (InterruptedException ie) {\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());\n<line3>    CountDownLatch latch = new CountDownLatch(serverSockets.size());\n<line4>    serverSockets.forEach(serverSocket -> executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));\n<line5>    try {\n<line6>        latch.await();\n<line7>    } catch (InterruptedException ie) {\n<line8>        LOG.error(\"Interrupted while sleeping in LearnerCnxAcceptor.\", ie);\n<line9>    } finally {\n<line10>        closeSockets();\n<line11>        executor.shutdown();\n<line12>        try {\n<line13>            if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line14>                LOG.error(\"not all the LearnerCnxAcceptorHandler terminated properly\");\n<line15>            }\n<line16>        } catch (InterruptedException ie) {\n<line17>            LOG.error(\"Interrupted while terminating LearnerCnxAcceptor.\", ie);\n<line18>        }\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while sleeping in LearnerCnxAcceptor.\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSockets();\n<line3>    executor.shutdown();\n<line4>    try {\n<line5>        if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line6>        }\n<line7>    } catch (InterruptedException ie) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    closeSockets();\n<line3>    executor.shutdown();\n<line4>    try {\n<line5>        if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line6>            LOG.error(\"not all the LearnerCnxAcceptorHandler terminated properly\");\n<line7>        }\n<line8>    } catch (InterruptedException ie) {\n<line9>        LOG.error(\"Interrupted while terminating LearnerCnxAcceptor.\", ie);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line3>        LOG.error(\"not all the LearnerCnxAcceptorHandler terminated properly\");\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"not all the LearnerCnxAcceptorHandler terminated properly\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while terminating LearnerCnxAcceptor.\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket socket = null;\n<line3>    boolean error = false;\n<line4>    try {\n<line5>        socket = serverSocket.accept();\n<line6>        // start with the initLimit, once the ack is processed\n<line7>        // in LearnerHandler switch to the syncLimit\n<line8>        socket.setSoTimeout(self.tickTime * self.initLimit);\n<line9>        socket.setTcpNoDelay(nodelay);\n<line10>        BufferedInputStream is = new BufferedInputStream(socket.getInputStream());\n<line11>        LearnerHandler fh = new LearnerHandler(socket, is, Leader.this);\n<line12>        fh.start();\n<line13>    } catch (SocketException e) {\n<line14>        error = true;\n<line15>        if (stop.get()) {\n<line16>        } else {\n<line17>            throw e;\n<line18>        }\n<line19>    } catch (SaslException e) {\n<line20>        error = true;\n<line21>    } catch (Exception e) {\n<line22>        error = true;\n<line23>        throw e;\n<line24>    } finally {\n<line25>        // Don't leak sockets on errors\n<line26>        if (error && socket != null && !socket.isClosed()) {\n<line27>            try {\n<line28>                socket.close();\n<line29>            } catch (IOException e) {\n<line30>            }\n<line31>        }\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    Socket socket = null;\n<line3>    boolean error = false;\n<line4>    try {\n<line5>        socket = serverSocket.accept();\n<line6>        // start with the initLimit, once the ack is processed\n<line7>        // in LearnerHandler switch to the syncLimit\n<line8>        socket.setSoTimeout(self.tickTime * self.initLimit);\n<line9>        socket.setTcpNoDelay(nodelay);\n<line10>        BufferedInputStream is = new BufferedInputStream(socket.getInputStream());\n<line11>        LearnerHandler fh = new LearnerHandler(socket, is, Leader.this);\n<line12>        fh.start();\n<line13>    } catch (SocketException e) {\n<line14>        error = true;\n<line15>        if (stop.get()) {\n<line16>            LOG.warn(\"Exception while shutting down acceptor.\", e);\n<line17>        } else {\n<line18>            throw e;\n<line19>        }\n<line20>    } catch (SaslException e) {\n<line21>        LOG.error(\"Exception while connecting to quorum learner\", e);\n<line22>        error = true;\n<line23>    } catch (Exception e) {\n<line24>        error = true;\n<line25>        throw e;\n<line26>    } finally {\n<line27>        // Don't leak sockets on errors\n<line28>        if (error && socket != null && !socket.isClosed()) {\n<line29>            try {\n<line30>                socket.close();\n<line31>            } catch (IOException e) {\n<line32>                LOG.warn(\"Error closing socket: \" + socket, e);\n<line33>            }\n<line34>        }\n<line35>    }\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    error = true;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while connecting to quorum learner\", e);\n<line3>    error = true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    self.end_fle = Time.currentElapsedTime();\n<line3>    long electionTimeTaken = self.end_fle - self.start_fle;\n<line4>    self.setElectionTimeTaken(electionTimeTaken);\n<line5>    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n<line6>    self.start_fle = 0;\n<line7>    self.end_fle = 0;\n<line8>    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n<line9>    try {\n<line10>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line11>        self.tick.set(0);\n<line12>        zk.loadData();\n<line13>        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n<line14>        // Start thread that waits for connection requests from\n<line15>        // new followers.\n<line16>        cnxAcceptor = new LearnerCnxAcceptor();\n<line17>        cnxAcceptor.start();\n<line18>        long epoch = getEpochToPropose(self.getMyId(), self.getAcceptedEpoch());\n<line19>        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n<line20>        synchronized (this) {\n<line21>            lastProposed = zk.getZxid();\n<line22>        }\n<line23>        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);\n<line24>        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n<line25>        }\n<line26>        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line27>        QuorumVerifier curQV = self.getQuorumVerifier();\n<line28>        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n<line29>            // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n<line30>            // specified by the user; the lack of version in a config file is interpreted as version=0).\n<line31>            // As soon as a config is established we would like to increase its version so that it\n<line32>            // takes presedence over other initial configs that were not established (such as a config\n<line33>            // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n<line34>            // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n<line35>            // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n<line36>            // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n<line37>            // and there's still no agreement on the new version that we'd like to use. Instead, we use\n<line38>            // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n<line39>            // so its a good way to let followers know about the new version. (The original reason for sending\n<line40>            // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n<line41>            // that it finds before starting to propose operations. Here we're reusing the same code path for\n<line42>            // reaching consensus on the new version number.)\n<line43>            // It is important that this is done before the leader executes waitForEpochAck,\n<line44>            // so before LearnerHandlers return from their waitForEpochAck\n<line45>            // hence before they construct the NEWLEADER message containing\n<line46>            // the last-seen-quorumverifier of the leader, which we change below\n<line47>            try {\n<line48>                QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line49>                newQV.setVersion(zk.getZxid());\n<line50>                self.setLastSeenQuorumVerifier(newQV, true);\n<line51>            } catch (Exception e) {\n<line52>                throw new IOException(e);\n<line53>            }\n<line54>        }\n<line55>        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n<line56>        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line57>            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line58>        }\n<line59>        // We have to get at least a majority of servers in sync with\n<line60>        // us. We do this by waiting for the NEWLEADER packet to get\n<line61>        // acknowledged\n<line62>        waitForEpochAck(self.getMyId(), leaderStateSummary);\n<line63>        self.setCurrentEpoch(epoch);\n<line64>        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getMyId());\n<line65>        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line66>        try {\n<line67>            waitForNewLeaderAck(self.getMyId(), zk.getZxid());\n<line68>        } catch (InterruptedException e) {\n<line69>            shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \" + newLeaderProposal.ackSetsToString() + \" ]\");\n<line70>            HashSet<Long> followerSet = new HashSet<>();\n<line71>            for (LearnerHandler f : getLearners()) {\n<line72>                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {\n<line73>                    followerSet.add(f.getSid());\n<line74>                }\n<line75>            }\n<line76>            boolean initTicksShouldBeIncreased = true;\n<line77>            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {\n<line78>                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n<line79>                    initTicksShouldBeIncreased = false;\n<line80>                    break;\n<line81>                }\n<line82>            }\n<line83>            if (initTicksShouldBeIncreased) {\n<line84>            }\n<line85>            return;\n<line86>        }\n<line87>        startZkServer();\n<line88>        /**\n<line89>         * WARNING: do not use this for anything other than QA testing\n<line90>         * on a real cluster. Specifically to enable verification that quorum\n<line91>         * can handle the lower 32bit roll-over issue identified in\n<line92>         * ZOOKEEPER-1277. Without this option it would take a very long\n<line93>         * time (on order of a month say) to see the 4 billion writes\n<line94>         * necessary to cause the roll-over to occur.\n<line95>         *\n<line96>         * This field allows you to override the zxid of the server. Typically\n<line97>         * you'll want to set it to something like 0xfffffff0 and then\n<line98>         * start the quorum, run some operations and see the re-election.\n<line99>         */\n<line100>        String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n<line101>        if (initialZxid != null) {\n<line102>            long zxid = Long.parseLong(initialZxid);\n<line103>            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n<line104>        }\n<line105>        if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n<line106>            self.setZooKeeperServer(zk);\n<line107>        }\n<line108>        self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line109>        self.adminServer.setZooKeeperServer(zk);\n<line110>        // We ping twice a tick, so we only update the tick every other\n<line111>        // iteration\n<line112>        boolean tickSkip = true;\n<line113>        // If not null then shutdown this leader\n<line114>        String shutdownMessage = null;\n<line115>        while (true) {\n<line116>            synchronized (this) {\n<line117>                long start = Time.currentElapsedTime();\n<line118>                long cur = start;\n<line119>                long end = start + self.tickTime / 2;\n<line120>                while (cur < end) {\n<line121>                    wait(end - cur);\n<line122>                    cur = Time.currentElapsedTime();\n<line123>                }\n<line124>                if (!tickSkip) {\n<line125>                    self.tick.incrementAndGet();\n<line126>                }\n<line127>                // We use an instance of SyncedLearnerTracker to\n<line128>                // track synced learners to make sure we still have a\n<line129>                // quorum of current (and potentially next pending) view.\n<line130>                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n<line131>                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n<line132>                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line133>                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line134>                }\n<line135>                syncedAckSet.addAck(self.getMyId());\n<line136>                for (LearnerHandler f : getLearners()) {\n<line137>                    if (f.synced()) {\n<line138>                        syncedAckSet.addAck(f.getSid());\n<line139>                    }\n<line140>                }\n<line141>                // check leader running status\n<line142>                if (!this.isRunning()) {\n<line143>                    // set shutdown flag\n<line144>                    shutdownMessage = \"Unexpected internal error\";\n<line145>                    break;\n<line146>                }\n<line147>                /*\n<line148>                     *\n<line149>                     * We will need to re-validate the outstandingProposal to maintain the progress of ZooKeeper.\n<line150>                     * It is likely a proposal is waiting for enough ACKs to be committed. The proposals are sent out, but the\n<line151>                     * only follower goes away which makes the proposals will not be committed until the follower recovers back.\n<line152>                     * An earlier proposal which is not committed will block any further proposals. So, We need to re-validate those\n<line153>                     * outstanding proposal with the help from Oracle. A key point in the process of re-validation is that the proposals\n<line154>                     * need to be processed in order.\n<line155>                     *\n<line156>                     * We make the whole method blocking to avoid any possible race condition on outstandingProposal and lastCommitted\n<line157>                     * as well as to avoid nested synchronization.\n<line158>                     *\n<line159>                     * As a more generic approach, we pass the object of forwardingFollowers to QuorumOracleMaj to determine if we need\n<line160>                     * the help from Oracle.\n<line161>                     *\n<line162>                     *\n<line163>                     * the size of outstandingProposals can be 1. The only one outstanding proposal is the one waiting for the ACK from\n<line164>                     * the leader itself.\n<line165>                     * */\n<line166>                if (!tickSkip && !syncedAckSet.hasAllQuorums() && !(self.getQuorumVerifier().overrideQuorumDecision(getForwardingFollowers()) && self.getQuorumVerifier().revalidateOutstandingProp(this, new ArrayList<>(outstandingProposals.values()), lastCommitted))) {\n<line167>                    // Lost quorum of last committed and/or last proposed\n<line168>                    // config, set shutdown flag\n<line169>                    shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \" + syncedAckSet.ackSetsToString() + \" ]\";\n<line170>                    break;\n<line171>                }\n<line172>                tickSkip = !tickSkip;\n<line173>            }\n<line174>            for (LearnerHandler f : getLearners()) {\n<line175>                f.ping();\n<line176>            }\n<line177>        }\n<line178>        if (shutdownMessage != null) {\n<line179>            shutdown(shutdownMessage);\n<line180>            // leader goes in looking state\n<line181>        }\n<line182>    } finally {\n<line183>        zk.unregisterJMX(this);\n<line184>    }\n<line185>}","output":"<line1>{\n<line2>    self.end_fle = Time.currentElapsedTime();\n<line3>    long electionTimeTaken = self.end_fle - self.start_fle;\n<line4>    self.setElectionTimeTaken(electionTimeTaken);\n<line5>    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n<line6>    LOG.info(\"LEADING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);\n<line7>    self.start_fle = 0;\n<line8>    self.end_fle = 0;\n<line9>    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n<line10>    try {\n<line11>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line12>        self.tick.set(0);\n<line13>        zk.loadData();\n<line14>        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n<line15>        // Start thread that waits for connection requests from\n<line16>        // new followers.\n<line17>        cnxAcceptor = new LearnerCnxAcceptor();\n<line18>        cnxAcceptor.start();\n<line19>        long epoch = getEpochToPropose(self.getMyId(), self.getAcceptedEpoch());\n<line20>        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n<line21>        synchronized (this) {\n<line22>            lastProposed = zk.getZxid();\n<line23>        }\n<line24>        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);\n<line25>        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n<line26>            LOG.info(\"NEWLEADER proposal has Zxid of {}\", Long.toHexString(newLeaderProposal.packet.getZxid()));\n<line27>        }\n<line28>        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line29>        QuorumVerifier curQV = self.getQuorumVerifier();\n<line30>        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n<line31>            // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n<line32>            // specified by the user; the lack of version in a config file is interpreted as version=0).\n<line33>            // As soon as a config is established we would like to increase its version so that it\n<line34>            // takes presedence over other initial configs that were not established (such as a config\n<line35>            // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n<line36>            // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n<line37>            // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n<line38>            // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n<line39>            // and there's still no agreement on the new version that we'd like to use. Instead, we use\n<line40>            // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n<line41>            // so its a good way to let followers know about the new version. (The original reason for sending\n<line42>            // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n<line43>            // that it finds before starting to propose operations. Here we're reusing the same code path for\n<line44>            // reaching consensus on the new version number.)\n<line45>            // It is important that this is done before the leader executes waitForEpochAck,\n<line46>            // so before LearnerHandlers return from their waitForEpochAck\n<line47>            // hence before they construct the NEWLEADER message containing\n<line48>            // the last-seen-quorumverifier of the leader, which we change below\n<line49>            try {\n<line50>                LOG.debug(String.format(\"set lastSeenQuorumVerifier to currentQuorumVerifier (%s)\", curQV.toString()));\n<line51>                QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line52>                newQV.setVersion(zk.getZxid());\n<line53>                self.setLastSeenQuorumVerifier(newQV, true);\n<line54>            } catch (Exception e) {\n<line55>                throw new IOException(e);\n<line56>            }\n<line57>        }\n<line58>        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n<line59>        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line60>            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line61>        }\n<line62>        // We have to get at least a majority of servers in sync with\n<line63>        // us. We do this by waiting for the NEWLEADER packet to get\n<line64>        // acknowledged\n<line65>        waitForEpochAck(self.getMyId(), leaderStateSummary);\n<line66>        self.setCurrentEpoch(epoch);\n<line67>        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getMyId());\n<line68>        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line69>        try {\n<line70>            waitForNewLeaderAck(self.getMyId(), zk.getZxid());\n<line71>        } catch (InterruptedException e) {\n<line72>            shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \" + newLeaderProposal.ackSetsToString() + \" ]\");\n<line73>            HashSet<Long> followerSet = new HashSet<>();\n<line74>            for (LearnerHandler f : getLearners()) {\n<line75>                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {\n<line76>                    followerSet.add(f.getSid());\n<line77>                }\n<line78>            }\n<line79>            boolean initTicksShouldBeIncreased = true;\n<line80>            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {\n<line81>                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n<line82>                    initTicksShouldBeIncreased = false;\n<line83>                    break;\n<line84>                }\n<line85>            }\n<line86>            if (initTicksShouldBeIncreased) {\n<line87>                LOG.warn(\"Enough followers present. Perhaps the initTicks need to be increased.\");\n<line88>            }\n<line89>            return;\n<line90>        }\n<line91>        startZkServer();\n<line92>        /**\n<line93>         * WARNING: do not use this for anything other than QA testing\n<line94>         * on a real cluster. Specifically to enable verification that quorum\n<line95>         * can handle the lower 32bit roll-over issue identified in\n<line96>         * ZOOKEEPER-1277. Without this option it would take a very long\n<line97>         * time (on order of a month say) to see the 4 billion writes\n<line98>         * necessary to cause the roll-over to occur.\n<line99>         *\n<line100>         * This field allows you to override the zxid of the server. Typically\n<line101>         * you'll want to set it to something like 0xfffffff0 and then\n<line102>         * start the quorum, run some operations and see the re-election.\n<line103>         */\n<line104>        String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n<line105>        if (initialZxid != null) {\n<line106>            long zxid = Long.parseLong(initialZxid);\n<line107>            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n<line108>        }\n<line109>        if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n<line110>            self.setZooKeeperServer(zk);\n<line111>        }\n<line112>        self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line113>        self.adminServer.setZooKeeperServer(zk);\n<line114>        // We ping twice a tick, so we only update the tick every other\n<line115>        // iteration\n<line116>        boolean tickSkip = true;\n<line117>        // If not null then shutdown this leader\n<line118>        String shutdownMessage = null;\n<line119>        while (true) {\n<line120>            synchronized (this) {\n<line121>                long start = Time.currentElapsedTime();\n<line122>                long cur = start;\n<line123>                long end = start + self.tickTime / 2;\n<line124>                while (cur < end) {\n<line125>                    wait(end - cur);\n<line126>                    cur = Time.currentElapsedTime();\n<line127>                }\n<line128>                if (!tickSkip) {\n<line129>                    self.tick.incrementAndGet();\n<line130>                }\n<line131>                // We use an instance of SyncedLearnerTracker to\n<line132>                // track synced learners to make sure we still have a\n<line133>                // quorum of current (and potentially next pending) view.\n<line134>                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n<line135>                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n<line136>                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line137>                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line138>                }\n<line139>                syncedAckSet.addAck(self.getMyId());\n<line140>                for (LearnerHandler f : getLearners()) {\n<line141>                    if (f.synced()) {\n<line142>                        syncedAckSet.addAck(f.getSid());\n<line143>                    }\n<line144>                }\n<line145>                // check leader running status\n<line146>                if (!this.isRunning()) {\n<line147>                    // set shutdown flag\n<line148>                    shutdownMessage = \"Unexpected internal error\";\n<line149>                    break;\n<line150>                }\n<line151>                /*\n<line152>                     *\n<line153>                     * We will need to re-validate the outstandingProposal to maintain the progress of ZooKeeper.\n<line154>                     * It is likely a proposal is waiting for enough ACKs to be committed. The proposals are sent out, but the\n<line155>                     * only follower goes away which makes the proposals will not be committed until the follower recovers back.\n<line156>                     * An earlier proposal which is not committed will block any further proposals. So, We need to re-validate those\n<line157>                     * outstanding proposal with the help from Oracle. A key point in the process of re-validation is that the proposals\n<line158>                     * need to be processed in order.\n<line159>                     *\n<line160>                     * We make the whole method blocking to avoid any possible race condition on outstandingProposal and lastCommitted\n<line161>                     * as well as to avoid nested synchronization.\n<line162>                     *\n<line163>                     * As a more generic approach, we pass the object of forwardingFollowers to QuorumOracleMaj to determine if we need\n<line164>                     * the help from Oracle.\n<line165>                     *\n<line166>                     *\n<line167>                     * the size of outstandingProposals can be 1. The only one outstanding proposal is the one waiting for the ACK from\n<line168>                     * the leader itself.\n<line169>                     * */\n<line170>                if (!tickSkip && !syncedAckSet.hasAllQuorums() && !(self.getQuorumVerifier().overrideQuorumDecision(getForwardingFollowers()) && self.getQuorumVerifier().revalidateOutstandingProp(this, new ArrayList<>(outstandingProposals.values()), lastCommitted))) {\n<line171>                    // Lost quorum of last committed and/or last proposed\n<line172>                    // config, set shutdown flag\n<line173>                    shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \" + syncedAckSet.ackSetsToString() + \" ]\";\n<line174>                    break;\n<line175>                }\n<line176>                tickSkip = !tickSkip;\n<line177>            }\n<line178>            for (LearnerHandler f : getLearners()) {\n<line179>                f.ping();\n<line180>            }\n<line181>        }\n<line182>        if (shutdownMessage != null) {\n<line183>            shutdown(shutdownMessage);\n<line184>            // leader goes in looking state\n<line185>        }\n<line186>    } finally {\n<line187>        zk.unregisterJMX(this);\n<line188>    }\n<line189>}"},{"input":"","instruction":"<line1>{\n<line2>    self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line3>    self.tick.set(0);\n<line4>    zk.loadData();\n<line5>    leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n<line6>    // Start thread that waits for connection requests from\n<line7>    // new followers.\n<line8>    cnxAcceptor = new LearnerCnxAcceptor();\n<line9>    cnxAcceptor.start();\n<line10>    long epoch = getEpochToPropose(self.getMyId(), self.getAcceptedEpoch());\n<line11>    zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n<line12>    synchronized (this) {\n<line13>        lastProposed = zk.getZxid();\n<line14>    }\n<line15>    newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);\n<line16>    if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n<line17>    }\n<line18>    QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line19>    QuorumVerifier curQV = self.getQuorumVerifier();\n<line20>    if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n<line21>        // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n<line22>        // specified by the user; the lack of version in a config file is interpreted as version=0).\n<line23>        // As soon as a config is established we would like to increase its version so that it\n<line24>        // takes presedence over other initial configs that were not established (such as a config\n<line25>        // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n<line26>        // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n<line27>        // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n<line28>        // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n<line29>        // and there's still no agreement on the new version that we'd like to use. Instead, we use\n<line30>        // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n<line31>        // so its a good way to let followers know about the new version. (The original reason for sending\n<line32>        // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n<line33>        // that it finds before starting to propose operations. Here we're reusing the same code path for\n<line34>        // reaching consensus on the new version number.)\n<line35>        // It is important that this is done before the leader executes waitForEpochAck,\n<line36>        // so before LearnerHandlers return from their waitForEpochAck\n<line37>        // hence before they construct the NEWLEADER message containing\n<line38>        // the last-seen-quorumverifier of the leader, which we change below\n<line39>        try {\n<line40>            QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line41>            newQV.setVersion(zk.getZxid());\n<line42>            self.setLastSeenQuorumVerifier(newQV, true);\n<line43>        } catch (Exception e) {\n<line44>            throw new IOException(e);\n<line45>        }\n<line46>    }\n<line47>    newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n<line48>    if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line49>        newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line50>    }\n<line51>    // We have to get at least a majority of servers in sync with\n<line52>    // us. We do this by waiting for the NEWLEADER packet to get\n<line53>    // acknowledged\n<line54>    waitForEpochAck(self.getMyId(), leaderStateSummary);\n<line55>    self.setCurrentEpoch(epoch);\n<line56>    self.setLeaderAddressAndId(self.getQuorumAddress(), self.getMyId());\n<line57>    self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line58>    try {\n<line59>        waitForNewLeaderAck(self.getMyId(), zk.getZxid());\n<line60>    } catch (InterruptedException e) {\n<line61>        shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \" + newLeaderProposal.ackSetsToString() + \" ]\");\n<line62>        HashSet<Long> followerSet = new HashSet<>();\n<line63>        for (LearnerHandler f : getLearners()) {\n<line64>            if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {\n<line65>                followerSet.add(f.getSid());\n<line66>            }\n<line67>        }\n<line68>        boolean initTicksShouldBeIncreased = true;\n<line69>        for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {\n<line70>            if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n<line71>                initTicksShouldBeIncreased = false;\n<line72>                break;\n<line73>            }\n<line74>        }\n<line75>        if (initTicksShouldBeIncreased) {\n<line76>        }\n<line77>        return;\n<line78>    }\n<line79>    startZkServer();\n<line80>    /**\n<line81>     * WARNING: do not use this for anything other than QA testing\n<line82>     * on a real cluster. Specifically to enable verification that quorum\n<line83>     * can handle the lower 32bit roll-over issue identified in\n<line84>     * ZOOKEEPER-1277. Without this option it would take a very long\n<line85>     * time (on order of a month say) to see the 4 billion writes\n<line86>     * necessary to cause the roll-over to occur.\n<line87>     *\n<line88>     * This field allows you to override the zxid of the server. Typically\n<line89>     * you'll want to set it to something like 0xfffffff0 and then\n<line90>     * start the quorum, run some operations and see the re-election.\n<line91>     */\n<line92>    String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n<line93>    if (initialZxid != null) {\n<line94>        long zxid = Long.parseLong(initialZxid);\n<line95>        zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n<line96>    }\n<line97>    if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n<line98>        self.setZooKeeperServer(zk);\n<line99>    }\n<line100>    self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line101>    self.adminServer.setZooKeeperServer(zk);\n<line102>    // We ping twice a tick, so we only update the tick every other\n<line103>    // iteration\n<line104>    boolean tickSkip = true;\n<line105>    // If not null then shutdown this leader\n<line106>    String shutdownMessage = null;\n<line107>    while (true) {\n<line108>        synchronized (this) {\n<line109>            long start = Time.currentElapsedTime();\n<line110>            long cur = start;\n<line111>            long end = start + self.tickTime / 2;\n<line112>            while (cur < end) {\n<line113>                wait(end - cur);\n<line114>                cur = Time.currentElapsedTime();\n<line115>            }\n<line116>            if (!tickSkip) {\n<line117>                self.tick.incrementAndGet();\n<line118>            }\n<line119>            // We use an instance of SyncedLearnerTracker to\n<line120>            // track synced learners to make sure we still have a\n<line121>            // quorum of current (and potentially next pending) view.\n<line122>            SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n<line123>            syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n<line124>            if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line125>                syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line126>            }\n<line127>            syncedAckSet.addAck(self.getMyId());\n<line128>            for (LearnerHandler f : getLearners()) {\n<line129>                if (f.synced()) {\n<line130>                    syncedAckSet.addAck(f.getSid());\n<line131>                }\n<line132>            }\n<line133>            // check leader running status\n<line134>            if (!this.isRunning()) {\n<line135>                // set shutdown flag\n<line136>                shutdownMessage = \"Unexpected internal error\";\n<line137>                break;\n<line138>            }\n<line139>            /*\n<line140>                     *\n<line141>                     * We will need to re-validate the outstandingProposal to maintain the progress of ZooKeeper.\n<line142>                     * It is likely a proposal is waiting for enough ACKs to be committed. The proposals are sent out, but the\n<line143>                     * only follower goes away which makes the proposals will not be committed until the follower recovers back.\n<line144>                     * An earlier proposal which is not committed will block any further proposals. So, We need to re-validate those\n<line145>                     * outstanding proposal with the help from Oracle. A key point in the process of re-validation is that the proposals\n<line146>                     * need to be processed in order.\n<line147>                     *\n<line148>                     * We make the whole method blocking to avoid any possible race condition on outstandingProposal and lastCommitted\n<line149>                     * as well as to avoid nested synchronization.\n<line150>                     *\n<line151>                     * As a more generic approach, we pass the object of forwardingFollowers to QuorumOracleMaj to determine if we need\n<line152>                     * the help from Oracle.\n<line153>                     *\n<line154>                     *\n<line155>                     * the size of outstandingProposals can be 1. The only one outstanding proposal is the one waiting for the ACK from\n<line156>                     * the leader itself.\n<line157>                     * */\n<line158>            if (!tickSkip && !syncedAckSet.hasAllQuorums() && !(self.getQuorumVerifier().overrideQuorumDecision(getForwardingFollowers()) && self.getQuorumVerifier().revalidateOutstandingProp(this, new ArrayList<>(outstandingProposals.values()), lastCommitted))) {\n<line159>                // Lost quorum of last committed and/or last proposed\n<line160>                // config, set shutdown flag\n<line161>                shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \" + syncedAckSet.ackSetsToString() + \" ]\";\n<line162>                break;\n<line163>            }\n<line164>            tickSkip = !tickSkip;\n<line165>        }\n<line166>        for (LearnerHandler f : getLearners()) {\n<line167>            f.ping();\n<line168>        }\n<line169>    }\n<line170>    if (shutdownMessage != null) {\n<line171>        shutdown(shutdownMessage);\n<line172>        // leader goes in looking state\n<line173>    }\n<line174>}","output":"<line1>{\n<line2>    self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line3>    self.tick.set(0);\n<line4>    zk.loadData();\n<line5>    leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n<line6>    // Start thread that waits for connection requests from\n<line7>    // new followers.\n<line8>    cnxAcceptor = new LearnerCnxAcceptor();\n<line9>    cnxAcceptor.start();\n<line10>    long epoch = getEpochToPropose(self.getMyId(), self.getAcceptedEpoch());\n<line11>    zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n<line12>    synchronized (this) {\n<line13>        lastProposed = zk.getZxid();\n<line14>    }\n<line15>    newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);\n<line16>    if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n<line17>        LOG.info(\"NEWLEADER proposal has Zxid of {}\", Long.toHexString(newLeaderProposal.packet.getZxid()));\n<line18>    }\n<line19>    QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n<line20>    QuorumVerifier curQV = self.getQuorumVerifier();\n<line21>    if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n<line22>        // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n<line23>        // specified by the user; the lack of version in a config file is interpreted as version=0).\n<line24>        // As soon as a config is established we would like to increase its version so that it\n<line25>        // takes presedence over other initial configs that were not established (such as a config\n<line26>        // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n<line27>        // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n<line28>        // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n<line29>        // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n<line30>        // and there's still no agreement on the new version that we'd like to use. Instead, we use\n<line31>        // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n<line32>        // so its a good way to let followers know about the new version. (The original reason for sending\n<line33>        // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n<line34>        // that it finds before starting to propose operations. Here we're reusing the same code path for\n<line35>        // reaching consensus on the new version number.)\n<line36>        // It is important that this is done before the leader executes waitForEpochAck,\n<line37>        // so before LearnerHandlers return from their waitForEpochAck\n<line38>        // hence before they construct the NEWLEADER message containing\n<line39>        // the last-seen-quorumverifier of the leader, which we change below\n<line40>        try {\n<line41>            LOG.debug(String.format(\"set lastSeenQuorumVerifier to currentQuorumVerifier (%s)\", curQV.toString()));\n<line42>            QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line43>            newQV.setVersion(zk.getZxid());\n<line44>            self.setLastSeenQuorumVerifier(newQV, true);\n<line45>        } catch (Exception e) {\n<line46>            throw new IOException(e);\n<line47>        }\n<line48>    }\n<line49>    newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n<line50>    if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line51>        newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line52>    }\n<line53>    // We have to get at least a majority of servers in sync with\n<line54>    // us. We do this by waiting for the NEWLEADER packet to get\n<line55>    // acknowledged\n<line56>    waitForEpochAck(self.getMyId(), leaderStateSummary);\n<line57>    self.setCurrentEpoch(epoch);\n<line58>    self.setLeaderAddressAndId(self.getQuorumAddress(), self.getMyId());\n<line59>    self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line60>    try {\n<line61>        waitForNewLeaderAck(self.getMyId(), zk.getZxid());\n<line62>    } catch (InterruptedException e) {\n<line63>        shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \" + newLeaderProposal.ackSetsToString() + \" ]\");\n<line64>        HashSet<Long> followerSet = new HashSet<>();\n<line65>        for (LearnerHandler f : getLearners()) {\n<line66>            if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {\n<line67>                followerSet.add(f.getSid());\n<line68>            }\n<line69>        }\n<line70>        boolean initTicksShouldBeIncreased = true;\n<line71>        for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {\n<line72>            if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n<line73>                initTicksShouldBeIncreased = false;\n<line74>                break;\n<line75>            }\n<line76>        }\n<line77>        if (initTicksShouldBeIncreased) {\n<line78>            LOG.warn(\"Enough followers present. Perhaps the initTicks need to be increased.\");\n<line79>        }\n<line80>        return;\n<line81>    }\n<line82>    startZkServer();\n<line83>    /**\n<line84>     * WARNING: do not use this for anything other than QA testing\n<line85>     * on a real cluster. Specifically to enable verification that quorum\n<line86>     * can handle the lower 32bit roll-over issue identified in\n<line87>     * ZOOKEEPER-1277. Without this option it would take a very long\n<line88>     * time (on order of a month say) to see the 4 billion writes\n<line89>     * necessary to cause the roll-over to occur.\n<line90>     *\n<line91>     * This field allows you to override the zxid of the server. Typically\n<line92>     * you'll want to set it to something like 0xfffffff0 and then\n<line93>     * start the quorum, run some operations and see the re-election.\n<line94>     */\n<line95>    String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n<line96>    if (initialZxid != null) {\n<line97>        long zxid = Long.parseLong(initialZxid);\n<line98>        zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n<line99>    }\n<line100>    if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n<line101>        self.setZooKeeperServer(zk);\n<line102>    }\n<line103>    self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line104>    self.adminServer.setZooKeeperServer(zk);\n<line105>    // We ping twice a tick, so we only update the tick every other\n<line106>    // iteration\n<line107>    boolean tickSkip = true;\n<line108>    // If not null then shutdown this leader\n<line109>    String shutdownMessage = null;\n<line110>    while (true) {\n<line111>        synchronized (this) {\n<line112>            long start = Time.currentElapsedTime();\n<line113>            long cur = start;\n<line114>            long end = start + self.tickTime / 2;\n<line115>            while (cur < end) {\n<line116>                wait(end - cur);\n<line117>                cur = Time.currentElapsedTime();\n<line118>            }\n<line119>            if (!tickSkip) {\n<line120>                self.tick.incrementAndGet();\n<line121>            }\n<line122>            // We use an instance of SyncedLearnerTracker to\n<line123>            // track synced learners to make sure we still have a\n<line124>            // quorum of current (and potentially next pending) view.\n<line125>            SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n<line126>            syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n<line127>            if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {\n<line128>                syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line129>            }\n<line130>            syncedAckSet.addAck(self.getMyId());\n<line131>            for (LearnerHandler f : getLearners()) {\n<line132>                if (f.synced()) {\n<line133>                    syncedAckSet.addAck(f.getSid());\n<line134>                }\n<line135>            }\n<line136>            // check leader running status\n<line137>            if (!this.isRunning()) {\n<line138>                // set shutdown flag\n<line139>                shutdownMessage = \"Unexpected internal error\";\n<line140>                break;\n<line141>            }\n<line142>            /*\n<line143>                     *\n<line144>                     * We will need to re-validate the outstandingProposal to maintain the progress of ZooKeeper.\n<line145>                     * It is likely a proposal is waiting for enough ACKs to be committed. The proposals are sent out, but the\n<line146>                     * only follower goes away which makes the proposals will not be committed until the follower recovers back.\n<line147>                     * An earlier proposal which is not committed will block any further proposals. So, We need to re-validate those\n<line148>                     * outstanding proposal with the help from Oracle. A key point in the process of re-validation is that the proposals\n<line149>                     * need to be processed in order.\n<line150>                     *\n<line151>                     * We make the whole method blocking to avoid any possible race condition on outstandingProposal and lastCommitted\n<line152>                     * as well as to avoid nested synchronization.\n<line153>                     *\n<line154>                     * As a more generic approach, we pass the object of forwardingFollowers to QuorumOracleMaj to determine if we need\n<line155>                     * the help from Oracle.\n<line156>                     *\n<line157>                     *\n<line158>                     * the size of outstandingProposals can be 1. The only one outstanding proposal is the one waiting for the ACK from\n<line159>                     * the leader itself.\n<line160>                     * */\n<line161>            if (!tickSkip && !syncedAckSet.hasAllQuorums() && !(self.getQuorumVerifier().overrideQuorumDecision(getForwardingFollowers()) && self.getQuorumVerifier().revalidateOutstandingProp(this, new ArrayList<>(outstandingProposals.values()), lastCommitted))) {\n<line162>                // Lost quorum of last committed and/or last proposed\n<line163>                // config, set shutdown flag\n<line164>                shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \" + syncedAckSet.ackSetsToString() + \" ]\";\n<line165>                break;\n<line166>            }\n<line167>            tickSkip = !tickSkip;\n<line168>        }\n<line169>        for (LearnerHandler f : getLearners()) {\n<line170>            f.ping();\n<line171>        }\n<line172>    }\n<line173>    if (shutdownMessage != null) {\n<line174>        shutdown(shutdownMessage);\n<line175>        // leader goes in looking state\n<line176>    }\n<line177>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"NEWLEADER proposal has Zxid of {}\", Long.toHexString(newLeaderProposal.packet.getZxid()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n<line3>    // specified by the user; the lack of version in a config file is interpreted as version=0).\n<line4>    // As soon as a config is established we would like to increase its version so that it\n<line5>    // takes presedence over other initial configs that were not established (such as a config\n<line6>    // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n<line7>    // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n<line8>    // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n<line9>    // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n<line10>    // and there's still no agreement on the new version that we'd like to use. Instead, we use\n<line11>    // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n<line12>    // so its a good way to let followers know about the new version. (The original reason for sending\n<line13>    // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n<line14>    // that it finds before starting to propose operations. Here we're reusing the same code path for\n<line15>    // reaching consensus on the new version number.)\n<line16>    // It is important that this is done before the leader executes waitForEpochAck,\n<line17>    // so before LearnerHandlers return from their waitForEpochAck\n<line18>    // hence before they construct the NEWLEADER message containing\n<line19>    // the last-seen-quorumverifier of the leader, which we change below\n<line20>    try {\n<line21>        QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line22>        newQV.setVersion(zk.getZxid());\n<line23>        self.setLastSeenQuorumVerifier(newQV, true);\n<line24>    } catch (Exception e) {\n<line25>        throw new IOException(e);\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n<line3>    // specified by the user; the lack of version in a config file is interpreted as version=0).\n<line4>    // As soon as a config is established we would like to increase its version so that it\n<line5>    // takes presedence over other initial configs that were not established (such as a config\n<line6>    // of a server trying to join the ensemble, which may be a partial view of the system, not the full config).\n<line7>    // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n<line8>    // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n<line9>    // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier,\n<line10>    // and there's still no agreement on the new version that we'd like to use. Instead, we use\n<line11>    // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n<line12>    // so its a good way to let followers know about the new version. (The original reason for sending\n<line13>    // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n<line14>    // that it finds before starting to propose operations. Here we're reusing the same code path for\n<line15>    // reaching consensus on the new version number.)\n<line16>    // It is important that this is done before the leader executes waitForEpochAck,\n<line17>    // so before LearnerHandlers return from their waitForEpochAck\n<line18>    // hence before they construct the NEWLEADER message containing\n<line19>    // the last-seen-quorumverifier of the leader, which we change below\n<line20>    try {\n<line21>        LOG.debug(String.format(\"set lastSeenQuorumVerifier to currentQuorumVerifier (%s)\", curQV.toString()));\n<line22>        QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line23>        newQV.setVersion(zk.getZxid());\n<line24>        self.setLastSeenQuorumVerifier(newQV, true);\n<line25>    } catch (Exception e) {\n<line26>        throw new IOException(e);\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line3>    newQV.setVersion(zk.getZxid());\n<line4>    self.setLastSeenQuorumVerifier(newQV, true);\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(String.format(\"set lastSeenQuorumVerifier to currentQuorumVerifier (%s)\", curQV.toString()));\n<line3>    QuorumVerifier newQV = self.configFromString(curQV.toString());\n<line4>    newQV.setVersion(zk.getZxid());\n<line5>    self.setLastSeenQuorumVerifier(newQV, true);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (isShutdown) {\n<line3>        return;\n<line4>    }\n<line5>    if (cnxAcceptor != null) {\n<line6>        cnxAcceptor.halt();\n<line7>    } else {\n<line8>        closeSockets();\n<line9>    }\n<line10>    // NIO should not accept conenctions\n<line11>    self.setZooKeeperServer(null);\n<line12>    self.adminServer.setZooKeeperServer(null);\n<line13>    self.closeAllConnections();\n<line14>    // shutdown the previous zk\n<line15>    if (zk != null) {\n<line16>        zk.shutdown();\n<line17>    }\n<line18>    synchronized (learners) {\n<line19>        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {\n<line20>            LearnerHandler f = it.next();\n<line21>            it.remove();\n<line22>            f.shutdown();\n<line23>        }\n<line24>    }\n<line25>    isShutdown = true;\n<line26>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    if (isShutdown) {\n<line4>        return;\n<line5>    }\n<line6>    LOG.info(\"Shutdown called. For the reason {}\", reason);\n<line7>    if (cnxAcceptor != null) {\n<line8>        cnxAcceptor.halt();\n<line9>    } else {\n<line10>        closeSockets();\n<line11>    }\n<line12>    // NIO should not accept conenctions\n<line13>    self.setZooKeeperServer(null);\n<line14>    self.adminServer.setZooKeeperServer(null);\n<line15>    self.closeAllConnections();\n<line16>    // shutdown the previous zk\n<line17>    if (zk != null) {\n<line18>        zk.shutdown();\n<line19>    }\n<line20>    synchronized (learners) {\n<line21>        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {\n<line22>            LearnerHandler f = it.next();\n<line23>            it.remove();\n<line24>            f.shutdown();\n<line25>        }\n<line26>    }\n<line27>    isShutdown = true;\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    // make sure that ops are committed in order. With reconfigurations it is now possible\n<line3>    // that different operations wait for different sets of acks, and we still want to enforce\n<line4>    // that they are committed in order. Currently we only permit one outstanding reconfiguration\n<line5>    // such that the reconfiguration and subsequent outstanding ops proposed while the reconfig is\n<line6>    // pending all wait for a quorum of old and new config, so it's not possible to get enough acks\n<line7>    // for an operation without getting enough acks for preceding ops. But in the future if multiple\n<line8>    // concurrent reconfigs are allowed, this can happen.\n<line9>    if (outstandingProposals.containsKey(zxid - 1)) {\n<line10>        return false;\n<line11>    }\n<line12>    // in order to be committed, a proposal must be accepted by a quorum.\n<line13>    //\n<line14>    // getting a quorum from all necessary configurations.\n<line15>    if (!p.hasAllQuorums()) {\n<line16>        return false;\n<line17>    }\n<line18>    // commit proposals in order\n<line19>    if (zxid != lastCommitted + 1) {\n<line20>    }\n<line21>    outstandingProposals.remove(zxid);\n<line22>    if (p.request != null) {\n<line23>        toBeApplied.add(p);\n<line24>    }\n<line25>    if (p.request == null) {\n<line26>    } else if (p.request.getHdr().getType() == OpCode.reconfig) {\n<line27>        //if this server is voter in new config with the same quorum address,\n<line28>        //then it will remain the leader\n<line29>        //otherwise an up-to-date follower will be designated as leader. This saves\n<line30>        //leader election time, unless the designated leader fails\n<line31>        Long designatedLeader = getDesignatedLeader(p, zxid);\n<line32>        QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();\n<line33>        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n<line34>        if (designatedLeader != self.getMyId()) {\n<line35>            allowedToCommit = false;\n<line36>        }\n<line37>        // we're sending the designated leader, and if the leader is changing the followers are\n<line38>        // responsible for closing the connection - this way we are sure that at least a majority of them\n<line39>        // receive the commit message.\n<line40>        commitAndActivate(zxid, designatedLeader);\n<line41>        informAndActivate(p, designatedLeader);\n<line42>    } else {\n<line43>        p.request.logLatency(ServerMetrics.getMetrics().QUORUM_ACK_LATENCY);\n<line44>        commit(zxid);\n<line45>        inform(p);\n<line46>    }\n<line47>    zk.commitProcessor.commit(p.request);\n<line48>    if (pendingSyncs.containsKey(zxid)) {\n<line49>        for (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {\n<line50>            sendSync(r);\n<line51>        }\n<line52>    }\n<line53>    return true;\n<line54>}","output":"<line1>{\n<line2>    // make sure that ops are committed in order. With reconfigurations it is now possible\n<line3>    // that different operations wait for different sets of acks, and we still want to enforce\n<line4>    // that they are committed in order. Currently we only permit one outstanding reconfiguration\n<line5>    // such that the reconfiguration and subsequent outstanding ops proposed while the reconfig is\n<line6>    // pending all wait for a quorum of old and new config, so it's not possible to get enough acks\n<line7>    // for an operation without getting enough acks for preceding ops. But in the future if multiple\n<line8>    // concurrent reconfigs are allowed, this can happen.\n<line9>    if (outstandingProposals.containsKey(zxid - 1)) {\n<line10>        return false;\n<line11>    }\n<line12>    // in order to be committed, a proposal must be accepted by a quorum.\n<line13>    //\n<line14>    // getting a quorum from all necessary configurations.\n<line15>    if (!p.hasAllQuorums()) {\n<line16>        return false;\n<line17>    }\n<line18>    // commit proposals in order\n<line19>    if (zxid != lastCommitted + 1) {\n<line20>        LOG.warn(\"Commiting zxid 0x{} from {} not first!\", Long.toHexString(zxid), followerAddr);\n<line21>        LOG.warn(\"First is 0x{}\", Long.toHexString(lastCommitted + 1));\n<line22>    }\n<line23>    outstandingProposals.remove(zxid);\n<line24>    if (p.request != null) {\n<line25>        toBeApplied.add(p);\n<line26>    }\n<line27>    if (p.request == null) {\n<line28>        LOG.warn(\"Going to commit null: {}\", p);\n<line29>    } else if (p.request.getHdr().getType() == OpCode.reconfig) {\n<line30>        LOG.debug(\"Committing a reconfiguration! {}\", outstandingProposals.size());\n<line31>        //if this server is voter in new config with the same quorum address,\n<line32>        //then it will remain the leader\n<line33>        //otherwise an up-to-date follower will be designated as leader. This saves\n<line34>        //leader election time, unless the designated leader fails\n<line35>        Long designatedLeader = getDesignatedLeader(p, zxid);\n<line36>        QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();\n<line37>        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n<line38>        if (designatedLeader != self.getMyId()) {\n<line39>            LOG.info(String.format(\"Committing a reconfiguration (reconfigEnabled=%s); this leader is not the designated \" + \"leader anymore, setting allowedToCommit=false\", self.isReconfigEnabled()));\n<line40>            allowedToCommit = false;\n<line41>        }\n<line42>        // we're sending the designated leader, and if the leader is changing the followers are\n<line43>        // responsible for closing the connection - this way we are sure that at least a majority of them\n<line44>        // receive the commit message.\n<line45>        commitAndActivate(zxid, designatedLeader);\n<line46>        informAndActivate(p, designatedLeader);\n<line47>    } else {\n<line48>        p.request.logLatency(ServerMetrics.getMetrics().QUORUM_ACK_LATENCY);\n<line49>        commit(zxid);\n<line50>        inform(p);\n<line51>    }\n<line52>    zk.commitProcessor.commit(p.request);\n<line53>    if (pendingSyncs.containsKey(zxid)) {\n<line54>        for (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {\n<line55>            sendSync(r);\n<line56>        }\n<line57>    }\n<line58>    return true;\n<line59>}"},{"input":"","instruction":"<line1>{\n<line2>    //if this server is voter in new config with the same quorum address,\n<line3>    //then it will remain the leader\n<line4>    //otherwise an up-to-date follower will be designated as leader. This saves\n<line5>    //leader election time, unless the designated leader fails\n<line6>    Long designatedLeader = getDesignatedLeader(p, zxid);\n<line7>    QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();\n<line8>    self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n<line9>    if (designatedLeader != self.getMyId()) {\n<line10>        allowedToCommit = false;\n<line11>    }\n<line12>    // we're sending the designated leader, and if the leader is changing the followers are\n<line13>    // responsible for closing the connection - this way we are sure that at least a majority of them\n<line14>    // receive the commit message.\n<line15>    commitAndActivate(zxid, designatedLeader);\n<line16>    informAndActivate(p, designatedLeader);\n<line17>}","output":"<line1>{\n<line2>    LOG.debug(\"Committing a reconfiguration! {}\", outstandingProposals.size());\n<line3>    //if this server is voter in new config with the same quorum address,\n<line4>    //then it will remain the leader\n<line5>    //otherwise an up-to-date follower will be designated as leader. This saves\n<line6>    //leader election time, unless the designated leader fails\n<line7>    Long designatedLeader = getDesignatedLeader(p, zxid);\n<line8>    QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();\n<line9>    self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n<line10>    if (designatedLeader != self.getMyId()) {\n<line11>        LOG.info(String.format(\"Committing a reconfiguration (reconfigEnabled=%s); this leader is not the designated \" + \"leader anymore, setting allowedToCommit=false\", self.isReconfigEnabled()));\n<line12>        allowedToCommit = false;\n<line13>    }\n<line14>    // we're sending the designated leader, and if the leader is changing the followers are\n<line15>    // responsible for closing the connection - this way we are sure that at least a majority of them\n<line16>    // receive the commit message.\n<line17>    commitAndActivate(zxid, designatedLeader);\n<line18>    informAndActivate(p, designatedLeader);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    allowedToCommit = false;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(String.format(\"Committing a reconfiguration (reconfigEnabled=%s); this leader is not the designated \" + \"leader anymore, setting allowedToCommit=false\", self.isReconfigEnabled()));\n<line3>    allowedToCommit = false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!allowedToCommit) {\n<line3>        // last op committed was a leader change - from now on\n<line4>        return;\n<line5>    }\n<line6>    // the new leader should commit\n<line7>        for (Proposal p : outstandingProposals.values()) {\n<line8>            long packetZxid = p.packet.getZxid();\n<line9>        }\n<line10>    }\n<line11>    if ((zxid & 0xffffffffL) == 0) {\n<line12>        /*\n<line13>             * We no longer process NEWLEADER ack with this method. However,\n<line14>             * the learner sends an ack back to the leader after it gets\n<line15>             * UPTODATE, so we just ignore the message.\n<line16>             */\n<line17>        return;\n<line18>    }\n<line19>    if (outstandingProposals.size() == 0) {\n<line20>        return;\n<line21>    }\n<line22>    if (lastCommitted >= zxid) {\n<line23>        // The proposal has already been committed\n<line24>        return;\n<line25>    }\n<line26>    Proposal p = outstandingProposals.get(zxid);\n<line27>    if (p == null) {\n<line28>        return;\n<line29>    }\n<line30>    if (ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0)) {\n<line31>        p.request.logLatency(ServerMetrics.getMetrics().ACK_LATENCY, Long.toString(sid));\n<line32>    }\n<line33>    p.addAck(sid);\n<line34>    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);\n<line35>    // If p is a reconfiguration, multiple other operations may be ready to be committed,\n<line36>    // since operations wait for different sets of acks.\n<line37>    // Currently we only permit one outstanding reconfiguration at a time\n<line38>    // such that the reconfiguration and subsequent outstanding ops proposed while the reconfig is\n<line39>    // pending all wait for a quorum of old and new config, so its not possible to get enough acks\n<line40>    // for an operation without getting enough acks for preceding ops. But in the future if multiple\n<line41>    // concurrent reconfigs are allowed, this can happen and then we need to check whether some pending\n<line42>    // ops may already have enough acks and can be committed, which is what this code does.\n<line43>    if (hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig) {\n<line44>        long curZxid = zxid;\n<line45>        while (allowedToCommit && hasCommitted && p != null) {\n<line46>            curZxid++;\n<line47>            p = outstandingProposals.get(curZxid);\n<line48>            if (p != null) {\n<line49>                hasCommitted = tryToCommit(p, curZxid, null);\n<line50>            }\n<line51>        }\n<line52>    }\n<line53>}","output":"<line1>{\n<line2>    if (!allowedToCommit) {\n<line3>        // last op committed was a leader change - from now on\n<line4>        return;\n<line5>    }\n<line6>    // the new leader should commit\n<line7>    if (LOG.isTraceEnabled()) {\n<line8>        LOG.trace(\"Ack zxid: 0x{}\", Long.toHexString(zxid));\n<line9>        for (Proposal p : outstandingProposals.values()) {\n<line10>            long packetZxid = p.packet.getZxid();\n<line11>            LOG.trace(\"outstanding proposal: 0x{}\", Long.toHexString(packetZxid));\n<line12>        }\n<line13>        LOG.trace(\"outstanding proposals all\");\n<line14>    }\n<line15>    if ((zxid & 0xffffffffL) == 0) {\n<line16>        /*\n<line17>             * We no longer process NEWLEADER ack with this method. However,\n<line18>             * the learner sends an ack back to the leader after it gets\n<line19>             * UPTODATE, so we just ignore the message.\n<line20>             */\n<line21>        return;\n<line22>    }\n<line23>    if (outstandingProposals.size() == 0) {\n<line24>        LOG.debug(\"outstanding is 0\");\n<line25>        return;\n<line26>    }\n<line27>    if (lastCommitted >= zxid) {\n<line28>        LOG.debug(\"proposal has already been committed, pzxid: 0x{} zxid: 0x{}\", Long.toHexString(lastCommitted), Long.toHexString(zxid));\n<line29>        // The proposal has already been committed\n<line30>        return;\n<line31>    }\n<line32>    Proposal p = outstandingProposals.get(zxid);\n<line33>    if (p == null) {\n<line34>        LOG.warn(\"Trying to commit future proposal: zxid 0x{} from {}\", Long.toHexString(zxid), followerAddr);\n<line35>        return;\n<line36>    }\n<line37>    if (ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0)) {\n<line38>        p.request.logLatency(ServerMetrics.getMetrics().ACK_LATENCY, Long.toString(sid));\n<line39>    }\n<line40>    p.addAck(sid);\n<line41>    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);\n<line42>    // If p is a reconfiguration, multiple other operations may be ready to be committed,\n<line43>    // since operations wait for different sets of acks.\n<line44>    // Currently we only permit one outstanding reconfiguration at a time\n<line45>    // such that the reconfiguration and subsequent outstanding ops proposed while the reconfig is\n<line46>    // pending all wait for a quorum of old and new config, so its not possible to get enough acks\n<line47>    // for an operation without getting enough acks for preceding ops. But in the future if multiple\n<line48>    // concurrent reconfigs are allowed, this can happen and then we need to check whether some pending\n<line49>    // ops may already have enough acks and can be committed, which is what this code does.\n<line50>    if (hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig) {\n<line51>        long curZxid = zxid;\n<line52>        while (allowedToCommit && hasCommitted && p != null) {\n<line53>            curZxid++;\n<line54>            p = outstandingProposals.get(curZxid);\n<line55>            if (p != null) {\n<line56>                hasCommitted = tryToCommit(p, curZxid, null);\n<line57>            }\n<line58>        }\n<line59>    }\n<line60>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"outstanding is 0\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // The proposal has already been committed\n<line3>    return;\n<line4>}","output":"<line1>{\n<line2>    LOG.debug(\"proposal has already been committed, pzxid: 0x{} zxid: 0x{}\", Long.toHexString(lastCommitted), Long.toHexString(zxid));\n<line3>    // The proposal has already been committed\n<line4>    return;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    next.processRequest(request);\n<line3>    // The only requests that should be on toBeApplied are write\n<line4>    // requests, for which we will have a hdr. We can't simply use\n<line5>    // request.zxid here because that is set on read requests to equal\n<line6>    // the zxid of the last write op.\n<line7>    if (request.getHdr() != null) {\n<line8>        long zxid = request.getHdr().getZxid();\n<line9>        Iterator<Proposal> iter = leader.toBeApplied.iterator();\n<line10>        if (iter.hasNext()) {\n<line11>            Proposal p = iter.next();\n<line12>            if (p.request != null && p.request.zxid == zxid) {\n<line13>                iter.remove();\n<line14>                return;\n<line15>            }\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    next.processRequest(request);\n<line3>    // The only requests that should be on toBeApplied are write\n<line4>    // requests, for which we will have a hdr. We can't simply use\n<line5>    // request.zxid here because that is set on read requests to equal\n<line6>    // the zxid of the last write op.\n<line7>    if (request.getHdr() != null) {\n<line8>        long zxid = request.getHdr().getZxid();\n<line9>        Iterator<Proposal> iter = leader.toBeApplied.iterator();\n<line10>        if (iter.hasNext()) {\n<line11>            Proposal p = iter.next();\n<line12>            if (p.request != null && p.request.zxid == zxid) {\n<line13>                iter.remove();\n<line14>                return;\n<line15>            }\n<line16>        }\n<line17>        LOG.error(\"Committed request not found on toBeApplied: {}\", request);\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    long zxid = request.getHdr().getZxid();\n<line3>    Iterator<Proposal> iter = leader.toBeApplied.iterator();\n<line4>    if (iter.hasNext()) {\n<line5>        Proposal p = iter.next();\n<line6>        if (p.request != null && p.request.zxid == zxid) {\n<line7>            iter.remove();\n<line8>            return;\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    long zxid = request.getHdr().getZxid();\n<line3>    Iterator<Proposal> iter = leader.toBeApplied.iterator();\n<line4>    if (iter.hasNext()) {\n<line5>        Proposal p = iter.next();\n<line6>        if (p.request != null && p.request.zxid == zxid) {\n<line7>            iter.remove();\n<line8>            return;\n<line9>        }\n<line10>    }\n<line11>    LOG.error(\"Committed request not found on toBeApplied: {}\", request);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    next.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    next.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.isThrottled()) {\n<line3>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>    }\n<line5>    /**\n<line6>     * Address the rollover issue. All lower 32bits set indicate a new leader\n<line7>     * election. Force a re-election instead. See ZOOKEEPER-1277\n<line8>     */\n<line9>    if ((request.zxid & 0xffffffffL) == 0xffffffffL) {\n<line10>        String msg = \"zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start\";\n<line11>        shutdown(msg);\n<line12>        throw new XidRolloverException(msg);\n<line13>    }\n<line14>    byte[] data = request.getSerializeData();\n<line15>    proposalStats.setLastBufferSize(data.length);\n<line16>    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);\n<line17>    Proposal p = new Proposal(request, pp);\n<line18>    synchronized (this) {\n<line19>        p.addQuorumVerifier(self.getQuorumVerifier());\n<line20>        if (request.getHdr().getType() == OpCode.reconfig) {\n<line21>            self.setLastSeenQuorumVerifier(request.qv, true);\n<line22>        }\n<line23>        if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {\n<line24>            p.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line25>        }\n<line26>        lastProposed = p.packet.getZxid();\n<line27>        outstandingProposals.put(lastProposed, p);\n<line28>        sendPacket(pp);\n<line29>    }\n<line30>    ServerMetrics.getMetrics().PROPOSAL_COUNT.add(1);\n<line31>    return p;\n<line32>}","output":"<line1>{\n<line2>    if (request.isThrottled()) {\n<line3>        LOG.error(\"Throttled request send as proposal: {}. Exiting.\", request);\n<line4>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line5>    }\n<line6>    /**\n<line7>     * Address the rollover issue. All lower 32bits set indicate a new leader\n<line8>     * election. Force a re-election instead. See ZOOKEEPER-1277\n<line9>     */\n<line10>    if ((request.zxid & 0xffffffffL) == 0xffffffffL) {\n<line11>        String msg = \"zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start\";\n<line12>        shutdown(msg);\n<line13>        throw new XidRolloverException(msg);\n<line14>    }\n<line15>    byte[] data = request.getSerializeData();\n<line16>    proposalStats.setLastBufferSize(data.length);\n<line17>    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);\n<line18>    Proposal p = new Proposal(request, pp);\n<line19>    synchronized (this) {\n<line20>        p.addQuorumVerifier(self.getQuorumVerifier());\n<line21>        if (request.getHdr().getType() == OpCode.reconfig) {\n<line22>            self.setLastSeenQuorumVerifier(request.qv, true);\n<line23>        }\n<line24>        if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {\n<line25>            p.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line26>        }\n<line27>        LOG.debug(\"Proposing:: {}\", request);\n<line28>        lastProposed = p.packet.getZxid();\n<line29>        outstandingProposals.put(lastProposed, p);\n<line30>        sendPacket(pp);\n<line31>    }\n<line32>    ServerMetrics.getMetrics().PROPOSAL_COUNT.add(1);\n<line33>    return p;\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Throttled request send as proposal: {}. Exiting.\", request);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    p.addQuorumVerifier(self.getQuorumVerifier());\n<line3>    if (request.getHdr().getType() == OpCode.reconfig) {\n<line4>        self.setLastSeenQuorumVerifier(request.qv, true);\n<line5>    }\n<line6>    if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {\n<line7>        p.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line8>    }\n<line9>    lastProposed = p.packet.getZxid();\n<line10>    outstandingProposals.put(lastProposed, p);\n<line11>    sendPacket(pp);\n<line12>}","output":"<line1>{\n<line2>    p.addQuorumVerifier(self.getQuorumVerifier());\n<line3>    if (request.getHdr().getType() == OpCode.reconfig) {\n<line4>        self.setLastSeenQuorumVerifier(request.qv, true);\n<line5>    }\n<line6>    if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {\n<line7>        p.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n<line8>    }\n<line9>    LOG.debug(\"Proposing:: {}\", request);\n<line10>    lastProposed = p.packet.getZxid();\n<line11>    outstandingProposals.put(lastProposed, p);\n<line12>    sendPacket(pp);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    maxTimeToWaitForEpoch = Integer.getInteger(MAX_TIME_TO_WAIT_FOR_EPOCH, -1);\n<line3>}","output":"<line1>{\n<line2>    maxTimeToWaitForEpoch = Integer.getInteger(MAX_TIME_TO_WAIT_FOR_EPOCH, -1);\n<line3>    LOG.info(\"{} = {}ms\", MAX_TIME_TO_WAIT_FOR_EPOCH, maxTimeToWaitForEpoch);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    Leader.maxTimeToWaitForEpoch = maxTimeToWaitForEpoch;\n<line3>}","output":"<line1>{\n<line2>    Leader.maxTimeToWaitForEpoch = maxTimeToWaitForEpoch;\n<line3>    LOG.info(\"Set {} to {}ms\", MAX_TIME_TO_WAIT_FOR_EPOCH, Leader.maxTimeToWaitForEpoch);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (connectingFollowers) {\n<line3>        quitWaitForEpoch = true;\n<line4>        connectingFollowers.notifyAll();\n<line5>    }\n<line6>    ServerMetrics.getMetrics().QUIT_LEADING_DUE_TO_DISLOYAL_VOTER.add(1);\n<line7>}","output":"<line1>{\n<line2>    synchronized (connectingFollowers) {\n<line3>        quitWaitForEpoch = true;\n<line4>        connectingFollowers.notifyAll();\n<line5>    }\n<line6>    ServerMetrics.getMetrics().QUIT_LEADING_DUE_TO_DISLOYAL_VOTER.add(1);\n<line7>    LOG.info(\"Quit leading due to voter changed mind.\");\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    // Update lastCommitted and Db's zxid to a value representing the new epoch\n<line3>    lastCommitted = zk.getZxid();\n<line4>    if (self.isReconfigEnabled()) {\n<line5>        /*\n<line6>             * ZOOKEEPER-1324. the leader sends the new config it must complete\n<line7>             *  to others inside a NEWLEADER message (see LearnerHandler where\n<line8>             *  the NEWLEADER message is constructed), and once it has enough\n<line9>             *  acks we must execute the following code so that it applies the\n<line10>             *  config to itself.\n<line11>             */\n<line12>        QuorumVerifier newQV = self.getLastSeenQuorumVerifier();\n<line13>        Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());\n<line14>        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n<line15>        if (designatedLeader != self.getMyId()) {\n<line16>            allowedToCommit = false;\n<line17>        }\n<line18>    } else {\n<line19>    }\n<line20>    leaderStartTime = Time.currentElapsedTime();\n<line21>    zk.startup();\n<line22>    /*\n<line23>         * Update the election vote here to ensure that all members of the\n<line24>         * ensemble report the same vote to new servers that start up and\n<line25>         * send leader election notifications to the ensemble.\n<line26>         *\n<line27>         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n<line28>         */\n<line29>    self.updateElectionVote(getEpoch());\n<line30>    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());\n<line31>}","output":"<line1>{\n<line2>    // Update lastCommitted and Db's zxid to a value representing the new epoch\n<line3>    lastCommitted = zk.getZxid();\n<line4>    LOG.info(\"Have quorum of supporters, sids: [{}]; starting up and setting last processed zxid: 0x{}\", newLeaderProposal.ackSetsToString(), Long.toHexString(zk.getZxid()));\n<line5>    if (self.isReconfigEnabled()) {\n<line6>        /*\n<line7>             * ZOOKEEPER-1324. the leader sends the new config it must complete\n<line8>             *  to others inside a NEWLEADER message (see LearnerHandler where\n<line9>             *  the NEWLEADER message is constructed), and once it has enough\n<line10>             *  acks we must execute the following code so that it applies the\n<line11>             *  config to itself.\n<line12>             */\n<line13>        QuorumVerifier newQV = self.getLastSeenQuorumVerifier();\n<line14>        Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());\n<line15>        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n<line16>        if (designatedLeader != self.getMyId()) {\n<line17>            LOG.warn(\"This leader is not the designated leader, it will be initialized with allowedToCommit = false\");\n<line18>            allowedToCommit = false;\n<line19>        }\n<line20>    } else {\n<line21>        LOG.info(\"Dynamic reconfig feature is disabled, skip designatedLeader calculation and reconfig processing.\");\n<line22>    }\n<line23>    leaderStartTime = Time.currentElapsedTime();\n<line24>    zk.startup();\n<line25>    /*\n<line26>         * Update the election vote here to ensure that all members of the\n<line27>         * ensemble report the same vote to new servers that start up and\n<line28>         * send leader election notifications to the ensemble.\n<line29>         *\n<line30>         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n<line31>         */\n<line32>    self.updateElectionVote(getEpoch());\n<line33>    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Dynamic reconfig feature is disabled, skip designatedLeader calculation and reconfig processing.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (newLeaderProposal.qvAcksetPairs) {\n<line3>        if (quorumFormed) {\n<line4>            return;\n<line5>        }\n<line6>        long currentZxid = newLeaderProposal.packet.getZxid();\n<line7>        if (zxid != currentZxid) {\n<line8>            return;\n<line9>        }\n<line10>        /*\n<line11>             * Note that addAck already checks that the learner\n<line12>             * is a PARTICIPANT.\n<line13>             */\n<line14>        newLeaderProposal.addAck(sid);\n<line15>        if (newLeaderProposal.hasAllQuorums()) {\n<line16>            quorumFormed = true;\n<line17>            newLeaderProposal.qvAcksetPairs.notifyAll();\n<line18>        } else {\n<line19>            long start = Time.currentElapsedTime();\n<line20>            long cur = start;\n<line21>            long end = start + self.getInitLimit() * self.getTickTime();\n<line22>            while (!quorumFormed && cur < end) {\n<line23>                newLeaderProposal.qvAcksetPairs.wait(end - cur);\n<line24>                cur = Time.currentElapsedTime();\n<line25>            }\n<line26>            if (!quorumFormed) {\n<line27>                throw new InterruptedException(\"Timeout while waiting for NEWLEADER to be acked by quorum\");\n<line28>            }\n<line29>        }\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    synchronized (newLeaderProposal.qvAcksetPairs) {\n<line3>        if (quorumFormed) {\n<line4>            return;\n<line5>        }\n<line6>        long currentZxid = newLeaderProposal.packet.getZxid();\n<line7>        if (zxid != currentZxid) {\n<line8>            LOG.error(\"NEWLEADER ACK from sid: {} is from a different epoch - current 0x{} received 0x{}\", sid, Long.toHexString(currentZxid), Long.toHexString(zxid));\n<line9>            return;\n<line10>        }\n<line11>        /*\n<line12>             * Note that addAck already checks that the learner\n<line13>             * is a PARTICIPANT.\n<line14>             */\n<line15>        newLeaderProposal.addAck(sid);\n<line16>        if (newLeaderProposal.hasAllQuorums()) {\n<line17>            quorumFormed = true;\n<line18>            newLeaderProposal.qvAcksetPairs.notifyAll();\n<line19>        } else {\n<line20>            long start = Time.currentElapsedTime();\n<line21>            long cur = start;\n<line22>            long end = start + self.getInitLimit() * self.getTickTime();\n<line23>            while (!quorumFormed && cur < end) {\n<line24>                newLeaderProposal.qvAcksetPairs.wait(end - cur);\n<line25>                cur = Time.currentElapsedTime();\n<line26>            }\n<line27>            if (!quorumFormed) {\n<line28>                throw new InterruptedException(\"Timeout while waiting for NEWLEADER to be acked by quorum\");\n<line29>            }\n<line30>        }\n<line31>    }\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    if (quorumFormed) {\n<line3>        return;\n<line4>    }\n<line5>    long currentZxid = newLeaderProposal.packet.getZxid();\n<line6>    if (zxid != currentZxid) {\n<line7>        return;\n<line8>    }\n<line9>    /*\n<line10>             * Note that addAck already checks that the learner\n<line11>             * is a PARTICIPANT.\n<line12>             */\n<line13>    newLeaderProposal.addAck(sid);\n<line14>    if (newLeaderProposal.hasAllQuorums()) {\n<line15>        quorumFormed = true;\n<line16>        newLeaderProposal.qvAcksetPairs.notifyAll();\n<line17>    } else {\n<line18>        long start = Time.currentElapsedTime();\n<line19>        long cur = start;\n<line20>        long end = start + self.getInitLimit() * self.getTickTime();\n<line21>        while (!quorumFormed && cur < end) {\n<line22>            newLeaderProposal.qvAcksetPairs.wait(end - cur);\n<line23>            cur = Time.currentElapsedTime();\n<line24>        }\n<line25>        if (!quorumFormed) {\n<line26>            throw new InterruptedException(\"Timeout while waiting for NEWLEADER to be acked by quorum\");\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    if (quorumFormed) {\n<line3>        return;\n<line4>    }\n<line5>    long currentZxid = newLeaderProposal.packet.getZxid();\n<line6>    if (zxid != currentZxid) {\n<line7>        LOG.error(\"NEWLEADER ACK from sid: {} is from a different epoch - current 0x{} received 0x{}\", sid, Long.toHexString(currentZxid), Long.toHexString(zxid));\n<line8>        return;\n<line9>    }\n<line10>    /*\n<line11>             * Note that addAck already checks that the learner\n<line12>             * is a PARTICIPANT.\n<line13>             */\n<line14>    newLeaderProposal.addAck(sid);\n<line15>    if (newLeaderProposal.hasAllQuorums()) {\n<line16>        quorumFormed = true;\n<line17>        newLeaderProposal.qvAcksetPairs.notifyAll();\n<line18>    } else {\n<line19>        long start = Time.currentElapsedTime();\n<line20>        long cur = start;\n<line21>        long end = start + self.getInitLimit() * self.getTickTime();\n<line22>        while (!quorumFormed && cur < end) {\n<line23>            newLeaderProposal.qvAcksetPairs.wait(end - cur);\n<line24>            cur = Time.currentElapsedTime();\n<line25>        }\n<line26>        if (!quorumFormed) {\n<line27>            throw new InterruptedException(\"Timeout while waiting for NEWLEADER to be acked by quorum\");\n<line28>        }\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"NEWLEADER ACK from sid: {} is from a different epoch - current 0x{} received 0x{}\", sid, Long.toHexString(currentZxid), Long.toHexString(zxid));\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line3>    DataInputStream dis = new DataInputStream(bis);\n<line4>    long id = dis.readLong();\n<line5>    int to = dis.readInt();\n<line6>    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n<line7>    DataOutputStream dos = new DataOutputStream(bos);\n<line8>    dos.writeLong(id);\n<line9>    boolean valid = zk.checkIfValidGlobalSession(id, to);\n<line10>    if (valid) {\n<line11>        try {\n<line12>            // set the session owner as the follower that owns the session\n<line13>            zk.setOwner(id, learnerHandler);\n<line14>        } catch (KeeperException.SessionExpiredException e) {\n<line15>        }\n<line16>    }\n<line17>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"Session 0x\" + Long.toHexString(id) + \" is valid: \" + valid);\n<line18>    }\n<line19>    dos.writeBoolean(valid);\n<line20>    qp.setData(bos.toByteArray());\n<line21>    learnerHandler.queuePacket(qp);\n<line22>}","output":"<line1>{\n<line2>    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line3>    DataInputStream dis = new DataInputStream(bis);\n<line4>    long id = dis.readLong();\n<line5>    int to = dis.readInt();\n<line6>    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n<line7>    DataOutputStream dos = new DataOutputStream(bos);\n<line8>    dos.writeLong(id);\n<line9>    boolean valid = zk.checkIfValidGlobalSession(id, to);\n<line10>    if (valid) {\n<line11>        try {\n<line12>            // set the session owner as the follower that owns the session\n<line13>            zk.setOwner(id, learnerHandler);\n<line14>        } catch (KeeperException.SessionExpiredException e) {\n<line15>            LOG.error(\"Somehow session 0x{} expired right after being renewed! (impossible)\", Long.toHexString(id), e);\n<line16>        }\n<line17>    }\n<line18>    if (LOG.isTraceEnabled()) {\n<line19>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"Session 0x\" + Long.toHexString(id) + \" is valid: \" + valid);\n<line20>    }\n<line21>    dos.writeBoolean(valid);\n<line22>    qp.setData(bos.toByteArray());\n<line23>    learnerHandler.queuePacket(qp);\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // set the session owner as the follower that owns the session\n<line4>        zk.setOwner(id, learnerHandler);\n<line5>    } catch (KeeperException.SessionExpiredException e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        // set the session owner as the follower that owns the session\n<line4>        zk.setOwner(id, learnerHandler);\n<line5>    } catch (KeeperException.SessionExpiredException e) {\n<line6>        LOG.error(\"Somehow session 0x{} expired right after being renewed! (impossible)\", Long.toHexString(id), e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Somehow session 0x{} expired right after being renewed! (impossible)\", Long.toHexString(id), e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeerMain main = new QuorumPeerMain();\n<line3>    try {\n<line4>        main.initializeAndRun(args);\n<line5>    } catch (IllegalArgumentException e) {\n<line6>        System.err.println(USAGE);\n<line7>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line8>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line9>    } catch (ConfigException e) {\n<line10>        System.err.println(\"Invalid config, exiting abnormally\");\n<line11>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line12>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line13>    } catch (DatadirException e) {\n<line14>        System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line15>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line16>        ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line17>    } catch (AdminServerException e) {\n<line18>        System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line19>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line20>        ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line21>    } catch (Exception e) {\n<line22>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line23>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line24>    }\n<line25>    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line26>}","output":"<line1>{\n<line2>    QuorumPeerMain main = new QuorumPeerMain();\n<line3>    try {\n<line4>        main.initializeAndRun(args);\n<line5>    } catch (IllegalArgumentException e) {\n<line6>        LOG.error(\"Invalid arguments, exiting abnormally\", e);\n<line7>        LOG.info(USAGE);\n<line8>        System.err.println(USAGE);\n<line9>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line10>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line11>    } catch (ConfigException e) {\n<line12>        LOG.error(\"Invalid config, exiting abnormally\", e);\n<line13>        System.err.println(\"Invalid config, exiting abnormally\");\n<line14>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line15>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line16>    } catch (DatadirException e) {\n<line17>        LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n<line18>        System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line19>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line20>        ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line21>    } catch (AdminServerException e) {\n<line22>        LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n<line23>        System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line24>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line25>        ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line26>    } catch (Exception e) {\n<line27>        LOG.error(\"Unexpected exception, exiting abnormally\", e);\n<line28>        ZKAuditProvider.addServerStartFailureAuditLog();\n<line29>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line30>    }\n<line31>    LOG.info(\"Exiting normally\");\n<line32>    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(USAGE);\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Invalid arguments, exiting abnormally\", e);\n<line3>    LOG.info(USAGE);\n<line4>    System.err.println(USAGE);\n<line5>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line6>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(\"Invalid config, exiting abnormally\");\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Invalid config, exiting abnormally\", e);\n<line3>    System.err.println(\"Invalid config, exiting abnormally\");\n<line4>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line5>    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n<line3>    System.err.println(\"Unable to access datadir, exiting abnormally\");\n<line4>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line5>    ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line5>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n<line3>    System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n<line4>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line5>    ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception, exiting abnormally\", e);\n<line3>    ZKAuditProvider.addServerStartFailureAuditLog();\n<line4>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        ManagedUtil.registerLog4jMBeans();\n<line4>    } catch (JMException e) {\n<line5>    }\n<line6>    final MetricsProvider metricsProvider;\n<line7>    try {\n<line8>        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());\n<line9>    } catch (MetricsProviderLifeCycleException error) {\n<line10>        throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n<line11>    }\n<line12>    try {\n<line13>        ServerMetrics.metricsProviderInitialized(metricsProvider);\n<line14>        ProviderRegistry.initialize();\n<line15>        ServerCnxnFactory cnxnFactory = null;\n<line16>        ServerCnxnFactory secureCnxnFactory = null;\n<line17>        if (config.getClientPortAddress() != null) {\n<line18>            cnxnFactory = ServerCnxnFactory.createFactory();\n<line19>            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n<line20>        }\n<line21>        if (config.getSecureClientPortAddress() != null) {\n<line22>            secureCnxnFactory = ServerCnxnFactory.createFactory();\n<line23>            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n<line24>        }\n<line25>        quorumPeer = getQuorumPeer();\n<line26>        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));\n<line27>        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n<line28>        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());\n<line29>        //quorumPeer.setQuorumPeers(config.getAllMembers());\n<line30>        quorumPeer.setElectionType(config.getElectionAlg());\n<line31>        quorumPeer.setMyid(config.getServerId());\n<line32>        quorumPeer.setTickTime(config.getTickTime());\n<line33>        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n<line34>        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n<line35>        quorumPeer.setInitLimit(config.getInitLimit());\n<line36>        quorumPeer.setSyncLimit(config.getSyncLimit());\n<line37>        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());\n<line38>        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());\n<line39>        quorumPeer.setConfigFileName(config.getConfigFilename());\n<line40>        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());\n<line41>        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n<line42>        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n<line43>        if (config.getLastSeenQuorumVerifier() != null) {\n<line44>            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n<line45>        }\n<line46>        quorumPeer.initConfigInZKDatabase();\n<line47>        quorumPeer.setCnxnFactory(cnxnFactory);\n<line48>        quorumPeer.setSecureCnxnFactory(secureCnxnFactory);\n<line49>        quorumPeer.setSslQuorum(config.isSslQuorum());\n<line50>        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());\n<line51>        quorumPeer.setLearnerType(config.getPeerType());\n<line52>        quorumPeer.setSyncEnabled(config.getSyncEnabled());\n<line53>        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n<line54>        if (config.sslQuorumReloadCertFiles) {\n<line55>            quorumPeer.getX509Util().enableCertFileReloading();\n<line56>        }\n<line57>        quorumPeer.setMultiAddressEnabled(config.isMultiAddressEnabled());\n<line58>        quorumPeer.setMultiAddressReachabilityCheckEnabled(config.isMultiAddressReachabilityCheckEnabled());\n<line59>        quorumPeer.setMultiAddressReachabilityCheckTimeoutMs(config.getMultiAddressReachabilityCheckTimeoutMs());\n<line60>        // sets quorum sasl authentication configurations\n<line61>        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n<line62>        if (quorumPeer.isQuorumSaslAuthEnabled()) {\n<line63>            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n<line64>            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n<line65>            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n<line66>            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n<line67>            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n<line68>        }\n<line69>        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n<line70>        quorumPeer.initialize();\n<line71>        if (config.jvmPauseMonitorToRun) {\n<line72>            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));\n<line73>        }\n<line74>        quorumPeer.start();\n<line75>        ZKAuditProvider.addZKStartStopAuditLog();\n<line76>        quorumPeer.join();\n<line77>    } catch (InterruptedException e) {\n<line78>        // warn, but generally this is ok\n<line79>    } finally {\n<line80>        try {\n<line81>            metricsProvider.stop();\n<line82>        } catch (Throwable error) {\n<line83>        }\n<line84>    }\n<line85>}","output":"<line1>{\n<line2>    try {\n<line3>        ManagedUtil.registerLog4jMBeans();\n<line4>    } catch (JMException e) {\n<line5>        LOG.warn(\"Unable to register log4j JMX control\", e);\n<line6>    }\n<line7>    LOG.info(\"Starting quorum peer, myid=\" + config.getServerId());\n<line8>    final MetricsProvider metricsProvider;\n<line9>    try {\n<line10>        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());\n<line11>    } catch (MetricsProviderLifeCycleException error) {\n<line12>        throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n<line13>    }\n<line14>    try {\n<line15>        ServerMetrics.metricsProviderInitialized(metricsProvider);\n<line16>        ProviderRegistry.initialize();\n<line17>        ServerCnxnFactory cnxnFactory = null;\n<line18>        ServerCnxnFactory secureCnxnFactory = null;\n<line19>        if (config.getClientPortAddress() != null) {\n<line20>            cnxnFactory = ServerCnxnFactory.createFactory();\n<line21>            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n<line22>        }\n<line23>        if (config.getSecureClientPortAddress() != null) {\n<line24>            secureCnxnFactory = ServerCnxnFactory.createFactory();\n<line25>            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n<line26>        }\n<line27>        quorumPeer = getQuorumPeer();\n<line28>        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));\n<line29>        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n<line30>        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());\n<line31>        //quorumPeer.setQuorumPeers(config.getAllMembers());\n<line32>        quorumPeer.setElectionType(config.getElectionAlg());\n<line33>        quorumPeer.setMyid(config.getServerId());\n<line34>        quorumPeer.setTickTime(config.getTickTime());\n<line35>        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n<line36>        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n<line37>        quorumPeer.setInitLimit(config.getInitLimit());\n<line38>        quorumPeer.setSyncLimit(config.getSyncLimit());\n<line39>        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());\n<line40>        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());\n<line41>        quorumPeer.setConfigFileName(config.getConfigFilename());\n<line42>        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());\n<line43>        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n<line44>        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n<line45>        if (config.getLastSeenQuorumVerifier() != null) {\n<line46>            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n<line47>        }\n<line48>        quorumPeer.initConfigInZKDatabase();\n<line49>        quorumPeer.setCnxnFactory(cnxnFactory);\n<line50>        quorumPeer.setSecureCnxnFactory(secureCnxnFactory);\n<line51>        quorumPeer.setSslQuorum(config.isSslQuorum());\n<line52>        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());\n<line53>        quorumPeer.setLearnerType(config.getPeerType());\n<line54>        quorumPeer.setSyncEnabled(config.getSyncEnabled());\n<line55>        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n<line56>        if (config.sslQuorumReloadCertFiles) {\n<line57>            quorumPeer.getX509Util().enableCertFileReloading();\n<line58>        }\n<line59>        quorumPeer.setMultiAddressEnabled(config.isMultiAddressEnabled());\n<line60>        quorumPeer.setMultiAddressReachabilityCheckEnabled(config.isMultiAddressReachabilityCheckEnabled());\n<line61>        quorumPeer.setMultiAddressReachabilityCheckTimeoutMs(config.getMultiAddressReachabilityCheckTimeoutMs());\n<line62>        // sets quorum sasl authentication configurations\n<line63>        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n<line64>        if (quorumPeer.isQuorumSaslAuthEnabled()) {\n<line65>            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n<line66>            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n<line67>            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n<line68>            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n<line69>            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n<line70>        }\n<line71>        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n<line72>        quorumPeer.initialize();\n<line73>        if (config.jvmPauseMonitorToRun) {\n<line74>            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));\n<line75>        }\n<line76>        quorumPeer.start();\n<line77>        ZKAuditProvider.addZKStartStopAuditLog();\n<line78>        quorumPeer.join();\n<line79>    } catch (InterruptedException e) {\n<line80>        // warn, but generally this is ok\n<line81>        LOG.warn(\"Quorum Peer interrupted\", e);\n<line82>    } finally {\n<line83>        try {\n<line84>            metricsProvider.stop();\n<line85>        } catch (Throwable error) {\n<line86>            LOG.warn(\"Error while stopping metrics\", error);\n<line87>        }\n<line88>    }\n<line89>}"},{"input":"","instruction":"<line1>{\n<line2>    super(\"FollowerRequestProcessor:\" + zks.getServerId(), zks.getZooKeeperServerListener());\n<line3>    this.zks = zks;\n<line4>    this.nextProcessor = nextProcessor;\n<line5>    this.skipLearnerRequestToNextProcessor = Boolean.getBoolean(SKIP_LEARNER_REQUEST_TO_NEXT_PROCESSOR);\n<line6>}","output":"<line1>{\n<line2>    super(\"FollowerRequestProcessor:\" + zks.getServerId(), zks.getZooKeeperServerListener());\n<line3>    this.zks = zks;\n<line4>    this.nextProcessor = nextProcessor;\n<line5>    this.skipLearnerRequestToNextProcessor = Boolean.getBoolean(SKIP_LEARNER_REQUEST_TO_NEXT_PROCESSOR);\n<line6>    LOG.info(\"Initialized FollowerRequestProcessor with {} as {}\", SKIP_LEARNER_REQUEST_TO_NEXT_PROCESSOR, skipLearnerRequestToNextProcessor);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!finished) {\n<line4>            ServerMetrics.getMetrics().LEARNER_REQUEST_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n<line5>            Request request = queuedRequests.take();\n<line6>                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, \"\");\n<line7>            }\n<line8>            if (request == Request.requestOfDeath) {\n<line9>                break;\n<line10>            }\n<line11>            // Screen quorum requests against ACLs first\n<line12>            if (!zks.authWriteRequest(request)) {\n<line13>                continue;\n<line14>            }\n<line15>            // We want to queue the request to be processed before we submit\n<line16>            // the request to the leader so that we are ready to receive\n<line17>            // the response\n<line18>            maybeSendRequestToNextProcessor(request);\n<line19>            if (request.isThrottled()) {\n<line20>                continue;\n<line21>            }\n<line22>            // We now ship the request to the leader. As with all\n<line23>            // other quorum operations, sync also follows this code\n<line24>            // path, but different from others, we need to keep track\n<line25>            // of the sync operations this follower has pending, so we\n<line26>            // add it to pendingSyncs.\n<line27>            switch(request.type) {\n<line28>                case OpCode.sync:\n<line29>                    zks.pendingSyncs.add(request);\n<line30>                    zks.getFollower().request(request);\n<line31>                    break;\n<line32>                case OpCode.create:\n<line33>                case OpCode.create2:\n<line34>                case OpCode.createTTL:\n<line35>                case OpCode.createContainer:\n<line36>                case OpCode.delete:\n<line37>                case OpCode.deleteContainer:\n<line38>                case OpCode.setData:\n<line39>                case OpCode.reconfig:\n<line40>                case OpCode.setACL:\n<line41>                case OpCode.multi:\n<line42>                case OpCode.check:\n<line43>                    zks.getFollower().request(request);\n<line44>                    break;\n<line45>                case OpCode.createSession:\n<line46>                case OpCode.closeSession:\n<line47>                    // Don't forward local sessions to the leader.\n<line48>                    if (!request.isLocalSession()) {\n<line49>                        zks.getFollower().request(request);\n<line50>                    }\n<line51>                    break;\n<line52>            }\n<line53>        }\n<line54>    } catch (RuntimeException e) {\n<line55>        // spotbugs require explicit catch of RuntimeException\n<line56>        handleException(this.getName(), e);\n<line57>    } catch (Exception e) {\n<line58>        handleException(this.getName(), e);\n<line59>    }\n<line60>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!finished) {\n<line4>            ServerMetrics.getMetrics().LEARNER_REQUEST_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());\n<line5>            Request request = queuedRequests.take();\n<line6>            if (LOG.isTraceEnabled()) {\n<line7>                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, \"\");\n<line8>            }\n<line9>            if (request == Request.requestOfDeath) {\n<line10>                break;\n<line11>            }\n<line12>            // Screen quorum requests against ACLs first\n<line13>            if (!zks.authWriteRequest(request)) {\n<line14>                continue;\n<line15>            }\n<line16>            // We want to queue the request to be processed before we submit\n<line17>            // the request to the leader so that we are ready to receive\n<line18>            // the response\n<line19>            maybeSendRequestToNextProcessor(request);\n<line20>            if (request.isThrottled()) {\n<line21>                continue;\n<line22>            }\n<line23>            // We now ship the request to the leader. As with all\n<line24>            // other quorum operations, sync also follows this code\n<line25>            // path, but different from others, we need to keep track\n<line26>            // of the sync operations this follower has pending, so we\n<line27>            // add it to pendingSyncs.\n<line28>            switch(request.type) {\n<line29>                case OpCode.sync:\n<line30>                    zks.pendingSyncs.add(request);\n<line31>                    zks.getFollower().request(request);\n<line32>                    break;\n<line33>                case OpCode.create:\n<line34>                case OpCode.create2:\n<line35>                case OpCode.createTTL:\n<line36>                case OpCode.createContainer:\n<line37>                case OpCode.delete:\n<line38>                case OpCode.deleteContainer:\n<line39>                case OpCode.setData:\n<line40>                case OpCode.reconfig:\n<line41>                case OpCode.setACL:\n<line42>                case OpCode.multi:\n<line43>                case OpCode.check:\n<line44>                    zks.getFollower().request(request);\n<line45>                    break;\n<line46>                case OpCode.createSession:\n<line47>                case OpCode.closeSession:\n<line48>                    // Don't forward local sessions to the leader.\n<line49>                    if (!request.isLocalSession()) {\n<line50>                        zks.getFollower().request(request);\n<line51>                    }\n<line52>                    break;\n<line53>            }\n<line54>        }\n<line55>    } catch (RuntimeException e) {\n<line56>        // spotbugs require explicit catch of RuntimeException\n<line57>        handleException(this.getName(), e);\n<line58>    } catch (Exception e) {\n<line59>        handleException(this.getName(), e);\n<line60>    }\n<line61>    LOG.info(\"FollowerRequestProcessor exited loop!\");\n<line62>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!finished) {\n<line3>        if (checkForUpgrade) {\n<line4>            // Before sending the request, check if the request requires a\n<line5>            // global session and what we have is a local session. If so do\n<line6>            // an upgrade.\n<line7>            Request upgradeRequest = null;\n<line8>            try {\n<line9>                upgradeRequest = zks.checkUpgradeSession(request);\n<line10>            } catch (KeeperException ke) {\n<line11>                if (request.getHdr() != null) {\n<line12>                    request.getHdr().setType(OpCode.error);\n<line13>                    request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line14>                }\n<line15>                request.setException(ke);\n<line16>            } catch (IOException ie) {\n<line17>            }\n<line18>            if (upgradeRequest != null) {\n<line19>                queuedRequests.add(upgradeRequest);\n<line20>            }\n<line21>        }\n<line22>        queuedRequests.add(request);\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    if (!finished) {\n<line3>        if (checkForUpgrade) {\n<line4>            // Before sending the request, check if the request requires a\n<line5>            // global session and what we have is a local session. If so do\n<line6>            // an upgrade.\n<line7>            Request upgradeRequest = null;\n<line8>            try {\n<line9>                upgradeRequest = zks.checkUpgradeSession(request);\n<line10>            } catch (KeeperException ke) {\n<line11>                if (request.getHdr() != null) {\n<line12>                    request.getHdr().setType(OpCode.error);\n<line13>                    request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line14>                }\n<line15>                request.setException(ke);\n<line16>                LOG.warn(\"Error creating upgrade request\", ke);\n<line17>            } catch (IOException ie) {\n<line18>                LOG.error(\"Unexpected error in upgrade\", ie);\n<line19>            }\n<line20>            if (upgradeRequest != null) {\n<line21>                queuedRequests.add(upgradeRequest);\n<line22>            }\n<line23>        }\n<line24>        queuedRequests.add(request);\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    if (checkForUpgrade) {\n<line3>        // Before sending the request, check if the request requires a\n<line4>        // global session and what we have is a local session. If so do\n<line5>        // an upgrade.\n<line6>        Request upgradeRequest = null;\n<line7>        try {\n<line8>            upgradeRequest = zks.checkUpgradeSession(request);\n<line9>        } catch (KeeperException ke) {\n<line10>            if (request.getHdr() != null) {\n<line11>                request.getHdr().setType(OpCode.error);\n<line12>                request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line13>            }\n<line14>            request.setException(ke);\n<line15>        } catch (IOException ie) {\n<line16>        }\n<line17>        if (upgradeRequest != null) {\n<line18>            queuedRequests.add(upgradeRequest);\n<line19>        }\n<line20>    }\n<line21>    queuedRequests.add(request);\n<line22>}","output":"<line1>{\n<line2>    if (checkForUpgrade) {\n<line3>        // Before sending the request, check if the request requires a\n<line4>        // global session and what we have is a local session. If so do\n<line5>        // an upgrade.\n<line6>        Request upgradeRequest = null;\n<line7>        try {\n<line8>            upgradeRequest = zks.checkUpgradeSession(request);\n<line9>        } catch (KeeperException ke) {\n<line10>            if (request.getHdr() != null) {\n<line11>                request.getHdr().setType(OpCode.error);\n<line12>                request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line13>            }\n<line14>            request.setException(ke);\n<line15>            LOG.warn(\"Error creating upgrade request\", ke);\n<line16>        } catch (IOException ie) {\n<line17>            LOG.error(\"Unexpected error in upgrade\", ie);\n<line18>        }\n<line19>        if (upgradeRequest != null) {\n<line20>            queuedRequests.add(upgradeRequest);\n<line21>        }\n<line22>    }\n<line23>    queuedRequests.add(request);\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    // Before sending the request, check if the request requires a\n<line3>    // global session and what we have is a local session. If so do\n<line4>    // an upgrade.\n<line5>    Request upgradeRequest = null;\n<line6>    try {\n<line7>        upgradeRequest = zks.checkUpgradeSession(request);\n<line8>    } catch (KeeperException ke) {\n<line9>        if (request.getHdr() != null) {\n<line10>            request.getHdr().setType(OpCode.error);\n<line11>            request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line12>        }\n<line13>        request.setException(ke);\n<line14>    } catch (IOException ie) {\n<line15>    }\n<line16>    if (upgradeRequest != null) {\n<line17>        queuedRequests.add(upgradeRequest);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    // Before sending the request, check if the request requires a\n<line3>    // global session and what we have is a local session. If so do\n<line4>    // an upgrade.\n<line5>    Request upgradeRequest = null;\n<line6>    try {\n<line7>        upgradeRequest = zks.checkUpgradeSession(request);\n<line8>    } catch (KeeperException ke) {\n<line9>        if (request.getHdr() != null) {\n<line10>            request.getHdr().setType(OpCode.error);\n<line11>            request.setTxn(new ErrorTxn(ke.code().intValue()));\n<line12>        }\n<line13>        request.setException(ke);\n<line14>        LOG.warn(\"Error creating upgrade request\", ke);\n<line15>    } catch (IOException ie) {\n<line16>        LOG.error(\"Unexpected error in upgrade\", ie);\n<line17>    }\n<line18>    if (upgradeRequest != null) {\n<line19>        queuedRequests.add(upgradeRequest);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected error in upgrade\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    finished = true;\n<line3>    queuedRequests.clear();\n<line4>    queuedRequests.add(Request.requestOfDeath);\n<line5>    nextProcessor.shutdown();\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    finished = true;\n<line4>    queuedRequests.clear();\n<line5>    queuedRequests.add(Request.requestOfDeath);\n<line6>    nextProcessor.shutdown();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    Request request = makeUpgradeRequest(sessionId);\n<line3>    if (request != null) {\n<line4>        // This must be a global request\n<line5>        submitRequest(request);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    Request request = makeUpgradeRequest(sessionId);\n<line3>    if (request != null) {\n<line4>        LOG.info(\"Upgrading session 0x{}\", Long.toHexString(sessionId));\n<line5>        // This must be a global request\n<line6>        submitRequest(request);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    // This must be a global request\n<line3>    submitRequest(request);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Upgrading session 0x{}\", Long.toHexString(sessionId));\n<line3>    // This must be a global request\n<line4>    submitRequest(request);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // We need to set isLocalSession to tree for these type of request\n<line3>    // so that the request processor can process them correctly.\n<line4>    switch(si.type) {\n<line5>        case OpCode.createSession:\n<line6>            if (self.areLocalSessionsEnabled()) {\n<line7>                // All new sessions local by default.\n<line8>                si.setLocalSession(true);\n<line9>            }\n<line10>            break;\n<line11>        case OpCode.closeSession:\n<line12>            String reqType = \"global\";\n<line13>            if (upgradeableSessionTracker.isLocalSession(si.sessionId)) {\n<line14>                si.setLocalSession(true);\n<line15>                reqType = \"local\";\n<line16>            }\n<line17>            break;\n<line18>        default:\n<line19>            break;\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    // We need to set isLocalSession to tree for these type of request\n<line3>    // so that the request processor can process them correctly.\n<line4>    switch(si.type) {\n<line5>        case OpCode.createSession:\n<line6>            if (self.areLocalSessionsEnabled()) {\n<line7>                // All new sessions local by default.\n<line8>                si.setLocalSession(true);\n<line9>            }\n<line10>            break;\n<line11>        case OpCode.closeSession:\n<line12>            String reqType = \"global\";\n<line13>            if (upgradeableSessionTracker.isLocalSession(si.sessionId)) {\n<line14>                si.setLocalSession(true);\n<line15>                reqType = \"local\";\n<line16>            }\n<line17>            LOG.info(\"Submitting {} closeSession request for session 0x{}\", reqType, Long.toHexString(si.sessionId));\n<line18>            break;\n<line19>        default:\n<line20>            break;\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    Iterator<QuorumPacket> itr = committedPkts.iterator();\n<line3>    if (itr.hasNext()) {\n<line4>        QuorumPacket packet = itr.next();\n<line5>        if (packet.getZxid() > lastSeenZxid + 1) {\n<line6>            learnerHandler.shutdown();\n<line7>            return -1;\n<line8>        } else if (packet.getZxid() == lastSeenZxid + 1) {\n<line9>            learnerHandler.queuePacket(packet);\n<line10>        }\n<line11>        long queueHeadZxid = packet.getZxid();\n<line12>        long queueBytesUsed = LearnerHandler.packetSize(packet);\n<line13>        while (itr.hasNext()) {\n<line14>            packet = itr.next();\n<line15>            if (packet.getZxid() <= lastSeenZxid) {\n<line16>                continue;\n<line17>            }\n<line18>            learnerHandler.queuePacket(packet);\n<line19>            queueBytesUsed += LearnerHandler.packetSize(packet);\n<line20>        }\n<line21>    }\n<line22>    activeObservers.add(learnerHandler);\n<line23>    return lastProposedZxid;\n<line24>}","output":"<line1>{\n<line2>    Iterator<QuorumPacket> itr = committedPkts.iterator();\n<line3>    if (itr.hasNext()) {\n<line4>        QuorumPacket packet = itr.next();\n<line5>        if (packet.getZxid() > lastSeenZxid + 1) {\n<line6>            LOG.error(\"LearnerHandler is too far behind (0x{} < 0x{}), disconnecting {} at {}\", Long.toHexString(lastSeenZxid + 1), Long.toHexString(packet.getZxid()), learnerHandler.getSid(), learnerHandler.getRemoteAddress());\n<line7>            learnerHandler.shutdown();\n<line8>            return -1;\n<line9>        } else if (packet.getZxid() == lastSeenZxid + 1) {\n<line10>            learnerHandler.queuePacket(packet);\n<line11>        }\n<line12>        long queueHeadZxid = packet.getZxid();\n<line13>        long queueBytesUsed = LearnerHandler.packetSize(packet);\n<line14>        while (itr.hasNext()) {\n<line15>            packet = itr.next();\n<line16>            if (packet.getZxid() <= lastSeenZxid) {\n<line17>                continue;\n<line18>            }\n<line19>            learnerHandler.queuePacket(packet);\n<line20>            queueBytesUsed += LearnerHandler.packetSize(packet);\n<line21>        }\n<line22>        LOG.info(\"finished syncing observer from retained commit queue: sid {}, \" + \"queue head 0x{}, queue tail 0x{}, sync position 0x{}, num packets used {}, \" + \"num bytes used {}\", learnerHandler.getSid(), Long.toHexString(queueHeadZxid), Long.toHexString(packet.getZxid()), Long.toHexString(lastSeenZxid), packet.getZxid() - lastSeenZxid, queueBytesUsed);\n<line23>    }\n<line24>    activeObservers.add(learnerHandler);\n<line25>    return lastProposedZxid;\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPacket packet = itr.next();\n<line3>    if (packet.getZxid() > lastSeenZxid + 1) {\n<line4>        learnerHandler.shutdown();\n<line5>        return -1;\n<line6>    } else if (packet.getZxid() == lastSeenZxid + 1) {\n<line7>        learnerHandler.queuePacket(packet);\n<line8>    }\n<line9>    long queueHeadZxid = packet.getZxid();\n<line10>    long queueBytesUsed = LearnerHandler.packetSize(packet);\n<line11>    while (itr.hasNext()) {\n<line12>        packet = itr.next();\n<line13>        if (packet.getZxid() <= lastSeenZxid) {\n<line14>            continue;\n<line15>        }\n<line16>        learnerHandler.queuePacket(packet);\n<line17>        queueBytesUsed += LearnerHandler.packetSize(packet);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    QuorumPacket packet = itr.next();\n<line3>    if (packet.getZxid() > lastSeenZxid + 1) {\n<line4>        LOG.error(\"LearnerHandler is too far behind (0x{} < 0x{}), disconnecting {} at {}\", Long.toHexString(lastSeenZxid + 1), Long.toHexString(packet.getZxid()), learnerHandler.getSid(), learnerHandler.getRemoteAddress());\n<line5>        learnerHandler.shutdown();\n<line6>        return -1;\n<line7>    } else if (packet.getZxid() == lastSeenZxid + 1) {\n<line8>        learnerHandler.queuePacket(packet);\n<line9>    }\n<line10>    long queueHeadZxid = packet.getZxid();\n<line11>    long queueBytesUsed = LearnerHandler.packetSize(packet);\n<line12>    while (itr.hasNext()) {\n<line13>        packet = itr.next();\n<line14>        if (packet.getZxid() <= lastSeenZxid) {\n<line15>            continue;\n<line16>        }\n<line17>        learnerHandler.queuePacket(packet);\n<line18>        queueBytesUsed += LearnerHandler.packetSize(packet);\n<line19>    }\n<line20>    LOG.info(\"finished syncing observer from retained commit queue: sid {}, \" + \"queue head 0x{}, queue tail 0x{}, sync position 0x{}, num packets used {}, \" + \"num bytes used {}\", learnerHandler.getSid(), Long.toHexString(queueHeadZxid), Long.toHexString(packet.getZxid()), Long.toHexString(lastSeenZxid), packet.getZxid() - lastSeenZxid, queueBytesUsed);\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    learnerHandler.shutdown();\n<line3>    return -1;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"LearnerHandler is too far behind (0x{} < 0x{}), disconnecting {} at {}\", Long.toHexString(lastSeenZxid + 1), Long.toHexString(packet.getZxid()), learnerHandler.getSid(), learnerHandler.getRemoteAddress());\n<line3>    learnerHandler.shutdown();\n<line4>    return -1;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPacket pkt = proposedPkts.peek();\n<line3>    if (pkt == null || pkt.getZxid() > zxid) {\n<line4>        return null;\n<line5>    }\n<line6>    if (pkt.getZxid() != zxid) {\n<line7>        final String m = String.format(\"Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d\", zxid, pkt.getZxid());\n<line8>        throw new RuntimeException(m);\n<line9>    }\n<line10>    proposedPkts.remove();\n<line11>    return pkt;\n<line12>}","output":"<line1>{\n<line2>    QuorumPacket pkt = proposedPkts.peek();\n<line3>    if (pkt == null || pkt.getZxid() > zxid) {\n<line4>        LOG.debug(\"ignore missing proposal packet for {}\", Long.toHexString(zxid));\n<line5>        return null;\n<line6>    }\n<line7>    if (pkt.getZxid() != zxid) {\n<line8>        final String m = String.format(\"Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d\", zxid, pkt.getZxid());\n<line9>        LOG.error(m);\n<line10>        throw new RuntimeException(m);\n<line11>    }\n<line12>    proposedPkts.remove();\n<line13>    return pkt;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"ignore missing proposal packet for {}\", Long.toHexString(zxid));\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final String m = String.format(\"Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d\", zxid, pkt.getZxid());\n<line3>    throw new RuntimeException(m);\n<line4>}","output":"<line1>{\n<line2>    final String m = String.format(\"Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d\", zxid, pkt.getZxid());\n<line3>    LOG.error(m);\n<line4>    throw new RuntimeException(m);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerSocket ss;\n<line3>    synchronized (this) {\n<line4>        ss = this.ss;\n<line5>    }\n<line6>    while (listenerRunning) {\n<line7>        try {\n<line8>            Socket s = ss.accept();\n<line9>            // start with the initLimit, once the ack is processed\n<line10>            // in LearnerHandler switch to the syncLimit\n<line11>            s.setSoTimeout(self.tickTime * self.initLimit);\n<line12>            BufferedInputStream is = new BufferedInputStream(s.getInputStream());\n<line13>            LearnerHandler lh = new LearnerHandler(s, is, this);\n<line14>            lh.start();\n<line15>        } catch (Exception e) {\n<line16>            if (listenerRunning) {\n<line17>            } else {\n<line18>            }\n<line19>        }\n<line20>    }\n<line21>    /*\n<line22>         * we don't need to close ss because we only got here because listenerRunning is\n<line23>         * false and that is set and then ss is closed() in stop()\n<line24>         */\n<line25>}","output":"<line1>{\n<line2>    ServerSocket ss;\n<line3>    synchronized (this) {\n<line4>        ss = this.ss;\n<line5>    }\n<line6>    while (listenerRunning) {\n<line7>        try {\n<line8>            Socket s = ss.accept();\n<line9>            // start with the initLimit, once the ack is processed\n<line10>            // in LearnerHandler switch to the syncLimit\n<line11>            s.setSoTimeout(self.tickTime * self.initLimit);\n<line12>            BufferedInputStream is = new BufferedInputStream(s.getInputStream());\n<line13>            LearnerHandler lh = new LearnerHandler(s, is, this);\n<line14>            lh.start();\n<line15>        } catch (Exception e) {\n<line16>            if (listenerRunning) {\n<line17>                LOG.debug(\"Ignoring accept exception (maybe shutting down)\", e);\n<line18>            } else {\n<line19>                LOG.debug(\"Ignoring accept exception (maybe client closed)\", e);\n<line20>            }\n<line21>        }\n<line22>    }\n<line23>    /*\n<line24>         * we don't need to close ss because we only got here because listenerRunning is\n<line25>         * false and that is set and then ss is closed() in stop()\n<line26>         */\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Socket s = ss.accept();\n<line4>        // start with the initLimit, once the ack is processed\n<line5>        // in LearnerHandler switch to the syncLimit\n<line6>        s.setSoTimeout(self.tickTime * self.initLimit);\n<line7>        BufferedInputStream is = new BufferedInputStream(s.getInputStream());\n<line8>        LearnerHandler lh = new LearnerHandler(s, is, this);\n<line9>        lh.start();\n<line10>    } catch (Exception e) {\n<line11>        if (listenerRunning) {\n<line12>        } else {\n<line13>        }\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    try {\n<line3>        Socket s = ss.accept();\n<line4>        // start with the initLimit, once the ack is processed\n<line5>        // in LearnerHandler switch to the syncLimit\n<line6>        s.setSoTimeout(self.tickTime * self.initLimit);\n<line7>        BufferedInputStream is = new BufferedInputStream(s.getInputStream());\n<line8>        LearnerHandler lh = new LearnerHandler(s, is, this);\n<line9>        lh.start();\n<line10>    } catch (Exception e) {\n<line11>        if (listenerRunning) {\n<line12>            LOG.debug(\"Ignoring accept exception (maybe shutting down)\", e);\n<line13>        } else {\n<line14>            LOG.debug(\"Ignoring accept exception (maybe client closed)\", e);\n<line15>        }\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    if (listenerRunning) {\n<line3>    } else {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (listenerRunning) {\n<line3>        LOG.debug(\"Ignoring accept exception (maybe shutting down)\", e);\n<line4>    } else {\n<line5>        LOG.debug(\"Ignoring accept exception (maybe client closed)\", e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring accept exception (maybe shutting down)\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring accept exception (maybe client closed)\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (oracle == null) {\n<line3>        oracle = path;\n<line4>    } else {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (oracle == null) {\n<line3>        oracle = path;\n<line4>        LOG.info(\"Oracle is set to {}\", path);\n<line5>    } else {\n<line6>        LOG.warn(\"Oracle is already set. Ignore:{}\", path);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    oracle = path;\n<line3>}","output":"<line1>{\n<line2>    oracle = path;\n<line3>    LOG.info(\"Oracle is set to {}\", path);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    FileReader fr = null;\n<line3>    try {\n<line4>        int read;\n<line5>        fr = new FileReader(FilenameUtils.getFullPath(oracle) + FilenameUtils.getName(oracle));\n<line6>        read = fr.read();\n<line7>        fr.close();\n<line8>        return (char) read == '1';\n<line9>    } catch (Exception e) {\n<line10>        e.printStackTrace();\n<line11>        if (oracle == null) {\n<line12>        }\n<line13>        return false;\n<line14>    } finally {\n<line15>        if (fr != null) {\n<line16>            try {\n<line17>                fr.close();\n<line18>            } catch (IOException e) {\n<line19>                e.printStackTrace();\n<line20>            }\n<line21>        }\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    FileReader fr = null;\n<line3>    try {\n<line4>        int read;\n<line5>        fr = new FileReader(FilenameUtils.getFullPath(oracle) + FilenameUtils.getName(oracle));\n<line6>        read = fr.read();\n<line7>        LOG.debug(\"Oracle says:{}\", (char) read);\n<line8>        fr.close();\n<line9>        return (char) read == '1';\n<line10>    } catch (Exception e) {\n<line11>        e.printStackTrace();\n<line12>        if (oracle == null) {\n<line13>            LOG.error(\"Oracle is not set, return false\");\n<line14>        }\n<line15>        return false;\n<line16>    } finally {\n<line17>        if (fr != null) {\n<line18>            try {\n<line19>                fr.close();\n<line20>            } catch (IOException e) {\n<line21>                e.printStackTrace();\n<line22>            }\n<line23>        }\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    int read;\n<line3>    fr = new FileReader(FilenameUtils.getFullPath(oracle) + FilenameUtils.getName(oracle));\n<line4>    read = fr.read();\n<line5>    fr.close();\n<line6>    return (char) read == '1';\n<line7>}","output":"<line1>{\n<line2>    int read;\n<line3>    fr = new FileReader(FilenameUtils.getFullPath(oracle) + FilenameUtils.getName(oracle));\n<line4>    read = fr.read();\n<line5>    LOG.debug(\"Oracle says:{}\", (char) read);\n<line6>    fr.close();\n<line7>    return (char) read == '1';\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    e.printStackTrace();\n<line3>    if (oracle == null) {\n<line4>    }\n<line5>    return false;\n<line6>}","output":"<line1>{\n<line2>    e.printStackTrace();\n<line3>    if (oracle == null) {\n<line4>        LOG.error(\"Oracle is not set, return false\");\n<line5>    }\n<line6>    return false;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Oracle is not set, return false\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (outstandingProposal.size() >= 1) {\n<line4>            outstandingProposal.sort((o1, o2) -> (int) (o1.getZxid() - o2.getZxid()));\n<line5>            Leader.Proposal p;\n<line6>            int i = 0;\n<line7>            while (i < outstandingProposal.size()) {\n<line8>                p = outstandingProposal.get(i);\n<line9>                if (p.getZxid() > lastCommitted) {\n<line10>                    if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line11>                        break;\n<line12>                    } else {\n<line13>                        lastCommitted = p.getZxid();\n<line14>                        outstandingProposal.remove(p);\n<line15>                    }\n<line16>                }\n<line17>            }\n<line18>        }\n<line19>    } catch (Exception e) {\n<line20>        e.printStackTrace();\n<line21>        return false;\n<line22>    }\n<line23>    return true;\n<line24>}","output":"<line1>{\n<line2>    LOG.debug(\"Start Revalidation outstandingProposals\");\n<line3>    try {\n<line4>        while (outstandingProposal.size() >= 1) {\n<line5>            outstandingProposal.sort((o1, o2) -> (int) (o1.getZxid() - o2.getZxid()));\n<line6>            Leader.Proposal p;\n<line7>            int i = 0;\n<line8>            while (i < outstandingProposal.size()) {\n<line9>                p = outstandingProposal.get(i);\n<line10>                if (p.getZxid() > lastCommitted) {\n<line11>                    LOG.debug(\"Re-validate outstanding proposal: 0x{} size:{} lastCommitted:{}\", Long.toHexString(p.getZxid()), outstandingProposal.size(), Long.toHexString(lastCommitted));\n<line12>                    if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line13>                        break;\n<line14>                    } else {\n<line15>                        lastCommitted = p.getZxid();\n<line16>                        outstandingProposal.remove(p);\n<line17>                    }\n<line18>                }\n<line19>            }\n<line20>        }\n<line21>    } catch (Exception e) {\n<line22>        e.printStackTrace();\n<line23>        return false;\n<line24>    }\n<line25>    LOG.debug(\"Finish Revalidation outstandingProposals\");\n<line26>    return true;\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    while (outstandingProposal.size() >= 1) {\n<line3>        outstandingProposal.sort((o1, o2) -> (int) (o1.getZxid() - o2.getZxid()));\n<line4>        Leader.Proposal p;\n<line5>        int i = 0;\n<line6>        while (i < outstandingProposal.size()) {\n<line7>            p = outstandingProposal.get(i);\n<line8>            if (p.getZxid() > lastCommitted) {\n<line9>                if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line10>                    break;\n<line11>                } else {\n<line12>                    lastCommitted = p.getZxid();\n<line13>                    outstandingProposal.remove(p);\n<line14>                }\n<line15>            }\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    while (outstandingProposal.size() >= 1) {\n<line3>        outstandingProposal.sort((o1, o2) -> (int) (o1.getZxid() - o2.getZxid()));\n<line4>        Leader.Proposal p;\n<line5>        int i = 0;\n<line6>        while (i < outstandingProposal.size()) {\n<line7>            p = outstandingProposal.get(i);\n<line8>            if (p.getZxid() > lastCommitted) {\n<line9>                LOG.debug(\"Re-validate outstanding proposal: 0x{} size:{} lastCommitted:{}\", Long.toHexString(p.getZxid()), outstandingProposal.size(), Long.toHexString(lastCommitted));\n<line10>                if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line11>                    break;\n<line12>                } else {\n<line13>                    lastCommitted = p.getZxid();\n<line14>                    outstandingProposal.remove(p);\n<line15>                }\n<line16>            }\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    outstandingProposal.sort((o1, o2) -> (int) (o1.getZxid() - o2.getZxid()));\n<line3>    Leader.Proposal p;\n<line4>    int i = 0;\n<line5>    while (i < outstandingProposal.size()) {\n<line6>        p = outstandingProposal.get(i);\n<line7>        if (p.getZxid() > lastCommitted) {\n<line8>            if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line9>                break;\n<line10>            } else {\n<line11>                lastCommitted = p.getZxid();\n<line12>                outstandingProposal.remove(p);\n<line13>            }\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    outstandingProposal.sort((o1, o2) -> (int) (o1.getZxid() - o2.getZxid()));\n<line3>    Leader.Proposal p;\n<line4>    int i = 0;\n<line5>    while (i < outstandingProposal.size()) {\n<line6>        p = outstandingProposal.get(i);\n<line7>        if (p.getZxid() > lastCommitted) {\n<line8>            LOG.debug(\"Re-validate outstanding proposal: 0x{} size:{} lastCommitted:{}\", Long.toHexString(p.getZxid()), outstandingProposal.size(), Long.toHexString(lastCommitted));\n<line9>            if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line10>                break;\n<line11>            } else {\n<line12>                lastCommitted = p.getZxid();\n<line13>                outstandingProposal.remove(p);\n<line14>            }\n<line15>        }\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    p = outstandingProposal.get(i);\n<line3>    if (p.getZxid() > lastCommitted) {\n<line4>        if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line5>            break;\n<line6>        } else {\n<line7>            lastCommitted = p.getZxid();\n<line8>            outstandingProposal.remove(p);\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    p = outstandingProposal.get(i);\n<line3>    if (p.getZxid() > lastCommitted) {\n<line4>        LOG.debug(\"Re-validate outstanding proposal: 0x{} size:{} lastCommitted:{}\", Long.toHexString(p.getZxid()), outstandingProposal.size(), Long.toHexString(lastCommitted));\n<line5>        if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line6>            break;\n<line7>        } else {\n<line8>            lastCommitted = p.getZxid();\n<line9>            outstandingProposal.remove(p);\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line3>        break;\n<line4>    } else {\n<line5>        lastCommitted = p.getZxid();\n<line6>        outstandingProposal.remove(p);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.debug(\"Re-validate outstanding proposal: 0x{} size:{} lastCommitted:{}\", Long.toHexString(p.getZxid()), outstandingProposal.size(), Long.toHexString(lastCommitted));\n<line3>    if (!self.tryToCommit(p, p.getZxid(), null)) {\n<line4>        break;\n<line5>    } else {\n<line6>        lastCommitted = p.getZxid();\n<line7>        outstandingProposal.remove(p);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    if (oracle == null || getVotingMembers().size() > 2) {\n<line3>        return super.containsQuorum(ackSet);\n<line4>    } else if (!super.containsQuorum(ackSet)) {\n<line5>        if (getNeedOracle()) {\n<line6>            return askOracle();\n<line7>        } else {\n<line8>            return false;\n<line9>        }\n<line10>    } else {\n<line11>        return true;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    if (oracle == null || getVotingMembers().size() > 2) {\n<line3>        return super.containsQuorum(ackSet);\n<line4>    } else if (!super.containsQuorum(ackSet)) {\n<line5>        if (getNeedOracle()) {\n<line6>            LOG.debug(\"We lose the quorum, but we do not have any valid followers Oracle:{}\", askOracle());\n<line7>            return askOracle();\n<line8>        } else {\n<line9>            return false;\n<line10>        }\n<line11>    } else {\n<line12>        return true;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (getNeedOracle()) {\n<line3>        return askOracle();\n<line4>    } else {\n<line5>        return false;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (getNeedOracle()) {\n<line3>        LOG.debug(\"We lose the quorum, but we do not have any valid followers Oracle:{}\", askOracle());\n<line4>        return askOracle();\n<line5>    } else {\n<line6>        return false;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    return askOracle();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"We lose the quorum, but we do not have any valid followers Oracle:{}\", askOracle());\n<line3>    return askOracle();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    parse(qp);\n<line3>}","output":"<line1>{\n<line2>    parse(qp);\n<line3>    LOG.info(\"{}, {}, {}\", serverWeight.size(), serverGroup.size(), groupWeight.size());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    File configFile = new File(filename);\n<line3>    try {\n<line4>        if (!configFile.exists()) {\n<line5>            throw new IllegalArgumentException(configFile.toString() + \" file is missing\");\n<line6>        }\n<line7>        Properties cfg = new Properties();\n<line8>        FileInputStream in = new FileInputStream(configFile);\n<line9>        try {\n<line10>            cfg.load(in);\n<line11>        } finally {\n<line12>            in.close();\n<line13>        }\n<line14>        parse(cfg);\n<line15>    } catch (IOException e) {\n<line16>        throw new ConfigException(\"Error processing \" + filename, e);\n<line17>    } catch (IllegalArgumentException e) {\n<line18>        throw new ConfigException(\"Error processing \" + filename, e);\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    File configFile = new File(filename);\n<line3>    LOG.info(\"Reading configuration from: {}\", configFile);\n<line4>    try {\n<line5>        if (!configFile.exists()) {\n<line6>            throw new IllegalArgumentException(configFile.toString() + \" file is missing\");\n<line7>        }\n<line8>        Properties cfg = new Properties();\n<line9>        FileInputStream in = new FileInputStream(configFile);\n<line10>        try {\n<line11>            cfg.load(in);\n<line12>        } finally {\n<line13>            in.close();\n<line14>        }\n<line15>        parse(cfg);\n<line16>    } catch (IOException e) {\n<line17>        throw new ConfigException(\"Error processing \" + filename, e);\n<line18>    } catch (IllegalArgumentException e) {\n<line19>        throw new ConfigException(\"Error processing \" + filename, e);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    for (Entry<Long, Long> entry : serverGroup.entrySet()) {\n<line3>        Long sid = entry.getKey();\n<line4>        Long gid = entry.getValue();\n<line5>        if (!groupWeight.containsKey(gid)) {\n<line6>            groupWeight.put(gid, serverWeight.get(sid));\n<line7>        } else {\n<line8>            long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);\n<line9>            groupWeight.put(gid, totalWeight);\n<line10>        }\n<line11>    }\n<line12>    /*\n<line13>         * Do not consider groups with weight zero\n<line14>         */\n<line15>    for (long weight : groupWeight.values()) {\n<line16>        if (weight == ((long) 0)) {\n<line17>            numGroups--;\n<line18>        }\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    for (Entry<Long, Long> entry : serverGroup.entrySet()) {\n<line3>        Long sid = entry.getKey();\n<line4>        Long gid = entry.getValue();\n<line5>        if (!groupWeight.containsKey(gid)) {\n<line6>            groupWeight.put(gid, serverWeight.get(sid));\n<line7>        } else {\n<line8>            long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);\n<line9>            groupWeight.put(gid, totalWeight);\n<line10>        }\n<line11>    }\n<line12>    /*\n<line13>         * Do not consider groups with weight zero\n<line14>         */\n<line15>    for (long weight : groupWeight.values()) {\n<line16>        LOG.debug(\"Group weight: {}\", weight);\n<line17>        if (weight == ((long) 0)) {\n<line18>            numGroups--;\n<line19>            LOG.debug(\"One zero-weight group: 1, {}\", numGroups);\n<line20>        }\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    if (weight == ((long) 0)) {\n<line3>        numGroups--;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(\"Group weight: {}\", weight);\n<line3>    if (weight == ((long) 0)) {\n<line4>        numGroups--;\n<line5>        LOG.debug(\"One zero-weight group: 1, {}\", numGroups);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    numGroups--;\n<line3>}","output":"<line1>{\n<line2>    numGroups--;\n<line3>    LOG.debug(\"One zero-weight group: 1, {}\", numGroups);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    HashMap<Long, Long> expansion = new HashMap<>();\n<line3>    /*\n<line4>         * Adds up weights per group\n<line5>         */\n<line6>    if (set.size() == 0) {\n<line7>        return false;\n<line8>    }\n<line9>    for (long sid : set) {\n<line10>        Long gid = serverGroup.get(sid);\n<line11>        if (gid == null) {\n<line12>            continue;\n<line13>        }\n<line14>        if (!expansion.containsKey(gid)) {\n<line15>            expansion.put(gid, serverWeight.get(sid));\n<line16>        } else {\n<line17>            long totalWeight = serverWeight.get(sid) + expansion.get(gid);\n<line18>            expansion.put(gid, totalWeight);\n<line19>        }\n<line20>    }\n<line21>    /*\n<line22>         * Check if all groups have majority\n<line23>         */\n<line24>    int majGroupCounter = 0;\n<line25>    for (Entry<Long, Long> entry : expansion.entrySet()) {\n<line26>        Long gid = entry.getKey();\n<line27>        if (entry.getValue() > (groupWeight.get(gid) / 2)) {\n<line28>            majGroupCounter++;\n<line29>        }\n<line30>    }\n<line31>    if ((majGroupCounter > (numGroups / 2))) {\n<line32>        return true;\n<line33>    } else {\n<line34>        return false;\n<line35>    }\n<line36>}","output":"<line1>{\n<line2>    HashMap<Long, Long> expansion = new HashMap<>();\n<line3>    /*\n<line4>         * Adds up weights per group\n<line5>         */\n<line6>    LOG.debug(\"Set size: {}\", set.size());\n<line7>    if (set.size() == 0) {\n<line8>        return false;\n<line9>    }\n<line10>    for (long sid : set) {\n<line11>        Long gid = serverGroup.get(sid);\n<line12>        if (gid == null) {\n<line13>            continue;\n<line14>        }\n<line15>        if (!expansion.containsKey(gid)) {\n<line16>            expansion.put(gid, serverWeight.get(sid));\n<line17>        } else {\n<line18>            long totalWeight = serverWeight.get(sid) + expansion.get(gid);\n<line19>            expansion.put(gid, totalWeight);\n<line20>        }\n<line21>    }\n<line22>    /*\n<line23>         * Check if all groups have majority\n<line24>         */\n<line25>    int majGroupCounter = 0;\n<line26>    for (Entry<Long, Long> entry : expansion.entrySet()) {\n<line27>        Long gid = entry.getKey();\n<line28>        LOG.debug(\"Group info: {}, {}, {}\", entry.getValue(), gid, groupWeight.get(gid));\n<line29>        if (entry.getValue() > (groupWeight.get(gid) / 2)) {\n<line30>            majGroupCounter++;\n<line31>        }\n<line32>    }\n<line33>    LOG.debug(\"Majority group counter: {}, {}\", majGroupCounter, numGroups);\n<line34>    if ((majGroupCounter > (numGroups / 2))) {\n<line35>        LOG.debug(\"Positive set size: {}\", set.size());\n<line36>        return true;\n<line37>    } else {\n<line38>        LOG.debug(\"Negative set size: {}\", set.size());\n<line39>        return false;\n<line40>    }\n<line41>}"},{"input":"","instruction":"<line1>{\n<line2>    Long gid = entry.getKey();\n<line3>    if (entry.getValue() > (groupWeight.get(gid) / 2)) {\n<line4>        majGroupCounter++;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    Long gid = entry.getKey();\n<line3>    LOG.debug(\"Group info: {}, {}, {}\", entry.getValue(), gid, groupWeight.get(gid));\n<line4>    if (entry.getValue() > (groupWeight.get(gid) / 2)) {\n<line5>        majGroupCounter++;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    return true;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Positive set size: {}\", set.size());\n<line3>    return true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Negative set size: {}\", set.size());\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // check to avoid startup follows shutdown\n<line3>    if (shutdown) {\n<line4>        return;\n<line5>    }\n<line6>    registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);\n<line7>    super.startup();\n<line8>    self.setZooKeeperServer(this);\n<line9>    self.adminServer.setZooKeeperServer(this);\n<line10>}","output":"<line1>{\n<line2>    // check to avoid startup follows shutdown\n<line3>    if (shutdown) {\n<line4>        LOG.warn(\"Not starting Read-only server as startup follows shutdown!\");\n<line5>        return;\n<line6>    }\n<line7>    registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);\n<line8>    super.startup();\n<line9>    self.setZooKeeperServer(this);\n<line10>    self.adminServer.setZooKeeperServer(this);\n<line11>    LOG.info(\"Read-only server started\");\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    if (((LearnerSessionTracker) sessionTracker).isGlobalSession(sessionId)) {\n<line3>        String msg = \"Refusing global session reconnection in RO mode \" + cnxn.getRemoteSocketAddress();\n<line4>        throw new ServerCnxn.CloseRequestException(msg, ServerCnxn.DisconnectReason.RENEW_GLOBAL_SESSION_IN_RO_MODE);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (((LearnerSessionTracker) sessionTracker).isGlobalSession(sessionId)) {\n<line3>        String msg = \"Refusing global session reconnection in RO mode \" + cnxn.getRemoteSocketAddress();\n<line4>        LOG.info(msg);\n<line5>        throw new ServerCnxn.CloseRequestException(msg, ServerCnxn.DisconnectReason.RENEW_GLOBAL_SESSION_IN_RO_MODE);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = \"Refusing global session reconnection in RO mode \" + cnxn.getRemoteSocketAddress();\n<line3>    throw new ServerCnxn.CloseRequestException(msg, ServerCnxn.DisconnectReason.RENEW_GLOBAL_SESSION_IN_RO_MODE);\n<line4>}","output":"<line1>{\n<line2>    String msg = \"Refusing global session reconnection in RO mode \" + cnxn.getRemoteSocketAddress();\n<line3>    LOG.info(msg);\n<line4>    throw new ServerCnxn.CloseRequestException(msg, ServerCnxn.DisconnectReason.RENEW_GLOBAL_SESSION_IN_RO_MODE);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        return;\n<line4>    }\n<line5>    shutdown = true;\n<line6>    unregisterJMX(this);\n<line7>    // set peer's server to null\n<line8>    self.setZooKeeperServer(null);\n<line9>    // clear all the connections\n<line10>    self.closeAllConnections();\n<line11>    self.adminServer.setZooKeeperServer(null);\n<line12>    // shutdown the server itself\n<line13>    super.shutdown();\n<line14>}","output":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line4>        return;\n<line5>    }\n<line6>    shutdown = true;\n<line7>    unregisterJMX(this);\n<line8>    // set peer's server to null\n<line9>    self.setZooKeeperServer(null);\n<line10>    // clear all the connections\n<line11>    self.closeAllConnections();\n<line12>    self.adminServer.setZooKeeperServer(null);\n<line13>    // shutdown the server itself\n<line14>    super.shutdown();\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    self.end_fle = Time.currentElapsedTime();\n<line3>    long electionTimeTaken = self.end_fle - self.start_fle;\n<line4>    self.setElectionTimeTaken(electionTimeTaken);\n<line5>    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n<line6>    self.start_fle = 0;\n<line7>    self.end_fle = 0;\n<line8>    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n<line9>    long connectionTime = 0;\n<line10>    boolean completedSync = false;\n<line11>    try {\n<line12>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line13>        QuorumServer leaderServer = findLeader();\n<line14>        try {\n<line15>            connectToLeader(leaderServer.addr, leaderServer.hostname);\n<line16>            connectionTime = System.currentTimeMillis();\n<line17>            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n<line18>            if (self.isReconfigStateChange()) {\n<line19>                throw new Exception(\"learned about role change\");\n<line20>            }\n<line21>            //check to see if the leader zxid is lower than ours\n<line22>            //this should never happen but is just a safety check\n<line23>            long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n<line24>            if (newEpoch < self.getAcceptedEpoch()) {\n<line25>                throw new IOException(\"Error: Epoch of leader is lower\");\n<line26>            }\n<line27>            long startTime = Time.currentElapsedTime();\n<line28>            self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n<line29>            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line30>            syncWithLeader(newEpochZxid);\n<line31>            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line32>            completedSync = true;\n<line33>            long syncTime = Time.currentElapsedTime() - startTime;\n<line34>            ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n<line35>            if (self.getObserverMasterPort() > 0) {\n<line36>                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line37>                om.start();\n<line38>            } else {\n<line39>                om = null;\n<line40>            }\n<line41>            // create a reusable packet to reduce gc impact\n<line42>            QuorumPacket qp = new QuorumPacket();\n<line43>            while (this.isRunning()) {\n<line44>                readPacket(qp);\n<line45>                processPacket(qp);\n<line46>            }\n<line47>        } catch (Exception e) {\n<line48>            closeSocket();\n<line49>            // clear pending revalidations\n<line50>            pendingRevalidations.clear();\n<line51>        }\n<line52>    } finally {\n<line53>        if (om != null) {\n<line54>            om.stop();\n<line55>        }\n<line56>        zk.unregisterJMX(this);\n<line57>        if (connectionTime != 0) {\n<line58>            long connectionDuration = System.currentTimeMillis() - connectionTime;\n<line59>            messageTracker.dumpToLog(leaderAddr.toString());\n<line60>        }\n<line61>    }\n<line62>}","output":"<line1>{\n<line2>    self.end_fle = Time.currentElapsedTime();\n<line3>    long electionTimeTaken = self.end_fle - self.start_fle;\n<line4>    self.setElectionTimeTaken(electionTimeTaken);\n<line5>    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);\n<line6>    LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);\n<line7>    self.start_fle = 0;\n<line8>    self.end_fle = 0;\n<line9>    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n<line10>    long connectionTime = 0;\n<line11>    boolean completedSync = false;\n<line12>    try {\n<line13>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line14>        QuorumServer leaderServer = findLeader();\n<line15>        try {\n<line16>            connectToLeader(leaderServer.addr, leaderServer.hostname);\n<line17>            connectionTime = System.currentTimeMillis();\n<line18>            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n<line19>            if (self.isReconfigStateChange()) {\n<line20>                throw new Exception(\"learned about role change\");\n<line21>            }\n<line22>            //check to see if the leader zxid is lower than ours\n<line23>            //this should never happen but is just a safety check\n<line24>            long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n<line25>            if (newEpoch < self.getAcceptedEpoch()) {\n<line26>                LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid) + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n<line27>                throw new IOException(\"Error: Epoch of leader is lower\");\n<line28>            }\n<line29>            long startTime = Time.currentElapsedTime();\n<line30>            self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n<line31>            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line32>            syncWithLeader(newEpochZxid);\n<line33>            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line34>            completedSync = true;\n<line35>            long syncTime = Time.currentElapsedTime() - startTime;\n<line36>            ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n<line37>            if (self.getObserverMasterPort() > 0) {\n<line38>                LOG.info(\"Starting ObserverMaster\");\n<line39>                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line40>                om.start();\n<line41>            } else {\n<line42>                om = null;\n<line43>            }\n<line44>            // create a reusable packet to reduce gc impact\n<line45>            QuorumPacket qp = new QuorumPacket();\n<line46>            while (this.isRunning()) {\n<line47>                readPacket(qp);\n<line48>                processPacket(qp);\n<line49>            }\n<line50>        } catch (Exception e) {\n<line51>            LOG.warn(\"Exception when following the leader\", e);\n<line52>            closeSocket();\n<line53>            // clear pending revalidations\n<line54>            pendingRevalidations.clear();\n<line55>        }\n<line56>    } finally {\n<line57>        if (om != null) {\n<line58>            om.stop();\n<line59>        }\n<line60>        zk.unregisterJMX(this);\n<line61>        if (connectionTime != 0) {\n<line62>            long connectionDuration = System.currentTimeMillis() - connectionTime;\n<line63>            LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n<line64>            messageTracker.dumpToLog(leaderAddr.toString());\n<line65>        }\n<line66>    }\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line3>    QuorumServer leaderServer = findLeader();\n<line4>    try {\n<line5>        connectToLeader(leaderServer.addr, leaderServer.hostname);\n<line6>        connectionTime = System.currentTimeMillis();\n<line7>        long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n<line8>        if (self.isReconfigStateChange()) {\n<line9>            throw new Exception(\"learned about role change\");\n<line10>        }\n<line11>        //check to see if the leader zxid is lower than ours\n<line12>        //this should never happen but is just a safety check\n<line13>        long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n<line14>        if (newEpoch < self.getAcceptedEpoch()) {\n<line15>            throw new IOException(\"Error: Epoch of leader is lower\");\n<line16>        }\n<line17>        long startTime = Time.currentElapsedTime();\n<line18>        self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n<line19>        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line20>        syncWithLeader(newEpochZxid);\n<line21>        self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line22>        completedSync = true;\n<line23>        long syncTime = Time.currentElapsedTime() - startTime;\n<line24>        ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n<line25>        if (self.getObserverMasterPort() > 0) {\n<line26>            om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line27>            om.start();\n<line28>        } else {\n<line29>            om = null;\n<line30>        }\n<line31>        // create a reusable packet to reduce gc impact\n<line32>        QuorumPacket qp = new QuorumPacket();\n<line33>        while (this.isRunning()) {\n<line34>            readPacket(qp);\n<line35>            processPacket(qp);\n<line36>        }\n<line37>    } catch (Exception e) {\n<line38>        closeSocket();\n<line39>        // clear pending revalidations\n<line40>        pendingRevalidations.clear();\n<line41>    }\n<line42>}","output":"<line1>{\n<line2>    self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line3>    QuorumServer leaderServer = findLeader();\n<line4>    try {\n<line5>        connectToLeader(leaderServer.addr, leaderServer.hostname);\n<line6>        connectionTime = System.currentTimeMillis();\n<line7>        long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n<line8>        if (self.isReconfigStateChange()) {\n<line9>            throw new Exception(\"learned about role change\");\n<line10>        }\n<line11>        //check to see if the leader zxid is lower than ours\n<line12>        //this should never happen but is just a safety check\n<line13>        long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n<line14>        if (newEpoch < self.getAcceptedEpoch()) {\n<line15>            LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid) + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n<line16>            throw new IOException(\"Error: Epoch of leader is lower\");\n<line17>        }\n<line18>        long startTime = Time.currentElapsedTime();\n<line19>        self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n<line20>        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line21>        syncWithLeader(newEpochZxid);\n<line22>        self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line23>        completedSync = true;\n<line24>        long syncTime = Time.currentElapsedTime() - startTime;\n<line25>        ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n<line26>        if (self.getObserverMasterPort() > 0) {\n<line27>            LOG.info(\"Starting ObserverMaster\");\n<line28>            om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line29>            om.start();\n<line30>        } else {\n<line31>            om = null;\n<line32>        }\n<line33>        // create a reusable packet to reduce gc impact\n<line34>        QuorumPacket qp = new QuorumPacket();\n<line35>        while (this.isRunning()) {\n<line36>            readPacket(qp);\n<line37>            processPacket(qp);\n<line38>        }\n<line39>    } catch (Exception e) {\n<line40>        LOG.warn(\"Exception when following the leader\", e);\n<line41>        closeSocket();\n<line42>        // clear pending revalidations\n<line43>        pendingRevalidations.clear();\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    connectToLeader(leaderServer.addr, leaderServer.hostname);\n<line3>    connectionTime = System.currentTimeMillis();\n<line4>    long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n<line5>    if (self.isReconfigStateChange()) {\n<line6>        throw new Exception(\"learned about role change\");\n<line7>    }\n<line8>    //check to see if the leader zxid is lower than ours\n<line9>    //this should never happen but is just a safety check\n<line10>    long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n<line11>    if (newEpoch < self.getAcceptedEpoch()) {\n<line12>        throw new IOException(\"Error: Epoch of leader is lower\");\n<line13>    }\n<line14>    long startTime = Time.currentElapsedTime();\n<line15>    self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n<line16>    self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line17>    syncWithLeader(newEpochZxid);\n<line18>    self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line19>    completedSync = true;\n<line20>    long syncTime = Time.currentElapsedTime() - startTime;\n<line21>    ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n<line22>    if (self.getObserverMasterPort() > 0) {\n<line23>        om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line24>        om.start();\n<line25>    } else {\n<line26>        om = null;\n<line27>    }\n<line28>    // create a reusable packet to reduce gc impact\n<line29>    QuorumPacket qp = new QuorumPacket();\n<line30>    while (this.isRunning()) {\n<line31>        readPacket(qp);\n<line32>        processPacket(qp);\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    connectToLeader(leaderServer.addr, leaderServer.hostname);\n<line3>    connectionTime = System.currentTimeMillis();\n<line4>    long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n<line5>    if (self.isReconfigStateChange()) {\n<line6>        throw new Exception(\"learned about role change\");\n<line7>    }\n<line8>    //check to see if the leader zxid is lower than ours\n<line9>    //this should never happen but is just a safety check\n<line10>    long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n<line11>    if (newEpoch < self.getAcceptedEpoch()) {\n<line12>        LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid) + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n<line13>        throw new IOException(\"Error: Epoch of leader is lower\");\n<line14>    }\n<line15>    long startTime = Time.currentElapsedTime();\n<line16>    self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n<line17>    self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line18>    syncWithLeader(newEpochZxid);\n<line19>    self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line20>    completedSync = true;\n<line21>    long syncTime = Time.currentElapsedTime() - startTime;\n<line22>    ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n<line23>    if (self.getObserverMasterPort() > 0) {\n<line24>        LOG.info(\"Starting ObserverMaster\");\n<line25>        om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line26>        om.start();\n<line27>    } else {\n<line28>        om = null;\n<line29>    }\n<line30>    // create a reusable packet to reduce gc impact\n<line31>    QuorumPacket qp = new QuorumPacket();\n<line32>    while (this.isRunning()) {\n<line33>        readPacket(qp);\n<line34>        processPacket(qp);\n<line35>    }\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new IOException(\"Error: Epoch of leader is lower\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid) + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n<line3>    throw new IOException(\"Error: Epoch of leader is lower\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line3>    om.start();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Starting ObserverMaster\");\n<line3>    om = new ObserverMaster(self, fzk, self.getObserverMasterPort());\n<line4>    om.start();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (om != null) {\n<line3>        om.stop();\n<line4>    }\n<line5>    zk.unregisterJMX(this);\n<line6>    if (connectionTime != 0) {\n<line7>        long connectionDuration = System.currentTimeMillis() - connectionTime;\n<line8>        messageTracker.dumpToLog(leaderAddr.toString());\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (om != null) {\n<line3>        om.stop();\n<line4>    }\n<line5>    zk.unregisterJMX(this);\n<line6>    if (connectionTime != 0) {\n<line7>        long connectionDuration = System.currentTimeMillis() - connectionTime;\n<line8>        LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n<line9>        messageTracker.dumpToLog(leaderAddr.toString());\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    long connectionDuration = System.currentTimeMillis() - connectionTime;\n<line3>    messageTracker.dumpToLog(leaderAddr.toString());\n<line4>}","output":"<line1>{\n<line2>    long connectionDuration = System.currentTimeMillis() - connectionTime;\n<line3>    LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n<line4>    messageTracker.dumpToLog(leaderAddr.toString());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    switch(qp.getType()) {\n<line3>        case Leader.PING:\n<line4>            ping(qp);\n<line5>            break;\n<line6>        case Leader.PROPOSAL:\n<line7>            ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add(1);\n<line8>            TxnLogEntry logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line9>            TxnHeader hdr = logEntry.getHeader();\n<line10>            Record txn = logEntry.getTxn();\n<line11>            TxnDigest digest = logEntry.getDigest();\n<line12>            if (hdr.getZxid() != lastQueued + 1) {\n<line13>            }\n<line14>            lastQueued = hdr.getZxid();\n<line15>            if (hdr.getType() == OpCode.reconfig) {\n<line16>                SetDataTxn setDataTxn = (SetDataTxn) txn;\n<line17>                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line18>                self.setLastSeenQuorumVerifier(qv, true);\n<line19>            }\n<line20>            fzk.logRequest(hdr, txn, digest);\n<line21>            if (hdr != null) {\n<line22>                /*\n<line23>                 * Request header is created only by the leader, so this is only set\n<line24>                 * for quorum packets. If there is a clock drift, the latency may be\n<line25>                 * negative. Headers use wall time, not CLOCK_MONOTONIC.\n<line26>                 */\n<line27>                long now = Time.currentWallTime();\n<line28>                long latency = now - hdr.getTime();\n<line29>                if (latency >= 0) {\n<line30>                    ServerMetrics.getMetrics().PROPOSAL_LATENCY.add(latency);\n<line31>                }\n<line32>            }\n<line33>            if (om != null) {\n<line34>                final long startTime = Time.currentElapsedTime();\n<line35>                om.proposalReceived(qp);\n<line36>                ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);\n<line37>            }\n<line38>            break;\n<line39>        case Leader.COMMIT:\n<line40>            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);\n<line41>            fzk.commit(qp.getZxid());\n<line42>            if (om != null) {\n<line43>                final long startTime = Time.currentElapsedTime();\n<line44>                om.proposalCommitted(qp.getZxid());\n<line45>                ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);\n<line46>            }\n<line47>            break;\n<line48>        case Leader.COMMITANDACTIVATE:\n<line49>            // get the new configuration from the request\n<line50>            Request request = fzk.pendingTxns.element();\n<line51>            SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();\n<line52>            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line53>            // get new designated leader from (current) leader's message\n<line54>            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line55>            long suggestedLeaderId = buffer.getLong();\n<line56>            final long zxid = qp.getZxid();\n<line57>            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, zxid, true);\n<line58>            // commit (writes the new config to ZK tree (/zookeeper/config)\n<line59>            fzk.commit(zxid);\n<line60>            if (om != null) {\n<line61>                om.informAndActivate(zxid, suggestedLeaderId);\n<line62>            }\n<line63>            if (majorChange) {\n<line64>                throw new Exception(\"changes proposed in reconfig\");\n<line65>            }\n<line66>            break;\n<line67>        case Leader.UPTODATE:\n<line68>            break;\n<line69>        case Leader.REVALIDATE:\n<line70>            if (om == null || !om.revalidateLearnerSession(qp)) {\n<line71>                revalidate(qp);\n<line72>            }\n<line73>            break;\n<line74>        case Leader.SYNC:\n<line75>            fzk.sync();\n<line76>            break;\n<line77>        default:\n<line78>            break;\n<line79>    }\n<line80>}","output":"<line1>{\n<line2>    switch(qp.getType()) {\n<line3>        case Leader.PING:\n<line4>            ping(qp);\n<line5>            break;\n<line6>        case Leader.PROPOSAL:\n<line7>            ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add(1);\n<line8>            TxnLogEntry logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line9>            TxnHeader hdr = logEntry.getHeader();\n<line10>            Record txn = logEntry.getTxn();\n<line11>            TxnDigest digest = logEntry.getDigest();\n<line12>            if (hdr.getZxid() != lastQueued + 1) {\n<line13>                LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line14>            }\n<line15>            lastQueued = hdr.getZxid();\n<line16>            if (hdr.getType() == OpCode.reconfig) {\n<line17>                SetDataTxn setDataTxn = (SetDataTxn) txn;\n<line18>                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line19>                self.setLastSeenQuorumVerifier(qv, true);\n<line20>            }\n<line21>            fzk.logRequest(hdr, txn, digest);\n<line22>            if (hdr != null) {\n<line23>                /*\n<line24>                 * Request header is created only by the leader, so this is only set\n<line25>                 * for quorum packets. If there is a clock drift, the latency may be\n<line26>                 * negative. Headers use wall time, not CLOCK_MONOTONIC.\n<line27>                 */\n<line28>                long now = Time.currentWallTime();\n<line29>                long latency = now - hdr.getTime();\n<line30>                if (latency >= 0) {\n<line31>                    ServerMetrics.getMetrics().PROPOSAL_LATENCY.add(latency);\n<line32>                }\n<line33>            }\n<line34>            if (om != null) {\n<line35>                final long startTime = Time.currentElapsedTime();\n<line36>                om.proposalReceived(qp);\n<line37>                ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);\n<line38>            }\n<line39>            break;\n<line40>        case Leader.COMMIT:\n<line41>            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);\n<line42>            fzk.commit(qp.getZxid());\n<line43>            if (om != null) {\n<line44>                final long startTime = Time.currentElapsedTime();\n<line45>                om.proposalCommitted(qp.getZxid());\n<line46>                ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);\n<line47>            }\n<line48>            break;\n<line49>        case Leader.COMMITANDACTIVATE:\n<line50>            // get the new configuration from the request\n<line51>            Request request = fzk.pendingTxns.element();\n<line52>            SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();\n<line53>            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line54>            // get new designated leader from (current) leader's message\n<line55>            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line56>            long suggestedLeaderId = buffer.getLong();\n<line57>            final long zxid = qp.getZxid();\n<line58>            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, zxid, true);\n<line59>            // commit (writes the new config to ZK tree (/zookeeper/config)\n<line60>            fzk.commit(zxid);\n<line61>            if (om != null) {\n<line62>                om.informAndActivate(zxid, suggestedLeaderId);\n<line63>            }\n<line64>            if (majorChange) {\n<line65>                throw new Exception(\"changes proposed in reconfig\");\n<line66>            }\n<line67>            break;\n<line68>        case Leader.UPTODATE:\n<line69>            LOG.error(\"Received an UPTODATE message after Follower started\");\n<line70>            break;\n<line71>        case Leader.REVALIDATE:\n<line72>            if (om == null || !om.revalidateLearnerSession(qp)) {\n<line73>                revalidate(qp);\n<line74>            }\n<line75>            break;\n<line76>        case Leader.SYNC:\n<line77>            fzk.sync();\n<line78>            break;\n<line79>        default:\n<line80>            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n<line81>            break;\n<line82>    }\n<line83>}"},{"input":"","instruction":"<line1>{\n<line2>    super.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"shutdown Follower\");\n<line3>    super.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    learnerHandler.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"terminating learner handler connection on demand {}\", toString());\n<line3>    learnerHandler.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        /*\n<line4>             * In each iteration of the following loop we process at most\n<line5>             * requestsToProcess requests of queuedRequests. We have to limit\n<line6>             * the number of request we poll from queuedRequests, since it is\n<line7>             * possible to endlessly poll read requests from queuedRequests, and\n<line8>             * that will lead to a starvation of non-local committed requests.\n<line9>             */\n<line10>        int requestsToProcess = 0;\n<line11>        boolean commitIsWaiting = false;\n<line12>        do {\n<line13>            /*\n<line14>                 * Since requests are placed in the queue before being sent to\n<line15>                 * the leader, if commitIsWaiting = true, the commit belongs to\n<line16>                 * the first update operation in the queuedRequests or to a\n<line17>                 * request from a client on another server (i.e., the order of\n<line18>                 * the following two lines is important!).\n<line19>                 */\n<line20>            synchronized (this) {\n<line21>                commitIsWaiting = !committedRequests.isEmpty();\n<line22>                requestsToProcess = queuedRequests.size();\n<line23>                if (requestsToProcess == 0 && !commitIsWaiting) {\n<line24>                    // Waiting for requests to process\n<line25>                    while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {\n<line26>                        wait();\n<line27>                        commitIsWaiting = !committedRequests.isEmpty();\n<line28>                        requestsToProcess = queuedRequests.size();\n<line29>                    }\n<line30>                }\n<line31>            }\n<line32>            ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());\n<line33>            ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());\n<line34>            ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());\n<line35>            long time = Time.currentElapsedTime();\n<line36>            /*\n<line37>                 * Processing up to requestsToProcess requests from the incoming\n<line38>                 * queue (queuedRequests). If maxReadBatchSize is set then no\n<line39>                 * commits will be processed until maxReadBatchSize number of\n<line40>                 * reads are processed (or no more reads remain in the queue).\n<line41>                 * After the loop a single committed request is processed if\n<line42>                 * one is waiting (or a batch of commits if maxCommitBatchSize\n<line43>                 * is set).\n<line44>                 */\n<line45>            Request request;\n<line46>            int readsProcessed = 0;\n<line47>            while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {\n<line48>                requestsToProcess--;\n<line49>                if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {\n<line50>                    // Add request to pending\n<line51>                    Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());\n<line52>                    requests.addLast(request);\n<line53>                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());\n<line54>                } else {\n<line55>                    readsProcessed++;\n<line56>                    numReadQueuedRequests.decrementAndGet();\n<line57>                    sendToNextProcessor(request);\n<line58>                }\n<line59>                /*\n<line60>                     * Stop feeding the pool if there is a local pending update\n<line61>                     * and a committed request that is ready. Once we have a\n<line62>                     * pending request with a waiting committed request, we know\n<line63>                     * we can process the committed one. This is because commits\n<line64>                     * for local requests arrive in the order they appeared in\n<line65>                     * the queue, so if we have a pending request and a\n<line66>                     * committed request, the committed request must be for that\n<line67>                     * pending write or for a write originating at a different\n<line68>                     * server. We skip this if maxReadBatchSize is set.\n<line69>                     */\n<line70>                if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {\n<line71>                    /*\n<line72>                         * We set commitIsWaiting so that we won't check\n<line73>                         * committedRequests again.\n<line74>                         */\n<line75>                    commitIsWaiting = true;\n<line76>                    break;\n<line77>                }\n<line78>            }\n<line79>            ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);\n<line80>            if (!commitIsWaiting) {\n<line81>                commitIsWaiting = !committedRequests.isEmpty();\n<line82>            }\n<line83>            /*\n<line84>                 * Handle commits, if any.\n<line85>                 */\n<line86>            if (commitIsWaiting && !stopped) {\n<line87>                /*\n<line88>                     * Drain outstanding reads\n<line89>                     */\n<line90>                waitForEmptyPool();\n<line91>                if (stopped) {\n<line92>                    return;\n<line93>                }\n<line94>                int commitsToProcess = maxCommitBatchSize;\n<line95>                /*\n<line96>                     * Loop through all the commits, and try to drain them.\n<line97>                     */\n<line98>                Set<Long> queuesToDrain = new HashSet<>();\n<line99>                long startWriteTime = Time.currentElapsedTime();\n<line100>                int commitsProcessed = 0;\n<line101>                while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line102>                    // Process committed head\n<line103>                    request = committedRequests.peek();\n<line104>                    if (request.isThrottled()) {\n<line105>                        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line106>                    }\n<line107>                    /*\n<line108>                         * Check if this is a local write request is pending,\n<line109>                         * if so, update it with the committed info. If the commit matches\n<line110>                         * the first write queued in the blockedRequestQueue, we know this is\n<line111>                         * a commit for a local write, as commits are received in order. Else\n<line112>                         * it must be a commit for a remote write.\n<line113>                         */\n<line114>                    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line115>                        /*\n<line116>                             * Commit matches the earliest write in our write queue.\n<line117>                             */\n<line118>                        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line119>                        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line120>                        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line121>                            /*\n<line122>                                 * Can't process this write yet.\n<line123>                                 * Either there are reads pending in this session, or we\n<line124>                                 * haven't gotten to this write yet.\n<line125>                                 */\n<line126>                            break;\n<line127>                        } else {\n<line128>                            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line129>                            // If session queue != null, then it is also not empty.\n<line130>                            Request topPending = sessionQueue.poll();\n<line131>                            /*\n<line132>                                 * Generally, we want to send to the next processor our version of the request,\n<line133>                                 * since it contains the session information that is needed for post update processing.\n<line134>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line135>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line136>                                 * requests that are outstanding and have originated from this server\n<line137>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line138>                                 * outstanding request completes. Note that in the other case, the operation\n<line139>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line140>                                 * session that needs to be notified.\n<line141>                                 */\n<line142>                            topPending.setHdr(request.getHdr());\n<line143>                            topPending.setTxn(request.getTxn());\n<line144>                            topPending.setTxnDigest(request.getTxnDigest());\n<line145>                            topPending.zxid = request.zxid;\n<line146>                            topPending.commitRecvTime = request.commitRecvTime;\n<line147>                            request = topPending;\n<line148>                            if (request.isThrottled()) {\n<line149>                                ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line150>                            }\n<line151>                            // Only decrement if we take a request off the queue.\n<line152>                            numWriteQueuedRequests.decrementAndGet();\n<line153>                            queuedWriteRequests.poll();\n<line154>                            queuesToDrain.add(request.sessionId);\n<line155>                        }\n<line156>                    }\n<line157>                    /*\n<line158>                         * Pull the request off the commit queue, now that we are going\n<line159>                         * to process it.\n<line160>                         */\n<line161>                    committedRequests.remove();\n<line162>                    commitsToProcess--;\n<line163>                    commitsProcessed++;\n<line164>                    // Process the write inline.\n<line165>                    processWrite(request);\n<line166>                    commitIsWaiting = !committedRequests.isEmpty();\n<line167>                }\n<line168>                ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line169>                ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line170>                /*\n<line171>                     * Process following reads if any, remove session queue(s) if\n<line172>                     * empty.\n<line173>                     */\n<line174>                readsProcessed = 0;\n<line175>                for (Long sessionId : queuesToDrain) {\n<line176>                    Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line177>                    int readsAfterWrite = 0;\n<line178>                    while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line179>                        numReadQueuedRequests.decrementAndGet();\n<line180>                        sendToNextProcessor(sessionQueue.poll());\n<line181>                        readsAfterWrite++;\n<line182>                    }\n<line183>                    ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line184>                    readsProcessed += readsAfterWrite;\n<line185>                    // Remove empty queues\n<line186>                    if (sessionQueue.isEmpty()) {\n<line187>                        pendingRequests.remove(sessionId);\n<line188>                    }\n<line189>                }\n<line190>                ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line191>                ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line192>            }\n<line193>            ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);\n<line194>            endOfIteration();\n<line195>        } while (!stoppedMainLoop);\n<line196>    } catch (Throwable e) {\n<line197>        handleException(this.getName(), e);\n<line198>    }\n<line199>}","output":"<line1>{\n<line2>    try {\n<line3>        /*\n<line4>             * In each iteration of the following loop we process at most\n<line5>             * requestsToProcess requests of queuedRequests. We have to limit\n<line6>             * the number of request we poll from queuedRequests, since it is\n<line7>             * possible to endlessly poll read requests from queuedRequests, and\n<line8>             * that will lead to a starvation of non-local committed requests.\n<line9>             */\n<line10>        int requestsToProcess = 0;\n<line11>        boolean commitIsWaiting = false;\n<line12>        do {\n<line13>            /*\n<line14>                 * Since requests are placed in the queue before being sent to\n<line15>                 * the leader, if commitIsWaiting = true, the commit belongs to\n<line16>                 * the first update operation in the queuedRequests or to a\n<line17>                 * request from a client on another server (i.e., the order of\n<line18>                 * the following two lines is important!).\n<line19>                 */\n<line20>            synchronized (this) {\n<line21>                commitIsWaiting = !committedRequests.isEmpty();\n<line22>                requestsToProcess = queuedRequests.size();\n<line23>                if (requestsToProcess == 0 && !commitIsWaiting) {\n<line24>                    // Waiting for requests to process\n<line25>                    while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {\n<line26>                        wait();\n<line27>                        commitIsWaiting = !committedRequests.isEmpty();\n<line28>                        requestsToProcess = queuedRequests.size();\n<line29>                    }\n<line30>                }\n<line31>            }\n<line32>            ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());\n<line33>            ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());\n<line34>            ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());\n<line35>            long time = Time.currentElapsedTime();\n<line36>            /*\n<line37>                 * Processing up to requestsToProcess requests from the incoming\n<line38>                 * queue (queuedRequests). If maxReadBatchSize is set then no\n<line39>                 * commits will be processed until maxReadBatchSize number of\n<line40>                 * reads are processed (or no more reads remain in the queue).\n<line41>                 * After the loop a single committed request is processed if\n<line42>                 * one is waiting (or a batch of commits if maxCommitBatchSize\n<line43>                 * is set).\n<line44>                 */\n<line45>            Request request;\n<line46>            int readsProcessed = 0;\n<line47>            while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {\n<line48>                requestsToProcess--;\n<line49>                if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {\n<line50>                    // Add request to pending\n<line51>                    Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());\n<line52>                    requests.addLast(request);\n<line53>                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());\n<line54>                } else {\n<line55>                    readsProcessed++;\n<line56>                    numReadQueuedRequests.decrementAndGet();\n<line57>                    sendToNextProcessor(request);\n<line58>                }\n<line59>                /*\n<line60>                     * Stop feeding the pool if there is a local pending update\n<line61>                     * and a committed request that is ready. Once we have a\n<line62>                     * pending request with a waiting committed request, we know\n<line63>                     * we can process the committed one. This is because commits\n<line64>                     * for local requests arrive in the order they appeared in\n<line65>                     * the queue, so if we have a pending request and a\n<line66>                     * committed request, the committed request must be for that\n<line67>                     * pending write or for a write originating at a different\n<line68>                     * server. We skip this if maxReadBatchSize is set.\n<line69>                     */\n<line70>                if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {\n<line71>                    /*\n<line72>                         * We set commitIsWaiting so that we won't check\n<line73>                         * committedRequests again.\n<line74>                         */\n<line75>                    commitIsWaiting = true;\n<line76>                    break;\n<line77>                }\n<line78>            }\n<line79>            ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);\n<line80>            if (!commitIsWaiting) {\n<line81>                commitIsWaiting = !committedRequests.isEmpty();\n<line82>            }\n<line83>            /*\n<line84>                 * Handle commits, if any.\n<line85>                 */\n<line86>            if (commitIsWaiting && !stopped) {\n<line87>                /*\n<line88>                     * Drain outstanding reads\n<line89>                     */\n<line90>                waitForEmptyPool();\n<line91>                if (stopped) {\n<line92>                    return;\n<line93>                }\n<line94>                int commitsToProcess = maxCommitBatchSize;\n<line95>                /*\n<line96>                     * Loop through all the commits, and try to drain them.\n<line97>                     */\n<line98>                Set<Long> queuesToDrain = new HashSet<>();\n<line99>                long startWriteTime = Time.currentElapsedTime();\n<line100>                int commitsProcessed = 0;\n<line101>                while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line102>                    // Process committed head\n<line103>                    request = committedRequests.peek();\n<line104>                    if (request.isThrottled()) {\n<line105>                        LOG.error(\"Throttled request in committed pool: {}. Exiting.\", request);\n<line106>                        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line107>                    }\n<line108>                    /*\n<line109>                         * Check if this is a local write request is pending,\n<line110>                         * if so, update it with the committed info. If the commit matches\n<line111>                         * the first write queued in the blockedRequestQueue, we know this is\n<line112>                         * a commit for a local write, as commits are received in order. Else\n<line113>                         * it must be a commit for a remote write.\n<line114>                         */\n<line115>                    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line116>                        /*\n<line117>                             * Commit matches the earliest write in our write queue.\n<line118>                             */\n<line119>                        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line120>                        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line121>                        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line122>                            /*\n<line123>                                 * Can't process this write yet.\n<line124>                                 * Either there are reads pending in this session, or we\n<line125>                                 * haven't gotten to this write yet.\n<line126>                                 */\n<line127>                            break;\n<line128>                        } else {\n<line129>                            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line130>                            // If session queue != null, then it is also not empty.\n<line131>                            Request topPending = sessionQueue.poll();\n<line132>                            /*\n<line133>                                 * Generally, we want to send to the next processor our version of the request,\n<line134>                                 * since it contains the session information that is needed for post update processing.\n<line135>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line136>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line137>                                 * requests that are outstanding and have originated from this server\n<line138>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line139>                                 * outstanding request completes. Note that in the other case, the operation\n<line140>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line141>                                 * session that needs to be notified.\n<line142>                                 */\n<line143>                            topPending.setHdr(request.getHdr());\n<line144>                            topPending.setTxn(request.getTxn());\n<line145>                            topPending.setTxnDigest(request.getTxnDigest());\n<line146>                            topPending.zxid = request.zxid;\n<line147>                            topPending.commitRecvTime = request.commitRecvTime;\n<line148>                            request = topPending;\n<line149>                            if (request.isThrottled()) {\n<line150>                                LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line151>                                ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line152>                            }\n<line153>                            // Only decrement if we take a request off the queue.\n<line154>                            numWriteQueuedRequests.decrementAndGet();\n<line155>                            queuedWriteRequests.poll();\n<line156>                            queuesToDrain.add(request.sessionId);\n<line157>                        }\n<line158>                    }\n<line159>                    /*\n<line160>                         * Pull the request off the commit queue, now that we are going\n<line161>                         * to process it.\n<line162>                         */\n<line163>                    committedRequests.remove();\n<line164>                    commitsToProcess--;\n<line165>                    commitsProcessed++;\n<line166>                    // Process the write inline.\n<line167>                    processWrite(request);\n<line168>                    commitIsWaiting = !committedRequests.isEmpty();\n<line169>                }\n<line170>                ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line171>                ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line172>                /*\n<line173>                     * Process following reads if any, remove session queue(s) if\n<line174>                     * empty.\n<line175>                     */\n<line176>                readsProcessed = 0;\n<line177>                for (Long sessionId : queuesToDrain) {\n<line178>                    Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line179>                    int readsAfterWrite = 0;\n<line180>                    while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line181>                        numReadQueuedRequests.decrementAndGet();\n<line182>                        sendToNextProcessor(sessionQueue.poll());\n<line183>                        readsAfterWrite++;\n<line184>                    }\n<line185>                    ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line186>                    readsProcessed += readsAfterWrite;\n<line187>                    // Remove empty queues\n<line188>                    if (sessionQueue.isEmpty()) {\n<line189>                        pendingRequests.remove(sessionId);\n<line190>                    }\n<line191>                }\n<line192>                ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line193>                ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line194>            }\n<line195>            ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);\n<line196>            endOfIteration();\n<line197>        } while (!stoppedMainLoop);\n<line198>    } catch (Throwable e) {\n<line199>        handleException(this.getName(), e);\n<line200>    }\n<line201>    LOG.info(\"CommitProcessor exited loop!\");\n<line202>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>             * In each iteration of the following loop we process at most\n<line4>             * requestsToProcess requests of queuedRequests. We have to limit\n<line5>             * the number of request we poll from queuedRequests, since it is\n<line6>             * possible to endlessly poll read requests from queuedRequests, and\n<line7>             * that will lead to a starvation of non-local committed requests.\n<line8>             */\n<line9>    int requestsToProcess = 0;\n<line10>    boolean commitIsWaiting = false;\n<line11>    do {\n<line12>        /*\n<line13>                 * Since requests are placed in the queue before being sent to\n<line14>                 * the leader, if commitIsWaiting = true, the commit belongs to\n<line15>                 * the first update operation in the queuedRequests or to a\n<line16>                 * request from a client on another server (i.e., the order of\n<line17>                 * the following two lines is important!).\n<line18>                 */\n<line19>        synchronized (this) {\n<line20>            commitIsWaiting = !committedRequests.isEmpty();\n<line21>            requestsToProcess = queuedRequests.size();\n<line22>            if (requestsToProcess == 0 && !commitIsWaiting) {\n<line23>                // Waiting for requests to process\n<line24>                while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {\n<line25>                    wait();\n<line26>                    commitIsWaiting = !committedRequests.isEmpty();\n<line27>                    requestsToProcess = queuedRequests.size();\n<line28>                }\n<line29>            }\n<line30>        }\n<line31>        ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());\n<line32>        ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());\n<line33>        ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());\n<line34>        long time = Time.currentElapsedTime();\n<line35>        /*\n<line36>                 * Processing up to requestsToProcess requests from the incoming\n<line37>                 * queue (queuedRequests). If maxReadBatchSize is set then no\n<line38>                 * commits will be processed until maxReadBatchSize number of\n<line39>                 * reads are processed (or no more reads remain in the queue).\n<line40>                 * After the loop a single committed request is processed if\n<line41>                 * one is waiting (or a batch of commits if maxCommitBatchSize\n<line42>                 * is set).\n<line43>                 */\n<line44>        Request request;\n<line45>        int readsProcessed = 0;\n<line46>        while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {\n<line47>            requestsToProcess--;\n<line48>            if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {\n<line49>                // Add request to pending\n<line50>                Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());\n<line51>                requests.addLast(request);\n<line52>                ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());\n<line53>            } else {\n<line54>                readsProcessed++;\n<line55>                numReadQueuedRequests.decrementAndGet();\n<line56>                sendToNextProcessor(request);\n<line57>            }\n<line58>            /*\n<line59>                     * Stop feeding the pool if there is a local pending update\n<line60>                     * and a committed request that is ready. Once we have a\n<line61>                     * pending request with a waiting committed request, we know\n<line62>                     * we can process the committed one. This is because commits\n<line63>                     * for local requests arrive in the order they appeared in\n<line64>                     * the queue, so if we have a pending request and a\n<line65>                     * committed request, the committed request must be for that\n<line66>                     * pending write or for a write originating at a different\n<line67>                     * server. We skip this if maxReadBatchSize is set.\n<line68>                     */\n<line69>            if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {\n<line70>                /*\n<line71>                         * We set commitIsWaiting so that we won't check\n<line72>                         * committedRequests again.\n<line73>                         */\n<line74>                commitIsWaiting = true;\n<line75>                break;\n<line76>            }\n<line77>        }\n<line78>        ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);\n<line79>        if (!commitIsWaiting) {\n<line80>            commitIsWaiting = !committedRequests.isEmpty();\n<line81>        }\n<line82>        /*\n<line83>                 * Handle commits, if any.\n<line84>                 */\n<line85>        if (commitIsWaiting && !stopped) {\n<line86>            /*\n<line87>                     * Drain outstanding reads\n<line88>                     */\n<line89>            waitForEmptyPool();\n<line90>            if (stopped) {\n<line91>                return;\n<line92>            }\n<line93>            int commitsToProcess = maxCommitBatchSize;\n<line94>            /*\n<line95>                     * Loop through all the commits, and try to drain them.\n<line96>                     */\n<line97>            Set<Long> queuesToDrain = new HashSet<>();\n<line98>            long startWriteTime = Time.currentElapsedTime();\n<line99>            int commitsProcessed = 0;\n<line100>            while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line101>                // Process committed head\n<line102>                request = committedRequests.peek();\n<line103>                if (request.isThrottled()) {\n<line104>                    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line105>                }\n<line106>                /*\n<line107>                         * Check if this is a local write request is pending,\n<line108>                         * if so, update it with the committed info. If the commit matches\n<line109>                         * the first write queued in the blockedRequestQueue, we know this is\n<line110>                         * a commit for a local write, as commits are received in order. Else\n<line111>                         * it must be a commit for a remote write.\n<line112>                         */\n<line113>                if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line114>                    /*\n<line115>                             * Commit matches the earliest write in our write queue.\n<line116>                             */\n<line117>                    Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line118>                    ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line119>                    if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line120>                        /*\n<line121>                                 * Can't process this write yet.\n<line122>                                 * Either there are reads pending in this session, or we\n<line123>                                 * haven't gotten to this write yet.\n<line124>                                 */\n<line125>                        break;\n<line126>                    } else {\n<line127>                        ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line128>                        // If session queue != null, then it is also not empty.\n<line129>                        Request topPending = sessionQueue.poll();\n<line130>                        /*\n<line131>                                 * Generally, we want to send to the next processor our version of the request,\n<line132>                                 * since it contains the session information that is needed for post update processing.\n<line133>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line134>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line135>                                 * requests that are outstanding and have originated from this server\n<line136>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line137>                                 * outstanding request completes. Note that in the other case, the operation\n<line138>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line139>                                 * session that needs to be notified.\n<line140>                                 */\n<line141>                        topPending.setHdr(request.getHdr());\n<line142>                        topPending.setTxn(request.getTxn());\n<line143>                        topPending.setTxnDigest(request.getTxnDigest());\n<line144>                        topPending.zxid = request.zxid;\n<line145>                        topPending.commitRecvTime = request.commitRecvTime;\n<line146>                        request = topPending;\n<line147>                        if (request.isThrottled()) {\n<line148>                            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line149>                        }\n<line150>                        // Only decrement if we take a request off the queue.\n<line151>                        numWriteQueuedRequests.decrementAndGet();\n<line152>                        queuedWriteRequests.poll();\n<line153>                        queuesToDrain.add(request.sessionId);\n<line154>                    }\n<line155>                }\n<line156>                /*\n<line157>                         * Pull the request off the commit queue, now that we are going\n<line158>                         * to process it.\n<line159>                         */\n<line160>                committedRequests.remove();\n<line161>                commitsToProcess--;\n<line162>                commitsProcessed++;\n<line163>                // Process the write inline.\n<line164>                processWrite(request);\n<line165>                commitIsWaiting = !committedRequests.isEmpty();\n<line166>            }\n<line167>            ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line168>            ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line169>            /*\n<line170>                     * Process following reads if any, remove session queue(s) if\n<line171>                     * empty.\n<line172>                     */\n<line173>            readsProcessed = 0;\n<line174>            for (Long sessionId : queuesToDrain) {\n<line175>                Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line176>                int readsAfterWrite = 0;\n<line177>                while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line178>                    numReadQueuedRequests.decrementAndGet();\n<line179>                    sendToNextProcessor(sessionQueue.poll());\n<line180>                    readsAfterWrite++;\n<line181>                }\n<line182>                ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line183>                readsProcessed += readsAfterWrite;\n<line184>                // Remove empty queues\n<line185>                if (sessionQueue.isEmpty()) {\n<line186>                    pendingRequests.remove(sessionId);\n<line187>                }\n<line188>            }\n<line189>            ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line190>            ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line191>        }\n<line192>        ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);\n<line193>        endOfIteration();\n<line194>    } while (!stoppedMainLoop);\n<line195>}","output":"<line1>{\n<line2>    /*\n<line3>             * In each iteration of the following loop we process at most\n<line4>             * requestsToProcess requests of queuedRequests. We have to limit\n<line5>             * the number of request we poll from queuedRequests, since it is\n<line6>             * possible to endlessly poll read requests from queuedRequests, and\n<line7>             * that will lead to a starvation of non-local committed requests.\n<line8>             */\n<line9>    int requestsToProcess = 0;\n<line10>    boolean commitIsWaiting = false;\n<line11>    do {\n<line12>        /*\n<line13>                 * Since requests are placed in the queue before being sent to\n<line14>                 * the leader, if commitIsWaiting = true, the commit belongs to\n<line15>                 * the first update operation in the queuedRequests or to a\n<line16>                 * request from a client on another server (i.e., the order of\n<line17>                 * the following two lines is important!).\n<line18>                 */\n<line19>        synchronized (this) {\n<line20>            commitIsWaiting = !committedRequests.isEmpty();\n<line21>            requestsToProcess = queuedRequests.size();\n<line22>            if (requestsToProcess == 0 && !commitIsWaiting) {\n<line23>                // Waiting for requests to process\n<line24>                while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {\n<line25>                    wait();\n<line26>                    commitIsWaiting = !committedRequests.isEmpty();\n<line27>                    requestsToProcess = queuedRequests.size();\n<line28>                }\n<line29>            }\n<line30>        }\n<line31>        ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());\n<line32>        ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());\n<line33>        ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());\n<line34>        long time = Time.currentElapsedTime();\n<line35>        /*\n<line36>                 * Processing up to requestsToProcess requests from the incoming\n<line37>                 * queue (queuedRequests). If maxReadBatchSize is set then no\n<line38>                 * commits will be processed until maxReadBatchSize number of\n<line39>                 * reads are processed (or no more reads remain in the queue).\n<line40>                 * After the loop a single committed request is processed if\n<line41>                 * one is waiting (or a batch of commits if maxCommitBatchSize\n<line42>                 * is set).\n<line43>                 */\n<line44>        Request request;\n<line45>        int readsProcessed = 0;\n<line46>        while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {\n<line47>            requestsToProcess--;\n<line48>            if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {\n<line49>                // Add request to pending\n<line50>                Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());\n<line51>                requests.addLast(request);\n<line52>                ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());\n<line53>            } else {\n<line54>                readsProcessed++;\n<line55>                numReadQueuedRequests.decrementAndGet();\n<line56>                sendToNextProcessor(request);\n<line57>            }\n<line58>            /*\n<line59>                     * Stop feeding the pool if there is a local pending update\n<line60>                     * and a committed request that is ready. Once we have a\n<line61>                     * pending request with a waiting committed request, we know\n<line62>                     * we can process the committed one. This is because commits\n<line63>                     * for local requests arrive in the order they appeared in\n<line64>                     * the queue, so if we have a pending request and a\n<line65>                     * committed request, the committed request must be for that\n<line66>                     * pending write or for a write originating at a different\n<line67>                     * server. We skip this if maxReadBatchSize is set.\n<line68>                     */\n<line69>            if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {\n<line70>                /*\n<line71>                         * We set commitIsWaiting so that we won't check\n<line72>                         * committedRequests again.\n<line73>                         */\n<line74>                commitIsWaiting = true;\n<line75>                break;\n<line76>            }\n<line77>        }\n<line78>        ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);\n<line79>        if (!commitIsWaiting) {\n<line80>            commitIsWaiting = !committedRequests.isEmpty();\n<line81>        }\n<line82>        /*\n<line83>                 * Handle commits, if any.\n<line84>                 */\n<line85>        if (commitIsWaiting && !stopped) {\n<line86>            /*\n<line87>                     * Drain outstanding reads\n<line88>                     */\n<line89>            waitForEmptyPool();\n<line90>            if (stopped) {\n<line91>                return;\n<line92>            }\n<line93>            int commitsToProcess = maxCommitBatchSize;\n<line94>            /*\n<line95>                     * Loop through all the commits, and try to drain them.\n<line96>                     */\n<line97>            Set<Long> queuesToDrain = new HashSet<>();\n<line98>            long startWriteTime = Time.currentElapsedTime();\n<line99>            int commitsProcessed = 0;\n<line100>            while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line101>                // Process committed head\n<line102>                request = committedRequests.peek();\n<line103>                if (request.isThrottled()) {\n<line104>                    LOG.error(\"Throttled request in committed pool: {}. Exiting.\", request);\n<line105>                    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line106>                }\n<line107>                /*\n<line108>                         * Check if this is a local write request is pending,\n<line109>                         * if so, update it with the committed info. If the commit matches\n<line110>                         * the first write queued in the blockedRequestQueue, we know this is\n<line111>                         * a commit for a local write, as commits are received in order. Else\n<line112>                         * it must be a commit for a remote write.\n<line113>                         */\n<line114>                if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line115>                    /*\n<line116>                             * Commit matches the earliest write in our write queue.\n<line117>                             */\n<line118>                    Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line119>                    ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line120>                    if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line121>                        /*\n<line122>                                 * Can't process this write yet.\n<line123>                                 * Either there are reads pending in this session, or we\n<line124>                                 * haven't gotten to this write yet.\n<line125>                                 */\n<line126>                        break;\n<line127>                    } else {\n<line128>                        ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line129>                        // If session queue != null, then it is also not empty.\n<line130>                        Request topPending = sessionQueue.poll();\n<line131>                        /*\n<line132>                                 * Generally, we want to send to the next processor our version of the request,\n<line133>                                 * since it contains the session information that is needed for post update processing.\n<line134>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line135>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line136>                                 * requests that are outstanding and have originated from this server\n<line137>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line138>                                 * outstanding request completes. Note that in the other case, the operation\n<line139>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line140>                                 * session that needs to be notified.\n<line141>                                 */\n<line142>                        topPending.setHdr(request.getHdr());\n<line143>                        topPending.setTxn(request.getTxn());\n<line144>                        topPending.setTxnDigest(request.getTxnDigest());\n<line145>                        topPending.zxid = request.zxid;\n<line146>                        topPending.commitRecvTime = request.commitRecvTime;\n<line147>                        request = topPending;\n<line148>                        if (request.isThrottled()) {\n<line149>                            LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line150>                            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line151>                        }\n<line152>                        // Only decrement if we take a request off the queue.\n<line153>                        numWriteQueuedRequests.decrementAndGet();\n<line154>                        queuedWriteRequests.poll();\n<line155>                        queuesToDrain.add(request.sessionId);\n<line156>                    }\n<line157>                }\n<line158>                /*\n<line159>                         * Pull the request off the commit queue, now that we are going\n<line160>                         * to process it.\n<line161>                         */\n<line162>                committedRequests.remove();\n<line163>                commitsToProcess--;\n<line164>                commitsProcessed++;\n<line165>                // Process the write inline.\n<line166>                processWrite(request);\n<line167>                commitIsWaiting = !committedRequests.isEmpty();\n<line168>            }\n<line169>            ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line170>            ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line171>            /*\n<line172>                     * Process following reads if any, remove session queue(s) if\n<line173>                     * empty.\n<line174>                     */\n<line175>            readsProcessed = 0;\n<line176>            for (Long sessionId : queuesToDrain) {\n<line177>                Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line178>                int readsAfterWrite = 0;\n<line179>                while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line180>                    numReadQueuedRequests.decrementAndGet();\n<line181>                    sendToNextProcessor(sessionQueue.poll());\n<line182>                    readsAfterWrite++;\n<line183>                }\n<line184>                ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line185>                readsProcessed += readsAfterWrite;\n<line186>                // Remove empty queues\n<line187>                if (sessionQueue.isEmpty()) {\n<line188>                    pendingRequests.remove(sessionId);\n<line189>                }\n<line190>            }\n<line191>            ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line192>            ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line193>        }\n<line194>        ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);\n<line195>        endOfIteration();\n<line196>    } while (!stoppedMainLoop);\n<line197>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                 * Since requests are placed in the queue before being sent to\n<line4>                 * the leader, if commitIsWaiting = true, the commit belongs to\n<line5>                 * the first update operation in the queuedRequests or to a\n<line6>                 * request from a client on another server (i.e., the order of\n<line7>                 * the following two lines is important!).\n<line8>                 */\n<line9>    synchronized (this) {\n<line10>        commitIsWaiting = !committedRequests.isEmpty();\n<line11>        requestsToProcess = queuedRequests.size();\n<line12>        if (requestsToProcess == 0 && !commitIsWaiting) {\n<line13>            // Waiting for requests to process\n<line14>            while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {\n<line15>                wait();\n<line16>                commitIsWaiting = !committedRequests.isEmpty();\n<line17>                requestsToProcess = queuedRequests.size();\n<line18>            }\n<line19>        }\n<line20>    }\n<line21>    ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());\n<line22>    ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());\n<line23>    ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());\n<line24>    long time = Time.currentElapsedTime();\n<line25>    /*\n<line26>                 * Processing up to requestsToProcess requests from the incoming\n<line27>                 * queue (queuedRequests). If maxReadBatchSize is set then no\n<line28>                 * commits will be processed until maxReadBatchSize number of\n<line29>                 * reads are processed (or no more reads remain in the queue).\n<line30>                 * After the loop a single committed request is processed if\n<line31>                 * one is waiting (or a batch of commits if maxCommitBatchSize\n<line32>                 * is set).\n<line33>                 */\n<line34>    Request request;\n<line35>    int readsProcessed = 0;\n<line36>    while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {\n<line37>        requestsToProcess--;\n<line38>        if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {\n<line39>            // Add request to pending\n<line40>            Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());\n<line41>            requests.addLast(request);\n<line42>            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());\n<line43>        } else {\n<line44>            readsProcessed++;\n<line45>            numReadQueuedRequests.decrementAndGet();\n<line46>            sendToNextProcessor(request);\n<line47>        }\n<line48>        /*\n<line49>                     * Stop feeding the pool if there is a local pending update\n<line50>                     * and a committed request that is ready. Once we have a\n<line51>                     * pending request with a waiting committed request, we know\n<line52>                     * we can process the committed one. This is because commits\n<line53>                     * for local requests arrive in the order they appeared in\n<line54>                     * the queue, so if we have a pending request and a\n<line55>                     * committed request, the committed request must be for that\n<line56>                     * pending write or for a write originating at a different\n<line57>                     * server. We skip this if maxReadBatchSize is set.\n<line58>                     */\n<line59>        if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {\n<line60>            /*\n<line61>                         * We set commitIsWaiting so that we won't check\n<line62>                         * committedRequests again.\n<line63>                         */\n<line64>            commitIsWaiting = true;\n<line65>            break;\n<line66>        }\n<line67>    }\n<line68>    ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);\n<line69>    if (!commitIsWaiting) {\n<line70>        commitIsWaiting = !committedRequests.isEmpty();\n<line71>    }\n<line72>    /*\n<line73>                 * Handle commits, if any.\n<line74>                 */\n<line75>    if (commitIsWaiting && !stopped) {\n<line76>        /*\n<line77>                     * Drain outstanding reads\n<line78>                     */\n<line79>        waitForEmptyPool();\n<line80>        if (stopped) {\n<line81>            return;\n<line82>        }\n<line83>        int commitsToProcess = maxCommitBatchSize;\n<line84>        /*\n<line85>                     * Loop through all the commits, and try to drain them.\n<line86>                     */\n<line87>        Set<Long> queuesToDrain = new HashSet<>();\n<line88>        long startWriteTime = Time.currentElapsedTime();\n<line89>        int commitsProcessed = 0;\n<line90>        while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line91>            // Process committed head\n<line92>            request = committedRequests.peek();\n<line93>            if (request.isThrottled()) {\n<line94>                ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line95>            }\n<line96>            /*\n<line97>                         * Check if this is a local write request is pending,\n<line98>                         * if so, update it with the committed info. If the commit matches\n<line99>                         * the first write queued in the blockedRequestQueue, we know this is\n<line100>                         * a commit for a local write, as commits are received in order. Else\n<line101>                         * it must be a commit for a remote write.\n<line102>                         */\n<line103>            if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line104>                /*\n<line105>                             * Commit matches the earliest write in our write queue.\n<line106>                             */\n<line107>                Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line108>                ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line109>                if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line110>                    /*\n<line111>                                 * Can't process this write yet.\n<line112>                                 * Either there are reads pending in this session, or we\n<line113>                                 * haven't gotten to this write yet.\n<line114>                                 */\n<line115>                    break;\n<line116>                } else {\n<line117>                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line118>                    // If session queue != null, then it is also not empty.\n<line119>                    Request topPending = sessionQueue.poll();\n<line120>                    /*\n<line121>                                 * Generally, we want to send to the next processor our version of the request,\n<line122>                                 * since it contains the session information that is needed for post update processing.\n<line123>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line124>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line125>                                 * requests that are outstanding and have originated from this server\n<line126>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line127>                                 * outstanding request completes. Note that in the other case, the operation\n<line128>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line129>                                 * session that needs to be notified.\n<line130>                                 */\n<line131>                    topPending.setHdr(request.getHdr());\n<line132>                    topPending.setTxn(request.getTxn());\n<line133>                    topPending.setTxnDigest(request.getTxnDigest());\n<line134>                    topPending.zxid = request.zxid;\n<line135>                    topPending.commitRecvTime = request.commitRecvTime;\n<line136>                    request = topPending;\n<line137>                    if (request.isThrottled()) {\n<line138>                        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line139>                    }\n<line140>                    // Only decrement if we take a request off the queue.\n<line141>                    numWriteQueuedRequests.decrementAndGet();\n<line142>                    queuedWriteRequests.poll();\n<line143>                    queuesToDrain.add(request.sessionId);\n<line144>                }\n<line145>            }\n<line146>            /*\n<line147>                         * Pull the request off the commit queue, now that we are going\n<line148>                         * to process it.\n<line149>                         */\n<line150>            committedRequests.remove();\n<line151>            commitsToProcess--;\n<line152>            commitsProcessed++;\n<line153>            // Process the write inline.\n<line154>            processWrite(request);\n<line155>            commitIsWaiting = !committedRequests.isEmpty();\n<line156>        }\n<line157>        ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line158>        ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line159>        /*\n<line160>                     * Process following reads if any, remove session queue(s) if\n<line161>                     * empty.\n<line162>                     */\n<line163>        readsProcessed = 0;\n<line164>        for (Long sessionId : queuesToDrain) {\n<line165>            Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line166>            int readsAfterWrite = 0;\n<line167>            while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line168>                numReadQueuedRequests.decrementAndGet();\n<line169>                sendToNextProcessor(sessionQueue.poll());\n<line170>                readsAfterWrite++;\n<line171>            }\n<line172>            ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line173>            readsProcessed += readsAfterWrite;\n<line174>            // Remove empty queues\n<line175>            if (sessionQueue.isEmpty()) {\n<line176>                pendingRequests.remove(sessionId);\n<line177>            }\n<line178>        }\n<line179>        ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line180>        ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line181>    }\n<line182>    ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);\n<line183>    endOfIteration();\n<line184>}","output":"<line1>{\n<line2>    /*\n<line3>                 * Since requests are placed in the queue before being sent to\n<line4>                 * the leader, if commitIsWaiting = true, the commit belongs to\n<line5>                 * the first update operation in the queuedRequests or to a\n<line6>                 * request from a client on another server (i.e., the order of\n<line7>                 * the following two lines is important!).\n<line8>                 */\n<line9>    synchronized (this) {\n<line10>        commitIsWaiting = !committedRequests.isEmpty();\n<line11>        requestsToProcess = queuedRequests.size();\n<line12>        if (requestsToProcess == 0 && !commitIsWaiting) {\n<line13>            // Waiting for requests to process\n<line14>            while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {\n<line15>                wait();\n<line16>                commitIsWaiting = !committedRequests.isEmpty();\n<line17>                requestsToProcess = queuedRequests.size();\n<line18>            }\n<line19>        }\n<line20>    }\n<line21>    ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());\n<line22>    ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());\n<line23>    ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());\n<line24>    long time = Time.currentElapsedTime();\n<line25>    /*\n<line26>                 * Processing up to requestsToProcess requests from the incoming\n<line27>                 * queue (queuedRequests). If maxReadBatchSize is set then no\n<line28>                 * commits will be processed until maxReadBatchSize number of\n<line29>                 * reads are processed (or no more reads remain in the queue).\n<line30>                 * After the loop a single committed request is processed if\n<line31>                 * one is waiting (or a batch of commits if maxCommitBatchSize\n<line32>                 * is set).\n<line33>                 */\n<line34>    Request request;\n<line35>    int readsProcessed = 0;\n<line36>    while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {\n<line37>        requestsToProcess--;\n<line38>        if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {\n<line39>            // Add request to pending\n<line40>            Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());\n<line41>            requests.addLast(request);\n<line42>            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());\n<line43>        } else {\n<line44>            readsProcessed++;\n<line45>            numReadQueuedRequests.decrementAndGet();\n<line46>            sendToNextProcessor(request);\n<line47>        }\n<line48>        /*\n<line49>                     * Stop feeding the pool if there is a local pending update\n<line50>                     * and a committed request that is ready. Once we have a\n<line51>                     * pending request with a waiting committed request, we know\n<line52>                     * we can process the committed one. This is because commits\n<line53>                     * for local requests arrive in the order they appeared in\n<line54>                     * the queue, so if we have a pending request and a\n<line55>                     * committed request, the committed request must be for that\n<line56>                     * pending write or for a write originating at a different\n<line57>                     * server. We skip this if maxReadBatchSize is set.\n<line58>                     */\n<line59>        if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {\n<line60>            /*\n<line61>                         * We set commitIsWaiting so that we won't check\n<line62>                         * committedRequests again.\n<line63>                         */\n<line64>            commitIsWaiting = true;\n<line65>            break;\n<line66>        }\n<line67>    }\n<line68>    ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);\n<line69>    if (!commitIsWaiting) {\n<line70>        commitIsWaiting = !committedRequests.isEmpty();\n<line71>    }\n<line72>    /*\n<line73>                 * Handle commits, if any.\n<line74>                 */\n<line75>    if (commitIsWaiting && !stopped) {\n<line76>        /*\n<line77>                     * Drain outstanding reads\n<line78>                     */\n<line79>        waitForEmptyPool();\n<line80>        if (stopped) {\n<line81>            return;\n<line82>        }\n<line83>        int commitsToProcess = maxCommitBatchSize;\n<line84>        /*\n<line85>                     * Loop through all the commits, and try to drain them.\n<line86>                     */\n<line87>        Set<Long> queuesToDrain = new HashSet<>();\n<line88>        long startWriteTime = Time.currentElapsedTime();\n<line89>        int commitsProcessed = 0;\n<line90>        while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line91>            // Process committed head\n<line92>            request = committedRequests.peek();\n<line93>            if (request.isThrottled()) {\n<line94>                LOG.error(\"Throttled request in committed pool: {}. Exiting.\", request);\n<line95>                ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line96>            }\n<line97>            /*\n<line98>                         * Check if this is a local write request is pending,\n<line99>                         * if so, update it with the committed info. If the commit matches\n<line100>                         * the first write queued in the blockedRequestQueue, we know this is\n<line101>                         * a commit for a local write, as commits are received in order. Else\n<line102>                         * it must be a commit for a remote write.\n<line103>                         */\n<line104>            if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line105>                /*\n<line106>                             * Commit matches the earliest write in our write queue.\n<line107>                             */\n<line108>                Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line109>                ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line110>                if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line111>                    /*\n<line112>                                 * Can't process this write yet.\n<line113>                                 * Either there are reads pending in this session, or we\n<line114>                                 * haven't gotten to this write yet.\n<line115>                                 */\n<line116>                    break;\n<line117>                } else {\n<line118>                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line119>                    // If session queue != null, then it is also not empty.\n<line120>                    Request topPending = sessionQueue.poll();\n<line121>                    /*\n<line122>                                 * Generally, we want to send to the next processor our version of the request,\n<line123>                                 * since it contains the session information that is needed for post update processing.\n<line124>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line125>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line126>                                 * requests that are outstanding and have originated from this server\n<line127>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line128>                                 * outstanding request completes. Note that in the other case, the operation\n<line129>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line130>                                 * session that needs to be notified.\n<line131>                                 */\n<line132>                    topPending.setHdr(request.getHdr());\n<line133>                    topPending.setTxn(request.getTxn());\n<line134>                    topPending.setTxnDigest(request.getTxnDigest());\n<line135>                    topPending.zxid = request.zxid;\n<line136>                    topPending.commitRecvTime = request.commitRecvTime;\n<line137>                    request = topPending;\n<line138>                    if (request.isThrottled()) {\n<line139>                        LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line140>                        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line141>                    }\n<line142>                    // Only decrement if we take a request off the queue.\n<line143>                    numWriteQueuedRequests.decrementAndGet();\n<line144>                    queuedWriteRequests.poll();\n<line145>                    queuesToDrain.add(request.sessionId);\n<line146>                }\n<line147>            }\n<line148>            /*\n<line149>                         * Pull the request off the commit queue, now that we are going\n<line150>                         * to process it.\n<line151>                         */\n<line152>            committedRequests.remove();\n<line153>            commitsToProcess--;\n<line154>            commitsProcessed++;\n<line155>            // Process the write inline.\n<line156>            processWrite(request);\n<line157>            commitIsWaiting = !committedRequests.isEmpty();\n<line158>        }\n<line159>        ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line160>        ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line161>        /*\n<line162>                     * Process following reads if any, remove session queue(s) if\n<line163>                     * empty.\n<line164>                     */\n<line165>        readsProcessed = 0;\n<line166>        for (Long sessionId : queuesToDrain) {\n<line167>            Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line168>            int readsAfterWrite = 0;\n<line169>            while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line170>                numReadQueuedRequests.decrementAndGet();\n<line171>                sendToNextProcessor(sessionQueue.poll());\n<line172>                readsAfterWrite++;\n<line173>            }\n<line174>            ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line175>            readsProcessed += readsAfterWrite;\n<line176>            // Remove empty queues\n<line177>            if (sessionQueue.isEmpty()) {\n<line178>                pendingRequests.remove(sessionId);\n<line179>            }\n<line180>        }\n<line181>        ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line182>        ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line183>    }\n<line184>    ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);\n<line185>    endOfIteration();\n<line186>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                     * Drain outstanding reads\n<line4>                     */\n<line5>    waitForEmptyPool();\n<line6>    if (stopped) {\n<line7>        return;\n<line8>    }\n<line9>    int commitsToProcess = maxCommitBatchSize;\n<line10>    /*\n<line11>                     * Loop through all the commits, and try to drain them.\n<line12>                     */\n<line13>    Set<Long> queuesToDrain = new HashSet<>();\n<line14>    long startWriteTime = Time.currentElapsedTime();\n<line15>    int commitsProcessed = 0;\n<line16>    while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line17>        // Process committed head\n<line18>        request = committedRequests.peek();\n<line19>        if (request.isThrottled()) {\n<line20>            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line21>        }\n<line22>        /*\n<line23>                         * Check if this is a local write request is pending,\n<line24>                         * if so, update it with the committed info. If the commit matches\n<line25>                         * the first write queued in the blockedRequestQueue, we know this is\n<line26>                         * a commit for a local write, as commits are received in order. Else\n<line27>                         * it must be a commit for a remote write.\n<line28>                         */\n<line29>        if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line30>            /*\n<line31>                             * Commit matches the earliest write in our write queue.\n<line32>                             */\n<line33>            Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line34>            ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line35>            if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line36>                /*\n<line37>                                 * Can't process this write yet.\n<line38>                                 * Either there are reads pending in this session, or we\n<line39>                                 * haven't gotten to this write yet.\n<line40>                                 */\n<line41>                break;\n<line42>            } else {\n<line43>                ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line44>                // If session queue != null, then it is also not empty.\n<line45>                Request topPending = sessionQueue.poll();\n<line46>                /*\n<line47>                                 * Generally, we want to send to the next processor our version of the request,\n<line48>                                 * since it contains the session information that is needed for post update processing.\n<line49>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line50>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line51>                                 * requests that are outstanding and have originated from this server\n<line52>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line53>                                 * outstanding request completes. Note that in the other case, the operation\n<line54>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line55>                                 * session that needs to be notified.\n<line56>                                 */\n<line57>                topPending.setHdr(request.getHdr());\n<line58>                topPending.setTxn(request.getTxn());\n<line59>                topPending.setTxnDigest(request.getTxnDigest());\n<line60>                topPending.zxid = request.zxid;\n<line61>                topPending.commitRecvTime = request.commitRecvTime;\n<line62>                request = topPending;\n<line63>                if (request.isThrottled()) {\n<line64>                    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line65>                }\n<line66>                // Only decrement if we take a request off the queue.\n<line67>                numWriteQueuedRequests.decrementAndGet();\n<line68>                queuedWriteRequests.poll();\n<line69>                queuesToDrain.add(request.sessionId);\n<line70>            }\n<line71>        }\n<line72>        /*\n<line73>                         * Pull the request off the commit queue, now that we are going\n<line74>                         * to process it.\n<line75>                         */\n<line76>        committedRequests.remove();\n<line77>        commitsToProcess--;\n<line78>        commitsProcessed++;\n<line79>        // Process the write inline.\n<line80>        processWrite(request);\n<line81>        commitIsWaiting = !committedRequests.isEmpty();\n<line82>    }\n<line83>    ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line84>    ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line85>    /*\n<line86>                     * Process following reads if any, remove session queue(s) if\n<line87>                     * empty.\n<line88>                     */\n<line89>    readsProcessed = 0;\n<line90>    for (Long sessionId : queuesToDrain) {\n<line91>        Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line92>        int readsAfterWrite = 0;\n<line93>        while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line94>            numReadQueuedRequests.decrementAndGet();\n<line95>            sendToNextProcessor(sessionQueue.poll());\n<line96>            readsAfterWrite++;\n<line97>        }\n<line98>        ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line99>        readsProcessed += readsAfterWrite;\n<line100>        // Remove empty queues\n<line101>        if (sessionQueue.isEmpty()) {\n<line102>            pendingRequests.remove(sessionId);\n<line103>        }\n<line104>    }\n<line105>    ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line106>    ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line107>}","output":"<line1>{\n<line2>    /*\n<line3>                     * Drain outstanding reads\n<line4>                     */\n<line5>    waitForEmptyPool();\n<line6>    if (stopped) {\n<line7>        return;\n<line8>    }\n<line9>    int commitsToProcess = maxCommitBatchSize;\n<line10>    /*\n<line11>                     * Loop through all the commits, and try to drain them.\n<line12>                     */\n<line13>    Set<Long> queuesToDrain = new HashSet<>();\n<line14>    long startWriteTime = Time.currentElapsedTime();\n<line15>    int commitsProcessed = 0;\n<line16>    while (commitIsWaiting && !stopped && commitsToProcess > 0) {\n<line17>        // Process committed head\n<line18>        request = committedRequests.peek();\n<line19>        if (request.isThrottled()) {\n<line20>            LOG.error(\"Throttled request in committed pool: {}. Exiting.\", request);\n<line21>            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line22>        }\n<line23>        /*\n<line24>                         * Check if this is a local write request is pending,\n<line25>                         * if so, update it with the committed info. If the commit matches\n<line26>                         * the first write queued in the blockedRequestQueue, we know this is\n<line27>                         * a commit for a local write, as commits are received in order. Else\n<line28>                         * it must be a commit for a remote write.\n<line29>                         */\n<line30>        if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line31>            /*\n<line32>                             * Commit matches the earliest write in our write queue.\n<line33>                             */\n<line34>            Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line35>            ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line36>            if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line37>                /*\n<line38>                                 * Can't process this write yet.\n<line39>                                 * Either there are reads pending in this session, or we\n<line40>                                 * haven't gotten to this write yet.\n<line41>                                 */\n<line42>                break;\n<line43>            } else {\n<line44>                ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line45>                // If session queue != null, then it is also not empty.\n<line46>                Request topPending = sessionQueue.poll();\n<line47>                /*\n<line48>                                 * Generally, we want to send to the next processor our version of the request,\n<line49>                                 * since it contains the session information that is needed for post update processing.\n<line50>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line51>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line52>                                 * requests that are outstanding and have originated from this server\n<line53>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line54>                                 * outstanding request completes. Note that in the other case, the operation\n<line55>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line56>                                 * session that needs to be notified.\n<line57>                                 */\n<line58>                topPending.setHdr(request.getHdr());\n<line59>                topPending.setTxn(request.getTxn());\n<line60>                topPending.setTxnDigest(request.getTxnDigest());\n<line61>                topPending.zxid = request.zxid;\n<line62>                topPending.commitRecvTime = request.commitRecvTime;\n<line63>                request = topPending;\n<line64>                if (request.isThrottled()) {\n<line65>                    LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line66>                    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line67>                }\n<line68>                // Only decrement if we take a request off the queue.\n<line69>                numWriteQueuedRequests.decrementAndGet();\n<line70>                queuedWriteRequests.poll();\n<line71>                queuesToDrain.add(request.sessionId);\n<line72>            }\n<line73>        }\n<line74>        /*\n<line75>                         * Pull the request off the commit queue, now that we are going\n<line76>                         * to process it.\n<line77>                         */\n<line78>        committedRequests.remove();\n<line79>        commitsToProcess--;\n<line80>        commitsProcessed++;\n<line81>        // Process the write inline.\n<line82>        processWrite(request);\n<line83>        commitIsWaiting = !committedRequests.isEmpty();\n<line84>    }\n<line85>    ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);\n<line86>    ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);\n<line87>    /*\n<line88>                     * Process following reads if any, remove session queue(s) if\n<line89>                     * empty.\n<line90>                     */\n<line91>    readsProcessed = 0;\n<line92>    for (Long sessionId : queuesToDrain) {\n<line93>        Deque<Request> sessionQueue = pendingRequests.get(sessionId);\n<line94>        int readsAfterWrite = 0;\n<line95>        while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {\n<line96>            numReadQueuedRequests.decrementAndGet();\n<line97>            sendToNextProcessor(sessionQueue.poll());\n<line98>            readsAfterWrite++;\n<line99>        }\n<line100>        ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);\n<line101>        readsProcessed += readsAfterWrite;\n<line102>        // Remove empty queues\n<line103>        if (sessionQueue.isEmpty()) {\n<line104>            pendingRequests.remove(sessionId);\n<line105>        }\n<line106>    }\n<line107>    ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());\n<line108>    ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);\n<line109>}"},{"input":"","instruction":"<line1>{\n<line2>    // Process committed head\n<line3>    request = committedRequests.peek();\n<line4>    if (request.isThrottled()) {\n<line5>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line6>    }\n<line7>    /*\n<line8>                         * Check if this is a local write request is pending,\n<line9>                         * if so, update it with the committed info. If the commit matches\n<line10>                         * the first write queued in the blockedRequestQueue, we know this is\n<line11>                         * a commit for a local write, as commits are received in order. Else\n<line12>                         * it must be a commit for a remote write.\n<line13>                         */\n<line14>    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line15>        /*\n<line16>                             * Commit matches the earliest write in our write queue.\n<line17>                             */\n<line18>        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line19>        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line20>        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line21>            /*\n<line22>                                 * Can't process this write yet.\n<line23>                                 * Either there are reads pending in this session, or we\n<line24>                                 * haven't gotten to this write yet.\n<line25>                                 */\n<line26>            break;\n<line27>        } else {\n<line28>            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line29>            // If session queue != null, then it is also not empty.\n<line30>            Request topPending = sessionQueue.poll();\n<line31>            /*\n<line32>                                 * Generally, we want to send to the next processor our version of the request,\n<line33>                                 * since it contains the session information that is needed for post update processing.\n<line34>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line35>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line36>                                 * requests that are outstanding and have originated from this server\n<line37>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line38>                                 * outstanding request completes. Note that in the other case, the operation\n<line39>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line40>                                 * session that needs to be notified.\n<line41>                                 */\n<line42>            topPending.setHdr(request.getHdr());\n<line43>            topPending.setTxn(request.getTxn());\n<line44>            topPending.setTxnDigest(request.getTxnDigest());\n<line45>            topPending.zxid = request.zxid;\n<line46>            topPending.commitRecvTime = request.commitRecvTime;\n<line47>            request = topPending;\n<line48>            if (request.isThrottled()) {\n<line49>                ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line50>            }\n<line51>            // Only decrement if we take a request off the queue.\n<line52>            numWriteQueuedRequests.decrementAndGet();\n<line53>            queuedWriteRequests.poll();\n<line54>            queuesToDrain.add(request.sessionId);\n<line55>        }\n<line56>    }\n<line57>    /*\n<line58>                         * Pull the request off the commit queue, now that we are going\n<line59>                         * to process it.\n<line60>                         */\n<line61>    committedRequests.remove();\n<line62>    commitsToProcess--;\n<line63>    commitsProcessed++;\n<line64>    // Process the write inline.\n<line65>    processWrite(request);\n<line66>    commitIsWaiting = !committedRequests.isEmpty();\n<line67>}","output":"<line1>{\n<line2>    // Process committed head\n<line3>    request = committedRequests.peek();\n<line4>    if (request.isThrottled()) {\n<line5>        LOG.error(\"Throttled request in committed pool: {}. Exiting.\", request);\n<line6>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line7>    }\n<line8>    /*\n<line9>                         * Check if this is a local write request is pending,\n<line10>                         * if so, update it with the committed info. If the commit matches\n<line11>                         * the first write queued in the blockedRequestQueue, we know this is\n<line12>                         * a commit for a local write, as commits are received in order. Else\n<line13>                         * it must be a commit for a remote write.\n<line14>                         */\n<line15>    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {\n<line16>        /*\n<line17>                             * Commit matches the earliest write in our write queue.\n<line18>                             */\n<line19>        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line20>        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line21>        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line22>            /*\n<line23>                                 * Can't process this write yet.\n<line24>                                 * Either there are reads pending in this session, or we\n<line25>                                 * haven't gotten to this write yet.\n<line26>                                 */\n<line27>            break;\n<line28>        } else {\n<line29>            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line30>            // If session queue != null, then it is also not empty.\n<line31>            Request topPending = sessionQueue.poll();\n<line32>            /*\n<line33>                                 * Generally, we want to send to the next processor our version of the request,\n<line34>                                 * since it contains the session information that is needed for post update processing.\n<line35>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line36>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line37>                                 * requests that are outstanding and have originated from this server\n<line38>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line39>                                 * outstanding request completes. Note that in the other case, the operation\n<line40>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line41>                                 * session that needs to be notified.\n<line42>                                 */\n<line43>            topPending.setHdr(request.getHdr());\n<line44>            topPending.setTxn(request.getTxn());\n<line45>            topPending.setTxnDigest(request.getTxnDigest());\n<line46>            topPending.zxid = request.zxid;\n<line47>            topPending.commitRecvTime = request.commitRecvTime;\n<line48>            request = topPending;\n<line49>            if (request.isThrottled()) {\n<line50>                LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line51>                ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line52>            }\n<line53>            // Only decrement if we take a request off the queue.\n<line54>            numWriteQueuedRequests.decrementAndGet();\n<line55>            queuedWriteRequests.poll();\n<line56>            queuesToDrain.add(request.sessionId);\n<line57>        }\n<line58>    }\n<line59>    /*\n<line60>                         * Pull the request off the commit queue, now that we are going\n<line61>                         * to process it.\n<line62>                         */\n<line63>    committedRequests.remove();\n<line64>    commitsToProcess--;\n<line65>    commitsProcessed++;\n<line66>    // Process the write inline.\n<line67>    processWrite(request);\n<line68>    commitIsWaiting = !committedRequests.isEmpty();\n<line69>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Throttled request in committed pool: {}. Exiting.\", request);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                             * Commit matches the earliest write in our write queue.\n<line4>                             */\n<line5>    Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line6>    ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line7>    if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line8>        /*\n<line9>                                 * Can't process this write yet.\n<line10>                                 * Either there are reads pending in this session, or we\n<line11>                                 * haven't gotten to this write yet.\n<line12>                                 */\n<line13>        break;\n<line14>    } else {\n<line15>        ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line16>        // If session queue != null, then it is also not empty.\n<line17>        Request topPending = sessionQueue.poll();\n<line18>        /*\n<line19>                                 * Generally, we want to send to the next processor our version of the request,\n<line20>                                 * since it contains the session information that is needed for post update processing.\n<line21>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line22>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line23>                                 * requests that are outstanding and have originated from this server\n<line24>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line25>                                 * outstanding request completes. Note that in the other case, the operation\n<line26>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line27>                                 * session that needs to be notified.\n<line28>                                 */\n<line29>        topPending.setHdr(request.getHdr());\n<line30>        topPending.setTxn(request.getTxn());\n<line31>        topPending.setTxnDigest(request.getTxnDigest());\n<line32>        topPending.zxid = request.zxid;\n<line33>        topPending.commitRecvTime = request.commitRecvTime;\n<line34>        request = topPending;\n<line35>        if (request.isThrottled()) {\n<line36>            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line37>        }\n<line38>        // Only decrement if we take a request off the queue.\n<line39>        numWriteQueuedRequests.decrementAndGet();\n<line40>        queuedWriteRequests.poll();\n<line41>        queuesToDrain.add(request.sessionId);\n<line42>    }\n<line43>}","output":"<line1>{\n<line2>    /*\n<line3>                             * Commit matches the earliest write in our write queue.\n<line4>                             */\n<line5>    Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);\n<line6>    ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());\n<line7>    if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {\n<line8>        /*\n<line9>                                 * Can't process this write yet.\n<line10>                                 * Either there are reads pending in this session, or we\n<line11>                                 * haven't gotten to this write yet.\n<line12>                                 */\n<line13>        break;\n<line14>    } else {\n<line15>        ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line16>        // If session queue != null, then it is also not empty.\n<line17>        Request topPending = sessionQueue.poll();\n<line18>        /*\n<line19>                                 * Generally, we want to send to the next processor our version of the request,\n<line20>                                 * since it contains the session information that is needed for post update processing.\n<line21>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line22>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line23>                                 * requests that are outstanding and have originated from this server\n<line24>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line25>                                 * outstanding request completes. Note that in the other case, the operation\n<line26>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line27>                                 * session that needs to be notified.\n<line28>                                 */\n<line29>        topPending.setHdr(request.getHdr());\n<line30>        topPending.setTxn(request.getTxn());\n<line31>        topPending.setTxnDigest(request.getTxnDigest());\n<line32>        topPending.zxid = request.zxid;\n<line33>        topPending.commitRecvTime = request.commitRecvTime;\n<line34>        request = topPending;\n<line35>        if (request.isThrottled()) {\n<line36>            LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line37>            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line38>        }\n<line39>        // Only decrement if we take a request off the queue.\n<line40>        numWriteQueuedRequests.decrementAndGet();\n<line41>        queuedWriteRequests.poll();\n<line42>        queuesToDrain.add(request.sessionId);\n<line43>    }\n<line44>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line3>    // If session queue != null, then it is also not empty.\n<line4>    Request topPending = sessionQueue.poll();\n<line5>    /*\n<line6>                                 * Generally, we want to send to the next processor our version of the request,\n<line7>                                 * since it contains the session information that is needed for post update processing.\n<line8>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line9>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line10>                                 * requests that are outstanding and have originated from this server\n<line11>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line12>                                 * outstanding request completes. Note that in the other case, the operation\n<line13>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line14>                                 * session that needs to be notified.\n<line15>                                 */\n<line16>    topPending.setHdr(request.getHdr());\n<line17>    topPending.setTxn(request.getTxn());\n<line18>    topPending.setTxnDigest(request.getTxnDigest());\n<line19>    topPending.zxid = request.zxid;\n<line20>    topPending.commitRecvTime = request.commitRecvTime;\n<line21>    request = topPending;\n<line22>    if (request.isThrottled()) {\n<line23>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line24>    }\n<line25>    // Only decrement if we take a request off the queue.\n<line26>    numWriteQueuedRequests.decrementAndGet();\n<line27>    queuedWriteRequests.poll();\n<line28>    queuesToDrain.add(request.sessionId);\n<line29>}","output":"<line1>{\n<line2>    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());\n<line3>    // If session queue != null, then it is also not empty.\n<line4>    Request topPending = sessionQueue.poll();\n<line5>    /*\n<line6>                                 * Generally, we want to send to the next processor our version of the request,\n<line7>                                 * since it contains the session information that is needed for post update processing.\n<line8>                                 * In more details, when a request is in the local queue, there is (or could be) a client\n<line9>                                 * attached to this server waiting for a response, and there is other bookkeeping of\n<line10>                                 * requests that are outstanding and have originated from this server\n<line11>                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an\n<line12>                                 * outstanding request completes. Note that in the other case, the operation\n<line13>                                 * originated from a different server and there is no local bookkeeping or a local client\n<line14>                                 * session that needs to be notified.\n<line15>                                 */\n<line16>    topPending.setHdr(request.getHdr());\n<line17>    topPending.setTxn(request.getTxn());\n<line18>    topPending.setTxnDigest(request.getTxnDigest());\n<line19>    topPending.zxid = request.zxid;\n<line20>    topPending.commitRecvTime = request.commitRecvTime;\n<line21>    request = topPending;\n<line22>    if (request.isThrottled()) {\n<line23>        LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line24>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line25>    }\n<line26>    // Only decrement if we take a request off the queue.\n<line27>    numWriteQueuedRequests.decrementAndGet();\n<line28>    queuedWriteRequests.poll();\n<line29>    queuesToDrain.add(request.sessionId);\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Throttled request in committed & pending pool: {}. Exiting.\", request);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int numCores = Runtime.getRuntime().availableProcessors();\n<line3>    int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores);\n<line4>    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000);\n<line5>    initBatchSizes();\n<line6>    if (workerPool == null) {\n<line7>        workerPool = new WorkerService(\"CommitProcWork\", numWorkerThreads, true);\n<line8>    }\n<line9>    stopped = false;\n<line10>    stoppedMainLoop = false;\n<line11>    super.start();\n<line12>}","output":"<line1>{\n<line2>    int numCores = Runtime.getRuntime().availableProcessors();\n<line3>    int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores);\n<line4>    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000);\n<line5>    initBatchSizes();\n<line6>    LOG.info(\"Configuring CommitProcessor with {} worker threads.\", numWorkerThreads > 0 ? numWorkerThreads : \"no\");\n<line7>    if (workerPool == null) {\n<line8>        workerPool = new WorkerService(\"CommitProcWork\", numWorkerThreads, true);\n<line9>    }\n<line10>    stopped = false;\n<line11>    stoppedMainLoop = false;\n<line12>    super.start();\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    maxReadBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_READ_BATCH_SIZE, -1);\n<line3>    maxCommitBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_COMMIT_BATCH_SIZE, 1);\n<line4>    if (maxCommitBatchSize <= 0) {\n<line5>        String errorMsg = \"maxCommitBatchSize must be positive, was \" + maxCommitBatchSize;\n<line6>        throw new IllegalArgumentException(errorMsg);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    maxReadBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_READ_BATCH_SIZE, -1);\n<line3>    maxCommitBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_COMMIT_BATCH_SIZE, 1);\n<line4>    if (maxCommitBatchSize <= 0) {\n<line5>        String errorMsg = \"maxCommitBatchSize must be positive, was \" + maxCommitBatchSize;\n<line6>        throw new IllegalArgumentException(errorMsg);\n<line7>    }\n<line8>    LOG.info(\"Configuring CommitProcessor with readBatchSize {} commitBatchSize {}\", maxReadBatchSize, maxCommitBatchSize);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    maxReadBatchSize = size;\n<line3>}","output":"<line1>{\n<line2>    maxReadBatchSize = size;\n<line3>    LOG.info(\"Configuring CommitProcessor with readBatchSize {}\", maxReadBatchSize);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (size > 0) {\n<line3>        maxCommitBatchSize = size;\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (size > 0) {\n<line3>        maxCommitBatchSize = size;\n<line4>        LOG.info(\"Configuring CommitProcessor with commitBatchSize {}\", maxCommitBatchSize);\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    maxCommitBatchSize = size;\n<line3>}","output":"<line1>{\n<line2>    maxCommitBatchSize = size;\n<line3>    LOG.info(\"Configuring CommitProcessor with commitBatchSize {}\", maxCommitBatchSize);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!stopped) {\n<line3>        CommitProcessor.this.halt();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (!stopped) {\n<line3>        LOG.error(\"Exception thrown by downstream processor, unable to continue.\");\n<line4>        CommitProcessor.this.halt();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    CommitProcessor.this.halt();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception thrown by downstream processor, unable to continue.\");\n<line3>    CommitProcessor.this.halt();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (stopped || request == null) {\n<line3>        return;\n<line4>    }\n<line5>    request.commitRecvTime = Time.currentElapsedTime();\n<line6>    ServerMetrics.getMetrics().COMMITS_QUEUED.add(1);\n<line7>    committedRequests.add(request);\n<line8>    wakeup();\n<line9>}","output":"<line1>{\n<line2>    if (stopped || request == null) {\n<line3>        return;\n<line4>    }\n<line5>    LOG.debug(\"Committing request:: {}\", request);\n<line6>    request.commitRecvTime = Time.currentElapsedTime();\n<line7>    ServerMetrics.getMetrics().COMMITS_QUEUED.add(1);\n<line8>    committedRequests.add(request);\n<line9>    wakeup();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (stopped) {\n<line3>        return;\n<line4>    }\n<line5>    request.commitProcQueueStartTime = Time.currentElapsedTime();\n<line6>    queuedRequests.add(request);\n<line7>    // If the request will block, add it to the queue of blocking requests\n<line8>    if (needCommit(request)) {\n<line9>        queuedWriteRequests.add(request);\n<line10>        numWriteQueuedRequests.incrementAndGet();\n<line11>    } else {\n<line12>        numReadQueuedRequests.incrementAndGet();\n<line13>    }\n<line14>    wakeup();\n<line15>}","output":"<line1>{\n<line2>    if (stopped) {\n<line3>        return;\n<line4>    }\n<line5>    LOG.debug(\"Processing request:: {}\", request);\n<line6>    request.commitProcQueueStartTime = Time.currentElapsedTime();\n<line7>    queuedRequests.add(request);\n<line8>    // If the request will block, add it to the queue of blocking requests\n<line9>    if (needCommit(request)) {\n<line10>        queuedWriteRequests.add(request);\n<line11>        numWriteQueuedRequests.incrementAndGet();\n<line12>    } else {\n<line13>        numReadQueuedRequests.incrementAndGet();\n<line14>    }\n<line15>    wakeup();\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    halt();\n<line3>    if (workerPool != null) {\n<line4>        workerPool.join(workerShutdownTimeoutMS);\n<line5>    }\n<line6>    if (nextProcessor != null) {\n<line7>        nextProcessor.shutdown();\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    halt();\n<line4>    if (workerPool != null) {\n<line5>        workerPool.join(workerShutdownTimeoutMS);\n<line6>    }\n<line7>    if (nextProcessor != null) {\n<line8>        nextProcessor.shutdown();\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    this.zks = zks;\n<line3>    this.nextProcessor = nextProcessor;\n<line4>    AckRequestProcessor ackProcessor = new AckRequestProcessor(zks.getLeader());\n<line5>    syncProcessor = new SyncRequestProcessor(zks, ackProcessor);\n<line6>    forwardLearnerRequestsToCommitProcessorDisabled = Boolean.getBoolean(FORWARD_LEARNER_REQUESTS_TO_COMMIT_PROCESSOR_DISABLED);\n<line7>}","output":"<line1>{\n<line2>    this.zks = zks;\n<line3>    this.nextProcessor = nextProcessor;\n<line4>    AckRequestProcessor ackProcessor = new AckRequestProcessor(zks.getLeader());\n<line5>    syncProcessor = new SyncRequestProcessor(zks, ackProcessor);\n<line6>    forwardLearnerRequestsToCommitProcessorDisabled = Boolean.getBoolean(FORWARD_LEARNER_REQUESTS_TO_COMMIT_PROCESSOR_DISABLED);\n<line7>    LOG.info(\"{} = {}\", FORWARD_LEARNER_REQUESTS_TO_COMMIT_PROCESSOR_DISABLED, forwardLearnerRequestsToCommitProcessorDisabled);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    nextProcessor.shutdown();\n<line3>    syncProcessor.shutdown();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Shutting down\");\n<line3>    nextProcessor.shutdown();\n<line4>    syncProcessor.shutdown();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"leaderConnectDelayDuringRetryMs: {}\", leaderConnectDelayDuringRetryMs);\n<line3>    LOG.info(\"TCP NoDelay set to: {}\", nodelay);\n<line4>    LOG.info(\"{} = {}\", LEARNER_ASYNC_SENDING, asyncSending);\n<line5>    LOG.info(\"{} = {}\", LEARNER_CLOSE_SOCKET_ASYNC, closeSocketAsync);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    asyncSending = newMode;\n<line3>}","output":"<line1>{\n<line2>    asyncSending = newMode;\n<line3>    LOG.info(\"{} = {}\", LEARNER_ASYNC_SENDING, asyncSending);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line3>    DataOutputStream dos = new DataOutputStream(baos);\n<line4>    dos.writeLong(clientId);\n<line5>    dos.writeInt(timeout);\n<line6>    dos.close();\n<line7>    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);\n<line8>    pendingRevalidations.put(clientId, cnxn);\n<line9>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"To validate session 0x\" + Long.toHexString(clientId));\n<line10>    }\n<line11>    writePacket(qp, true);\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Revalidating client: 0x{}\", Long.toHexString(clientId));\n<line3>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line4>    DataOutputStream dos = new DataOutputStream(baos);\n<line5>    dos.writeLong(clientId);\n<line6>    dos.writeInt(timeout);\n<line7>    dos.close();\n<line8>    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);\n<line9>    pendingRevalidations.put(clientId, cnxn);\n<line10>    if (LOG.isTraceEnabled()) {\n<line11>        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, \"To validate session 0x\" + Long.toHexString(clientId));\n<line12>    }\n<line13>    writePacket(qp, true);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.isThrottled()) {\n<line3>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>    }\n<line5>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line6>    DataOutputStream oa = new DataOutputStream(baos);\n<line7>    oa.writeLong(request.sessionId);\n<line8>    oa.writeInt(request.cxid);\n<line9>    oa.writeInt(request.type);\n<line10>    byte[] payload = request.readRequestBytes();\n<line11>    if (payload != null) {\n<line12>        oa.write(payload);\n<line13>    }\n<line14>    oa.close();\n<line15>    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos.toByteArray(), request.authInfo);\n<line16>    writePacket(qp, true);\n<line17>}","output":"<line1>{\n<line2>    if (request.isThrottled()) {\n<line3>        LOG.error(\"Throttled request sent to leader: {}. Exiting\", request);\n<line4>        ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line5>    }\n<line6>    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n<line7>    DataOutputStream oa = new DataOutputStream(baos);\n<line8>    oa.writeLong(request.sessionId);\n<line9>    oa.writeInt(request.cxid);\n<line10>    oa.writeInt(request.type);\n<line11>    byte[] payload = request.readRequestBytes();\n<line12>    if (payload != null) {\n<line13>        oa.write(payload);\n<line14>    }\n<line15>    oa.close();\n<line16>    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos.toByteArray(), request.authInfo);\n<line17>    writePacket(qp, true);\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Throttled request sent to leader: {}. Exiting\", request);\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.leaderAddr = multiAddr;\n<line3>    Set<InetSocketAddress> addresses;\n<line4>    if (self.isMultiAddressReachabilityCheckEnabled()) {\n<line5>        // even if none of the addresses are reachable, we want to try to establish connection\n<line6>        // see ZOOKEEPER-3758\n<line7>        addresses = multiAddr.getAllReachableAddressesOrAll();\n<line8>    } else {\n<line9>        addresses = multiAddr.getAllAddresses();\n<line10>    }\n<line11>    ExecutorService executor = Executors.newFixedThreadPool(addresses.size());\n<line12>    CountDownLatch latch = new CountDownLatch(addresses.size());\n<line13>    AtomicReference<Socket> socket = new AtomicReference<>(null);\n<line14>    addresses.stream().map(address -> new LeaderConnector(address, socket, latch)).forEach(executor::submit);\n<line15>    try {\n<line16>        latch.await();\n<line17>    } catch (InterruptedException e) {\n<line18>    } finally {\n<line19>        executor.shutdown();\n<line20>        try {\n<line21>            if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line22>            }\n<line23>        } catch (InterruptedException ie) {\n<line24>        }\n<line25>    }\n<line26>    if (socket.get() == null) {\n<line27>        throw new IOException(\"Failed connect to \" + multiAddr);\n<line28>    } else {\n<line29>        sock = socket.get();\n<line30>        sockBeingClosed.set(false);\n<line31>    }\n<line32>    self.authLearner.authenticate(sock, hostname);\n<line33>    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n<line34>    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n<line35>    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n<line36>    if (asyncSending) {\n<line37>        startSendingThread();\n<line38>    }\n<line39>}","output":"<line1>{\n<line2>    this.leaderAddr = multiAddr;\n<line3>    Set<InetSocketAddress> addresses;\n<line4>    if (self.isMultiAddressReachabilityCheckEnabled()) {\n<line5>        // even if none of the addresses are reachable, we want to try to establish connection\n<line6>        // see ZOOKEEPER-3758\n<line7>        addresses = multiAddr.getAllReachableAddressesOrAll();\n<line8>    } else {\n<line9>        addresses = multiAddr.getAllAddresses();\n<line10>    }\n<line11>    ExecutorService executor = Executors.newFixedThreadPool(addresses.size());\n<line12>    CountDownLatch latch = new CountDownLatch(addresses.size());\n<line13>    AtomicReference<Socket> socket = new AtomicReference<>(null);\n<line14>    addresses.stream().map(address -> new LeaderConnector(address, socket, latch)).forEach(executor::submit);\n<line15>    try {\n<line16>        latch.await();\n<line17>    } catch (InterruptedException e) {\n<line18>        LOG.warn(\"Interrupted while trying to connect to Leader\", e);\n<line19>    } finally {\n<line20>        executor.shutdown();\n<line21>        try {\n<line22>            if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line23>                LOG.error(\"not all the LeaderConnector terminated properly\");\n<line24>            }\n<line25>        } catch (InterruptedException ie) {\n<line26>            LOG.error(\"Interrupted while terminating LeaderConnector executor.\", ie);\n<line27>        }\n<line28>    }\n<line29>    if (socket.get() == null) {\n<line30>        throw new IOException(\"Failed connect to \" + multiAddr);\n<line31>    } else {\n<line32>        sock = socket.get();\n<line33>        sockBeingClosed.set(false);\n<line34>    }\n<line35>    self.authLearner.authenticate(sock, hostname);\n<line36>    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n<line37>    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n<line38>    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n<line39>    if (asyncSending) {\n<line40>        startSendingThread();\n<line41>    }\n<line42>}"},{"input":"","instruction":"<line1>{\n<line2>    executor.shutdown();\n<line3>    try {\n<line4>        if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line5>        }\n<line6>    } catch (InterruptedException ie) {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    executor.shutdown();\n<line3>    try {\n<line4>        if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line5>            LOG.error(\"not all the LeaderConnector terminated properly\");\n<line6>        }\n<line7>    } catch (InterruptedException ie) {\n<line8>        LOG.error(\"Interrupted while terminating LeaderConnector executor.\", ie);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n<line3>        LOG.error(\"not all the LeaderConnector terminated properly\");\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"not all the LeaderConnector terminated properly\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while terminating LeaderConnector executor.\", ie);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Thread.currentThread().setName(\"LeaderConnector-\" + address);\n<line4>        Socket sock = connectToLeader();\n<line5>        if (sock != null && sock.isConnected()) {\n<line6>            if (socket.compareAndSet(null, sock)) {\n<line7>            } else {\n<line8>                sock.close();\n<line9>            }\n<line10>        }\n<line11>    } catch (Exception e) {\n<line12>    } finally {\n<line13>        latch.countDown();\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    try {\n<line3>        Thread.currentThread().setName(\"LeaderConnector-\" + address);\n<line4>        Socket sock = connectToLeader();\n<line5>        if (sock != null && sock.isConnected()) {\n<line6>            if (socket.compareAndSet(null, sock)) {\n<line7>                LOG.info(\"Successfully connected to leader, using address: {}\", address);\n<line8>            } else {\n<line9>                LOG.info(\"Connection to the leader is already established, close the redundant connection\");\n<line10>                sock.close();\n<line11>            }\n<line12>        }\n<line13>    } catch (Exception e) {\n<line14>        LOG.error(\"Failed connect to {}\", address, e);\n<line15>    } finally {\n<line16>        latch.countDown();\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread.currentThread().setName(\"LeaderConnector-\" + address);\n<line3>    Socket sock = connectToLeader();\n<line4>    if (sock != null && sock.isConnected()) {\n<line5>        if (socket.compareAndSet(null, sock)) {\n<line6>        } else {\n<line7>            sock.close();\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    Thread.currentThread().setName(\"LeaderConnector-\" + address);\n<line3>    Socket sock = connectToLeader();\n<line4>    if (sock != null && sock.isConnected()) {\n<line5>        if (socket.compareAndSet(null, sock)) {\n<line6>            LOG.info(\"Successfully connected to leader, using address: {}\", address);\n<line7>        } else {\n<line8>            LOG.info(\"Connection to the leader is already established, close the redundant connection\");\n<line9>            sock.close();\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    if (socket.compareAndSet(null, sock)) {\n<line3>    } else {\n<line4>        sock.close();\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (socket.compareAndSet(null, sock)) {\n<line3>        LOG.info(\"Successfully connected to leader, using address: {}\", address);\n<line4>    } else {\n<line5>        LOG.info(\"Connection to the leader is already established, close the redundant connection\");\n<line6>        sock.close();\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Successfully connected to leader, using address: {}\", address);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    sock.close();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Connection to the leader is already established, close the redundant connection\");\n<line3>    sock.close();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed connect to {}\", address, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket sock = createSocket();\n<line3>    // leader connection timeout defaults to tickTime * initLimit\n<line4>    int connectTimeout = self.tickTime * self.initLimit;\n<line5>    // but if connectToLearnerMasterLimit is specified, use that value to calculate\n<line6>    // timeout instead of using the initLimit value\n<line7>    if (self.connectToLearnerMasterLimit > 0) {\n<line8>        connectTimeout = self.tickTime * self.connectToLearnerMasterLimit;\n<line9>    }\n<line10>    int remainingTimeout;\n<line11>    long startNanoTime = nanoTime();\n<line12>    for (int tries = 0; tries < 5 && socket.get() == null; tries++) {\n<line13>        try {\n<line14>            // recalculate the init limit time because retries sleep for 1000 milliseconds\n<line15>            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line16>            if (remainingTimeout <= 0) {\n<line17>                throw new IOException(\"connectToLeader exceeded on retries.\");\n<line18>            }\n<line19>            sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));\n<line20>            if (self.isSslQuorum()) {\n<line21>                ((SSLSocket) sock).startHandshake();\n<line22>            }\n<line23>            sock.setTcpNoDelay(nodelay);\n<line24>            break;\n<line25>        } catch (IOException e) {\n<line26>            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line27>            if (remainingTimeout <= leaderConnectDelayDuringRetryMs) {\n<line28>                throw e;\n<line29>            } else if (tries >= 4) {\n<line30>                throw e;\n<line31>            } else {\n<line32>                sock = createSocket();\n<line33>            }\n<line34>        }\n<line35>        Thread.sleep(leaderConnectDelayDuringRetryMs);\n<line36>    }\n<line37>    return sock;\n<line38>}","output":"<line1>{\n<line2>    Socket sock = createSocket();\n<line3>    // leader connection timeout defaults to tickTime * initLimit\n<line4>    int connectTimeout = self.tickTime * self.initLimit;\n<line5>    // but if connectToLearnerMasterLimit is specified, use that value to calculate\n<line6>    // timeout instead of using the initLimit value\n<line7>    if (self.connectToLearnerMasterLimit > 0) {\n<line8>        connectTimeout = self.tickTime * self.connectToLearnerMasterLimit;\n<line9>    }\n<line10>    int remainingTimeout;\n<line11>    long startNanoTime = nanoTime();\n<line12>    for (int tries = 0; tries < 5 && socket.get() == null; tries++) {\n<line13>        try {\n<line14>            // recalculate the init limit time because retries sleep for 1000 milliseconds\n<line15>            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line16>            if (remainingTimeout <= 0) {\n<line17>                LOG.error(\"connectToLeader exceeded on retries.\");\n<line18>                throw new IOException(\"connectToLeader exceeded on retries.\");\n<line19>            }\n<line20>            sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));\n<line21>            if (self.isSslQuorum()) {\n<line22>                ((SSLSocket) sock).startHandshake();\n<line23>            }\n<line24>            sock.setTcpNoDelay(nodelay);\n<line25>            break;\n<line26>        } catch (IOException e) {\n<line27>            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line28>            if (remainingTimeout <= leaderConnectDelayDuringRetryMs) {\n<line29>                LOG.error(\"Unexpected exception, connectToLeader exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line30>                throw e;\n<line31>            } else if (tries >= 4) {\n<line32>                LOG.error(\"Unexpected exception, retries exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line33>                throw e;\n<line34>            } else {\n<line35>                LOG.warn(\"Unexpected exception, tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line36>                sock = createSocket();\n<line37>            }\n<line38>        }\n<line39>        Thread.sleep(leaderConnectDelayDuringRetryMs);\n<line40>    }\n<line41>    return sock;\n<line42>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        // recalculate the init limit time because retries sleep for 1000 milliseconds\n<line4>        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line5>        if (remainingTimeout <= 0) {\n<line6>            throw new IOException(\"connectToLeader exceeded on retries.\");\n<line7>        }\n<line8>        sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));\n<line9>        if (self.isSslQuorum()) {\n<line10>            ((SSLSocket) sock).startHandshake();\n<line11>        }\n<line12>        sock.setTcpNoDelay(nodelay);\n<line13>        break;\n<line14>    } catch (IOException e) {\n<line15>        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line16>        if (remainingTimeout <= leaderConnectDelayDuringRetryMs) {\n<line17>            throw e;\n<line18>        } else if (tries >= 4) {\n<line19>            throw e;\n<line20>        } else {\n<line21>            sock = createSocket();\n<line22>        }\n<line23>    }\n<line24>    Thread.sleep(leaderConnectDelayDuringRetryMs);\n<line25>}","output":"<line1>{\n<line2>    try {\n<line3>        // recalculate the init limit time because retries sleep for 1000 milliseconds\n<line4>        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line5>        if (remainingTimeout <= 0) {\n<line6>            LOG.error(\"connectToLeader exceeded on retries.\");\n<line7>            throw new IOException(\"connectToLeader exceeded on retries.\");\n<line8>        }\n<line9>        sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));\n<line10>        if (self.isSslQuorum()) {\n<line11>            ((SSLSocket) sock).startHandshake();\n<line12>        }\n<line13>        sock.setTcpNoDelay(nodelay);\n<line14>        break;\n<line15>    } catch (IOException e) {\n<line16>        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line17>        if (remainingTimeout <= leaderConnectDelayDuringRetryMs) {\n<line18>            LOG.error(\"Unexpected exception, connectToLeader exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line19>            throw e;\n<line20>        } else if (tries >= 4) {\n<line21>            LOG.error(\"Unexpected exception, retries exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line22>            throw e;\n<line23>        } else {\n<line24>            LOG.warn(\"Unexpected exception, tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line25>            sock = createSocket();\n<line26>        }\n<line27>    }\n<line28>    Thread.sleep(leaderConnectDelayDuringRetryMs);\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    // recalculate the init limit time because retries sleep for 1000 milliseconds\n<line3>    remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line4>    if (remainingTimeout <= 0) {\n<line5>        throw new IOException(\"connectToLeader exceeded on retries.\");\n<line6>    }\n<line7>    sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));\n<line8>    if (self.isSslQuorum()) {\n<line9>        ((SSLSocket) sock).startHandshake();\n<line10>    }\n<line11>    sock.setTcpNoDelay(nodelay);\n<line12>    break;\n<line13>}","output":"<line1>{\n<line2>    // recalculate the init limit time because retries sleep for 1000 milliseconds\n<line3>    remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line4>    if (remainingTimeout <= 0) {\n<line5>        LOG.error(\"connectToLeader exceeded on retries.\");\n<line6>        throw new IOException(\"connectToLeader exceeded on retries.\");\n<line7>    }\n<line8>    sockConnect(sock, address, Math.min(connectTimeout, remainingTimeout));\n<line9>    if (self.isSslQuorum()) {\n<line10>        ((SSLSocket) sock).startHandshake();\n<line11>    }\n<line12>    sock.setTcpNoDelay(nodelay);\n<line13>    break;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new IOException(\"connectToLeader exceeded on retries.\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"connectToLeader exceeded on retries.\");\n<line3>    throw new IOException(\"connectToLeader exceeded on retries.\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line3>    if (remainingTimeout <= leaderConnectDelayDuringRetryMs) {\n<line4>        throw e;\n<line5>    } else if (tries >= 4) {\n<line6>        throw e;\n<line7>    } else {\n<line8>        sock = createSocket();\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1_000_000);\n<line3>    if (remainingTimeout <= leaderConnectDelayDuringRetryMs) {\n<line4>        LOG.error(\"Unexpected exception, connectToLeader exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line5>        throw e;\n<line6>    } else if (tries >= 4) {\n<line7>        LOG.error(\"Unexpected exception, retries exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line8>        throw e;\n<line9>    } else {\n<line10>        LOG.warn(\"Unexpected exception, tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line11>        sock = createSocket();\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception, connectToLeader exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception, retries exceeded. tries={}, remaining init limit={}, connecting to {}\", tries, remainingTimeout, address, e);\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>         * Send follower info, including last zxid and sid\n<line4>         */\n<line5>    long lastLoggedZxid = self.getLastLoggedZxid();\n<line6>    QuorumPacket qp = new QuorumPacket();\n<line7>    qp.setType(pktType);\n<line8>    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));\n<line9>    /*\n<line10>         * Add sid to payload\n<line11>         */\n<line12>    LearnerInfo li = new LearnerInfo(self.getMyId(), 0x10000, self.getQuorumVerifier().getVersion());\n<line13>    ByteArrayOutputStream bsid = new ByteArrayOutputStream();\n<line14>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);\n<line15>    boa.writeRecord(li, \"LearnerInfo\");\n<line16>    qp.setData(bsid.toByteArray());\n<line17>    writePacket(qp, true);\n<line18>    readPacket(qp);\n<line19>    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n<line20>    if (qp.getType() == Leader.LEADERINFO) {\n<line21>        // we are connected to a 1.0 server so accept the new epoch and read the next packet\n<line22>        leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();\n<line23>        byte[] epochBytes = new byte[4];\n<line24>        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);\n<line25>        if (newEpoch > self.getAcceptedEpoch()) {\n<line26>            wrappedEpochBytes.putInt((int) self.getCurrentEpoch());\n<line27>            self.setAcceptedEpoch(newEpoch);\n<line28>        } else if (newEpoch == self.getAcceptedEpoch()) {\n<line29>            // since we have already acked an epoch equal to the leaders, we cannot ack\n<line30>            // again, but we still need to send our lastZxid to the leader so that we can\n<line31>            // sync with it if it does assume leadership of the epoch.\n<line32>            // the -1 indicates that this reply should not count as an ack for the new epoch\n<line33>            wrappedEpochBytes.putInt(-1);\n<line34>        } else {\n<line35>            throw new IOException(\"Leaders epoch, \" + newEpoch + \" is less than accepted epoch, \" + self.getAcceptedEpoch());\n<line36>        }\n<line37>        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);\n<line38>        writePacket(ackNewEpoch, true);\n<line39>        return ZxidUtils.makeZxid(newEpoch, 0);\n<line40>    } else {\n<line41>        if (newEpoch > self.getAcceptedEpoch()) {\n<line42>            self.setAcceptedEpoch(newEpoch);\n<line43>        }\n<line44>        if (qp.getType() != Leader.NEWLEADER) {\n<line45>            throw new IOException(\"First packet should have been NEWLEADER\");\n<line46>        }\n<line47>        return qp.getZxid();\n<line48>    }\n<line49>}","output":"<line1>{\n<line2>    /*\n<line3>         * Send follower info, including last zxid and sid\n<line4>         */\n<line5>    long lastLoggedZxid = self.getLastLoggedZxid();\n<line6>    QuorumPacket qp = new QuorumPacket();\n<line7>    qp.setType(pktType);\n<line8>    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));\n<line9>    /*\n<line10>         * Add sid to payload\n<line11>         */\n<line12>    LearnerInfo li = new LearnerInfo(self.getMyId(), 0x10000, self.getQuorumVerifier().getVersion());\n<line13>    ByteArrayOutputStream bsid = new ByteArrayOutputStream();\n<line14>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);\n<line15>    boa.writeRecord(li, \"LearnerInfo\");\n<line16>    qp.setData(bsid.toByteArray());\n<line17>    writePacket(qp, true);\n<line18>    readPacket(qp);\n<line19>    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n<line20>    if (qp.getType() == Leader.LEADERINFO) {\n<line21>        // we are connected to a 1.0 server so accept the new epoch and read the next packet\n<line22>        leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();\n<line23>        byte[] epochBytes = new byte[4];\n<line24>        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);\n<line25>        if (newEpoch > self.getAcceptedEpoch()) {\n<line26>            wrappedEpochBytes.putInt((int) self.getCurrentEpoch());\n<line27>            self.setAcceptedEpoch(newEpoch);\n<line28>        } else if (newEpoch == self.getAcceptedEpoch()) {\n<line29>            // since we have already acked an epoch equal to the leaders, we cannot ack\n<line30>            // again, but we still need to send our lastZxid to the leader so that we can\n<line31>            // sync with it if it does assume leadership of the epoch.\n<line32>            // the -1 indicates that this reply should not count as an ack for the new epoch\n<line33>            wrappedEpochBytes.putInt(-1);\n<line34>        } else {\n<line35>            throw new IOException(\"Leaders epoch, \" + newEpoch + \" is less than accepted epoch, \" + self.getAcceptedEpoch());\n<line36>        }\n<line37>        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);\n<line38>        writePacket(ackNewEpoch, true);\n<line39>        return ZxidUtils.makeZxid(newEpoch, 0);\n<line40>    } else {\n<line41>        if (newEpoch > self.getAcceptedEpoch()) {\n<line42>            self.setAcceptedEpoch(newEpoch);\n<line43>        }\n<line44>        if (qp.getType() != Leader.NEWLEADER) {\n<line45>            LOG.error(\"First packet should have been NEWLEADER\");\n<line46>            throw new IOException(\"First packet should have been NEWLEADER\");\n<line47>        }\n<line48>        return qp.getZxid();\n<line49>    }\n<line50>}"},{"input":"","instruction":"<line1>{\n<line2>    if (newEpoch > self.getAcceptedEpoch()) {\n<line3>        self.setAcceptedEpoch(newEpoch);\n<line4>    }\n<line5>    if (qp.getType() != Leader.NEWLEADER) {\n<line6>        throw new IOException(\"First packet should have been NEWLEADER\");\n<line7>    }\n<line8>    return qp.getZxid();\n<line9>}","output":"<line1>{\n<line2>    if (newEpoch > self.getAcceptedEpoch()) {\n<line3>        self.setAcceptedEpoch(newEpoch);\n<line4>    }\n<line5>    if (qp.getType() != Leader.NEWLEADER) {\n<line6>        LOG.error(\"First packet should have been NEWLEADER\");\n<line7>        throw new IOException(\"First packet should have been NEWLEADER\");\n<line8>    }\n<line9>    return qp.getZxid();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new IOException(\"First packet should have been NEWLEADER\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"First packet should have been NEWLEADER\");\n<line3>    throw new IOException(\"First packet should have been NEWLEADER\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);\n<line3>    QuorumPacket qp = new QuorumPacket();\n<line4>    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);\n<line5>    QuorumVerifier newLeaderQV = null;\n<line6>    // In the DIFF case we don't need to do a snapshot because the transactions will sync on top of any existing snapshot\n<line7>    // For SNAP and TRUNC the snapshot is needed to save that history\n<line8>    boolean snapshotNeeded = true;\n<line9>    boolean syncSnapshot = false;\n<line10>    readPacket(qp);\n<line11>    Deque<Long> packetsCommitted = new ArrayDeque<>();\n<line12>    Deque<PacketInFlight> packetsNotCommitted = new ArrayDeque<>();\n<line13>    Deque<Request> requestsToAck = new ArrayDeque<>();\n<line14>    synchronized (zk) {\n<line15>        if (qp.getType() == Leader.DIFF) {\n<line16>            self.setSyncMode(QuorumPeer.SyncMode.DIFF);\n<line17>            if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {\n<line18>                snapshotNeeded = true;\n<line19>                syncSnapshot = true;\n<line20>            } else {\n<line21>                snapshotNeeded = false;\n<line22>            }\n<line23>        } else if (qp.getType() == Leader.SNAP) {\n<line24>            self.setSyncMode(QuorumPeer.SyncMode.SNAP);\n<line25>            // The leader is going to dump the database\n<line26>            // db is clear as part of deserializeSnapshot()\n<line27>            zk.getZKDatabase().deserializeSnapshot(leaderIs);\n<line28>            // ZOOKEEPER-2819: overwrite config node content extracted\n<line29>            // from leader snapshot with local config, to avoid potential\n<line30>            // inconsistency of config node content during rolling restart.\n<line31>            if (!self.isReconfigEnabled()) {\n<line32>                zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line33>            }\n<line34>            String signature = leaderIs.readString(\"signature\");\n<line35>            if (!signature.equals(\"BenWasHere\")) {\n<line36>                throw new IOException(\"Missing signature\");\n<line37>            }\n<line38>            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line39>            // immediately persist the latest snapshot when there is txn log gap\n<line40>            syncSnapshot = true;\n<line41>        } else if (qp.getType() == Leader.TRUNC) {\n<line42>            //we need to truncate the log to the lastzxid of the leader\n<line43>            self.setSyncMode(QuorumPeer.SyncMode.TRUNC);\n<line44>            boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());\n<line45>            if (!truncated) {\n<line46>                // not able to truncate the log\n<line47>                ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line48>            }\n<line49>            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line50>        } else {\n<line51>            ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line52>        }\n<line53>        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line54>        zk.createSessionTracker();\n<line55>        long lastQueued = 0;\n<line56>        // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0\n<line57>        // we take the snapshot on the UPDATE message, since Zab V1.0 also gets the UPDATE (after the NEWLEADER)\n<line58>        // we need to make sure that we don't take the snapshot twice.\n<line59>        boolean isPreZAB1_0 = true;\n<line60>        //If we are not going to take the snapshot be sure the transactions are not applied in memory\n<line61>        // but written out to the transaction log\n<line62>        boolean writeToTxnLog = !snapshotNeeded;\n<line63>        TxnLogEntry logEntry;\n<line64>        // we are now going to start getting transactions to apply followed by an UPTODATE\n<line65>        outerLoop: while (self.isRunning()) {\n<line66>            readPacket(qp);\n<line67>            switch(qp.getType()) {\n<line68>                case Leader.PROPOSAL:\n<line69>                    PacketInFlight pif = new PacketInFlight();\n<line70>                    logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line71>                    pif.hdr = logEntry.getHeader();\n<line72>                    pif.rec = logEntry.getTxn();\n<line73>                    pif.digest = logEntry.getDigest();\n<line74>                    if (pif.hdr.getZxid() != lastQueued + 1) {\n<line75>                    }\n<line76>                    lastQueued = pif.hdr.getZxid();\n<line77>                    if (pif.hdr.getType() == OpCode.reconfig) {\n<line78>                        SetDataTxn setDataTxn = (SetDataTxn) pif.rec;\n<line79>                        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line80>                        self.setLastSeenQuorumVerifier(qv, true);\n<line81>                    }\n<line82>                    packetsNotCommitted.add(pif);\n<line83>                    break;\n<line84>                case Leader.COMMIT:\n<line85>                case Leader.COMMITANDACTIVATE:\n<line86>                    pif = packetsNotCommitted.peekFirst();\n<line87>                    if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {\n<line88>                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));\n<line89>                        boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);\n<line90>                        if (majorChange) {\n<line91>                            throw new Exception(\"changes proposed in reconfig\");\n<line92>                        }\n<line93>                    }\n<line94>                    if (!writeToTxnLog) {\n<line95>                        if (pif.hdr.getZxid() != qp.getZxid()) {\n<line96>                        } else {\n<line97>                            zk.processTxn(pif.hdr, pif.rec);\n<line98>                            packetsNotCommitted.remove();\n<line99>                        }\n<line100>                    } else {\n<line101>                        packetsCommitted.add(qp.getZxid());\n<line102>                    }\n<line103>                    break;\n<line104>                case Leader.INFORM:\n<line105>                case Leader.INFORMANDACTIVATE:\n<line106>                    PacketInFlight packet = new PacketInFlight();\n<line107>                    if (qp.getType() == Leader.INFORMANDACTIVATE) {\n<line108>                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line109>                        long suggestedLeaderId = buffer.getLong();\n<line110>                        byte[] remainingdata = new byte[buffer.remaining()];\n<line111>                        buffer.get(remainingdata);\n<line112>                        logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line113>                        packet.hdr = logEntry.getHeader();\n<line114>                        packet.rec = logEntry.getTxn();\n<line115>                        packet.digest = logEntry.getDigest();\n<line116>                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));\n<line117>                        boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line118>                        if (majorChange) {\n<line119>                            throw new Exception(\"changes proposed in reconfig\");\n<line120>                        }\n<line121>                    } else {\n<line122>                        logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line123>                        packet.rec = logEntry.getTxn();\n<line124>                        packet.hdr = logEntry.getHeader();\n<line125>                        packet.digest = logEntry.getDigest();\n<line126>                        // Log warning message if txn comes out-of-order\n<line127>                        if (packet.hdr.getZxid() != lastQueued + 1) {\n<line128>                        }\n<line129>                        lastQueued = packet.hdr.getZxid();\n<line130>                    }\n<line131>                    if (!writeToTxnLog) {\n<line132>                        // Apply to db directly if we haven't taken the snapshot\n<line133>                        zk.processTxn(packet.hdr, packet.rec);\n<line134>                    } else {\n<line135>                        packetsNotCommitted.add(packet);\n<line136>                        packetsCommitted.add(qp.getZxid());\n<line137>                    }\n<line138>                    break;\n<line139>                case Leader.UPTODATE:\n<line140>                    if (newLeaderQV != null) {\n<line141>                        boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);\n<line142>                        if (majorChange) {\n<line143>                            throw new Exception(\"changes proposed in reconfig\");\n<line144>                        }\n<line145>                    }\n<line146>                    if (isPreZAB1_0) {\n<line147>                        zk.takeSnapshot(syncSnapshot);\n<line148>                        self.setCurrentEpoch(newEpoch);\n<line149>                    }\n<line150>                    self.setZooKeeperServer(zk);\n<line151>                    self.adminServer.setZooKeeperServer(zk);\n<line152>                    break outerLoop;\n<line153>                case // Getting NEWLEADER here instead of in discovery\n<line154>                Leader.NEWLEADER:\n<line155>                    // means this is Zab 1.0\n<line156>                    if (qp.getData() != null && qp.getData().length > 1) {\n<line157>                        try {\n<line158>                            QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));\n<line159>                            self.setLastSeenQuorumVerifier(qv, true);\n<line160>                            newLeaderQV = qv;\n<line161>                        } catch (Exception e) {\n<line162>                            e.printStackTrace();\n<line163>                        }\n<line164>                    }\n<line165>                    if (snapshotNeeded) {\n<line166>                        zk.takeSnapshot(syncSnapshot);\n<line167>                    }\n<line168>                    writeToTxnLog = true;\n<line169>                    //Anything after this needs to go to the transaction log, not applied directly in memory\n<line170>                    isPreZAB1_0 = false;\n<line171>                    // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).\n<line172>                    sock.setSoTimeout(self.tickTime * self.syncLimit);\n<line173>                    self.setSyncMode(QuorumPeer.SyncMode.NONE);\n<line174>                    zk.startupWithoutServing();\n<line175>                    if (zk instanceof FollowerZooKeeperServer) {\n<line176>                        long startTime = Time.currentElapsedTime();\n<line177>                        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line178>                        for (PacketInFlight p : packetsNotCommitted) {\n<line179>                            final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line180>                            requestsToAck.add(request);\n<line181>                        }\n<line182>                        // persist the txns to disk\n<line183>                        fzk.getZKDatabase().commit();\n<line184>                        packetsNotCommitted.clear();\n<line185>                    }\n<line186>                    // set the current epoch after all the tnxs are persisted\n<line187>                    self.setCurrentEpoch(newEpoch);\n<line188>                    // send NEWLEADER ack after all the tnxs are persisted\n<line189>                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n<line190>                    break;\n<line191>            }\n<line192>        }\n<line193>    }\n<line194>    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));\n<line195>    writePacket(ack, true);\n<line196>    zk.startServing();\n<line197>    /*\n<line198>         * Update the election vote here to ensure that all members of the\n<line199>         * ensemble report the same vote to new servers that start up and\n<line200>         * send leader election notifications to the ensemble.\n<line201>         *\n<line202>         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n<line203>         */\n<line204>    self.updateElectionVote(newEpoch);\n<line205>    // We need to log the stuff that came in between the snapshot and the uptodate\n<line206>    if (zk instanceof FollowerZooKeeperServer) {\n<line207>        // reply ACK of PROPOSAL after ACK of NEWLEADER to avoid leader shutdown due to timeout\n<line208>        // on waiting for a quorum of followers\n<line209>        for (final Request request : requestsToAck) {\n<line210>            final QuorumPacket ackPacket = new QuorumPacket(Leader.ACK, request.getHdr().getZxid(), null, null);\n<line211>            writePacket(ackPacket, false);\n<line212>        }\n<line213>        writePacket(null, true);\n<line214>        requestsToAck.clear();\n<line215>        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line216>        for (PacketInFlight p : packetsNotCommitted) {\n<line217>            fzk.logRequest(p.hdr, p.rec, p.digest);\n<line218>        }\n<line219>        for (Long zxid : packetsCommitted) {\n<line220>            fzk.commit(zxid);\n<line221>        }\n<line222>    } else if (zk instanceof ObserverZooKeeperServer) {\n<line223>        // Similar to follower, we need to log requests between the snapshot\n<line224>        // and UPTODATE\n<line225>        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;\n<line226>        for (PacketInFlight p : packetsNotCommitted) {\n<line227>            Long zxid = packetsCommitted.peekFirst();\n<line228>            if (p.hdr.getZxid() != zxid) {\n<line229>                // log warning message if there is no matching commit\n<line230>                // old leader send outstanding proposal to observer\n<line231>                continue;\n<line232>            }\n<line233>            packetsCommitted.remove();\n<line234>            Request request = new Request(p.hdr.getClientId(), p.hdr.getCxid(), p.hdr.getType(), p.hdr, p.rec, -1);\n<line235>            request.setTxnDigest(p.digest);\n<line236>            ozk.commitRequest(request);\n<line237>        }\n<line238>    } else {\n<line239>        // New server type need to handle in-flight packets\n<line240>        throw new UnsupportedOperationException(\"Unknown server type\");\n<line241>    }\n<line242>}","output":"<line1>{\n<line2>    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);\n<line3>    QuorumPacket qp = new QuorumPacket();\n<line4>    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);\n<line5>    QuorumVerifier newLeaderQV = null;\n<line6>    // In the DIFF case we don't need to do a snapshot because the transactions will sync on top of any existing snapshot\n<line7>    // For SNAP and TRUNC the snapshot is needed to save that history\n<line8>    boolean snapshotNeeded = true;\n<line9>    boolean syncSnapshot = false;\n<line10>    readPacket(qp);\n<line11>    Deque<Long> packetsCommitted = new ArrayDeque<>();\n<line12>    Deque<PacketInFlight> packetsNotCommitted = new ArrayDeque<>();\n<line13>    Deque<Request> requestsToAck = new ArrayDeque<>();\n<line14>    synchronized (zk) {\n<line15>        if (qp.getType() == Leader.DIFF) {\n<line16>            LOG.info(\"Getting a diff from the leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line17>            self.setSyncMode(QuorumPeer.SyncMode.DIFF);\n<line18>            if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {\n<line19>                LOG.info(\"Forcing a snapshot write as part of upgrading from an older Zookeeper. This should only happen while upgrading.\");\n<line20>                snapshotNeeded = true;\n<line21>                syncSnapshot = true;\n<line22>            } else {\n<line23>                snapshotNeeded = false;\n<line24>            }\n<line25>        } else if (qp.getType() == Leader.SNAP) {\n<line26>            self.setSyncMode(QuorumPeer.SyncMode.SNAP);\n<line27>            LOG.info(\"Getting a snapshot from leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line28>            // The leader is going to dump the database\n<line29>            // db is clear as part of deserializeSnapshot()\n<line30>            zk.getZKDatabase().deserializeSnapshot(leaderIs);\n<line31>            // ZOOKEEPER-2819: overwrite config node content extracted\n<line32>            // from leader snapshot with local config, to avoid potential\n<line33>            // inconsistency of config node content during rolling restart.\n<line34>            if (!self.isReconfigEnabled()) {\n<line35>                LOG.debug(\"Reset config node content from local config after deserialization of snapshot.\");\n<line36>                zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line37>            }\n<line38>            String signature = leaderIs.readString(\"signature\");\n<line39>            if (!signature.equals(\"BenWasHere\")) {\n<line40>                LOG.error(\"Missing signature. Got {}\", signature);\n<line41>                throw new IOException(\"Missing signature\");\n<line42>            }\n<line43>            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line44>            // immediately persist the latest snapshot when there is txn log gap\n<line45>            syncSnapshot = true;\n<line46>        } else if (qp.getType() == Leader.TRUNC) {\n<line47>            //we need to truncate the log to the lastzxid of the leader\n<line48>            self.setSyncMode(QuorumPeer.SyncMode.TRUNC);\n<line49>            LOG.warn(\"Truncating log to get in sync with the leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line50>            boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());\n<line51>            if (!truncated) {\n<line52>                // not able to truncate the log\n<line53>                LOG.error(\"Not able to truncate the log 0x{}\", Long.toHexString(qp.getZxid()));\n<line54>                ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line55>            }\n<line56>            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line57>        } else {\n<line58>            LOG.error(\"Got unexpected packet from leader: {}, exiting ... \", LearnerHandler.packetToString(qp));\n<line59>            ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line60>        }\n<line61>        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line62>        zk.createSessionTracker();\n<line63>        long lastQueued = 0;\n<line64>        // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0\n<line65>        // we take the snapshot on the UPDATE message, since Zab V1.0 also gets the UPDATE (after the NEWLEADER)\n<line66>        // we need to make sure that we don't take the snapshot twice.\n<line67>        boolean isPreZAB1_0 = true;\n<line68>        //If we are not going to take the snapshot be sure the transactions are not applied in memory\n<line69>        // but written out to the transaction log\n<line70>        boolean writeToTxnLog = !snapshotNeeded;\n<line71>        TxnLogEntry logEntry;\n<line72>        // we are now going to start getting transactions to apply followed by an UPTODATE\n<line73>        outerLoop: while (self.isRunning()) {\n<line74>            readPacket(qp);\n<line75>            switch(qp.getType()) {\n<line76>                case Leader.PROPOSAL:\n<line77>                    PacketInFlight pif = new PacketInFlight();\n<line78>                    logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line79>                    pif.hdr = logEntry.getHeader();\n<line80>                    pif.rec = logEntry.getTxn();\n<line81>                    pif.digest = logEntry.getDigest();\n<line82>                    if (pif.hdr.getZxid() != lastQueued + 1) {\n<line83>                        LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(pif.hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line84>                    }\n<line85>                    lastQueued = pif.hdr.getZxid();\n<line86>                    if (pif.hdr.getType() == OpCode.reconfig) {\n<line87>                        SetDataTxn setDataTxn = (SetDataTxn) pif.rec;\n<line88>                        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line89>                        self.setLastSeenQuorumVerifier(qv, true);\n<line90>                    }\n<line91>                    packetsNotCommitted.add(pif);\n<line92>                    break;\n<line93>                case Leader.COMMIT:\n<line94>                case Leader.COMMITANDACTIVATE:\n<line95>                    pif = packetsNotCommitted.peekFirst();\n<line96>                    if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {\n<line97>                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));\n<line98>                        boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);\n<line99>                        if (majorChange) {\n<line100>                            throw new Exception(\"changes proposed in reconfig\");\n<line101>                        }\n<line102>                    }\n<line103>                    if (!writeToTxnLog) {\n<line104>                        if (pif.hdr.getZxid() != qp.getZxid()) {\n<line105>                            LOG.warn(\"Committing 0x{}, but next proposal is 0x{}\", Long.toHexString(qp.getZxid()), Long.toHexString(pif.hdr.getZxid()));\n<line106>                        } else {\n<line107>                            zk.processTxn(pif.hdr, pif.rec);\n<line108>                            packetsNotCommitted.remove();\n<line109>                        }\n<line110>                    } else {\n<line111>                        packetsCommitted.add(qp.getZxid());\n<line112>                    }\n<line113>                    break;\n<line114>                case Leader.INFORM:\n<line115>                case Leader.INFORMANDACTIVATE:\n<line116>                    PacketInFlight packet = new PacketInFlight();\n<line117>                    if (qp.getType() == Leader.INFORMANDACTIVATE) {\n<line118>                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line119>                        long suggestedLeaderId = buffer.getLong();\n<line120>                        byte[] remainingdata = new byte[buffer.remaining()];\n<line121>                        buffer.get(remainingdata);\n<line122>                        logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line123>                        packet.hdr = logEntry.getHeader();\n<line124>                        packet.rec = logEntry.getTxn();\n<line125>                        packet.digest = logEntry.getDigest();\n<line126>                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));\n<line127>                        boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line128>                        if (majorChange) {\n<line129>                            throw new Exception(\"changes proposed in reconfig\");\n<line130>                        }\n<line131>                    } else {\n<line132>                        logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line133>                        packet.rec = logEntry.getTxn();\n<line134>                        packet.hdr = logEntry.getHeader();\n<line135>                        packet.digest = logEntry.getDigest();\n<line136>                        // Log warning message if txn comes out-of-order\n<line137>                        if (packet.hdr.getZxid() != lastQueued + 1) {\n<line138>                            LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(packet.hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line139>                        }\n<line140>                        lastQueued = packet.hdr.getZxid();\n<line141>                    }\n<line142>                    if (!writeToTxnLog) {\n<line143>                        // Apply to db directly if we haven't taken the snapshot\n<line144>                        zk.processTxn(packet.hdr, packet.rec);\n<line145>                    } else {\n<line146>                        packetsNotCommitted.add(packet);\n<line147>                        packetsCommitted.add(qp.getZxid());\n<line148>                    }\n<line149>                    break;\n<line150>                case Leader.UPTODATE:\n<line151>                    LOG.info(\"Learner received UPTODATE message\");\n<line152>                    if (newLeaderQV != null) {\n<line153>                        boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);\n<line154>                        if (majorChange) {\n<line155>                            throw new Exception(\"changes proposed in reconfig\");\n<line156>                        }\n<line157>                    }\n<line158>                    if (isPreZAB1_0) {\n<line159>                        zk.takeSnapshot(syncSnapshot);\n<line160>                        self.setCurrentEpoch(newEpoch);\n<line161>                    }\n<line162>                    self.setZooKeeperServer(zk);\n<line163>                    self.adminServer.setZooKeeperServer(zk);\n<line164>                    break outerLoop;\n<line165>                case // Getting NEWLEADER here instead of in discovery\n<line166>                Leader.NEWLEADER:\n<line167>                    // means this is Zab 1.0\n<line168>                    LOG.info(\"Learner received NEWLEADER message\");\n<line169>                    if (qp.getData() != null && qp.getData().length > 1) {\n<line170>                        try {\n<line171>                            QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));\n<line172>                            self.setLastSeenQuorumVerifier(qv, true);\n<line173>                            newLeaderQV = qv;\n<line174>                        } catch (Exception e) {\n<line175>                            e.printStackTrace();\n<line176>                        }\n<line177>                    }\n<line178>                    if (snapshotNeeded) {\n<line179>                        zk.takeSnapshot(syncSnapshot);\n<line180>                    }\n<line181>                    writeToTxnLog = true;\n<line182>                    //Anything after this needs to go to the transaction log, not applied directly in memory\n<line183>                    isPreZAB1_0 = false;\n<line184>                    // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).\n<line185>                    sock.setSoTimeout(self.tickTime * self.syncLimit);\n<line186>                    self.setSyncMode(QuorumPeer.SyncMode.NONE);\n<line187>                    zk.startupWithoutServing();\n<line188>                    if (zk instanceof FollowerZooKeeperServer) {\n<line189>                        long startTime = Time.currentElapsedTime();\n<line190>                        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line191>                        for (PacketInFlight p : packetsNotCommitted) {\n<line192>                            final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line193>                            requestsToAck.add(request);\n<line194>                        }\n<line195>                        // persist the txns to disk\n<line196>                        fzk.getZKDatabase().commit();\n<line197>                        LOG.info(\"{} txns have been persisted and it took {}ms\", packetsNotCommitted.size(), Time.currentElapsedTime() - startTime);\n<line198>                        packetsNotCommitted.clear();\n<line199>                    }\n<line200>                    // set the current epoch after all the tnxs are persisted\n<line201>                    self.setCurrentEpoch(newEpoch);\n<line202>                    LOG.info(\"Set the current epoch to {}\", newEpoch);\n<line203>                    // send NEWLEADER ack after all the tnxs are persisted\n<line204>                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n<line205>                    LOG.info(\"Sent NEWLEADER ack to leader with zxid {}\", Long.toHexString(newLeaderZxid));\n<line206>                    break;\n<line207>            }\n<line208>        }\n<line209>    }\n<line210>    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));\n<line211>    writePacket(ack, true);\n<line212>    zk.startServing();\n<line213>    /*\n<line214>         * Update the election vote here to ensure that all members of the\n<line215>         * ensemble report the same vote to new servers that start up and\n<line216>         * send leader election notifications to the ensemble.\n<line217>         *\n<line218>         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n<line219>         */\n<line220>    self.updateElectionVote(newEpoch);\n<line221>    // We need to log the stuff that came in between the snapshot and the uptodate\n<line222>    if (zk instanceof FollowerZooKeeperServer) {\n<line223>        // reply ACK of PROPOSAL after ACK of NEWLEADER to avoid leader shutdown due to timeout\n<line224>        // on waiting for a quorum of followers\n<line225>        for (final Request request : requestsToAck) {\n<line226>            final QuorumPacket ackPacket = new QuorumPacket(Leader.ACK, request.getHdr().getZxid(), null, null);\n<line227>            writePacket(ackPacket, false);\n<line228>        }\n<line229>        writePacket(null, true);\n<line230>        requestsToAck.clear();\n<line231>        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line232>        for (PacketInFlight p : packetsNotCommitted) {\n<line233>            fzk.logRequest(p.hdr, p.rec, p.digest);\n<line234>        }\n<line235>        LOG.info(\"{} txns have been logged asynchronously\", packetsNotCommitted.size());\n<line236>        for (Long zxid : packetsCommitted) {\n<line237>            fzk.commit(zxid);\n<line238>        }\n<line239>        LOG.info(\"{} txns have been committed\", packetsCommitted.size());\n<line240>    } else if (zk instanceof ObserverZooKeeperServer) {\n<line241>        // Similar to follower, we need to log requests between the snapshot\n<line242>        // and UPTODATE\n<line243>        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;\n<line244>        for (PacketInFlight p : packetsNotCommitted) {\n<line245>            Long zxid = packetsCommitted.peekFirst();\n<line246>            if (p.hdr.getZxid() != zxid) {\n<line247>                // log warning message if there is no matching commit\n<line248>                // old leader send outstanding proposal to observer\n<line249>                LOG.warn(\"Committing 0x{}, but next proposal is 0x{}\", Long.toHexString(zxid), Long.toHexString(p.hdr.getZxid()));\n<line250>                continue;\n<line251>            }\n<line252>            packetsCommitted.remove();\n<line253>            Request request = new Request(p.hdr.getClientId(), p.hdr.getCxid(), p.hdr.getType(), p.hdr, p.rec, -1);\n<line254>            request.setTxnDigest(p.digest);\n<line255>            ozk.commitRequest(request);\n<line256>        }\n<line257>    } else {\n<line258>        // New server type need to handle in-flight packets\n<line259>        throw new UnsupportedOperationException(\"Unknown server type\");\n<line260>    }\n<line261>}"},{"input":"","instruction":"<line1>{\n<line2>    if (qp.getType() == Leader.DIFF) {\n<line3>        self.setSyncMode(QuorumPeer.SyncMode.DIFF);\n<line4>        if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {\n<line5>            snapshotNeeded = true;\n<line6>            syncSnapshot = true;\n<line7>        } else {\n<line8>            snapshotNeeded = false;\n<line9>        }\n<line10>    } else if (qp.getType() == Leader.SNAP) {\n<line11>        self.setSyncMode(QuorumPeer.SyncMode.SNAP);\n<line12>        // The leader is going to dump the database\n<line13>        // db is clear as part of deserializeSnapshot()\n<line14>        zk.getZKDatabase().deserializeSnapshot(leaderIs);\n<line15>        // ZOOKEEPER-2819: overwrite config node content extracted\n<line16>        // from leader snapshot with local config, to avoid potential\n<line17>        // inconsistency of config node content during rolling restart.\n<line18>        if (!self.isReconfigEnabled()) {\n<line19>            zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line20>        }\n<line21>        String signature = leaderIs.readString(\"signature\");\n<line22>        if (!signature.equals(\"BenWasHere\")) {\n<line23>            throw new IOException(\"Missing signature\");\n<line24>        }\n<line25>        zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line26>        // immediately persist the latest snapshot when there is txn log gap\n<line27>        syncSnapshot = true;\n<line28>    } else if (qp.getType() == Leader.TRUNC) {\n<line29>        //we need to truncate the log to the lastzxid of the leader\n<line30>        self.setSyncMode(QuorumPeer.SyncMode.TRUNC);\n<line31>        boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());\n<line32>        if (!truncated) {\n<line33>            // not able to truncate the log\n<line34>            ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line35>        }\n<line36>        zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line37>    } else {\n<line38>        ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line39>    }\n<line40>    zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line41>    zk.createSessionTracker();\n<line42>    long lastQueued = 0;\n<line43>    // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0\n<line44>    // we take the snapshot on the UPDATE message, since Zab V1.0 also gets the UPDATE (after the NEWLEADER)\n<line45>    // we need to make sure that we don't take the snapshot twice.\n<line46>    boolean isPreZAB1_0 = true;\n<line47>    //If we are not going to take the snapshot be sure the transactions are not applied in memory\n<line48>    // but written out to the transaction log\n<line49>    boolean writeToTxnLog = !snapshotNeeded;\n<line50>    TxnLogEntry logEntry;\n<line51>    // we are now going to start getting transactions to apply followed by an UPTODATE\n<line52>    outerLoop: while (self.isRunning()) {\n<line53>        readPacket(qp);\n<line54>        switch(qp.getType()) {\n<line55>            case Leader.PROPOSAL:\n<line56>                PacketInFlight pif = new PacketInFlight();\n<line57>                logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line58>                pif.hdr = logEntry.getHeader();\n<line59>                pif.rec = logEntry.getTxn();\n<line60>                pif.digest = logEntry.getDigest();\n<line61>                if (pif.hdr.getZxid() != lastQueued + 1) {\n<line62>                }\n<line63>                lastQueued = pif.hdr.getZxid();\n<line64>                if (pif.hdr.getType() == OpCode.reconfig) {\n<line65>                    SetDataTxn setDataTxn = (SetDataTxn) pif.rec;\n<line66>                    QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line67>                    self.setLastSeenQuorumVerifier(qv, true);\n<line68>                }\n<line69>                packetsNotCommitted.add(pif);\n<line70>                break;\n<line71>            case Leader.COMMIT:\n<line72>            case Leader.COMMITANDACTIVATE:\n<line73>                pif = packetsNotCommitted.peekFirst();\n<line74>                if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {\n<line75>                    QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));\n<line76>                    boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);\n<line77>                    if (majorChange) {\n<line78>                        throw new Exception(\"changes proposed in reconfig\");\n<line79>                    }\n<line80>                }\n<line81>                if (!writeToTxnLog) {\n<line82>                    if (pif.hdr.getZxid() != qp.getZxid()) {\n<line83>                    } else {\n<line84>                        zk.processTxn(pif.hdr, pif.rec);\n<line85>                        packetsNotCommitted.remove();\n<line86>                    }\n<line87>                } else {\n<line88>                    packetsCommitted.add(qp.getZxid());\n<line89>                }\n<line90>                break;\n<line91>            case Leader.INFORM:\n<line92>            case Leader.INFORMANDACTIVATE:\n<line93>                PacketInFlight packet = new PacketInFlight();\n<line94>                if (qp.getType() == Leader.INFORMANDACTIVATE) {\n<line95>                    ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line96>                    long suggestedLeaderId = buffer.getLong();\n<line97>                    byte[] remainingdata = new byte[buffer.remaining()];\n<line98>                    buffer.get(remainingdata);\n<line99>                    logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line100>                    packet.hdr = logEntry.getHeader();\n<line101>                    packet.rec = logEntry.getTxn();\n<line102>                    packet.digest = logEntry.getDigest();\n<line103>                    QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));\n<line104>                    boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line105>                    if (majorChange) {\n<line106>                        throw new Exception(\"changes proposed in reconfig\");\n<line107>                    }\n<line108>                } else {\n<line109>                    logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line110>                    packet.rec = logEntry.getTxn();\n<line111>                    packet.hdr = logEntry.getHeader();\n<line112>                    packet.digest = logEntry.getDigest();\n<line113>                    // Log warning message if txn comes out-of-order\n<line114>                    if (packet.hdr.getZxid() != lastQueued + 1) {\n<line115>                    }\n<line116>                    lastQueued = packet.hdr.getZxid();\n<line117>                }\n<line118>                if (!writeToTxnLog) {\n<line119>                    // Apply to db directly if we haven't taken the snapshot\n<line120>                    zk.processTxn(packet.hdr, packet.rec);\n<line121>                } else {\n<line122>                    packetsNotCommitted.add(packet);\n<line123>                    packetsCommitted.add(qp.getZxid());\n<line124>                }\n<line125>                break;\n<line126>            case Leader.UPTODATE:\n<line127>                if (newLeaderQV != null) {\n<line128>                    boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);\n<line129>                    if (majorChange) {\n<line130>                        throw new Exception(\"changes proposed in reconfig\");\n<line131>                    }\n<line132>                }\n<line133>                if (isPreZAB1_0) {\n<line134>                    zk.takeSnapshot(syncSnapshot);\n<line135>                    self.setCurrentEpoch(newEpoch);\n<line136>                }\n<line137>                self.setZooKeeperServer(zk);\n<line138>                self.adminServer.setZooKeeperServer(zk);\n<line139>                break outerLoop;\n<line140>            case // Getting NEWLEADER here instead of in discovery\n<line141>            Leader.NEWLEADER:\n<line142>                // means this is Zab 1.0\n<line143>                if (qp.getData() != null && qp.getData().length > 1) {\n<line144>                    try {\n<line145>                        QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));\n<line146>                        self.setLastSeenQuorumVerifier(qv, true);\n<line147>                        newLeaderQV = qv;\n<line148>                    } catch (Exception e) {\n<line149>                        e.printStackTrace();\n<line150>                    }\n<line151>                }\n<line152>                if (snapshotNeeded) {\n<line153>                    zk.takeSnapshot(syncSnapshot);\n<line154>                }\n<line155>                writeToTxnLog = true;\n<line156>                //Anything after this needs to go to the transaction log, not applied directly in memory\n<line157>                isPreZAB1_0 = false;\n<line158>                // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).\n<line159>                sock.setSoTimeout(self.tickTime * self.syncLimit);\n<line160>                self.setSyncMode(QuorumPeer.SyncMode.NONE);\n<line161>                zk.startupWithoutServing();\n<line162>                if (zk instanceof FollowerZooKeeperServer) {\n<line163>                    long startTime = Time.currentElapsedTime();\n<line164>                    FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line165>                    for (PacketInFlight p : packetsNotCommitted) {\n<line166>                        final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line167>                        requestsToAck.add(request);\n<line168>                    }\n<line169>                    // persist the txns to disk\n<line170>                    fzk.getZKDatabase().commit();\n<line171>                    packetsNotCommitted.clear();\n<line172>                }\n<line173>                // set the current epoch after all the tnxs are persisted\n<line174>                self.setCurrentEpoch(newEpoch);\n<line175>                // send NEWLEADER ack after all the tnxs are persisted\n<line176>                writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n<line177>                break;\n<line178>        }\n<line179>    }\n<line180>}","output":"<line1>{\n<line2>    if (qp.getType() == Leader.DIFF) {\n<line3>        LOG.info(\"Getting a diff from the leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line4>        self.setSyncMode(QuorumPeer.SyncMode.DIFF);\n<line5>        if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {\n<line6>            LOG.info(\"Forcing a snapshot write as part of upgrading from an older Zookeeper. This should only happen while upgrading.\");\n<line7>            snapshotNeeded = true;\n<line8>            syncSnapshot = true;\n<line9>        } else {\n<line10>            snapshotNeeded = false;\n<line11>        }\n<line12>    } else if (qp.getType() == Leader.SNAP) {\n<line13>        self.setSyncMode(QuorumPeer.SyncMode.SNAP);\n<line14>        LOG.info(\"Getting a snapshot from leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line15>        // The leader is going to dump the database\n<line16>        // db is clear as part of deserializeSnapshot()\n<line17>        zk.getZKDatabase().deserializeSnapshot(leaderIs);\n<line18>        // ZOOKEEPER-2819: overwrite config node content extracted\n<line19>        // from leader snapshot with local config, to avoid potential\n<line20>        // inconsistency of config node content during rolling restart.\n<line21>        if (!self.isReconfigEnabled()) {\n<line22>            LOG.debug(\"Reset config node content from local config after deserialization of snapshot.\");\n<line23>            zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line24>        }\n<line25>        String signature = leaderIs.readString(\"signature\");\n<line26>        if (!signature.equals(\"BenWasHere\")) {\n<line27>            LOG.error(\"Missing signature. Got {}\", signature);\n<line28>            throw new IOException(\"Missing signature\");\n<line29>        }\n<line30>        zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line31>        // immediately persist the latest snapshot when there is txn log gap\n<line32>        syncSnapshot = true;\n<line33>    } else if (qp.getType() == Leader.TRUNC) {\n<line34>        //we need to truncate the log to the lastzxid of the leader\n<line35>        self.setSyncMode(QuorumPeer.SyncMode.TRUNC);\n<line36>        LOG.warn(\"Truncating log to get in sync with the leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line37>        boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());\n<line38>        if (!truncated) {\n<line39>            // not able to truncate the log\n<line40>            LOG.error(\"Not able to truncate the log 0x{}\", Long.toHexString(qp.getZxid()));\n<line41>            ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line42>        }\n<line43>        zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line44>    } else {\n<line45>        LOG.error(\"Got unexpected packet from leader: {}, exiting ... \", LearnerHandler.packetToString(qp));\n<line46>        ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line47>    }\n<line48>    zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line49>    zk.createSessionTracker();\n<line50>    long lastQueued = 0;\n<line51>    // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0\n<line52>    // we take the snapshot on the UPDATE message, since Zab V1.0 also gets the UPDATE (after the NEWLEADER)\n<line53>    // we need to make sure that we don't take the snapshot twice.\n<line54>    boolean isPreZAB1_0 = true;\n<line55>    //If we are not going to take the snapshot be sure the transactions are not applied in memory\n<line56>    // but written out to the transaction log\n<line57>    boolean writeToTxnLog = !snapshotNeeded;\n<line58>    TxnLogEntry logEntry;\n<line59>    // we are now going to start getting transactions to apply followed by an UPTODATE\n<line60>    outerLoop: while (self.isRunning()) {\n<line61>        readPacket(qp);\n<line62>        switch(qp.getType()) {\n<line63>            case Leader.PROPOSAL:\n<line64>                PacketInFlight pif = new PacketInFlight();\n<line65>                logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line66>                pif.hdr = logEntry.getHeader();\n<line67>                pif.rec = logEntry.getTxn();\n<line68>                pif.digest = logEntry.getDigest();\n<line69>                if (pif.hdr.getZxid() != lastQueued + 1) {\n<line70>                    LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(pif.hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line71>                }\n<line72>                lastQueued = pif.hdr.getZxid();\n<line73>                if (pif.hdr.getType() == OpCode.reconfig) {\n<line74>                    SetDataTxn setDataTxn = (SetDataTxn) pif.rec;\n<line75>                    QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line76>                    self.setLastSeenQuorumVerifier(qv, true);\n<line77>                }\n<line78>                packetsNotCommitted.add(pif);\n<line79>                break;\n<line80>            case Leader.COMMIT:\n<line81>            case Leader.COMMITANDACTIVATE:\n<line82>                pif = packetsNotCommitted.peekFirst();\n<line83>                if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {\n<line84>                    QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));\n<line85>                    boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);\n<line86>                    if (majorChange) {\n<line87>                        throw new Exception(\"changes proposed in reconfig\");\n<line88>                    }\n<line89>                }\n<line90>                if (!writeToTxnLog) {\n<line91>                    if (pif.hdr.getZxid() != qp.getZxid()) {\n<line92>                        LOG.warn(\"Committing 0x{}, but next proposal is 0x{}\", Long.toHexString(qp.getZxid()), Long.toHexString(pif.hdr.getZxid()));\n<line93>                    } else {\n<line94>                        zk.processTxn(pif.hdr, pif.rec);\n<line95>                        packetsNotCommitted.remove();\n<line96>                    }\n<line97>                } else {\n<line98>                    packetsCommitted.add(qp.getZxid());\n<line99>                }\n<line100>                break;\n<line101>            case Leader.INFORM:\n<line102>            case Leader.INFORMANDACTIVATE:\n<line103>                PacketInFlight packet = new PacketInFlight();\n<line104>                if (qp.getType() == Leader.INFORMANDACTIVATE) {\n<line105>                    ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line106>                    long suggestedLeaderId = buffer.getLong();\n<line107>                    byte[] remainingdata = new byte[buffer.remaining()];\n<line108>                    buffer.get(remainingdata);\n<line109>                    logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line110>                    packet.hdr = logEntry.getHeader();\n<line111>                    packet.rec = logEntry.getTxn();\n<line112>                    packet.digest = logEntry.getDigest();\n<line113>                    QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));\n<line114>                    boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line115>                    if (majorChange) {\n<line116>                        throw new Exception(\"changes proposed in reconfig\");\n<line117>                    }\n<line118>                } else {\n<line119>                    logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line120>                    packet.rec = logEntry.getTxn();\n<line121>                    packet.hdr = logEntry.getHeader();\n<line122>                    packet.digest = logEntry.getDigest();\n<line123>                    // Log warning message if txn comes out-of-order\n<line124>                    if (packet.hdr.getZxid() != lastQueued + 1) {\n<line125>                        LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(packet.hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line126>                    }\n<line127>                    lastQueued = packet.hdr.getZxid();\n<line128>                }\n<line129>                if (!writeToTxnLog) {\n<line130>                    // Apply to db directly if we haven't taken the snapshot\n<line131>                    zk.processTxn(packet.hdr, packet.rec);\n<line132>                } else {\n<line133>                    packetsNotCommitted.add(packet);\n<line134>                    packetsCommitted.add(qp.getZxid());\n<line135>                }\n<line136>                break;\n<line137>            case Leader.UPTODATE:\n<line138>                LOG.info(\"Learner received UPTODATE message\");\n<line139>                if (newLeaderQV != null) {\n<line140>                    boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);\n<line141>                    if (majorChange) {\n<line142>                        throw new Exception(\"changes proposed in reconfig\");\n<line143>                    }\n<line144>                }\n<line145>                if (isPreZAB1_0) {\n<line146>                    zk.takeSnapshot(syncSnapshot);\n<line147>                    self.setCurrentEpoch(newEpoch);\n<line148>                }\n<line149>                self.setZooKeeperServer(zk);\n<line150>                self.adminServer.setZooKeeperServer(zk);\n<line151>                break outerLoop;\n<line152>            case // Getting NEWLEADER here instead of in discovery\n<line153>            Leader.NEWLEADER:\n<line154>                // means this is Zab 1.0\n<line155>                LOG.info(\"Learner received NEWLEADER message\");\n<line156>                if (qp.getData() != null && qp.getData().length > 1) {\n<line157>                    try {\n<line158>                        QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));\n<line159>                        self.setLastSeenQuorumVerifier(qv, true);\n<line160>                        newLeaderQV = qv;\n<line161>                    } catch (Exception e) {\n<line162>                        e.printStackTrace();\n<line163>                    }\n<line164>                }\n<line165>                if (snapshotNeeded) {\n<line166>                    zk.takeSnapshot(syncSnapshot);\n<line167>                }\n<line168>                writeToTxnLog = true;\n<line169>                //Anything after this needs to go to the transaction log, not applied directly in memory\n<line170>                isPreZAB1_0 = false;\n<line171>                // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).\n<line172>                sock.setSoTimeout(self.tickTime * self.syncLimit);\n<line173>                self.setSyncMode(QuorumPeer.SyncMode.NONE);\n<line174>                zk.startupWithoutServing();\n<line175>                if (zk instanceof FollowerZooKeeperServer) {\n<line176>                    long startTime = Time.currentElapsedTime();\n<line177>                    FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line178>                    for (PacketInFlight p : packetsNotCommitted) {\n<line179>                        final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line180>                        requestsToAck.add(request);\n<line181>                    }\n<line182>                    // persist the txns to disk\n<line183>                    fzk.getZKDatabase().commit();\n<line184>                    LOG.info(\"{} txns have been persisted and it took {}ms\", packetsNotCommitted.size(), Time.currentElapsedTime() - startTime);\n<line185>                    packetsNotCommitted.clear();\n<line186>                }\n<line187>                // set the current epoch after all the tnxs are persisted\n<line188>                self.setCurrentEpoch(newEpoch);\n<line189>                LOG.info(\"Set the current epoch to {}\", newEpoch);\n<line190>                // send NEWLEADER ack after all the tnxs are persisted\n<line191>                writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n<line192>                LOG.info(\"Sent NEWLEADER ack to leader with zxid {}\", Long.toHexString(newLeaderZxid));\n<line193>                break;\n<line194>        }\n<line195>    }\n<line196>}"},{"input":"","instruction":"<line1>{\n<line2>    self.setSyncMode(QuorumPeer.SyncMode.DIFF);\n<line3>    if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {\n<line4>        snapshotNeeded = true;\n<line5>        syncSnapshot = true;\n<line6>    } else {\n<line7>        snapshotNeeded = false;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Getting a diff from the leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line3>    self.setSyncMode(QuorumPeer.SyncMode.DIFF);\n<line4>    if (zk.shouldForceWriteInitialSnapshotAfterLeaderElection()) {\n<line5>        LOG.info(\"Forcing a snapshot write as part of upgrading from an older Zookeeper. This should only happen while upgrading.\");\n<line6>        snapshotNeeded = true;\n<line7>        syncSnapshot = true;\n<line8>    } else {\n<line9>        snapshotNeeded = false;\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    snapshotNeeded = true;\n<line3>    syncSnapshot = true;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Forcing a snapshot write as part of upgrading from an older Zookeeper. This should only happen while upgrading.\");\n<line3>    snapshotNeeded = true;\n<line4>    syncSnapshot = true;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    self.setSyncMode(QuorumPeer.SyncMode.SNAP);\n<line3>    // The leader is going to dump the database\n<line4>    // db is clear as part of deserializeSnapshot()\n<line5>    zk.getZKDatabase().deserializeSnapshot(leaderIs);\n<line6>    // ZOOKEEPER-2819: overwrite config node content extracted\n<line7>    // from leader snapshot with local config, to avoid potential\n<line8>    // inconsistency of config node content during rolling restart.\n<line9>    if (!self.isReconfigEnabled()) {\n<line10>        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line11>    }\n<line12>    String signature = leaderIs.readString(\"signature\");\n<line13>    if (!signature.equals(\"BenWasHere\")) {\n<line14>        throw new IOException(\"Missing signature\");\n<line15>    }\n<line16>    zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line17>    // immediately persist the latest snapshot when there is txn log gap\n<line18>    syncSnapshot = true;\n<line19>}","output":"<line1>{\n<line2>    self.setSyncMode(QuorumPeer.SyncMode.SNAP);\n<line3>    LOG.info(\"Getting a snapshot from leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line4>    // The leader is going to dump the database\n<line5>    // db is clear as part of deserializeSnapshot()\n<line6>    zk.getZKDatabase().deserializeSnapshot(leaderIs);\n<line7>    // ZOOKEEPER-2819: overwrite config node content extracted\n<line8>    // from leader snapshot with local config, to avoid potential\n<line9>    // inconsistency of config node content during rolling restart.\n<line10>    if (!self.isReconfigEnabled()) {\n<line11>        LOG.debug(\"Reset config node content from local config after deserialization of snapshot.\");\n<line12>        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line13>    }\n<line14>    String signature = leaderIs.readString(\"signature\");\n<line15>    if (!signature.equals(\"BenWasHere\")) {\n<line16>        LOG.error(\"Missing signature. Got {}\", signature);\n<line17>        throw new IOException(\"Missing signature\");\n<line18>    }\n<line19>    zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line20>    // immediately persist the latest snapshot when there is txn log gap\n<line21>    syncSnapshot = true;\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Reset config node content from local config after deserialization of snapshot.\");\n<line3>    zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new IOException(\"Missing signature\");\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Missing signature. Got {}\", signature);\n<line3>    throw new IOException(\"Missing signature\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    //we need to truncate the log to the lastzxid of the leader\n<line3>    self.setSyncMode(QuorumPeer.SyncMode.TRUNC);\n<line4>    boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());\n<line5>    if (!truncated) {\n<line6>        // not able to truncate the log\n<line7>        ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line8>    }\n<line9>    zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line10>}","output":"<line1>{\n<line2>    //we need to truncate the log to the lastzxid of the leader\n<line3>    self.setSyncMode(QuorumPeer.SyncMode.TRUNC);\n<line4>    LOG.warn(\"Truncating log to get in sync with the leader 0x{}\", Long.toHexString(qp.getZxid()));\n<line5>    boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());\n<line6>    if (!truncated) {\n<line7>        // not able to truncate the log\n<line8>        LOG.error(\"Not able to truncate the log 0x{}\", Long.toHexString(qp.getZxid()));\n<line9>        ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line10>    }\n<line11>    zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // not able to truncate the log\n<line3>    ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line4>}","output":"<line1>{\n<line2>    // not able to truncate the log\n<line3>    LOG.error(\"Not able to truncate the log 0x{}\", Long.toHexString(qp.getZxid()));\n<line4>    ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Got unexpected packet from leader: {}, exiting ... \", LearnerHandler.packetToString(qp));\n<line3>    ServiceUtils.requestSystemExit(ExitCode.QUORUM_PACKET_ERROR.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    readPacket(qp);\n<line3>    switch(qp.getType()) {\n<line4>        case Leader.PROPOSAL:\n<line5>            PacketInFlight pif = new PacketInFlight();\n<line6>            logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line7>            pif.hdr = logEntry.getHeader();\n<line8>            pif.rec = logEntry.getTxn();\n<line9>            pif.digest = logEntry.getDigest();\n<line10>            if (pif.hdr.getZxid() != lastQueued + 1) {\n<line11>            }\n<line12>            lastQueued = pif.hdr.getZxid();\n<line13>            if (pif.hdr.getType() == OpCode.reconfig) {\n<line14>                SetDataTxn setDataTxn = (SetDataTxn) pif.rec;\n<line15>                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line16>                self.setLastSeenQuorumVerifier(qv, true);\n<line17>            }\n<line18>            packetsNotCommitted.add(pif);\n<line19>            break;\n<line20>        case Leader.COMMIT:\n<line21>        case Leader.COMMITANDACTIVATE:\n<line22>            pif = packetsNotCommitted.peekFirst();\n<line23>            if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {\n<line24>                QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));\n<line25>                boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);\n<line26>                if (majorChange) {\n<line27>                    throw new Exception(\"changes proposed in reconfig\");\n<line28>                }\n<line29>            }\n<line30>            if (!writeToTxnLog) {\n<line31>                if (pif.hdr.getZxid() != qp.getZxid()) {\n<line32>                } else {\n<line33>                    zk.processTxn(pif.hdr, pif.rec);\n<line34>                    packetsNotCommitted.remove();\n<line35>                }\n<line36>            } else {\n<line37>                packetsCommitted.add(qp.getZxid());\n<line38>            }\n<line39>            break;\n<line40>        case Leader.INFORM:\n<line41>        case Leader.INFORMANDACTIVATE:\n<line42>            PacketInFlight packet = new PacketInFlight();\n<line43>            if (qp.getType() == Leader.INFORMANDACTIVATE) {\n<line44>                ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line45>                long suggestedLeaderId = buffer.getLong();\n<line46>                byte[] remainingdata = new byte[buffer.remaining()];\n<line47>                buffer.get(remainingdata);\n<line48>                logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line49>                packet.hdr = logEntry.getHeader();\n<line50>                packet.rec = logEntry.getTxn();\n<line51>                packet.digest = logEntry.getDigest();\n<line52>                QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));\n<line53>                boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line54>                if (majorChange) {\n<line55>                    throw new Exception(\"changes proposed in reconfig\");\n<line56>                }\n<line57>            } else {\n<line58>                logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line59>                packet.rec = logEntry.getTxn();\n<line60>                packet.hdr = logEntry.getHeader();\n<line61>                packet.digest = logEntry.getDigest();\n<line62>                // Log warning message if txn comes out-of-order\n<line63>                if (packet.hdr.getZxid() != lastQueued + 1) {\n<line64>                }\n<line65>                lastQueued = packet.hdr.getZxid();\n<line66>            }\n<line67>            if (!writeToTxnLog) {\n<line68>                // Apply to db directly if we haven't taken the snapshot\n<line69>                zk.processTxn(packet.hdr, packet.rec);\n<line70>            } else {\n<line71>                packetsNotCommitted.add(packet);\n<line72>                packetsCommitted.add(qp.getZxid());\n<line73>            }\n<line74>            break;\n<line75>        case Leader.UPTODATE:\n<line76>            if (newLeaderQV != null) {\n<line77>                boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);\n<line78>                if (majorChange) {\n<line79>                    throw new Exception(\"changes proposed in reconfig\");\n<line80>                }\n<line81>            }\n<line82>            if (isPreZAB1_0) {\n<line83>                zk.takeSnapshot(syncSnapshot);\n<line84>                self.setCurrentEpoch(newEpoch);\n<line85>            }\n<line86>            self.setZooKeeperServer(zk);\n<line87>            self.adminServer.setZooKeeperServer(zk);\n<line88>            break outerLoop;\n<line89>        case // Getting NEWLEADER here instead of in discovery\n<line90>        Leader.NEWLEADER:\n<line91>            // means this is Zab 1.0\n<line92>            if (qp.getData() != null && qp.getData().length > 1) {\n<line93>                try {\n<line94>                    QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));\n<line95>                    self.setLastSeenQuorumVerifier(qv, true);\n<line96>                    newLeaderQV = qv;\n<line97>                } catch (Exception e) {\n<line98>                    e.printStackTrace();\n<line99>                }\n<line100>            }\n<line101>            if (snapshotNeeded) {\n<line102>                zk.takeSnapshot(syncSnapshot);\n<line103>            }\n<line104>            writeToTxnLog = true;\n<line105>            //Anything after this needs to go to the transaction log, not applied directly in memory\n<line106>            isPreZAB1_0 = false;\n<line107>            // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).\n<line108>            sock.setSoTimeout(self.tickTime * self.syncLimit);\n<line109>            self.setSyncMode(QuorumPeer.SyncMode.NONE);\n<line110>            zk.startupWithoutServing();\n<line111>            if (zk instanceof FollowerZooKeeperServer) {\n<line112>                long startTime = Time.currentElapsedTime();\n<line113>                FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line114>                for (PacketInFlight p : packetsNotCommitted) {\n<line115>                    final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line116>                    requestsToAck.add(request);\n<line117>                }\n<line118>                // persist the txns to disk\n<line119>                fzk.getZKDatabase().commit();\n<line120>                packetsNotCommitted.clear();\n<line121>            }\n<line122>            // set the current epoch after all the tnxs are persisted\n<line123>            self.setCurrentEpoch(newEpoch);\n<line124>            // send NEWLEADER ack after all the tnxs are persisted\n<line125>            writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n<line126>            break;\n<line127>    }\n<line128>}","output":"<line1>{\n<line2>    readPacket(qp);\n<line3>    switch(qp.getType()) {\n<line4>        case Leader.PROPOSAL:\n<line5>            PacketInFlight pif = new PacketInFlight();\n<line6>            logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line7>            pif.hdr = logEntry.getHeader();\n<line8>            pif.rec = logEntry.getTxn();\n<line9>            pif.digest = logEntry.getDigest();\n<line10>            if (pif.hdr.getZxid() != lastQueued + 1) {\n<line11>                LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(pif.hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line12>            }\n<line13>            lastQueued = pif.hdr.getZxid();\n<line14>            if (pif.hdr.getType() == OpCode.reconfig) {\n<line15>                SetDataTxn setDataTxn = (SetDataTxn) pif.rec;\n<line16>                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData(), UTF_8));\n<line17>                self.setLastSeenQuorumVerifier(qv, true);\n<line18>            }\n<line19>            packetsNotCommitted.add(pif);\n<line20>            break;\n<line21>        case Leader.COMMIT:\n<line22>        case Leader.COMMITANDACTIVATE:\n<line23>            pif = packetsNotCommitted.peekFirst();\n<line24>            if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {\n<line25>                QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData(), UTF_8));\n<line26>                boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);\n<line27>                if (majorChange) {\n<line28>                    throw new Exception(\"changes proposed in reconfig\");\n<line29>                }\n<line30>            }\n<line31>            if (!writeToTxnLog) {\n<line32>                if (pif.hdr.getZxid() != qp.getZxid()) {\n<line33>                    LOG.warn(\"Committing 0x{}, but next proposal is 0x{}\", Long.toHexString(qp.getZxid()), Long.toHexString(pif.hdr.getZxid()));\n<line34>                } else {\n<line35>                    zk.processTxn(pif.hdr, pif.rec);\n<line36>                    packetsNotCommitted.remove();\n<line37>                }\n<line38>            } else {\n<line39>                packetsCommitted.add(qp.getZxid());\n<line40>            }\n<line41>            break;\n<line42>        case Leader.INFORM:\n<line43>        case Leader.INFORMANDACTIVATE:\n<line44>            PacketInFlight packet = new PacketInFlight();\n<line45>            if (qp.getType() == Leader.INFORMANDACTIVATE) {\n<line46>                ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line47>                long suggestedLeaderId = buffer.getLong();\n<line48>                byte[] remainingdata = new byte[buffer.remaining()];\n<line49>                buffer.get(remainingdata);\n<line50>                logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line51>                packet.hdr = logEntry.getHeader();\n<line52>                packet.rec = logEntry.getTxn();\n<line53>                packet.digest = logEntry.getDigest();\n<line54>                QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData(), UTF_8));\n<line55>                boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line56>                if (majorChange) {\n<line57>                    throw new Exception(\"changes proposed in reconfig\");\n<line58>                }\n<line59>            } else {\n<line60>                logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line61>                packet.rec = logEntry.getTxn();\n<line62>                packet.hdr = logEntry.getHeader();\n<line63>                packet.digest = logEntry.getDigest();\n<line64>                // Log warning message if txn comes out-of-order\n<line65>                if (packet.hdr.getZxid() != lastQueued + 1) {\n<line66>                    LOG.warn(\"Got zxid 0x{} expected 0x{}\", Long.toHexString(packet.hdr.getZxid()), Long.toHexString(lastQueued + 1));\n<line67>                }\n<line68>                lastQueued = packet.hdr.getZxid();\n<line69>            }\n<line70>            if (!writeToTxnLog) {\n<line71>                // Apply to db directly if we haven't taken the snapshot\n<line72>                zk.processTxn(packet.hdr, packet.rec);\n<line73>            } else {\n<line74>                packetsNotCommitted.add(packet);\n<line75>                packetsCommitted.add(qp.getZxid());\n<line76>            }\n<line77>            break;\n<line78>        case Leader.UPTODATE:\n<line79>            LOG.info(\"Learner received UPTODATE message\");\n<line80>            if (newLeaderQV != null) {\n<line81>                boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);\n<line82>                if (majorChange) {\n<line83>                    throw new Exception(\"changes proposed in reconfig\");\n<line84>                }\n<line85>            }\n<line86>            if (isPreZAB1_0) {\n<line87>                zk.takeSnapshot(syncSnapshot);\n<line88>                self.setCurrentEpoch(newEpoch);\n<line89>            }\n<line90>            self.setZooKeeperServer(zk);\n<line91>            self.adminServer.setZooKeeperServer(zk);\n<line92>            break outerLoop;\n<line93>        case // Getting NEWLEADER here instead of in discovery\n<line94>        Leader.NEWLEADER:\n<line95>            // means this is Zab 1.0\n<line96>            LOG.info(\"Learner received NEWLEADER message\");\n<line97>            if (qp.getData() != null && qp.getData().length > 1) {\n<line98>                try {\n<line99>                    QuorumVerifier qv = self.configFromString(new String(qp.getData(), UTF_8));\n<line100>                    self.setLastSeenQuorumVerifier(qv, true);\n<line101>                    newLeaderQV = qv;\n<line102>                } catch (Exception e) {\n<line103>                    e.printStackTrace();\n<line104>                }\n<line105>            }\n<line106>            if (snapshotNeeded) {\n<line107>                zk.takeSnapshot(syncSnapshot);\n<line108>            }\n<line109>            writeToTxnLog = true;\n<line110>            //Anything after this needs to go to the transaction log, not applied directly in memory\n<line111>            isPreZAB1_0 = false;\n<line112>            // ZOOKEEPER-3911: make sure sync the uncommitted logs before commit them (ACK NEWLEADER).\n<line113>            sock.setSoTimeout(self.tickTime * self.syncLimit);\n<line114>            self.setSyncMode(QuorumPeer.SyncMode.NONE);\n<line115>            zk.startupWithoutServing();\n<line116>            if (zk instanceof FollowerZooKeeperServer) {\n<line117>                long startTime = Time.currentElapsedTime();\n<line118>                FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line119>                for (PacketInFlight p : packetsNotCommitted) {\n<line120>                    final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line121>                    requestsToAck.add(request);\n<line122>                }\n<line123>                // persist the txns to disk\n<line124>                fzk.getZKDatabase().commit();\n<line125>                LOG.info(\"{} txns have been persisted and it took {}ms\", packetsNotCommitted.size(), Time.currentElapsedTime() - startTime);\n<line126>                packetsNotCommitted.clear();\n<line127>            }\n<line128>            // set the current epoch after all the tnxs are persisted\n<line129>            self.setCurrentEpoch(newEpoch);\n<line130>            LOG.info(\"Set the current epoch to {}\", newEpoch);\n<line131>            // send NEWLEADER ack after all the tnxs are persisted\n<line132>            writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n<line133>            LOG.info(\"Sent NEWLEADER ack to leader with zxid {}\", Long.toHexString(newLeaderZxid));\n<line134>            break;\n<line135>    }\n<line136>}"},{"input":"","instruction":"<line1>{\n<line2>    long startTime = Time.currentElapsedTime();\n<line3>    FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line4>    for (PacketInFlight p : packetsNotCommitted) {\n<line5>        final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line6>        requestsToAck.add(request);\n<line7>    }\n<line8>    // persist the txns to disk\n<line9>    fzk.getZKDatabase().commit();\n<line10>    packetsNotCommitted.clear();\n<line11>}","output":"<line1>{\n<line2>    long startTime = Time.currentElapsedTime();\n<line3>    FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line4>    for (PacketInFlight p : packetsNotCommitted) {\n<line5>        final Request request = fzk.appendRequest(p.hdr, p.rec, p.digest);\n<line6>        requestsToAck.add(request);\n<line7>    }\n<line8>    // persist the txns to disk\n<line9>    fzk.getZKDatabase().commit();\n<line10>    LOG.info(\"{} txns have been persisted and it took {}ms\", packetsNotCommitted.size(), Time.currentElapsedTime() - startTime);\n<line11>    packetsNotCommitted.clear();\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // reply ACK of PROPOSAL after ACK of NEWLEADER to avoid leader shutdown due to timeout\n<line3>    // on waiting for a quorum of followers\n<line4>    for (final Request request : requestsToAck) {\n<line5>        final QuorumPacket ackPacket = new QuorumPacket(Leader.ACK, request.getHdr().getZxid(), null, null);\n<line6>        writePacket(ackPacket, false);\n<line7>    }\n<line8>    writePacket(null, true);\n<line9>    requestsToAck.clear();\n<line10>    FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line11>    for (PacketInFlight p : packetsNotCommitted) {\n<line12>        fzk.logRequest(p.hdr, p.rec, p.digest);\n<line13>    }\n<line14>    for (Long zxid : packetsCommitted) {\n<line15>        fzk.commit(zxid);\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    // reply ACK of PROPOSAL after ACK of NEWLEADER to avoid leader shutdown due to timeout\n<line3>    // on waiting for a quorum of followers\n<line4>    for (final Request request : requestsToAck) {\n<line5>        final QuorumPacket ackPacket = new QuorumPacket(Leader.ACK, request.getHdr().getZxid(), null, null);\n<line6>        writePacket(ackPacket, false);\n<line7>    }\n<line8>    writePacket(null, true);\n<line9>    requestsToAck.clear();\n<line10>    FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;\n<line11>    for (PacketInFlight p : packetsNotCommitted) {\n<line12>        fzk.logRequest(p.hdr, p.rec, p.digest);\n<line13>    }\n<line14>    LOG.info(\"{} txns have been logged asynchronously\", packetsNotCommitted.size());\n<line15>    for (Long zxid : packetsCommitted) {\n<line16>        fzk.commit(zxid);\n<line17>    }\n<line18>    LOG.info(\"{} txns have been committed\", packetsCommitted.size());\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"{} = {}\", LEADER_CLOSE_SOCKET_ASYNC, closeSocketAsync);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    super(\"LearnerHandler-\" + sock.getRemoteSocketAddress());\n<line3>    this.sock = sock;\n<line4>    this.learnerMaster = learnerMaster;\n<line5>    this.bufferedInput = bufferedInput;\n<line6>    if (Boolean.getBoolean(FORCE_SNAP_SYNC)) {\n<line7>        forceSnapSync = true;\n<line8>    }\n<line9>    try {\n<line10>        QuorumAuthServer authServer = learnerMaster.getQuorumAuthServer();\n<line11>        if (authServer != null) {\n<line12>            authServer.authenticate(sock, new DataInputStream(bufferedInput));\n<line13>        }\n<line14>    } catch (IOException e) {\n<line15>        closeSocket();\n<line16>        throw new SaslException(\"Authentication failure: \" + e.getMessage());\n<line17>    }\n<line18>    this.messageTracker = new MessageTracker(MessageTracker.BUFFERED_MESSAGE_SIZE);\n<line19>}","output":"<line1>{\n<line2>    super(\"LearnerHandler-\" + sock.getRemoteSocketAddress());\n<line3>    this.sock = sock;\n<line4>    this.learnerMaster = learnerMaster;\n<line5>    this.bufferedInput = bufferedInput;\n<line6>    if (Boolean.getBoolean(FORCE_SNAP_SYNC)) {\n<line7>        forceSnapSync = true;\n<line8>        LOG.info(\"Forcing snapshot sync is enabled\");\n<line9>    }\n<line10>    try {\n<line11>        QuorumAuthServer authServer = learnerMaster.getQuorumAuthServer();\n<line12>        if (authServer != null) {\n<line13>            authServer.authenticate(sock, new DataInputStream(bufferedInput));\n<line14>        }\n<line15>    } catch (IOException e) {\n<line16>        LOG.error(\"Server failed to authenticate quorum learner, addr: {}, closing connection\", sock.getRemoteSocketAddress(), e);\n<line17>        closeSocket();\n<line18>        throw new SaslException(\"Authentication failure: \" + e.getMessage());\n<line19>    }\n<line20>    this.messageTracker = new MessageTracker(MessageTracker.BUFFERED_MESSAGE_SIZE);\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    forceSnapSync = true;\n<line3>}","output":"<line1>{\n<line2>    forceSnapSync = true;\n<line3>    LOG.info(\"Forcing snapshot sync is enabled\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket();\n<line3>    throw new SaslException(\"Authentication failure: \" + e.getMessage());\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Server failed to authenticate quorum learner, addr: {}, closing connection\", sock.getRemoteSocketAddress(), e);\n<line3>    closeSocket();\n<line4>    throw new SaslException(\"Authentication failure: \" + e.getMessage());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    while (true) {\n<line3>        try {\n<line4>            QuorumPacket p;\n<line5>            p = queuedPackets.poll();\n<line6>            if (p == null) {\n<line7>                bufferedOutput.flush();\n<line8>                p = queuedPackets.take();\n<line9>            }\n<line10>            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());\n<line11>            if (p instanceof MarkerQuorumPacket) {\n<line12>                MarkerQuorumPacket m = (MarkerQuorumPacket) p;\n<line13>                ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);\n<line14>                continue;\n<line15>            }\n<line16>            queuedPacketsSize.addAndGet(-packetSize(p));\n<line17>            if (p == proposalOfDeath) {\n<line18>                // Packet of death!\n<line19>                break;\n<line20>            }\n<line21>            if (p.getType() == Leader.PROPOSAL) {\n<line22>                syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());\n<line23>            }\n<line24>                long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line25>                if (p.getType() == Leader.PING) {\n<line26>                    traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line27>                }\n<line28>                ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);\n<line29>            }\n<line30>            // Log the zxid of the last request, if it is a valid zxid.\n<line31>            if (p.getZxid() > 0) {\n<line32>                lastZxid = p.getZxid();\n<line33>            }\n<line34>            oa.writeRecord(p, \"packet\");\n<line35>            packetsSent.incrementAndGet();\n<line36>            messageTracker.trackSent(p.getType());\n<line37>        } catch (IOException e) {\n<line38>            // this will cause everything to shutdown on\n<line39>            // this learner handler and will help notify\n<line40>            // the learner/observer instantaneously\n<line41>            closeSocket();\n<line42>            break;\n<line43>        }\n<line44>    }\n<line45>}","output":"<line1>{\n<line2>    while (true) {\n<line3>        try {\n<line4>            QuorumPacket p;\n<line5>            p = queuedPackets.poll();\n<line6>            if (p == null) {\n<line7>                bufferedOutput.flush();\n<line8>                p = queuedPackets.take();\n<line9>            }\n<line10>            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());\n<line11>            if (p instanceof MarkerQuorumPacket) {\n<line12>                MarkerQuorumPacket m = (MarkerQuorumPacket) p;\n<line13>                ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);\n<line14>                continue;\n<line15>            }\n<line16>            queuedPacketsSize.addAndGet(-packetSize(p));\n<line17>            if (p == proposalOfDeath) {\n<line18>                // Packet of death!\n<line19>                break;\n<line20>            }\n<line21>            if (p.getType() == Leader.PROPOSAL) {\n<line22>                syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());\n<line23>            }\n<line24>            if (LOG.isTraceEnabled()) {\n<line25>                long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line26>                if (p.getType() == Leader.PING) {\n<line27>                    traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line28>                }\n<line29>                ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);\n<line30>            }\n<line31>            // Log the zxid of the last request, if it is a valid zxid.\n<line32>            if (p.getZxid() > 0) {\n<line33>                lastZxid = p.getZxid();\n<line34>            }\n<line35>            oa.writeRecord(p, \"packet\");\n<line36>            packetsSent.incrementAndGet();\n<line37>            messageTracker.trackSent(p.getType());\n<line38>        } catch (IOException e) {\n<line39>            LOG.error(\"Exception while sending packets in LearnerHandler\", e);\n<line40>            // this will cause everything to shutdown on\n<line41>            // this learner handler and will help notify\n<line42>            // the learner/observer instantaneously\n<line43>            closeSocket();\n<line44>            break;\n<line45>        }\n<line46>    }\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        QuorumPacket p;\n<line4>        p = queuedPackets.poll();\n<line5>        if (p == null) {\n<line6>            bufferedOutput.flush();\n<line7>            p = queuedPackets.take();\n<line8>        }\n<line9>        ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());\n<line10>        if (p instanceof MarkerQuorumPacket) {\n<line11>            MarkerQuorumPacket m = (MarkerQuorumPacket) p;\n<line12>            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);\n<line13>            continue;\n<line14>        }\n<line15>        queuedPacketsSize.addAndGet(-packetSize(p));\n<line16>        if (p == proposalOfDeath) {\n<line17>            // Packet of death!\n<line18>            break;\n<line19>        }\n<line20>        if (p.getType() == Leader.PROPOSAL) {\n<line21>            syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());\n<line22>        }\n<line23>            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line24>            if (p.getType() == Leader.PING) {\n<line25>                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line26>            }\n<line27>            ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);\n<line28>        }\n<line29>        // Log the zxid of the last request, if it is a valid zxid.\n<line30>        if (p.getZxid() > 0) {\n<line31>            lastZxid = p.getZxid();\n<line32>        }\n<line33>        oa.writeRecord(p, \"packet\");\n<line34>        packetsSent.incrementAndGet();\n<line35>        messageTracker.trackSent(p.getType());\n<line36>    } catch (IOException e) {\n<line37>        // this will cause everything to shutdown on\n<line38>        // this learner handler and will help notify\n<line39>        // the learner/observer instantaneously\n<line40>        closeSocket();\n<line41>        break;\n<line42>    }\n<line43>}","output":"<line1>{\n<line2>    try {\n<line3>        QuorumPacket p;\n<line4>        p = queuedPackets.poll();\n<line5>        if (p == null) {\n<line6>            bufferedOutput.flush();\n<line7>            p = queuedPackets.take();\n<line8>        }\n<line9>        ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());\n<line10>        if (p instanceof MarkerQuorumPacket) {\n<line11>            MarkerQuorumPacket m = (MarkerQuorumPacket) p;\n<line12>            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);\n<line13>            continue;\n<line14>        }\n<line15>        queuedPacketsSize.addAndGet(-packetSize(p));\n<line16>        if (p == proposalOfDeath) {\n<line17>            // Packet of death!\n<line18>            break;\n<line19>        }\n<line20>        if (p.getType() == Leader.PROPOSAL) {\n<line21>            syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());\n<line22>        }\n<line23>        if (LOG.isTraceEnabled()) {\n<line24>            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line25>            if (p.getType() == Leader.PING) {\n<line26>                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line27>            }\n<line28>            ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);\n<line29>        }\n<line30>        // Log the zxid of the last request, if it is a valid zxid.\n<line31>        if (p.getZxid() > 0) {\n<line32>            lastZxid = p.getZxid();\n<line33>        }\n<line34>        oa.writeRecord(p, \"packet\");\n<line35>        packetsSent.incrementAndGet();\n<line36>        messageTracker.trackSent(p.getType());\n<line37>    } catch (IOException e) {\n<line38>        LOG.error(\"Exception while sending packets in LearnerHandler\", e);\n<line39>        // this will cause everything to shutdown on\n<line40>        // this learner handler and will help notify\n<line41>        // the learner/observer instantaneously\n<line42>        closeSocket();\n<line43>        break;\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    // this will cause everything to shutdown on\n<line3>    // this learner handler and will help notify\n<line4>    // the learner/observer instantaneously\n<line5>    closeSocket();\n<line6>    break;\n<line7>}","output":"<line1>{\n<line2>    LOG.error(\"Exception while sending packets in LearnerHandler\", e);\n<line3>    // this will cause everything to shutdown on\n<line4>    // this learner handler and will help notify\n<line5>    // the learner/observer instantaneously\n<line6>    closeSocket();\n<line7>    break;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        learnerMaster.addLearnerHandler(this);\n<line4>        tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();\n<line5>        ia = BinaryInputArchive.getArchive(bufferedInput);\n<line6>        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n<line7>        oa = BinaryOutputArchive.getArchive(bufferedOutput);\n<line8>        QuorumPacket qp = new QuorumPacket();\n<line9>        ia.readRecord(qp, \"packet\");\n<line10>        messageTracker.trackReceived(qp.getType());\n<line11>        if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {\n<line12>            return;\n<line13>        }\n<line14>        if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {\n<line15>            throw new IOException(\"Non observer attempting to connect to ObserverMaster. type = \" + qp.getType());\n<line16>        }\n<line17>        byte[] learnerInfoData = qp.getData();\n<line18>        if (learnerInfoData != null) {\n<line19>            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);\n<line20>            if (learnerInfoData.length >= 8) {\n<line21>                this.sid = bbsid.getLong();\n<line22>            }\n<line23>            if (learnerInfoData.length >= 12) {\n<line24>                // protocolVersion\n<line25>                this.version = bbsid.getInt();\n<line26>            }\n<line27>            if (learnerInfoData.length >= 20) {\n<line28>                long configVersion = bbsid.getLong();\n<line29>                if (configVersion > learnerMaster.getQuorumVerifierVersion()) {\n<line30>                    throw new IOException(\"Follower is ahead of the leader (has a later activated configuration)\");\n<line31>                }\n<line32>            }\n<line33>        } else {\n<line34>            this.sid = learnerMaster.getAndDecrementFollowerCounter();\n<line35>        }\n<line36>        String followerInfo = learnerMaster.getPeerInfo(this.sid);\n<line37>        if (followerInfo.isEmpty()) {\n<line38>        } else {\n<line39>        }\n<line40>        if (qp.getType() == Leader.OBSERVERINFO) {\n<line41>            learnerType = LearnerType.OBSERVER;\n<line42>        }\n<line43>        learnerMaster.registerLearnerHandlerBean(this, sock);\n<line44>        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n<line45>        long peerLastZxid;\n<line46>        StateSummary ss = null;\n<line47>        long zxid = qp.getZxid();\n<line48>        long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);\n<line49>        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);\n<line50>        if (this.getVersion() < 0x10000) {\n<line51>            // we are going to have to extrapolate the epoch information\n<line52>            long epoch = ZxidUtils.getEpochFromZxid(zxid);\n<line53>            ss = new StateSummary(epoch, zxid);\n<line54>            // fake the message\n<line55>            learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line56>        } else {\n<line57>            byte[] ver = new byte[4];\n<line58>            ByteBuffer.wrap(ver).putInt(0x10000);\n<line59>            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);\n<line60>            oa.writeRecord(newEpochPacket, \"packet\");\n<line61>            messageTracker.trackSent(Leader.LEADERINFO);\n<line62>            bufferedOutput.flush();\n<line63>            QuorumPacket ackEpochPacket = new QuorumPacket();\n<line64>            ia.readRecord(ackEpochPacket, \"packet\");\n<line65>            messageTracker.trackReceived(ackEpochPacket.getType());\n<line66>            if (ackEpochPacket.getType() != Leader.ACKEPOCH) {\n<line67>                return;\n<line68>            }\n<line69>            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());\n<line70>            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());\n<line71>            learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line72>        }\n<line73>        peerLastZxid = ss.getLastZxid();\n<line74>        // Take any necessary action if we need to send TRUNC or DIFF\n<line75>        // startForwarding() will be called in all cases\n<line76>        boolean needSnap = syncFollower(peerLastZxid, learnerMaster);\n<line77>        // syncs between followers and the leader are exempt from throttling because it\n<line78>        // is important to keep the state of quorum servers up-to-date. The exempted syncs\n<line79>        // are counted as concurrent syncs though\n<line80>        boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;\n<line81>        /* if we are not truncating or sending a diff just send a snapshot */\n<line82>        if (needSnap) {\n<line83>            syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();\n<line84>            syncThrottler.beginSync(exemptFromThrottle);\n<line85>            ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line86>            try {\n<line87>                long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line88>                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line89>                messageTracker.trackSent(Leader.SNAP);\n<line90>                bufferedOutput.flush();\n<line91>                // Dump data to peer\n<line92>                learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line93>                oa.writeString(\"BenWasHere\", \"signature\");\n<line94>                bufferedOutput.flush();\n<line95>            } finally {\n<line96>                ServerMetrics.getMetrics().SNAP_COUNT.add(1);\n<line97>            }\n<line98>        } else {\n<line99>            syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();\n<line100>            syncThrottler.beginSync(exemptFromThrottle);\n<line101>            ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line102>            ServerMetrics.getMetrics().DIFF_COUNT.add(1);\n<line103>        }\n<line104>        // the version of this quorumVerifier will be set by leader.lead() in case\n<line105>        // the leader is just being established. waitForEpochAck makes sure that readyToStart is true if\n<line106>        // we got here, so the version was set\n<line107>        if (getVersion() < 0x10000) {\n<line108>            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);\n<line109>            oa.writeRecord(newLeaderQP, \"packet\");\n<line110>        } else {\n<line111>            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);\n<line112>            queuedPackets.add(newLeaderQP);\n<line113>        }\n<line114>        bufferedOutput.flush();\n<line115>        // Start thread that blast packets in the queue to learner\n<line116>        startSendingPackets();\n<line117>        /*\n<line118>             * Have to wait for the first ACK, wait until\n<line119>             * the learnerMaster is ready, and only then we can\n<line120>             * start processing messages.\n<line121>             */\n<line122>        qp = new QuorumPacket();\n<line123>        ia.readRecord(qp, \"packet\");\n<line124>        messageTracker.trackReceived(qp.getType());\n<line125>        if (qp.getType() != Leader.ACK) {\n<line126>            return;\n<line127>        }\n<line128>        learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());\n<line129>        syncLimitCheck.start();\n<line130>        // sync ends when NEWLEADER-ACK is received\n<line131>        syncThrottler.endSync();\n<line132>        if (needSnap) {\n<line133>            ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line134>        } else {\n<line135>            ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line136>        }\n<line137>        syncThrottler = null;\n<line138>        // now that the ack has been processed expect the syncLimit\n<line139>        sock.setSoTimeout(learnerMaster.syncTimeout());\n<line140>        /*\n<line141>             * Wait until learnerMaster starts up\n<line142>             */\n<line143>        learnerMaster.waitForStartup();\n<line144>        // Mutation packets will be queued during the serialize,\n<line145>        // so we need to mark when the peer can actually start\n<line146>        // using the data\n<line147>        //\n<line148>        queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));\n<line149>        while (true) {\n<line150>            qp = new QuorumPacket();\n<line151>            ia.readRecord(qp, \"packet\");\n<line152>            messageTracker.trackReceived(qp.getType());\n<line153>                long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line154>                if (qp.getType() == Leader.PING) {\n<line155>                    traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line156>                }\n<line157>                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);\n<line158>            }\n<line159>            tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();\n<line160>            packetsReceived.incrementAndGet();\n<line161>            ByteBuffer bb;\n<line162>            long sessionId;\n<line163>            int cxid;\n<line164>            int type;\n<line165>            switch(qp.getType()) {\n<line166>                case Leader.ACK:\n<line167>                    if (this.learnerType == LearnerType.OBSERVER) {\n<line168>                    }\n<line169>                    syncLimitCheck.updateAck(qp.getZxid());\n<line170>                    learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());\n<line171>                    break;\n<line172>                case Leader.PING:\n<line173>                    // Process the touches\n<line174>                    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line175>                    DataInputStream dis = new DataInputStream(bis);\n<line176>                    while (dis.available() > 0) {\n<line177>                        long sess = dis.readLong();\n<line178>                        int to = dis.readInt();\n<line179>                        learnerMaster.touch(sess, to);\n<line180>                    }\n<line181>                    break;\n<line182>                case Leader.REVALIDATE:\n<line183>                    ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);\n<line184>                    learnerMaster.revalidateSession(qp, this);\n<line185>                    break;\n<line186>                case Leader.REQUEST:\n<line187>                    bb = ByteBuffer.wrap(qp.getData());\n<line188>                    sessionId = bb.getLong();\n<line189>                    cxid = bb.getInt();\n<line190>                    type = bb.getInt();\n<line191>                    bb = bb.slice();\n<line192>                    Request si;\n<line193>                    if (type == OpCode.sync) {\n<line194>                        si = new LearnerSyncRequest(this, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line195>                    } else {\n<line196>                        si = new Request(null, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line197>                    }\n<line198>                    si.setOwner(this);\n<line199>                    learnerMaster.submitLearnerRequest(si);\n<line200>                    requestsReceived.incrementAndGet();\n<line201>                    break;\n<line202>                default:\n<line203>                    break;\n<line204>            }\n<line205>        }\n<line206>    } catch (IOException e) {\n<line207>        closeSocket();\n<line208>    } catch (InterruptedException e) {\n<line209>    } catch (SyncThrottleException e) {\n<line210>        syncThrottler = null;\n<line211>    } catch (Exception e) {\n<line212>        throw e;\n<line213>    } finally {\n<line214>        if (syncThrottler != null) {\n<line215>            syncThrottler.endSync();\n<line216>            syncThrottler = null;\n<line217>        }\n<line218>        String remoteAddr = getRemoteAddress();\n<line219>        messageTracker.dumpToLog(remoteAddr);\n<line220>        shutdown();\n<line221>    }\n<line222>}","output":"<line1>{\n<line2>    try {\n<line3>        learnerMaster.addLearnerHandler(this);\n<line4>        tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();\n<line5>        ia = BinaryInputArchive.getArchive(bufferedInput);\n<line6>        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n<line7>        oa = BinaryOutputArchive.getArchive(bufferedOutput);\n<line8>        QuorumPacket qp = new QuorumPacket();\n<line9>        ia.readRecord(qp, \"packet\");\n<line10>        messageTracker.trackReceived(qp.getType());\n<line11>        if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {\n<line12>            LOG.error(\"First packet {} is not FOLLOWERINFO or OBSERVERINFO!\", qp.toString());\n<line13>            return;\n<line14>        }\n<line15>        if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {\n<line16>            throw new IOException(\"Non observer attempting to connect to ObserverMaster. type = \" + qp.getType());\n<line17>        }\n<line18>        byte[] learnerInfoData = qp.getData();\n<line19>        if (learnerInfoData != null) {\n<line20>            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);\n<line21>            if (learnerInfoData.length >= 8) {\n<line22>                this.sid = bbsid.getLong();\n<line23>            }\n<line24>            if (learnerInfoData.length >= 12) {\n<line25>                // protocolVersion\n<line26>                this.version = bbsid.getInt();\n<line27>            }\n<line28>            if (learnerInfoData.length >= 20) {\n<line29>                long configVersion = bbsid.getLong();\n<line30>                if (configVersion > learnerMaster.getQuorumVerifierVersion()) {\n<line31>                    throw new IOException(\"Follower is ahead of the leader (has a later activated configuration)\");\n<line32>                }\n<line33>            }\n<line34>        } else {\n<line35>            this.sid = learnerMaster.getAndDecrementFollowerCounter();\n<line36>        }\n<line37>        String followerInfo = learnerMaster.getPeerInfo(this.sid);\n<line38>        if (followerInfo.isEmpty()) {\n<line39>            LOG.info(\"Follower sid: {} not in the current config {}\", this.sid, Long.toHexString(learnerMaster.getQuorumVerifierVersion()));\n<line40>        } else {\n<line41>            LOG.info(\"Follower sid: {} : info : {}\", this.sid, followerInfo);\n<line42>        }\n<line43>        if (qp.getType() == Leader.OBSERVERINFO) {\n<line44>            learnerType = LearnerType.OBSERVER;\n<line45>        }\n<line46>        learnerMaster.registerLearnerHandlerBean(this, sock);\n<line47>        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n<line48>        long peerLastZxid;\n<line49>        StateSummary ss = null;\n<line50>        long zxid = qp.getZxid();\n<line51>        long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);\n<line52>        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);\n<line53>        if (this.getVersion() < 0x10000) {\n<line54>            // we are going to have to extrapolate the epoch information\n<line55>            long epoch = ZxidUtils.getEpochFromZxid(zxid);\n<line56>            ss = new StateSummary(epoch, zxid);\n<line57>            // fake the message\n<line58>            learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line59>        } else {\n<line60>            byte[] ver = new byte[4];\n<line61>            ByteBuffer.wrap(ver).putInt(0x10000);\n<line62>            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);\n<line63>            oa.writeRecord(newEpochPacket, \"packet\");\n<line64>            messageTracker.trackSent(Leader.LEADERINFO);\n<line65>            bufferedOutput.flush();\n<line66>            QuorumPacket ackEpochPacket = new QuorumPacket();\n<line67>            ia.readRecord(ackEpochPacket, \"packet\");\n<line68>            messageTracker.trackReceived(ackEpochPacket.getType());\n<line69>            if (ackEpochPacket.getType() != Leader.ACKEPOCH) {\n<line70>                LOG.error(\"{} is not ACKEPOCH\", ackEpochPacket.toString());\n<line71>                return;\n<line72>            }\n<line73>            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());\n<line74>            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());\n<line75>            learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line76>        }\n<line77>        peerLastZxid = ss.getLastZxid();\n<line78>        // Take any necessary action if we need to send TRUNC or DIFF\n<line79>        // startForwarding() will be called in all cases\n<line80>        boolean needSnap = syncFollower(peerLastZxid, learnerMaster);\n<line81>        // syncs between followers and the leader are exempt from throttling because it\n<line82>        // is important to keep the state of quorum servers up-to-date. The exempted syncs\n<line83>        // are counted as concurrent syncs though\n<line84>        boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;\n<line85>        /* if we are not truncating or sending a diff just send a snapshot */\n<line86>        if (needSnap) {\n<line87>            syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();\n<line88>            syncThrottler.beginSync(exemptFromThrottle);\n<line89>            ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line90>            try {\n<line91>                long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line92>                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line93>                messageTracker.trackSent(Leader.SNAP);\n<line94>                bufferedOutput.flush();\n<line95>                LOG.info(\"Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, \" + \"send zxid of db as 0x{}, {} concurrent snapshot sync, \" + \"snapshot sync was {} from throttle\", Long.toHexString(peerLastZxid), Long.toHexString(leaderLastZxid), Long.toHexString(zxidToSend), syncThrottler.getSyncInProgress(), exemptFromThrottle ? \"exempt\" : \"not exempt\");\n<line96>                // Dump data to peer\n<line97>                learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line98>                oa.writeString(\"BenWasHere\", \"signature\");\n<line99>                bufferedOutput.flush();\n<line100>            } finally {\n<line101>                ServerMetrics.getMetrics().SNAP_COUNT.add(1);\n<line102>            }\n<line103>        } else {\n<line104>            syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();\n<line105>            syncThrottler.beginSync(exemptFromThrottle);\n<line106>            ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line107>            ServerMetrics.getMetrics().DIFF_COUNT.add(1);\n<line108>        }\n<line109>        LOG.debug(\"Sending NEWLEADER message to {}\", sid);\n<line110>        // the version of this quorumVerifier will be set by leader.lead() in case\n<line111>        // the leader is just being established. waitForEpochAck makes sure that readyToStart is true if\n<line112>        // we got here, so the version was set\n<line113>        if (getVersion() < 0x10000) {\n<line114>            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);\n<line115>            oa.writeRecord(newLeaderQP, \"packet\");\n<line116>        } else {\n<line117>            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);\n<line118>            queuedPackets.add(newLeaderQP);\n<line119>        }\n<line120>        bufferedOutput.flush();\n<line121>        // Start thread that blast packets in the queue to learner\n<line122>        startSendingPackets();\n<line123>        /*\n<line124>             * Have to wait for the first ACK, wait until\n<line125>             * the learnerMaster is ready, and only then we can\n<line126>             * start processing messages.\n<line127>             */\n<line128>        qp = new QuorumPacket();\n<line129>        ia.readRecord(qp, \"packet\");\n<line130>        messageTracker.trackReceived(qp.getType());\n<line131>        if (qp.getType() != Leader.ACK) {\n<line132>            LOG.error(\"Next packet was supposed to be an ACK, but received packet: {}\", packetToString(qp));\n<line133>            return;\n<line134>        }\n<line135>        LOG.debug(\"Received NEWLEADER-ACK message from {}\", sid);\n<line136>        learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());\n<line137>        syncLimitCheck.start();\n<line138>        // sync ends when NEWLEADER-ACK is received\n<line139>        syncThrottler.endSync();\n<line140>        if (needSnap) {\n<line141>            ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line142>        } else {\n<line143>            ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line144>        }\n<line145>        syncThrottler = null;\n<line146>        // now that the ack has been processed expect the syncLimit\n<line147>        sock.setSoTimeout(learnerMaster.syncTimeout());\n<line148>        /*\n<line149>             * Wait until learnerMaster starts up\n<line150>             */\n<line151>        learnerMaster.waitForStartup();\n<line152>        // Mutation packets will be queued during the serialize,\n<line153>        // so we need to mark when the peer can actually start\n<line154>        // using the data\n<line155>        //\n<line156>        LOG.debug(\"Sending UPTODATE message to {}\", sid);\n<line157>        queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));\n<line158>        while (true) {\n<line159>            qp = new QuorumPacket();\n<line160>            ia.readRecord(qp, \"packet\");\n<line161>            messageTracker.trackReceived(qp.getType());\n<line162>            if (LOG.isTraceEnabled()) {\n<line163>                long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line164>                if (qp.getType() == Leader.PING) {\n<line165>                    traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line166>                }\n<line167>                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);\n<line168>            }\n<line169>            tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();\n<line170>            packetsReceived.incrementAndGet();\n<line171>            ByteBuffer bb;\n<line172>            long sessionId;\n<line173>            int cxid;\n<line174>            int type;\n<line175>            switch(qp.getType()) {\n<line176>                case Leader.ACK:\n<line177>                    if (this.learnerType == LearnerType.OBSERVER) {\n<line178>                        LOG.debug(\"Received ACK from Observer {}\", this.sid);\n<line179>                    }\n<line180>                    syncLimitCheck.updateAck(qp.getZxid());\n<line181>                    learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());\n<line182>                    break;\n<line183>                case Leader.PING:\n<line184>                    // Process the touches\n<line185>                    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line186>                    DataInputStream dis = new DataInputStream(bis);\n<line187>                    while (dis.available() > 0) {\n<line188>                        long sess = dis.readLong();\n<line189>                        int to = dis.readInt();\n<line190>                        learnerMaster.touch(sess, to);\n<line191>                    }\n<line192>                    break;\n<line193>                case Leader.REVALIDATE:\n<line194>                    ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);\n<line195>                    learnerMaster.revalidateSession(qp, this);\n<line196>                    break;\n<line197>                case Leader.REQUEST:\n<line198>                    bb = ByteBuffer.wrap(qp.getData());\n<line199>                    sessionId = bb.getLong();\n<line200>                    cxid = bb.getInt();\n<line201>                    type = bb.getInt();\n<line202>                    bb = bb.slice();\n<line203>                    Request si;\n<line204>                    if (type == OpCode.sync) {\n<line205>                        si = new LearnerSyncRequest(this, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line206>                    } else {\n<line207>                        si = new Request(null, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line208>                    }\n<line209>                    si.setOwner(this);\n<line210>                    learnerMaster.submitLearnerRequest(si);\n<line211>                    requestsReceived.incrementAndGet();\n<line212>                    break;\n<line213>                default:\n<line214>                    LOG.warn(\"unexpected quorum packet, type: {}\", packetToString(qp));\n<line215>                    break;\n<line216>            }\n<line217>        }\n<line218>    } catch (IOException e) {\n<line219>        LOG.error(\"Unexpected exception in LearnerHandler: \", e);\n<line220>        closeSocket();\n<line221>    } catch (InterruptedException e) {\n<line222>        LOG.error(\"Unexpected exception in LearnerHandler.\", e);\n<line223>    } catch (SyncThrottleException e) {\n<line224>        LOG.error(\"too many concurrent sync.\", e);\n<line225>        syncThrottler = null;\n<line226>    } catch (Exception e) {\n<line227>        LOG.error(\"Unexpected exception in LearnerHandler.\", e);\n<line228>        throw e;\n<line229>    } finally {\n<line230>        if (syncThrottler != null) {\n<line231>            syncThrottler.endSync();\n<line232>            syncThrottler = null;\n<line233>        }\n<line234>        String remoteAddr = getRemoteAddress();\n<line235>        LOG.warn(\"******* GOODBYE {} ********\", remoteAddr);\n<line236>        messageTracker.dumpToLog(remoteAddr);\n<line237>        shutdown();\n<line238>    }\n<line239>}"},{"input":"","instruction":"<line1>{\n<line2>    learnerMaster.addLearnerHandler(this);\n<line3>    tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();\n<line4>    ia = BinaryInputArchive.getArchive(bufferedInput);\n<line5>    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n<line6>    oa = BinaryOutputArchive.getArchive(bufferedOutput);\n<line7>    QuorumPacket qp = new QuorumPacket();\n<line8>    ia.readRecord(qp, \"packet\");\n<line9>    messageTracker.trackReceived(qp.getType());\n<line10>    if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {\n<line11>        return;\n<line12>    }\n<line13>    if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {\n<line14>        throw new IOException(\"Non observer attempting to connect to ObserverMaster. type = \" + qp.getType());\n<line15>    }\n<line16>    byte[] learnerInfoData = qp.getData();\n<line17>    if (learnerInfoData != null) {\n<line18>        ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);\n<line19>        if (learnerInfoData.length >= 8) {\n<line20>            this.sid = bbsid.getLong();\n<line21>        }\n<line22>        if (learnerInfoData.length >= 12) {\n<line23>            // protocolVersion\n<line24>            this.version = bbsid.getInt();\n<line25>        }\n<line26>        if (learnerInfoData.length >= 20) {\n<line27>            long configVersion = bbsid.getLong();\n<line28>            if (configVersion > learnerMaster.getQuorumVerifierVersion()) {\n<line29>                throw new IOException(\"Follower is ahead of the leader (has a later activated configuration)\");\n<line30>            }\n<line31>        }\n<line32>    } else {\n<line33>        this.sid = learnerMaster.getAndDecrementFollowerCounter();\n<line34>    }\n<line35>    String followerInfo = learnerMaster.getPeerInfo(this.sid);\n<line36>    if (followerInfo.isEmpty()) {\n<line37>    } else {\n<line38>    }\n<line39>    if (qp.getType() == Leader.OBSERVERINFO) {\n<line40>        learnerType = LearnerType.OBSERVER;\n<line41>    }\n<line42>    learnerMaster.registerLearnerHandlerBean(this, sock);\n<line43>    long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n<line44>    long peerLastZxid;\n<line45>    StateSummary ss = null;\n<line46>    long zxid = qp.getZxid();\n<line47>    long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);\n<line48>    long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);\n<line49>    if (this.getVersion() < 0x10000) {\n<line50>        // we are going to have to extrapolate the epoch information\n<line51>        long epoch = ZxidUtils.getEpochFromZxid(zxid);\n<line52>        ss = new StateSummary(epoch, zxid);\n<line53>        // fake the message\n<line54>        learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line55>    } else {\n<line56>        byte[] ver = new byte[4];\n<line57>        ByteBuffer.wrap(ver).putInt(0x10000);\n<line58>        QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);\n<line59>        oa.writeRecord(newEpochPacket, \"packet\");\n<line60>        messageTracker.trackSent(Leader.LEADERINFO);\n<line61>        bufferedOutput.flush();\n<line62>        QuorumPacket ackEpochPacket = new QuorumPacket();\n<line63>        ia.readRecord(ackEpochPacket, \"packet\");\n<line64>        messageTracker.trackReceived(ackEpochPacket.getType());\n<line65>        if (ackEpochPacket.getType() != Leader.ACKEPOCH) {\n<line66>            return;\n<line67>        }\n<line68>        ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());\n<line69>        ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());\n<line70>        learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line71>    }\n<line72>    peerLastZxid = ss.getLastZxid();\n<line73>    // Take any necessary action if we need to send TRUNC or DIFF\n<line74>    // startForwarding() will be called in all cases\n<line75>    boolean needSnap = syncFollower(peerLastZxid, learnerMaster);\n<line76>    // syncs between followers and the leader are exempt from throttling because it\n<line77>    // is important to keep the state of quorum servers up-to-date. The exempted syncs\n<line78>    // are counted as concurrent syncs though\n<line79>    boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;\n<line80>    /* if we are not truncating or sending a diff just send a snapshot */\n<line81>    if (needSnap) {\n<line82>        syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();\n<line83>        syncThrottler.beginSync(exemptFromThrottle);\n<line84>        ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line85>        try {\n<line86>            long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line87>            oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line88>            messageTracker.trackSent(Leader.SNAP);\n<line89>            bufferedOutput.flush();\n<line90>            // Dump data to peer\n<line91>            learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line92>            oa.writeString(\"BenWasHere\", \"signature\");\n<line93>            bufferedOutput.flush();\n<line94>        } finally {\n<line95>            ServerMetrics.getMetrics().SNAP_COUNT.add(1);\n<line96>        }\n<line97>    } else {\n<line98>        syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();\n<line99>        syncThrottler.beginSync(exemptFromThrottle);\n<line100>        ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line101>        ServerMetrics.getMetrics().DIFF_COUNT.add(1);\n<line102>    }\n<line103>    // the version of this quorumVerifier will be set by leader.lead() in case\n<line104>    // the leader is just being established. waitForEpochAck makes sure that readyToStart is true if\n<line105>    // we got here, so the version was set\n<line106>    if (getVersion() < 0x10000) {\n<line107>        QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);\n<line108>        oa.writeRecord(newLeaderQP, \"packet\");\n<line109>    } else {\n<line110>        QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);\n<line111>        queuedPackets.add(newLeaderQP);\n<line112>    }\n<line113>    bufferedOutput.flush();\n<line114>    // Start thread that blast packets in the queue to learner\n<line115>    startSendingPackets();\n<line116>    /*\n<line117>             * Have to wait for the first ACK, wait until\n<line118>             * the learnerMaster is ready, and only then we can\n<line119>             * start processing messages.\n<line120>             */\n<line121>    qp = new QuorumPacket();\n<line122>    ia.readRecord(qp, \"packet\");\n<line123>    messageTracker.trackReceived(qp.getType());\n<line124>    if (qp.getType() != Leader.ACK) {\n<line125>        return;\n<line126>    }\n<line127>    learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());\n<line128>    syncLimitCheck.start();\n<line129>    // sync ends when NEWLEADER-ACK is received\n<line130>    syncThrottler.endSync();\n<line131>    if (needSnap) {\n<line132>        ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line133>    } else {\n<line134>        ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line135>    }\n<line136>    syncThrottler = null;\n<line137>    // now that the ack has been processed expect the syncLimit\n<line138>    sock.setSoTimeout(learnerMaster.syncTimeout());\n<line139>    /*\n<line140>             * Wait until learnerMaster starts up\n<line141>             */\n<line142>    learnerMaster.waitForStartup();\n<line143>    // Mutation packets will be queued during the serialize,\n<line144>    // so we need to mark when the peer can actually start\n<line145>    // using the data\n<line146>    //\n<line147>    queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));\n<line148>    while (true) {\n<line149>        qp = new QuorumPacket();\n<line150>        ia.readRecord(qp, \"packet\");\n<line151>        messageTracker.trackReceived(qp.getType());\n<line152>            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line153>            if (qp.getType() == Leader.PING) {\n<line154>                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line155>            }\n<line156>            ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);\n<line157>        }\n<line158>        tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();\n<line159>        packetsReceived.incrementAndGet();\n<line160>        ByteBuffer bb;\n<line161>        long sessionId;\n<line162>        int cxid;\n<line163>        int type;\n<line164>        switch(qp.getType()) {\n<line165>            case Leader.ACK:\n<line166>                if (this.learnerType == LearnerType.OBSERVER) {\n<line167>                }\n<line168>                syncLimitCheck.updateAck(qp.getZxid());\n<line169>                learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());\n<line170>                break;\n<line171>            case Leader.PING:\n<line172>                // Process the touches\n<line173>                ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line174>                DataInputStream dis = new DataInputStream(bis);\n<line175>                while (dis.available() > 0) {\n<line176>                    long sess = dis.readLong();\n<line177>                    int to = dis.readInt();\n<line178>                    learnerMaster.touch(sess, to);\n<line179>                }\n<line180>                break;\n<line181>            case Leader.REVALIDATE:\n<line182>                ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);\n<line183>                learnerMaster.revalidateSession(qp, this);\n<line184>                break;\n<line185>            case Leader.REQUEST:\n<line186>                bb = ByteBuffer.wrap(qp.getData());\n<line187>                sessionId = bb.getLong();\n<line188>                cxid = bb.getInt();\n<line189>                type = bb.getInt();\n<line190>                bb = bb.slice();\n<line191>                Request si;\n<line192>                if (type == OpCode.sync) {\n<line193>                    si = new LearnerSyncRequest(this, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line194>                } else {\n<line195>                    si = new Request(null, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line196>                }\n<line197>                si.setOwner(this);\n<line198>                learnerMaster.submitLearnerRequest(si);\n<line199>                requestsReceived.incrementAndGet();\n<line200>                break;\n<line201>            default:\n<line202>                break;\n<line203>        }\n<line204>    }\n<line205>}","output":"<line1>{\n<line2>    learnerMaster.addLearnerHandler(this);\n<line3>    tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();\n<line4>    ia = BinaryInputArchive.getArchive(bufferedInput);\n<line5>    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n<line6>    oa = BinaryOutputArchive.getArchive(bufferedOutput);\n<line7>    QuorumPacket qp = new QuorumPacket();\n<line8>    ia.readRecord(qp, \"packet\");\n<line9>    messageTracker.trackReceived(qp.getType());\n<line10>    if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {\n<line11>        LOG.error(\"First packet {} is not FOLLOWERINFO or OBSERVERINFO!\", qp.toString());\n<line12>        return;\n<line13>    }\n<line14>    if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {\n<line15>        throw new IOException(\"Non observer attempting to connect to ObserverMaster. type = \" + qp.getType());\n<line16>    }\n<line17>    byte[] learnerInfoData = qp.getData();\n<line18>    if (learnerInfoData != null) {\n<line19>        ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);\n<line20>        if (learnerInfoData.length >= 8) {\n<line21>            this.sid = bbsid.getLong();\n<line22>        }\n<line23>        if (learnerInfoData.length >= 12) {\n<line24>            // protocolVersion\n<line25>            this.version = bbsid.getInt();\n<line26>        }\n<line27>        if (learnerInfoData.length >= 20) {\n<line28>            long configVersion = bbsid.getLong();\n<line29>            if (configVersion > learnerMaster.getQuorumVerifierVersion()) {\n<line30>                throw new IOException(\"Follower is ahead of the leader (has a later activated configuration)\");\n<line31>            }\n<line32>        }\n<line33>    } else {\n<line34>        this.sid = learnerMaster.getAndDecrementFollowerCounter();\n<line35>    }\n<line36>    String followerInfo = learnerMaster.getPeerInfo(this.sid);\n<line37>    if (followerInfo.isEmpty()) {\n<line38>        LOG.info(\"Follower sid: {} not in the current config {}\", this.sid, Long.toHexString(learnerMaster.getQuorumVerifierVersion()));\n<line39>    } else {\n<line40>        LOG.info(\"Follower sid: {} : info : {}\", this.sid, followerInfo);\n<line41>    }\n<line42>    if (qp.getType() == Leader.OBSERVERINFO) {\n<line43>        learnerType = LearnerType.OBSERVER;\n<line44>    }\n<line45>    learnerMaster.registerLearnerHandlerBean(this, sock);\n<line46>    long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n<line47>    long peerLastZxid;\n<line48>    StateSummary ss = null;\n<line49>    long zxid = qp.getZxid();\n<line50>    long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);\n<line51>    long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);\n<line52>    if (this.getVersion() < 0x10000) {\n<line53>        // we are going to have to extrapolate the epoch information\n<line54>        long epoch = ZxidUtils.getEpochFromZxid(zxid);\n<line55>        ss = new StateSummary(epoch, zxid);\n<line56>        // fake the message\n<line57>        learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line58>    } else {\n<line59>        byte[] ver = new byte[4];\n<line60>        ByteBuffer.wrap(ver).putInt(0x10000);\n<line61>        QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);\n<line62>        oa.writeRecord(newEpochPacket, \"packet\");\n<line63>        messageTracker.trackSent(Leader.LEADERINFO);\n<line64>        bufferedOutput.flush();\n<line65>        QuorumPacket ackEpochPacket = new QuorumPacket();\n<line66>        ia.readRecord(ackEpochPacket, \"packet\");\n<line67>        messageTracker.trackReceived(ackEpochPacket.getType());\n<line68>        if (ackEpochPacket.getType() != Leader.ACKEPOCH) {\n<line69>            LOG.error(\"{} is not ACKEPOCH\", ackEpochPacket.toString());\n<line70>            return;\n<line71>        }\n<line72>        ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());\n<line73>        ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());\n<line74>        learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line75>    }\n<line76>    peerLastZxid = ss.getLastZxid();\n<line77>    // Take any necessary action if we need to send TRUNC or DIFF\n<line78>    // startForwarding() will be called in all cases\n<line79>    boolean needSnap = syncFollower(peerLastZxid, learnerMaster);\n<line80>    // syncs between followers and the leader are exempt from throttling because it\n<line81>    // is important to keep the state of quorum servers up-to-date. The exempted syncs\n<line82>    // are counted as concurrent syncs though\n<line83>    boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;\n<line84>    /* if we are not truncating or sending a diff just send a snapshot */\n<line85>    if (needSnap) {\n<line86>        syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();\n<line87>        syncThrottler.beginSync(exemptFromThrottle);\n<line88>        ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line89>        try {\n<line90>            long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line91>            oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line92>            messageTracker.trackSent(Leader.SNAP);\n<line93>            bufferedOutput.flush();\n<line94>            LOG.info(\"Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, \" + \"send zxid of db as 0x{}, {} concurrent snapshot sync, \" + \"snapshot sync was {} from throttle\", Long.toHexString(peerLastZxid), Long.toHexString(leaderLastZxid), Long.toHexString(zxidToSend), syncThrottler.getSyncInProgress(), exemptFromThrottle ? \"exempt\" : \"not exempt\");\n<line95>            // Dump data to peer\n<line96>            learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line97>            oa.writeString(\"BenWasHere\", \"signature\");\n<line98>            bufferedOutput.flush();\n<line99>        } finally {\n<line100>            ServerMetrics.getMetrics().SNAP_COUNT.add(1);\n<line101>        }\n<line102>    } else {\n<line103>        syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();\n<line104>        syncThrottler.beginSync(exemptFromThrottle);\n<line105>        ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line106>        ServerMetrics.getMetrics().DIFF_COUNT.add(1);\n<line107>    }\n<line108>    LOG.debug(\"Sending NEWLEADER message to {}\", sid);\n<line109>    // the version of this quorumVerifier will be set by leader.lead() in case\n<line110>    // the leader is just being established. waitForEpochAck makes sure that readyToStart is true if\n<line111>    // we got here, so the version was set\n<line112>    if (getVersion() < 0x10000) {\n<line113>        QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);\n<line114>        oa.writeRecord(newLeaderQP, \"packet\");\n<line115>    } else {\n<line116>        QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);\n<line117>        queuedPackets.add(newLeaderQP);\n<line118>    }\n<line119>    bufferedOutput.flush();\n<line120>    // Start thread that blast packets in the queue to learner\n<line121>    startSendingPackets();\n<line122>    /*\n<line123>             * Have to wait for the first ACK, wait until\n<line124>             * the learnerMaster is ready, and only then we can\n<line125>             * start processing messages.\n<line126>             */\n<line127>    qp = new QuorumPacket();\n<line128>    ia.readRecord(qp, \"packet\");\n<line129>    messageTracker.trackReceived(qp.getType());\n<line130>    if (qp.getType() != Leader.ACK) {\n<line131>        LOG.error(\"Next packet was supposed to be an ACK, but received packet: {}\", packetToString(qp));\n<line132>        return;\n<line133>    }\n<line134>    LOG.debug(\"Received NEWLEADER-ACK message from {}\", sid);\n<line135>    learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());\n<line136>    syncLimitCheck.start();\n<line137>    // sync ends when NEWLEADER-ACK is received\n<line138>    syncThrottler.endSync();\n<line139>    if (needSnap) {\n<line140>        ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line141>    } else {\n<line142>        ServerMetrics.getMetrics().INFLIGHT_DIFF_COUNT.add(syncThrottler.getSyncInProgress());\n<line143>    }\n<line144>    syncThrottler = null;\n<line145>    // now that the ack has been processed expect the syncLimit\n<line146>    sock.setSoTimeout(learnerMaster.syncTimeout());\n<line147>    /*\n<line148>             * Wait until learnerMaster starts up\n<line149>             */\n<line150>    learnerMaster.waitForStartup();\n<line151>    // Mutation packets will be queued during the serialize,\n<line152>    // so we need to mark when the peer can actually start\n<line153>    // using the data\n<line154>    //\n<line155>    LOG.debug(\"Sending UPTODATE message to {}\", sid);\n<line156>    queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));\n<line157>    while (true) {\n<line158>        qp = new QuorumPacket();\n<line159>        ia.readRecord(qp, \"packet\");\n<line160>        messageTracker.trackReceived(qp.getType());\n<line161>        if (LOG.isTraceEnabled()) {\n<line162>            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line163>            if (qp.getType() == Leader.PING) {\n<line164>                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line165>            }\n<line166>            ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);\n<line167>        }\n<line168>        tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();\n<line169>        packetsReceived.incrementAndGet();\n<line170>        ByteBuffer bb;\n<line171>        long sessionId;\n<line172>        int cxid;\n<line173>        int type;\n<line174>        switch(qp.getType()) {\n<line175>            case Leader.ACK:\n<line176>                if (this.learnerType == LearnerType.OBSERVER) {\n<line177>                    LOG.debug(\"Received ACK from Observer {}\", this.sid);\n<line178>                }\n<line179>                syncLimitCheck.updateAck(qp.getZxid());\n<line180>                learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());\n<line181>                break;\n<line182>            case Leader.PING:\n<line183>                // Process the touches\n<line184>                ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line185>                DataInputStream dis = new DataInputStream(bis);\n<line186>                while (dis.available() > 0) {\n<line187>                    long sess = dis.readLong();\n<line188>                    int to = dis.readInt();\n<line189>                    learnerMaster.touch(sess, to);\n<line190>                }\n<line191>                break;\n<line192>            case Leader.REVALIDATE:\n<line193>                ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);\n<line194>                learnerMaster.revalidateSession(qp, this);\n<line195>                break;\n<line196>            case Leader.REQUEST:\n<line197>                bb = ByteBuffer.wrap(qp.getData());\n<line198>                sessionId = bb.getLong();\n<line199>                cxid = bb.getInt();\n<line200>                type = bb.getInt();\n<line201>                bb = bb.slice();\n<line202>                Request si;\n<line203>                if (type == OpCode.sync) {\n<line204>                    si = new LearnerSyncRequest(this, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line205>                } else {\n<line206>                    si = new Request(null, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line207>                }\n<line208>                si.setOwner(this);\n<line209>                learnerMaster.submitLearnerRequest(si);\n<line210>                requestsReceived.incrementAndGet();\n<line211>                break;\n<line212>            default:\n<line213>                LOG.warn(\"unexpected quorum packet, type: {}\", packetToString(qp));\n<line214>                break;\n<line215>        }\n<line216>    }\n<line217>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"First packet {} is not FOLLOWERINFO or OBSERVERINFO!\", qp.toString());\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Follower sid: {} not in the current config {}\", this.sid, Long.toHexString(learnerMaster.getQuorumVerifierVersion()));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Follower sid: {} : info : {}\", this.sid, followerInfo);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] ver = new byte[4];\n<line3>    ByteBuffer.wrap(ver).putInt(0x10000);\n<line4>    QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);\n<line5>    oa.writeRecord(newEpochPacket, \"packet\");\n<line6>    messageTracker.trackSent(Leader.LEADERINFO);\n<line7>    bufferedOutput.flush();\n<line8>    QuorumPacket ackEpochPacket = new QuorumPacket();\n<line9>    ia.readRecord(ackEpochPacket, \"packet\");\n<line10>    messageTracker.trackReceived(ackEpochPacket.getType());\n<line11>    if (ackEpochPacket.getType() != Leader.ACKEPOCH) {\n<line12>        return;\n<line13>    }\n<line14>    ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());\n<line15>    ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());\n<line16>    learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line17>}","output":"<line1>{\n<line2>    byte[] ver = new byte[4];\n<line3>    ByteBuffer.wrap(ver).putInt(0x10000);\n<line4>    QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);\n<line5>    oa.writeRecord(newEpochPacket, \"packet\");\n<line6>    messageTracker.trackSent(Leader.LEADERINFO);\n<line7>    bufferedOutput.flush();\n<line8>    QuorumPacket ackEpochPacket = new QuorumPacket();\n<line9>    ia.readRecord(ackEpochPacket, \"packet\");\n<line10>    messageTracker.trackReceived(ackEpochPacket.getType());\n<line11>    if (ackEpochPacket.getType() != Leader.ACKEPOCH) {\n<line12>        LOG.error(\"{} is not ACKEPOCH\", ackEpochPacket.toString());\n<line13>        return;\n<line14>    }\n<line15>    ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());\n<line16>    ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());\n<line17>    learnerMaster.waitForEpochAck(this.getSid(), ss);\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"{} is not ACKEPOCH\", ackEpochPacket.toString());\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();\n<line3>    syncThrottler.beginSync(exemptFromThrottle);\n<line4>    ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line5>    try {\n<line6>        long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line7>        oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line8>        messageTracker.trackSent(Leader.SNAP);\n<line9>        bufferedOutput.flush();\n<line10>        // Dump data to peer\n<line11>        learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line12>        oa.writeString(\"BenWasHere\", \"signature\");\n<line13>        bufferedOutput.flush();\n<line14>    } finally {\n<line15>        ServerMetrics.getMetrics().SNAP_COUNT.add(1);\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();\n<line3>    syncThrottler.beginSync(exemptFromThrottle);\n<line4>    ServerMetrics.getMetrics().INFLIGHT_SNAP_COUNT.add(syncThrottler.getSyncInProgress());\n<line5>    try {\n<line6>        long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line7>        oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line8>        messageTracker.trackSent(Leader.SNAP);\n<line9>        bufferedOutput.flush();\n<line10>        LOG.info(\"Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, \" + \"send zxid of db as 0x{}, {} concurrent snapshot sync, \" + \"snapshot sync was {} from throttle\", Long.toHexString(peerLastZxid), Long.toHexString(leaderLastZxid), Long.toHexString(zxidToSend), syncThrottler.getSyncInProgress(), exemptFromThrottle ? \"exempt\" : \"not exempt\");\n<line11>        // Dump data to peer\n<line12>        learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line13>        oa.writeString(\"BenWasHere\", \"signature\");\n<line14>        bufferedOutput.flush();\n<line15>    } finally {\n<line16>        ServerMetrics.getMetrics().SNAP_COUNT.add(1);\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line3>    oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line4>    messageTracker.trackSent(Leader.SNAP);\n<line5>    bufferedOutput.flush();\n<line6>    // Dump data to peer\n<line7>    learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line8>    oa.writeString(\"BenWasHere\", \"signature\");\n<line9>    bufferedOutput.flush();\n<line10>}","output":"<line1>{\n<line2>    long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();\n<line3>    oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), \"packet\");\n<line4>    messageTracker.trackSent(Leader.SNAP);\n<line5>    bufferedOutput.flush();\n<line6>    LOG.info(\"Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, \" + \"send zxid of db as 0x{}, {} concurrent snapshot sync, \" + \"snapshot sync was {} from throttle\", Long.toHexString(peerLastZxid), Long.toHexString(leaderLastZxid), Long.toHexString(zxidToSend), syncThrottler.getSyncInProgress(), exemptFromThrottle ? \"exempt\" : \"not exempt\");\n<line7>    // Dump data to peer\n<line8>    learnerMaster.getZKDatabase().serializeSnapshot(oa);\n<line9>    oa.writeString(\"BenWasHere\", \"signature\");\n<line10>    bufferedOutput.flush();\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Next packet was supposed to be an ACK, but received packet: {}\", packetToString(qp));\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    qp = new QuorumPacket();\n<line3>    ia.readRecord(qp, \"packet\");\n<line4>    messageTracker.trackReceived(qp.getType());\n<line5>        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line6>        if (qp.getType() == Leader.PING) {\n<line7>            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line8>        }\n<line9>        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);\n<line10>    }\n<line11>    tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();\n<line12>    packetsReceived.incrementAndGet();\n<line13>    ByteBuffer bb;\n<line14>    long sessionId;\n<line15>    int cxid;\n<line16>    int type;\n<line17>    switch(qp.getType()) {\n<line18>        case Leader.ACK:\n<line19>            if (this.learnerType == LearnerType.OBSERVER) {\n<line20>            }\n<line21>            syncLimitCheck.updateAck(qp.getZxid());\n<line22>            learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());\n<line23>            break;\n<line24>        case Leader.PING:\n<line25>            // Process the touches\n<line26>            ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line27>            DataInputStream dis = new DataInputStream(bis);\n<line28>            while (dis.available() > 0) {\n<line29>                long sess = dis.readLong();\n<line30>                int to = dis.readInt();\n<line31>                learnerMaster.touch(sess, to);\n<line32>            }\n<line33>            break;\n<line34>        case Leader.REVALIDATE:\n<line35>            ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);\n<line36>            learnerMaster.revalidateSession(qp, this);\n<line37>            break;\n<line38>        case Leader.REQUEST:\n<line39>            bb = ByteBuffer.wrap(qp.getData());\n<line40>            sessionId = bb.getLong();\n<line41>            cxid = bb.getInt();\n<line42>            type = bb.getInt();\n<line43>            bb = bb.slice();\n<line44>            Request si;\n<line45>            if (type == OpCode.sync) {\n<line46>                si = new LearnerSyncRequest(this, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line47>            } else {\n<line48>                si = new Request(null, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line49>            }\n<line50>            si.setOwner(this);\n<line51>            learnerMaster.submitLearnerRequest(si);\n<line52>            requestsReceived.incrementAndGet();\n<line53>            break;\n<line54>        default:\n<line55>            break;\n<line56>    }\n<line57>}","output":"<line1>{\n<line2>    qp = new QuorumPacket();\n<line3>    ia.readRecord(qp, \"packet\");\n<line4>    messageTracker.trackReceived(qp.getType());\n<line5>    if (LOG.isTraceEnabled()) {\n<line6>        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n<line7>        if (qp.getType() == Leader.PING) {\n<line8>            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line9>        }\n<line10>        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);\n<line11>    }\n<line12>    tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();\n<line13>    packetsReceived.incrementAndGet();\n<line14>    ByteBuffer bb;\n<line15>    long sessionId;\n<line16>    int cxid;\n<line17>    int type;\n<line18>    switch(qp.getType()) {\n<line19>        case Leader.ACK:\n<line20>            if (this.learnerType == LearnerType.OBSERVER) {\n<line21>                LOG.debug(\"Received ACK from Observer {}\", this.sid);\n<line22>            }\n<line23>            syncLimitCheck.updateAck(qp.getZxid());\n<line24>            learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());\n<line25>            break;\n<line26>        case Leader.PING:\n<line27>            // Process the touches\n<line28>            ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());\n<line29>            DataInputStream dis = new DataInputStream(bis);\n<line30>            while (dis.available() > 0) {\n<line31>                long sess = dis.readLong();\n<line32>                int to = dis.readInt();\n<line33>                learnerMaster.touch(sess, to);\n<line34>            }\n<line35>            break;\n<line36>        case Leader.REVALIDATE:\n<line37>            ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);\n<line38>            learnerMaster.revalidateSession(qp, this);\n<line39>            break;\n<line40>        case Leader.REQUEST:\n<line41>            bb = ByteBuffer.wrap(qp.getData());\n<line42>            sessionId = bb.getLong();\n<line43>            cxid = bb.getInt();\n<line44>            type = bb.getInt();\n<line45>            bb = bb.slice();\n<line46>            Request si;\n<line47>            if (type == OpCode.sync) {\n<line48>                si = new LearnerSyncRequest(this, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line49>            } else {\n<line50>                si = new Request(null, sessionId, cxid, type, RequestRecord.fromBytes(bb), qp.getAuthinfo());\n<line51>            }\n<line52>            si.setOwner(this);\n<line53>            learnerMaster.submitLearnerRequest(si);\n<line54>            requestsReceived.incrementAndGet();\n<line55>            break;\n<line56>        default:\n<line57>            LOG.warn(\"unexpected quorum packet, type: {}\", packetToString(qp));\n<line58>            break;\n<line59>    }\n<line60>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Received ACK from Observer {}\", this.sid);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSocket();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception in LearnerHandler: \", e);\n<line3>    closeSocket();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception in LearnerHandler.\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    syncThrottler = null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"too many concurrent sync.\", e);\n<line3>    syncThrottler = null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception in LearnerHandler.\", e);\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!sendingThreadStarted) {\n<line3>        // Start sending packets\n<line4>        new Thread() {\n<line5>\n<line6>            public void run() {\n<line7>                Thread.currentThread().setName(\"Sender-\" + sock.getRemoteSocketAddress());\n<line8>                try {\n<line9>                    sendPackets();\n<line10>                } catch (InterruptedException e) {\n<line11>                }\n<line12>            }\n<line13>        }.start();\n<line14>        sendingThreadStarted = true;\n<line15>    } else {\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    if (!sendingThreadStarted) {\n<line3>        // Start sending packets\n<line4>        new Thread() {\n<line5>\n<line6>            public void run() {\n<line7>                Thread.currentThread().setName(\"Sender-\" + sock.getRemoteSocketAddress());\n<line8>                try {\n<line9>                    sendPackets();\n<line10>                } catch (InterruptedException e) {\n<line11>                    LOG.warn(\"Unexpected interruption\", e);\n<line12>                }\n<line13>            }\n<line14>        }.start();\n<line15>        sendingThreadStarted = true;\n<line16>    } else {\n<line17>        LOG.error(\"Attempting to start sending thread after it already started\");\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Attempting to start sending thread after it already started\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>         * When leader election is completed, the leader will set its\n<line4>         * lastProcessedZxid to be (epoch < 32). There will be no txn associated\n<line5>         * with this zxid.\n<line6>         *\n<line7>         * The learner will set its lastProcessedZxid to the same value if\n<line8>         * it get DIFF or SNAP from the learnerMaster. If the same learner come\n<line9>         * back to sync with learnerMaster using this zxid, we will never find this\n<line10>         * zxid in our history. In this case, we will ignore TRUNC logic and\n<line11>         * always send DIFF if we have old enough history\n<line12>         */\n<line13>    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;\n<line14>    // Keep track of the latest zxid which already queued\n<line15>    long currentZxid = peerLastZxid;\n<line16>    boolean needSnap = true;\n<line17>    ZKDatabase db = learnerMaster.getZKDatabase();\n<line18>    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();\n<line19>    ReentrantReadWriteLock lock = db.getLogLock();\n<line20>    ReadLock rl = lock.readLock();\n<line21>    try {\n<line22>        rl.lock();\n<line23>        long maxCommittedLog = db.getmaxCommittedLog();\n<line24>        long minCommittedLog = db.getminCommittedLog();\n<line25>        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();\n<line26>        if (db.getCommittedLog().isEmpty()) {\n<line27>            /*\n<line28>                 * It is possible that committedLog is empty. In that case\n<line29>                 * setting these value to the latest txn in learnerMaster db\n<line30>                 * will reduce the case that we need to handle\n<line31>                 *\n<line32>                 * Here is how each case handle by the if block below\n<line33>                 * 1. lastProcessZxid == peerZxid -> Handle by (2)\n<line34>                 * 2. lastProcessZxid < peerZxid -> Handle by (3)\n<line35>                 * 3. lastProcessZxid > peerZxid -> Handle by (5)\n<line36>                 */\n<line37>            minCommittedLog = lastProcessedZxid;\n<line38>            maxCommittedLog = lastProcessedZxid;\n<line39>        }\n<line40>        /*\n<line41>             * Here are the cases that we want to handle\n<line42>             *\n<line43>             * 1. Force sending snapshot (for testing purpose)\n<line44>             * 2. Peer and learnerMaster is already sync, send empty diff\n<line45>             * 3. Follower has txn that we haven't seen. This may be old leader\n<line46>             *    so we need to send TRUNC. However, if peer has newEpochZxid,\n<line47>             *    we cannot send TRUNC since the follower has no txnlog\n<line48>             * 4. Follower is within committedLog range or already in-sync.\n<line49>             *    We may need to send DIFF or TRUNC depending on follower's zxid\n<line50>             *    We always send empty DIFF if follower is already in-sync\n<line51>             * 5. Follower missed the committedLog. We will try to use on-disk\n<line52>             *    txnlog + committedLog to sync with follower. If that fail,\n<line53>             *    we will send snapshot\n<line54>             */\n<line55>        if (forceSnapSync) {\n<line56>            // Force learnerMaster to use snapshot to sync with follower\n<line57>        } else if (lastProcessedZxid == peerLastZxid) {\n<line58>            // Follower is already sync with us, send empty diff\n<line59>            queueOpPacket(Leader.DIFF, peerLastZxid);\n<line60>            needOpPacket = false;\n<line61>            needSnap = false;\n<line62>        } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {\n<line63>            // Newer than committedLog, send trunc and done\n<line64>            queueOpPacket(Leader.TRUNC, maxCommittedLog);\n<line65>            currentZxid = maxCommittedLog;\n<line66>            needOpPacket = false;\n<line67>            needSnap = false;\n<line68>        } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {\n<line69>            // Follower is within commitLog range\n<line70>            Iterator<Proposal> itr = db.getCommittedLog().iterator();\n<line71>            currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);\n<line72>            needSnap = false;\n<line73>        } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {\n<line74>            // Use txnlog and committedLog to sync\n<line75>            // Calculate sizeLimit that we allow to retrieve txnlog from disk\n<line76>            long sizeLimit = db.calculateTxnLogSizeLimit();\n<line77>            // This method can return empty iterator if the requested zxid\n<line78>            // is older than on-disk txnlog\n<line79>            Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);\n<line80>            if (txnLogItr.hasNext()) {\n<line81>                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line82>                if (currentZxid < minCommittedLog) {\n<line83>                    currentZxid = peerLastZxid;\n<line84>                    // Clear out currently queued requests and revert\n<line85>                    // to sending a snapshot.\n<line86>                    queuedPackets.clear();\n<line87>                    needOpPacket = true;\n<line88>                } else {\n<line89>                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line90>                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line91>                    needSnap = false;\n<line92>                }\n<line93>            }\n<line94>            // closing the resources\n<line95>            if (txnLogItr instanceof TxnLogProposalIterator) {\n<line96>                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n<line97>                txnProposalItr.close();\n<line98>            }\n<line99>        } else {\n<line100>        }\n<line101>        if (needSnap) {\n<line102>            currentZxid = db.getDataTreeLastProcessedZxid();\n<line103>        }\n<line104>        leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);\n<line105>    } finally {\n<line106>        rl.unlock();\n<line107>    }\n<line108>    if (needOpPacket && !needSnap) {\n<line109>        // This should never happen, but we should fall back to sending\n<line110>        // snapshot just in case.\n<line111>        needSnap = true;\n<line112>    }\n<line113>    return needSnap;\n<line114>}","output":"<line1>{\n<line2>    /*\n<line3>         * When leader election is completed, the leader will set its\n<line4>         * lastProcessedZxid to be (epoch < 32). There will be no txn associated\n<line5>         * with this zxid.\n<line6>         *\n<line7>         * The learner will set its lastProcessedZxid to the same value if\n<line8>         * it get DIFF or SNAP from the learnerMaster. If the same learner come\n<line9>         * back to sync with learnerMaster using this zxid, we will never find this\n<line10>         * zxid in our history. In this case, we will ignore TRUNC logic and\n<line11>         * always send DIFF if we have old enough history\n<line12>         */\n<line13>    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;\n<line14>    // Keep track of the latest zxid which already queued\n<line15>    long currentZxid = peerLastZxid;\n<line16>    boolean needSnap = true;\n<line17>    ZKDatabase db = learnerMaster.getZKDatabase();\n<line18>    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();\n<line19>    ReentrantReadWriteLock lock = db.getLogLock();\n<line20>    ReadLock rl = lock.readLock();\n<line21>    try {\n<line22>        rl.lock();\n<line23>        long maxCommittedLog = db.getmaxCommittedLog();\n<line24>        long minCommittedLog = db.getminCommittedLog();\n<line25>        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();\n<line26>        LOG.info(\"Synchronizing with Learner sid: {} maxCommittedLog=0x{}\" + \" minCommittedLog=0x{} lastProcessedZxid=0x{}\" + \" peerLastZxid=0x{}\", getSid(), Long.toHexString(maxCommittedLog), Long.toHexString(minCommittedLog), Long.toHexString(lastProcessedZxid), Long.toHexString(peerLastZxid));\n<line27>        if (db.getCommittedLog().isEmpty()) {\n<line28>            /*\n<line29>                 * It is possible that committedLog is empty. In that case\n<line30>                 * setting these value to the latest txn in learnerMaster db\n<line31>                 * will reduce the case that we need to handle\n<line32>                 *\n<line33>                 * Here is how each case handle by the if block below\n<line34>                 * 1. lastProcessZxid == peerZxid -> Handle by (2)\n<line35>                 * 2. lastProcessZxid < peerZxid -> Handle by (3)\n<line36>                 * 3. lastProcessZxid > peerZxid -> Handle by (5)\n<line37>                 */\n<line38>            minCommittedLog = lastProcessedZxid;\n<line39>            maxCommittedLog = lastProcessedZxid;\n<line40>        }\n<line41>        /*\n<line42>             * Here are the cases that we want to handle\n<line43>             *\n<line44>             * 1. Force sending snapshot (for testing purpose)\n<line45>             * 2. Peer and learnerMaster is already sync, send empty diff\n<line46>             * 3. Follower has txn that we haven't seen. This may be old leader\n<line47>             *    so we need to send TRUNC. However, if peer has newEpochZxid,\n<line48>             *    we cannot send TRUNC since the follower has no txnlog\n<line49>             * 4. Follower is within committedLog range or already in-sync.\n<line50>             *    We may need to send DIFF or TRUNC depending on follower's zxid\n<line51>             *    We always send empty DIFF if follower is already in-sync\n<line52>             * 5. Follower missed the committedLog. We will try to use on-disk\n<line53>             *    txnlog + committedLog to sync with follower. If that fail,\n<line54>             *    we will send snapshot\n<line55>             */\n<line56>        if (forceSnapSync) {\n<line57>            // Force learnerMaster to use snapshot to sync with follower\n<line58>            LOG.warn(\"Forcing snapshot sync - should not see this in production\");\n<line59>        } else if (lastProcessedZxid == peerLastZxid) {\n<line60>            // Follower is already sync with us, send empty diff\n<line61>            LOG.info(\"Sending DIFF zxid=0x{} for peer sid: {}\", Long.toHexString(peerLastZxid), getSid());\n<line62>            queueOpPacket(Leader.DIFF, peerLastZxid);\n<line63>            needOpPacket = false;\n<line64>            needSnap = false;\n<line65>        } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {\n<line66>            // Newer than committedLog, send trunc and done\n<line67>            LOG.debug(\"Sending TRUNC to follower zxidToSend=0x{} for peer sid:{}\", Long.toHexString(maxCommittedLog), getSid());\n<line68>            queueOpPacket(Leader.TRUNC, maxCommittedLog);\n<line69>            currentZxid = maxCommittedLog;\n<line70>            needOpPacket = false;\n<line71>            needSnap = false;\n<line72>        } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {\n<line73>            // Follower is within commitLog range\n<line74>            LOG.info(\"Using committedLog for peer sid: {}\", getSid());\n<line75>            Iterator<Proposal> itr = db.getCommittedLog().iterator();\n<line76>            currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);\n<line77>            needSnap = false;\n<line78>        } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {\n<line79>            // Use txnlog and committedLog to sync\n<line80>            // Calculate sizeLimit that we allow to retrieve txnlog from disk\n<line81>            long sizeLimit = db.calculateTxnLogSizeLimit();\n<line82>            // This method can return empty iterator if the requested zxid\n<line83>            // is older than on-disk txnlog\n<line84>            Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);\n<line85>            if (txnLogItr.hasNext()) {\n<line86>                LOG.info(\"Use txnlog and committedLog for peer sid: {}\", getSid());\n<line87>                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line88>                if (currentZxid < minCommittedLog) {\n<line89>                    LOG.info(\"Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}\", Long.toHexString(currentZxid), Long.toHexString(minCommittedLog));\n<line90>                    currentZxid = peerLastZxid;\n<line91>                    // Clear out currently queued requests and revert\n<line92>                    // to sending a snapshot.\n<line93>                    queuedPackets.clear();\n<line94>                    needOpPacket = true;\n<line95>                } else {\n<line96>                    LOG.debug(\"Queueing committedLog 0x{}\", Long.toHexString(currentZxid));\n<line97>                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line98>                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line99>                    needSnap = false;\n<line100>                }\n<line101>            }\n<line102>            // closing the resources\n<line103>            if (txnLogItr instanceof TxnLogProposalIterator) {\n<line104>                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n<line105>                txnProposalItr.close();\n<line106>            }\n<line107>        } else {\n<line108>            LOG.warn(\"Unhandled scenario for peer sid: {} maxCommittedLog=0x{}\" + \" minCommittedLog=0x{} lastProcessedZxid=0x{}\" + \" peerLastZxid=0x{} txnLogSyncEnabled={}\", getSid(), Long.toHexString(maxCommittedLog), Long.toHexString(minCommittedLog), Long.toHexString(lastProcessedZxid), Long.toHexString(peerLastZxid), txnLogSyncEnabled);\n<line109>        }\n<line110>        if (needSnap) {\n<line111>            currentZxid = db.getDataTreeLastProcessedZxid();\n<line112>        }\n<line113>        LOG.debug(\"Start forwarding 0x{} for peer sid: {}\", Long.toHexString(currentZxid), getSid());\n<line114>        leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);\n<line115>    } finally {\n<line116>        rl.unlock();\n<line117>    }\n<line118>    if (needOpPacket && !needSnap) {\n<line119>        // This should never happen, but we should fall back to sending\n<line120>        // snapshot just in case.\n<line121>        LOG.error(\"Unhandled scenario for peer sid: {} fall back to use snapshot\", getSid());\n<line122>        needSnap = true;\n<line123>    }\n<line124>    return needSnap;\n<line125>}"},{"input":"","instruction":"<line1>{\n<line2>    rl.lock();\n<line3>    long maxCommittedLog = db.getmaxCommittedLog();\n<line4>    long minCommittedLog = db.getminCommittedLog();\n<line5>    long lastProcessedZxid = db.getDataTreeLastProcessedZxid();\n<line6>    if (db.getCommittedLog().isEmpty()) {\n<line7>        /*\n<line8>                 * It is possible that committedLog is empty. In that case\n<line9>                 * setting these value to the latest txn in learnerMaster db\n<line10>                 * will reduce the case that we need to handle\n<line11>                 *\n<line12>                 * Here is how each case handle by the if block below\n<line13>                 * 1. lastProcessZxid == peerZxid -> Handle by (2)\n<line14>                 * 2. lastProcessZxid < peerZxid -> Handle by (3)\n<line15>                 * 3. lastProcessZxid > peerZxid -> Handle by (5)\n<line16>                 */\n<line17>        minCommittedLog = lastProcessedZxid;\n<line18>        maxCommittedLog = lastProcessedZxid;\n<line19>    }\n<line20>    /*\n<line21>             * Here are the cases that we want to handle\n<line22>             *\n<line23>             * 1. Force sending snapshot (for testing purpose)\n<line24>             * 2. Peer and learnerMaster is already sync, send empty diff\n<line25>             * 3. Follower has txn that we haven't seen. This may be old leader\n<line26>             *    so we need to send TRUNC. However, if peer has newEpochZxid,\n<line27>             *    we cannot send TRUNC since the follower has no txnlog\n<line28>             * 4. Follower is within committedLog range or already in-sync.\n<line29>             *    We may need to send DIFF or TRUNC depending on follower's zxid\n<line30>             *    We always send empty DIFF if follower is already in-sync\n<line31>             * 5. Follower missed the committedLog. We will try to use on-disk\n<line32>             *    txnlog + committedLog to sync with follower. If that fail,\n<line33>             *    we will send snapshot\n<line34>             */\n<line35>    if (forceSnapSync) {\n<line36>        // Force learnerMaster to use snapshot to sync with follower\n<line37>    } else if (lastProcessedZxid == peerLastZxid) {\n<line38>        // Follower is already sync with us, send empty diff\n<line39>        queueOpPacket(Leader.DIFF, peerLastZxid);\n<line40>        needOpPacket = false;\n<line41>        needSnap = false;\n<line42>    } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {\n<line43>        // Newer than committedLog, send trunc and done\n<line44>        queueOpPacket(Leader.TRUNC, maxCommittedLog);\n<line45>        currentZxid = maxCommittedLog;\n<line46>        needOpPacket = false;\n<line47>        needSnap = false;\n<line48>    } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {\n<line49>        // Follower is within commitLog range\n<line50>        Iterator<Proposal> itr = db.getCommittedLog().iterator();\n<line51>        currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);\n<line52>        needSnap = false;\n<line53>    } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {\n<line54>        // Use txnlog and committedLog to sync\n<line55>        // Calculate sizeLimit that we allow to retrieve txnlog from disk\n<line56>        long sizeLimit = db.calculateTxnLogSizeLimit();\n<line57>        // This method can return empty iterator if the requested zxid\n<line58>        // is older than on-disk txnlog\n<line59>        Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);\n<line60>        if (txnLogItr.hasNext()) {\n<line61>            currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line62>            if (currentZxid < minCommittedLog) {\n<line63>                currentZxid = peerLastZxid;\n<line64>                // Clear out currently queued requests and revert\n<line65>                // to sending a snapshot.\n<line66>                queuedPackets.clear();\n<line67>                needOpPacket = true;\n<line68>            } else {\n<line69>                Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line70>                currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line71>                needSnap = false;\n<line72>            }\n<line73>        }\n<line74>        // closing the resources\n<line75>        if (txnLogItr instanceof TxnLogProposalIterator) {\n<line76>            TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n<line77>            txnProposalItr.close();\n<line78>        }\n<line79>    } else {\n<line80>    }\n<line81>    if (needSnap) {\n<line82>        currentZxid = db.getDataTreeLastProcessedZxid();\n<line83>    }\n<line84>    leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);\n<line85>}","output":"<line1>{\n<line2>    rl.lock();\n<line3>    long maxCommittedLog = db.getmaxCommittedLog();\n<line4>    long minCommittedLog = db.getminCommittedLog();\n<line5>    long lastProcessedZxid = db.getDataTreeLastProcessedZxid();\n<line6>    LOG.info(\"Synchronizing with Learner sid: {} maxCommittedLog=0x{}\" + \" minCommittedLog=0x{} lastProcessedZxid=0x{}\" + \" peerLastZxid=0x{}\", getSid(), Long.toHexString(maxCommittedLog), Long.toHexString(minCommittedLog), Long.toHexString(lastProcessedZxid), Long.toHexString(peerLastZxid));\n<line7>    if (db.getCommittedLog().isEmpty()) {\n<line8>        /*\n<line9>                 * It is possible that committedLog is empty. In that case\n<line10>                 * setting these value to the latest txn in learnerMaster db\n<line11>                 * will reduce the case that we need to handle\n<line12>                 *\n<line13>                 * Here is how each case handle by the if block below\n<line14>                 * 1. lastProcessZxid == peerZxid -> Handle by (2)\n<line15>                 * 2. lastProcessZxid < peerZxid -> Handle by (3)\n<line16>                 * 3. lastProcessZxid > peerZxid -> Handle by (5)\n<line17>                 */\n<line18>        minCommittedLog = lastProcessedZxid;\n<line19>        maxCommittedLog = lastProcessedZxid;\n<line20>    }\n<line21>    /*\n<line22>             * Here are the cases that we want to handle\n<line23>             *\n<line24>             * 1. Force sending snapshot (for testing purpose)\n<line25>             * 2. Peer and learnerMaster is already sync, send empty diff\n<line26>             * 3. Follower has txn that we haven't seen. This may be old leader\n<line27>             *    so we need to send TRUNC. However, if peer has newEpochZxid,\n<line28>             *    we cannot send TRUNC since the follower has no txnlog\n<line29>             * 4. Follower is within committedLog range or already in-sync.\n<line30>             *    We may need to send DIFF or TRUNC depending on follower's zxid\n<line31>             *    We always send empty DIFF if follower is already in-sync\n<line32>             * 5. Follower missed the committedLog. We will try to use on-disk\n<line33>             *    txnlog + committedLog to sync with follower. If that fail,\n<line34>             *    we will send snapshot\n<line35>             */\n<line36>    if (forceSnapSync) {\n<line37>        // Force learnerMaster to use snapshot to sync with follower\n<line38>        LOG.warn(\"Forcing snapshot sync - should not see this in production\");\n<line39>    } else if (lastProcessedZxid == peerLastZxid) {\n<line40>        // Follower is already sync with us, send empty diff\n<line41>        LOG.info(\"Sending DIFF zxid=0x{} for peer sid: {}\", Long.toHexString(peerLastZxid), getSid());\n<line42>        queueOpPacket(Leader.DIFF, peerLastZxid);\n<line43>        needOpPacket = false;\n<line44>        needSnap = false;\n<line45>    } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {\n<line46>        // Newer than committedLog, send trunc and done\n<line47>        LOG.debug(\"Sending TRUNC to follower zxidToSend=0x{} for peer sid:{}\", Long.toHexString(maxCommittedLog), getSid());\n<line48>        queueOpPacket(Leader.TRUNC, maxCommittedLog);\n<line49>        currentZxid = maxCommittedLog;\n<line50>        needOpPacket = false;\n<line51>        needSnap = false;\n<line52>    } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {\n<line53>        // Follower is within commitLog range\n<line54>        LOG.info(\"Using committedLog for peer sid: {}\", getSid());\n<line55>        Iterator<Proposal> itr = db.getCommittedLog().iterator();\n<line56>        currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);\n<line57>        needSnap = false;\n<line58>    } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {\n<line59>        // Use txnlog and committedLog to sync\n<line60>        // Calculate sizeLimit that we allow to retrieve txnlog from disk\n<line61>        long sizeLimit = db.calculateTxnLogSizeLimit();\n<line62>        // This method can return empty iterator if the requested zxid\n<line63>        // is older than on-disk txnlog\n<line64>        Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);\n<line65>        if (txnLogItr.hasNext()) {\n<line66>            LOG.info(\"Use txnlog and committedLog for peer sid: {}\", getSid());\n<line67>            currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line68>            if (currentZxid < minCommittedLog) {\n<line69>                LOG.info(\"Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}\", Long.toHexString(currentZxid), Long.toHexString(minCommittedLog));\n<line70>                currentZxid = peerLastZxid;\n<line71>                // Clear out currently queued requests and revert\n<line72>                // to sending a snapshot.\n<line73>                queuedPackets.clear();\n<line74>                needOpPacket = true;\n<line75>            } else {\n<line76>                LOG.debug(\"Queueing committedLog 0x{}\", Long.toHexString(currentZxid));\n<line77>                Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line78>                currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line79>                needSnap = false;\n<line80>            }\n<line81>        }\n<line82>        // closing the resources\n<line83>        if (txnLogItr instanceof TxnLogProposalIterator) {\n<line84>            TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n<line85>            txnProposalItr.close();\n<line86>        }\n<line87>    } else {\n<line88>        LOG.warn(\"Unhandled scenario for peer sid: {} maxCommittedLog=0x{}\" + \" minCommittedLog=0x{} lastProcessedZxid=0x{}\" + \" peerLastZxid=0x{} txnLogSyncEnabled={}\", getSid(), Long.toHexString(maxCommittedLog), Long.toHexString(minCommittedLog), Long.toHexString(lastProcessedZxid), Long.toHexString(peerLastZxid), txnLogSyncEnabled);\n<line89>    }\n<line90>    if (needSnap) {\n<line91>        currentZxid = db.getDataTreeLastProcessedZxid();\n<line92>    }\n<line93>    LOG.debug(\"Start forwarding 0x{} for peer sid: {}\", Long.toHexString(currentZxid), getSid());\n<line94>    leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);\n<line95>}"},{"input":"","instruction":"<line1>{\n<line2>    // Follower is already sync with us, send empty diff\n<line3>    queueOpPacket(Leader.DIFF, peerLastZxid);\n<line4>    needOpPacket = false;\n<line5>    needSnap = false;\n<line6>}","output":"<line1>{\n<line2>    // Follower is already sync with us, send empty diff\n<line3>    LOG.info(\"Sending DIFF zxid=0x{} for peer sid: {}\", Long.toHexString(peerLastZxid), getSid());\n<line4>    queueOpPacket(Leader.DIFF, peerLastZxid);\n<line5>    needOpPacket = false;\n<line6>    needSnap = false;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    // Newer than committedLog, send trunc and done\n<line3>    queueOpPacket(Leader.TRUNC, maxCommittedLog);\n<line4>    currentZxid = maxCommittedLog;\n<line5>    needOpPacket = false;\n<line6>    needSnap = false;\n<line7>}","output":"<line1>{\n<line2>    // Newer than committedLog, send trunc and done\n<line3>    LOG.debug(\"Sending TRUNC to follower zxidToSend=0x{} for peer sid:{}\", Long.toHexString(maxCommittedLog), getSid());\n<line4>    queueOpPacket(Leader.TRUNC, maxCommittedLog);\n<line5>    currentZxid = maxCommittedLog;\n<line6>    needOpPacket = false;\n<line7>    needSnap = false;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    // Follower is within commitLog range\n<line3>    Iterator<Proposal> itr = db.getCommittedLog().iterator();\n<line4>    currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);\n<line5>    needSnap = false;\n<line6>}","output":"<line1>{\n<line2>    // Follower is within commitLog range\n<line3>    LOG.info(\"Using committedLog for peer sid: {}\", getSid());\n<line4>    Iterator<Proposal> itr = db.getCommittedLog().iterator();\n<line5>    currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);\n<line6>    needSnap = false;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    // Use txnlog and committedLog to sync\n<line3>    // Calculate sizeLimit that we allow to retrieve txnlog from disk\n<line4>    long sizeLimit = db.calculateTxnLogSizeLimit();\n<line5>    // This method can return empty iterator if the requested zxid\n<line6>    // is older than on-disk txnlog\n<line7>    Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);\n<line8>    if (txnLogItr.hasNext()) {\n<line9>        currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line10>        if (currentZxid < minCommittedLog) {\n<line11>            currentZxid = peerLastZxid;\n<line12>            // Clear out currently queued requests and revert\n<line13>            // to sending a snapshot.\n<line14>            queuedPackets.clear();\n<line15>            needOpPacket = true;\n<line16>        } else {\n<line17>            Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line18>            currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line19>            needSnap = false;\n<line20>        }\n<line21>    }\n<line22>    // closing the resources\n<line23>    if (txnLogItr instanceof TxnLogProposalIterator) {\n<line24>        TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n<line25>        txnProposalItr.close();\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    // Use txnlog and committedLog to sync\n<line3>    // Calculate sizeLimit that we allow to retrieve txnlog from disk\n<line4>    long sizeLimit = db.calculateTxnLogSizeLimit();\n<line5>    // This method can return empty iterator if the requested zxid\n<line6>    // is older than on-disk txnlog\n<line7>    Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);\n<line8>    if (txnLogItr.hasNext()) {\n<line9>        LOG.info(\"Use txnlog and committedLog for peer sid: {}\", getSid());\n<line10>        currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line11>        if (currentZxid < minCommittedLog) {\n<line12>            LOG.info(\"Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}\", Long.toHexString(currentZxid), Long.toHexString(minCommittedLog));\n<line13>            currentZxid = peerLastZxid;\n<line14>            // Clear out currently queued requests and revert\n<line15>            // to sending a snapshot.\n<line16>            queuedPackets.clear();\n<line17>            needOpPacket = true;\n<line18>        } else {\n<line19>            LOG.debug(\"Queueing committedLog 0x{}\", Long.toHexString(currentZxid));\n<line20>            Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line21>            currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line22>            needSnap = false;\n<line23>        }\n<line24>    }\n<line25>    // closing the resources\n<line26>    if (txnLogItr instanceof TxnLogProposalIterator) {\n<line27>        TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n<line28>        txnProposalItr.close();\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line3>    if (currentZxid < minCommittedLog) {\n<line4>        currentZxid = peerLastZxid;\n<line5>        // Clear out currently queued requests and revert\n<line6>        // to sending a snapshot.\n<line7>        queuedPackets.clear();\n<line8>        needOpPacket = true;\n<line9>    } else {\n<line10>        Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line11>        currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line12>        needSnap = false;\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    LOG.info(\"Use txnlog and committedLog for peer sid: {}\", getSid());\n<line3>    currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);\n<line4>    if (currentZxid < minCommittedLog) {\n<line5>        LOG.info(\"Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}\", Long.toHexString(currentZxid), Long.toHexString(minCommittedLog));\n<line6>        currentZxid = peerLastZxid;\n<line7>        // Clear out currently queued requests and revert\n<line8>        // to sending a snapshot.\n<line9>        queuedPackets.clear();\n<line10>        needOpPacket = true;\n<line11>    } else {\n<line12>        LOG.debug(\"Queueing committedLog 0x{}\", Long.toHexString(currentZxid));\n<line13>        Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line14>        currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line15>        needSnap = false;\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    currentZxid = peerLastZxid;\n<line3>    // Clear out currently queued requests and revert\n<line4>    // to sending a snapshot.\n<line5>    queuedPackets.clear();\n<line6>    needOpPacket = true;\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}\", Long.toHexString(currentZxid), Long.toHexString(minCommittedLog));\n<line3>    currentZxid = peerLastZxid;\n<line4>    // Clear out currently queued requests and revert\n<line5>    // to sending a snapshot.\n<line6>    queuedPackets.clear();\n<line7>    needOpPacket = true;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line3>    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line4>    needSnap = false;\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(\"Queueing committedLog 0x{}\", Long.toHexString(currentZxid));\n<line3>    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n<line4>    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);\n<line5>    needSnap = false;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    // This should never happen, but we should fall back to sending\n<line3>    // snapshot just in case.\n<line4>    needSnap = true;\n<line5>}","output":"<line1>{\n<line2>    // This should never happen, but we should fall back to sending\n<line3>    // snapshot just in case.\n<line4>    LOG.error(\"Unhandled scenario for peer sid: {} fall back to use snapshot\", getSid());\n<line5>    needSnap = true;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;\n<line3>    long queuedZxid = peerLastZxid;\n<line4>    // as we look through proposals, this variable keeps track of previous\n<line5>    // proposal Id.\n<line6>    long prevProposalZxid = -1;\n<line7>    while (itr.hasNext()) {\n<line8>        Proposal propose = itr.next();\n<line9>        long packetZxid = propose.getZxid();\n<line10>        // abort if we hit the limit\n<line11>        if ((maxZxid != null) && (packetZxid > maxZxid)) {\n<line12>            break;\n<line13>        }\n<line14>        // skip the proposals the peer already has\n<line15>        if (packetZxid < peerLastZxid) {\n<line16>            prevProposalZxid = packetZxid;\n<line17>            continue;\n<line18>        }\n<line19>        // If we are sending the first packet, figure out whether to trunc\n<line20>        // or diff\n<line21>        if (needOpPacket) {\n<line22>            // Send diff when we see the follower's zxid in our history\n<line23>            if (packetZxid == peerLastZxid) {\n<line24>                queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line25>                needOpPacket = false;\n<line26>                continue;\n<line27>            }\n<line28>            if (isPeerNewEpochZxid) {\n<line29>                // Send diff and fall through if zxid is of a new-epoch\n<line30>                queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line31>                needOpPacket = false;\n<line32>            } else if (packetZxid > peerLastZxid) {\n<line33>                // Peer have some proposals that the learnerMaster hasn't seen yet\n<line34>                // it may used to be a leader\n<line35>                if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line36>                    // We cannot send TRUNC that cross epoch boundary.\n<line37>                    // The learner will crash if it is asked to do so.\n<line38>                    // We will send snapshot this those cases.\n<line39>                    return queuedZxid;\n<line40>                }\n<line41>                queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line42>                needOpPacket = false;\n<line43>            }\n<line44>        }\n<line45>        if (packetZxid <= queuedZxid) {\n<line46>            // We can get here, if we don't have op packet to queue\n<line47>            // or there is a duplicate txn in a given iterator\n<line48>            continue;\n<line49>        }\n<line50>        // Since this is already a committed proposal, we need to follow\n<line51>        // it by a commit packet\n<line52>        queuePacket(propose.getQuorumPacket());\n<line53>        queueOpPacket(Leader.COMMIT, packetZxid);\n<line54>        queuedZxid = packetZxid;\n<line55>    }\n<line56>    if (needOpPacket && isPeerNewEpochZxid) {\n<line57>        // We will send DIFF for this kind of zxid in any case. This if-block\n<line58>        // is the catch when our history older than learner and there is\n<line59>        // no new txn since then. So we need an empty diff\n<line60>        queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line61>        needOpPacket = false;\n<line62>    }\n<line63>    return queuedZxid;\n<line64>}","output":"<line1>{\n<line2>    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;\n<line3>    long queuedZxid = peerLastZxid;\n<line4>    // as we look through proposals, this variable keeps track of previous\n<line5>    // proposal Id.\n<line6>    long prevProposalZxid = -1;\n<line7>    while (itr.hasNext()) {\n<line8>        Proposal propose = itr.next();\n<line9>        long packetZxid = propose.getZxid();\n<line10>        // abort if we hit the limit\n<line11>        if ((maxZxid != null) && (packetZxid > maxZxid)) {\n<line12>            break;\n<line13>        }\n<line14>        // skip the proposals the peer already has\n<line15>        if (packetZxid < peerLastZxid) {\n<line16>            prevProposalZxid = packetZxid;\n<line17>            continue;\n<line18>        }\n<line19>        // If we are sending the first packet, figure out whether to trunc\n<line20>        // or diff\n<line21>        if (needOpPacket) {\n<line22>            // Send diff when we see the follower's zxid in our history\n<line23>            if (packetZxid == peerLastZxid) {\n<line24>                LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line25>                queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line26>                needOpPacket = false;\n<line27>                continue;\n<line28>            }\n<line29>            if (isPeerNewEpochZxid) {\n<line30>                // Send diff and fall through if zxid is of a new-epoch\n<line31>                LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line32>                queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line33>                needOpPacket = false;\n<line34>            } else if (packetZxid > peerLastZxid) {\n<line35>                // Peer have some proposals that the learnerMaster hasn't seen yet\n<line36>                // it may used to be a leader\n<line37>                if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line38>                    // We cannot send TRUNC that cross epoch boundary.\n<line39>                    // The learner will crash if it is asked to do so.\n<line40>                    // We will send snapshot this those cases.\n<line41>                    LOG.warn(\"Cannot send TRUNC to peer sid: \" + getSid() + \" peer zxid is from different epoch\");\n<line42>                    return queuedZxid;\n<line43>                }\n<line44>                LOG.info(\"Sending TRUNC zxid=0x{}  for peer sid: {}\", Long.toHexString(prevProposalZxid), getSid());\n<line45>                queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line46>                needOpPacket = false;\n<line47>            }\n<line48>        }\n<line49>        if (packetZxid <= queuedZxid) {\n<line50>            // We can get here, if we don't have op packet to queue\n<line51>            // or there is a duplicate txn in a given iterator\n<line52>            continue;\n<line53>        }\n<line54>        // Since this is already a committed proposal, we need to follow\n<line55>        // it by a commit packet\n<line56>        queuePacket(propose.getQuorumPacket());\n<line57>        queueOpPacket(Leader.COMMIT, packetZxid);\n<line58>        queuedZxid = packetZxid;\n<line59>    }\n<line60>    if (needOpPacket && isPeerNewEpochZxid) {\n<line61>        // We will send DIFF for this kind of zxid in any case. This if-block\n<line62>        // is the catch when our history older than learner and there is\n<line63>        // no new txn since then. So we need an empty diff\n<line64>        LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line65>        queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line66>        needOpPacket = false;\n<line67>    }\n<line68>    return queuedZxid;\n<line69>}"},{"input":"","instruction":"<line1>{\n<line2>    Proposal propose = itr.next();\n<line3>    long packetZxid = propose.getZxid();\n<line4>    // abort if we hit the limit\n<line5>    if ((maxZxid != null) && (packetZxid > maxZxid)) {\n<line6>        break;\n<line7>    }\n<line8>    // skip the proposals the peer already has\n<line9>    if (packetZxid < peerLastZxid) {\n<line10>        prevProposalZxid = packetZxid;\n<line11>        continue;\n<line12>    }\n<line13>    // If we are sending the first packet, figure out whether to trunc\n<line14>    // or diff\n<line15>    if (needOpPacket) {\n<line16>        // Send diff when we see the follower's zxid in our history\n<line17>        if (packetZxid == peerLastZxid) {\n<line18>            queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line19>            needOpPacket = false;\n<line20>            continue;\n<line21>        }\n<line22>        if (isPeerNewEpochZxid) {\n<line23>            // Send diff and fall through if zxid is of a new-epoch\n<line24>            queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line25>            needOpPacket = false;\n<line26>        } else if (packetZxid > peerLastZxid) {\n<line27>            // Peer have some proposals that the learnerMaster hasn't seen yet\n<line28>            // it may used to be a leader\n<line29>            if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line30>                // We cannot send TRUNC that cross epoch boundary.\n<line31>                // The learner will crash if it is asked to do so.\n<line32>                // We will send snapshot this those cases.\n<line33>                return queuedZxid;\n<line34>            }\n<line35>            queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line36>            needOpPacket = false;\n<line37>        }\n<line38>    }\n<line39>    if (packetZxid <= queuedZxid) {\n<line40>        // We can get here, if we don't have op packet to queue\n<line41>        // or there is a duplicate txn in a given iterator\n<line42>        continue;\n<line43>    }\n<line44>    // Since this is already a committed proposal, we need to follow\n<line45>    // it by a commit packet\n<line46>    queuePacket(propose.getQuorumPacket());\n<line47>    queueOpPacket(Leader.COMMIT, packetZxid);\n<line48>    queuedZxid = packetZxid;\n<line49>}","output":"<line1>{\n<line2>    Proposal propose = itr.next();\n<line3>    long packetZxid = propose.getZxid();\n<line4>    // abort if we hit the limit\n<line5>    if ((maxZxid != null) && (packetZxid > maxZxid)) {\n<line6>        break;\n<line7>    }\n<line8>    // skip the proposals the peer already has\n<line9>    if (packetZxid < peerLastZxid) {\n<line10>        prevProposalZxid = packetZxid;\n<line11>        continue;\n<line12>    }\n<line13>    // If we are sending the first packet, figure out whether to trunc\n<line14>    // or diff\n<line15>    if (needOpPacket) {\n<line16>        // Send diff when we see the follower's zxid in our history\n<line17>        if (packetZxid == peerLastZxid) {\n<line18>            LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line19>            queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line20>            needOpPacket = false;\n<line21>            continue;\n<line22>        }\n<line23>        if (isPeerNewEpochZxid) {\n<line24>            // Send diff and fall through if zxid is of a new-epoch\n<line25>            LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line26>            queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line27>            needOpPacket = false;\n<line28>        } else if (packetZxid > peerLastZxid) {\n<line29>            // Peer have some proposals that the learnerMaster hasn't seen yet\n<line30>            // it may used to be a leader\n<line31>            if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line32>                // We cannot send TRUNC that cross epoch boundary.\n<line33>                // The learner will crash if it is asked to do so.\n<line34>                // We will send snapshot this those cases.\n<line35>                LOG.warn(\"Cannot send TRUNC to peer sid: \" + getSid() + \" peer zxid is from different epoch\");\n<line36>                return queuedZxid;\n<line37>            }\n<line38>            LOG.info(\"Sending TRUNC zxid=0x{}  for peer sid: {}\", Long.toHexString(prevProposalZxid), getSid());\n<line39>            queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line40>            needOpPacket = false;\n<line41>        }\n<line42>    }\n<line43>    if (packetZxid <= queuedZxid) {\n<line44>        // We can get here, if we don't have op packet to queue\n<line45>        // or there is a duplicate txn in a given iterator\n<line46>        continue;\n<line47>    }\n<line48>    // Since this is already a committed proposal, we need to follow\n<line49>    // it by a commit packet\n<line50>    queuePacket(propose.getQuorumPacket());\n<line51>    queueOpPacket(Leader.COMMIT, packetZxid);\n<line52>    queuedZxid = packetZxid;\n<line53>}"},{"input":"","instruction":"<line1>{\n<line2>    // Send diff when we see the follower's zxid in our history\n<line3>    if (packetZxid == peerLastZxid) {\n<line4>        queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line5>        needOpPacket = false;\n<line6>        continue;\n<line7>    }\n<line8>    if (isPeerNewEpochZxid) {\n<line9>        // Send diff and fall through if zxid is of a new-epoch\n<line10>        queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line11>        needOpPacket = false;\n<line12>    } else if (packetZxid > peerLastZxid) {\n<line13>        // Peer have some proposals that the learnerMaster hasn't seen yet\n<line14>        // it may used to be a leader\n<line15>        if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line16>            // We cannot send TRUNC that cross epoch boundary.\n<line17>            // The learner will crash if it is asked to do so.\n<line18>            // We will send snapshot this those cases.\n<line19>            return queuedZxid;\n<line20>        }\n<line21>        queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line22>        needOpPacket = false;\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    // Send diff when we see the follower's zxid in our history\n<line3>    if (packetZxid == peerLastZxid) {\n<line4>        LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line5>        queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line6>        needOpPacket = false;\n<line7>        continue;\n<line8>    }\n<line9>    if (isPeerNewEpochZxid) {\n<line10>        // Send diff and fall through if zxid is of a new-epoch\n<line11>        LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line12>        queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line13>        needOpPacket = false;\n<line14>    } else if (packetZxid > peerLastZxid) {\n<line15>        // Peer have some proposals that the learnerMaster hasn't seen yet\n<line16>        // it may used to be a leader\n<line17>        if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line18>            // We cannot send TRUNC that cross epoch boundary.\n<line19>            // The learner will crash if it is asked to do so.\n<line20>            // We will send snapshot this those cases.\n<line21>            LOG.warn(\"Cannot send TRUNC to peer sid: \" + getSid() + \" peer zxid is from different epoch\");\n<line22>            return queuedZxid;\n<line23>        }\n<line24>        LOG.info(\"Sending TRUNC zxid=0x{}  for peer sid: {}\", Long.toHexString(prevProposalZxid), getSid());\n<line25>        queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line26>        needOpPacket = false;\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line3>    needOpPacket = false;\n<line4>    continue;\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line3>    queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line4>    needOpPacket = false;\n<line5>    continue;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    // Send diff and fall through if zxid is of a new-epoch\n<line3>    queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line4>    needOpPacket = false;\n<line5>}","output":"<line1>{\n<line2>    // Send diff and fall through if zxid is of a new-epoch\n<line3>    LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line4>    queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line5>    needOpPacket = false;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    // Peer have some proposals that the learnerMaster hasn't seen yet\n<line3>    // it may used to be a leader\n<line4>    if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line5>        // We cannot send TRUNC that cross epoch boundary.\n<line6>        // The learner will crash if it is asked to do so.\n<line7>        // We will send snapshot this those cases.\n<line8>        return queuedZxid;\n<line9>    }\n<line10>    queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line11>    needOpPacket = false;\n<line12>}","output":"<line1>{\n<line2>    // Peer have some proposals that the learnerMaster hasn't seen yet\n<line3>    // it may used to be a leader\n<line4>    if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {\n<line5>        // We cannot send TRUNC that cross epoch boundary.\n<line6>        // The learner will crash if it is asked to do so.\n<line7>        // We will send snapshot this those cases.\n<line8>        LOG.warn(\"Cannot send TRUNC to peer sid: \" + getSid() + \" peer zxid is from different epoch\");\n<line9>        return queuedZxid;\n<line10>    }\n<line11>    LOG.info(\"Sending TRUNC zxid=0x{}  for peer sid: {}\", Long.toHexString(prevProposalZxid), getSid());\n<line12>    queueOpPacket(Leader.TRUNC, prevProposalZxid);\n<line13>    needOpPacket = false;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    // We will send DIFF for this kind of zxid in any case. This if-block\n<line3>    // is the catch when our history older than learner and there is\n<line4>    // no new txn since then. So we need an empty diff\n<line5>    queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line6>    needOpPacket = false;\n<line7>}","output":"<line1>{\n<line2>    // We will send DIFF for this kind of zxid in any case. This if-block\n<line3>    // is the catch when our history older than learner and there is\n<line4>    // no new txn since then. So we need an empty diff\n<line5>    LOG.info(\"Sending DIFF zxid=0x{}  for peer sid: {}\", Long.toHexString(lastCommittedZxid), getSid());\n<line6>    queueOpPacket(Leader.DIFF, lastCommittedZxid);\n<line7>    needOpPacket = false;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sock != null && !sock.isClosed() && sockBeingClosed.compareAndSet(false, true)) {\n<line3>        if (closeSocketAsync) {\n<line4>            closeSockAsync();\n<line5>        } else {\n<line6>            closeSockSync();\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (sock != null && !sock.isClosed() && sockBeingClosed.compareAndSet(false, true)) {\n<line3>        if (closeSocketAsync) {\n<line4>            LOG.info(\"Asynchronously closing socket to learner {}.\", getSid());\n<line5>            closeSockAsync();\n<line6>        } else {\n<line7>            LOG.info(\"Synchronously closing socket to learner {}.\", getSid());\n<line8>            closeSockSync();\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (closeSocketAsync) {\n<line3>        closeSockAsync();\n<line4>    } else {\n<line5>        closeSockSync();\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (closeSocketAsync) {\n<line3>        LOG.info(\"Asynchronously closing socket to learner {}.\", getSid());\n<line4>        closeSockAsync();\n<line5>    } else {\n<line6>        LOG.info(\"Synchronously closing socket to learner {}.\", getSid());\n<line7>        closeSockSync();\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSockAsync();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Asynchronously closing socket to learner {}.\", getSid());\n<line3>    closeSockAsync();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    closeSockSync();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Synchronously closing socket to learner {}.\", getSid());\n<line3>    closeSockSync();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(path);\n<line4>        Properties cfg = new Properties();\n<line5>        try (FileInputStream in = new FileInputStream(configFile)) {\n<line6>            cfg.load(in);\n<line7>            configFileStr = path;\n<line8>        }\n<line9>        /* Read entire config file as initial configuration */\n<line10>        initialConfig = new String(Files.readAllBytes(configFile.toPath()));\n<line11>        parseProperties(cfg);\n<line12>    } catch (IOException e) {\n<line13>        throw new ConfigException(\"Error processing \" + path, e);\n<line14>    } catch (IllegalArgumentException e) {\n<line15>        throw new ConfigException(\"Error processing \" + path, e);\n<line16>    }\n<line17>    if (dynamicConfigFileStr != null) {\n<line18>        try {\n<line19>            Properties dynamicCfg = new Properties();\n<line20>            try (FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr)) {\n<line21>                dynamicCfg.load(inConfig);\n<line22>                if (dynamicCfg.getProperty(\"version\") != null) {\n<line23>                    throw new ConfigException(\"dynamic file shouldn't have version inside\");\n<line24>                }\n<line25>                String version = getVersionFromFilename(dynamicConfigFileStr);\n<line26>                // If there isn't any version associated with the filename,\n<line27>                // the default version is 0.\n<line28>                if (version != null) {\n<line29>                    dynamicCfg.setProperty(\"version\", version);\n<line30>                }\n<line31>            }\n<line32>            setupQuorumPeerConfig(dynamicCfg, false);\n<line33>        } catch (IOException e) {\n<line34>            throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n<line35>        } catch (IllegalArgumentException e) {\n<line36>            throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n<line37>        }\n<line38>        File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);\n<line39>        if (nextDynamicConfigFile.exists()) {\n<line40>            try {\n<line41>                Properties dynamicConfigNextCfg = new Properties();\n<line42>                try (FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile)) {\n<line43>                    dynamicConfigNextCfg.load(inConfigNext);\n<line44>                }\n<line45>                boolean isHierarchical = false;\n<line46>                for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {\n<line47>                    String key = entry.getKey().toString().trim();\n<line48>                    if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n<line49>                        isHierarchical = true;\n<line50>                        break;\n<line51>                    }\n<line52>                }\n<line53>                lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);\n<line54>            } catch (IOException e) {\n<line55>            }\n<line56>        }\n<line57>    }\n<line58>}","output":"<line1>{\n<line2>    LOG.info(\"Reading configuration from: \" + path);\n<line3>    try {\n<line4>        File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(path);\n<line5>        Properties cfg = new Properties();\n<line6>        try (FileInputStream in = new FileInputStream(configFile)) {\n<line7>            cfg.load(in);\n<line8>            configFileStr = path;\n<line9>        }\n<line10>        /* Read entire config file as initial configuration */\n<line11>        initialConfig = new String(Files.readAllBytes(configFile.toPath()));\n<line12>        parseProperties(cfg);\n<line13>    } catch (IOException e) {\n<line14>        throw new ConfigException(\"Error processing \" + path, e);\n<line15>    } catch (IllegalArgumentException e) {\n<line16>        throw new ConfigException(\"Error processing \" + path, e);\n<line17>    }\n<line18>    if (dynamicConfigFileStr != null) {\n<line19>        try {\n<line20>            Properties dynamicCfg = new Properties();\n<line21>            try (FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr)) {\n<line22>                dynamicCfg.load(inConfig);\n<line23>                if (dynamicCfg.getProperty(\"version\") != null) {\n<line24>                    throw new ConfigException(\"dynamic file shouldn't have version inside\");\n<line25>                }\n<line26>                String version = getVersionFromFilename(dynamicConfigFileStr);\n<line27>                // If there isn't any version associated with the filename,\n<line28>                // the default version is 0.\n<line29>                if (version != null) {\n<line30>                    dynamicCfg.setProperty(\"version\", version);\n<line31>                }\n<line32>            }\n<line33>            setupQuorumPeerConfig(dynamicCfg, false);\n<line34>        } catch (IOException e) {\n<line35>            throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n<line36>        } catch (IllegalArgumentException e) {\n<line37>            throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n<line38>        }\n<line39>        File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);\n<line40>        if (nextDynamicConfigFile.exists()) {\n<line41>            try {\n<line42>                Properties dynamicConfigNextCfg = new Properties();\n<line43>                try (FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile)) {\n<line44>                    dynamicConfigNextCfg.load(inConfigNext);\n<line45>                }\n<line46>                boolean isHierarchical = false;\n<line47>                for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {\n<line48>                    String key = entry.getKey().toString().trim();\n<line49>                    if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n<line50>                        isHierarchical = true;\n<line51>                        break;\n<line52>                    }\n<line53>                }\n<line54>                lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);\n<line55>            } catch (IOException e) {\n<line56>                LOG.warn(\"NextQuorumVerifier is initiated to null\");\n<line57>            }\n<line58>        }\n<line59>    }\n<line60>}"},{"input":"","instruction":"<line1>{\n<line2>    Integer clientPort = null;\n<line3>    Integer secureClientPort = null;\n<line4>    int observerMasterPort = 0;\n<line5>    String clientPortAddress = null;\n<line6>    String secureClientPortAddress = null;\n<line7>    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n<line8>    for (Entry<Object, Object> entry : zkProp.entrySet()) {\n<line9>        String key = entry.getKey().toString().trim();\n<line10>        String value = entry.getValue().toString().trim();\n<line11>        if (key.equals(\"dataDir\")) {\n<line12>            dataDir = vff.create(value);\n<line13>        } else if (key.equals(\"dataLogDir\")) {\n<line14>            dataLogDir = vff.create(value);\n<line15>        } else if (key.equals(\"clientPort\")) {\n<line16>            clientPort = Integer.parseInt(value);\n<line17>        } else if (key.equals(\"localSessionsEnabled\")) {\n<line18>            localSessionsEnabled = parseBoolean(key, value);\n<line19>        } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n<line20>            localSessionsUpgradingEnabled = parseBoolean(key, value);\n<line21>        } else if (key.equals(\"clientPortAddress\")) {\n<line22>            clientPortAddress = value.trim();\n<line23>        } else if (key.equals(\"secureClientPort\")) {\n<line24>            secureClientPort = Integer.parseInt(value);\n<line25>        } else if (key.equals(\"secureClientPortAddress\")) {\n<line26>            secureClientPortAddress = value.trim();\n<line27>        } else if (key.equals(\"observerMasterPort\")) {\n<line28>            observerMasterPort = Integer.parseInt(value);\n<line29>        } else if (key.equals(\"clientPortListenBacklog\")) {\n<line30>            clientPortListenBacklog = Integer.parseInt(value);\n<line31>        } else if (key.equals(\"tickTime\")) {\n<line32>            tickTime = Integer.parseInt(value);\n<line33>        } else if (key.equals(\"maxClientCnxns\")) {\n<line34>            maxClientCnxns = Integer.parseInt(value);\n<line35>        } else if (key.equals(\"minSessionTimeout\")) {\n<line36>            minSessionTimeout = Integer.parseInt(value);\n<line37>        } else if (key.equals(\"maxSessionTimeout\")) {\n<line38>            maxSessionTimeout = Integer.parseInt(value);\n<line39>        } else if (key.equals(\"initLimit\")) {\n<line40>            initLimit = Integer.parseInt(value);\n<line41>        } else if (key.equals(\"syncLimit\")) {\n<line42>            syncLimit = Integer.parseInt(value);\n<line43>        } else if (key.equals(\"connectToLearnerMasterLimit\")) {\n<line44>            connectToLearnerMasterLimit = Integer.parseInt(value);\n<line45>        } else if (key.equals(\"electionAlg\")) {\n<line46>            electionAlg = Integer.parseInt(value);\n<line47>            if (electionAlg != 3) {\n<line48>                throw new ConfigException(\"Invalid electionAlg value. Only 3 is supported.\");\n<line49>            }\n<line50>        } else if (key.equals(\"quorumListenOnAllIPs\")) {\n<line51>            quorumListenOnAllIPs = parseBoolean(key, value);\n<line52>        } else if (key.equals(\"peerType\")) {\n<line53>            if (value.toLowerCase().equals(\"observer\")) {\n<line54>                peerType = LearnerType.OBSERVER;\n<line55>            } else if (value.toLowerCase().equals(\"participant\")) {\n<line56>                peerType = LearnerType.PARTICIPANT;\n<line57>            } else {\n<line58>                throw new ConfigException(\"Unrecognised peertype: \" + value);\n<line59>            }\n<line60>        } else if (key.equals(\"syncEnabled\")) {\n<line61>            syncEnabled = parseBoolean(key, value);\n<line62>        } else if (key.equals(\"dynamicConfigFile\")) {\n<line63>            dynamicConfigFileStr = value;\n<line64>        } else if (key.equals(\"autopurge.snapRetainCount\")) {\n<line65>            snapRetainCount = Integer.parseInt(value);\n<line66>        } else if (key.equals(\"autopurge.purgeInterval\")) {\n<line67>            purgeInterval = Integer.parseInt(value);\n<line68>        } else if (key.equals(\"standaloneEnabled\")) {\n<line69>            setStandaloneEnabled(parseBoolean(key, value));\n<line70>        } else if (key.equals(\"reconfigEnabled\")) {\n<line71>            setReconfigEnabled(parseBoolean(key, value));\n<line72>        } else if (key.equals(\"sslQuorum\")) {\n<line73>            sslQuorum = parseBoolean(key, value);\n<line74>        } else if (key.equals(\"portUnification\")) {\n<line75>            shouldUsePortUnification = parseBoolean(key, value);\n<line76>        } else if (key.equals(\"sslQuorumReloadCertFiles\")) {\n<line77>            sslQuorumReloadCertFiles = parseBoolean(key, value);\n<line78>        } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n<line79>            throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n<line80>        } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {\n<line81>            quorumEnableSasl = parseBoolean(key, value);\n<line82>        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {\n<line83>            quorumServerRequireSasl = parseBoolean(key, value);\n<line84>        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {\n<line85>            quorumLearnerRequireSasl = parseBoolean(key, value);\n<line86>        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {\n<line87>            quorumLearnerLoginContext = value;\n<line88>        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {\n<line89>            quorumServerLoginContext = value;\n<line90>        } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {\n<line91>            quorumServicePrincipal = value;\n<line92>        } else if (key.equals(\"quorum.cnxn.threads.size\")) {\n<line93>            quorumCnxnThreadsSize = Integer.parseInt(value);\n<line94>        } else if (key.equals(JvmPauseMonitor.INFO_THRESHOLD_KEY)) {\n<line95>            jvmPauseInfoThresholdMs = Long.parseLong(value);\n<line96>        } else if (key.equals(JvmPauseMonitor.WARN_THRESHOLD_KEY)) {\n<line97>            jvmPauseWarnThresholdMs = Long.parseLong(value);\n<line98>        } else if (key.equals(JvmPauseMonitor.SLEEP_TIME_MS_KEY)) {\n<line99>            jvmPauseSleepTimeMs = Long.parseLong(value);\n<line100>        } else if (key.equals(JvmPauseMonitor.JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY)) {\n<line101>            jvmPauseMonitorToRun = parseBoolean(key, value);\n<line102>        } else if (key.equals(\"metricsProvider.className\")) {\n<line103>            metricsProviderClassName = value;\n<line104>        } else if (key.startsWith(\"metricsProvider.\")) {\n<line105>            String keyForMetricsProvider = key.substring(16);\n<line106>            metricsProviderConfiguration.put(keyForMetricsProvider, value);\n<line107>        } else if (key.equals(\"multiAddress.enabled\")) {\n<line108>            multiAddressEnabled = parseBoolean(key, value);\n<line109>        } else if (key.equals(\"multiAddress.reachabilityCheckTimeoutMs\")) {\n<line110>            multiAddressReachabilityCheckTimeoutMs = Integer.parseInt(value);\n<line111>        } else if (key.equals(\"multiAddress.reachabilityCheckEnabled\")) {\n<line112>            multiAddressReachabilityCheckEnabled = parseBoolean(key, value);\n<line113>        } else if (key.equals(\"oraclePath\")) {\n<line114>            oraclePath = value;\n<line115>        } else {\n<line116>            System.setProperty(\"zookeeper.\" + key, value);\n<line117>        }\n<line118>    }\n<line119>    if (!quorumEnableSasl && quorumServerRequireSasl) {\n<line120>        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + \" is disabled, so cannot enable \" + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n<line121>    }\n<line122>    if (!quorumEnableSasl && quorumLearnerRequireSasl) {\n<line123>        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + \" is disabled, so cannot enable \" + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);\n<line124>    }\n<line125>    // If quorumpeer learner is not auth enabled then self won't be able to\n<line126>    // join quorum. So this condition is ensuring that the quorumpeer learner\n<line127>    // is also auth enabled while enabling quorum server require sasl.\n<line128>    if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {\n<line129>        throw new IllegalArgumentException(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED + \" is disabled, so cannot enable \" + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n<line130>    }\n<line131>    // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n<line132>    // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n<line133>    // than 3.\n<line134>    if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n<line135>        snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n<line136>    }\n<line137>    if (dataDir == null) {\n<line138>        throw new IllegalArgumentException(\"dataDir is not set\");\n<line139>    }\n<line140>    if (dataLogDir == null) {\n<line141>        dataLogDir = dataDir;\n<line142>    }\n<line143>    if (clientPort == null) {\n<line144>        if (clientPortAddress != null) {\n<line145>            throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n<line146>        }\n<line147>    } else if (clientPortAddress != null) {\n<line148>        this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);\n<line149>    } else {\n<line150>        this.clientPortAddress = new InetSocketAddress(clientPort);\n<line151>    }\n<line152>    if (secureClientPort == null) {\n<line153>        if (secureClientPortAddress != null) {\n<line154>            throw new IllegalArgumentException(\"secureClientPortAddress is set but secureClientPort is not set\");\n<line155>        }\n<line156>    } else if (secureClientPortAddress != null) {\n<line157>        this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);\n<line158>    } else {\n<line159>        this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n<line160>    }\n<line161>    if (this.secureClientPortAddress != null) {\n<line162>        configureSSLAuth();\n<line163>    }\n<line164>    if (observerMasterPort <= 0) {\n<line165>    } else {\n<line166>        this.observerMasterPort = observerMasterPort;\n<line167>    }\n<line168>    if (tickTime == 0) {\n<line169>        throw new IllegalArgumentException(\"tickTime is not set\");\n<line170>    }\n<line171>    minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n<line172>    maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n<line173>    if (minSessionTimeout > maxSessionTimeout) {\n<line174>        throw new IllegalArgumentException(\"minSessionTimeout must not be larger than maxSessionTimeout\");\n<line175>    }\n<line176>    try {\n<line177>        Class.forName(metricsProviderClassName, false, Thread.currentThread().getContextClassLoader());\n<line178>    } catch (ClassNotFoundException error) {\n<line179>        throw new IllegalArgumentException(\"metrics provider class was not found\", error);\n<line180>    }\n<line181>    // backward compatibility - dynamic configuration in the same file as\n<line182>    // static configuration params see writeDynamicConfig()\n<line183>    if (dynamicConfigFileStr == null) {\n<line184>        setupQuorumPeerConfig(zkProp, true);\n<line185>        if (isDistributed() && isReconfigEnabled()) {\n<line186>            // we don't backup static config for standalone mode.\n<line187>            // we also don't backup if reconfig feature is disabled.\n<line188>            backupOldConfig();\n<line189>        }\n<line190>    }\n<line191>}","output":"<line1>{\n<line2>    Integer clientPort = null;\n<line3>    Integer secureClientPort = null;\n<line4>    int observerMasterPort = 0;\n<line5>    String clientPortAddress = null;\n<line6>    String secureClientPortAddress = null;\n<line7>    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n<line8>    for (Entry<Object, Object> entry : zkProp.entrySet()) {\n<line9>        String key = entry.getKey().toString().trim();\n<line10>        String value = entry.getValue().toString().trim();\n<line11>        if (key.equals(\"dataDir\")) {\n<line12>            dataDir = vff.create(value);\n<line13>        } else if (key.equals(\"dataLogDir\")) {\n<line14>            dataLogDir = vff.create(value);\n<line15>        } else if (key.equals(\"clientPort\")) {\n<line16>            clientPort = Integer.parseInt(value);\n<line17>        } else if (key.equals(\"localSessionsEnabled\")) {\n<line18>            localSessionsEnabled = parseBoolean(key, value);\n<line19>        } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n<line20>            localSessionsUpgradingEnabled = parseBoolean(key, value);\n<line21>        } else if (key.equals(\"clientPortAddress\")) {\n<line22>            clientPortAddress = value.trim();\n<line23>        } else if (key.equals(\"secureClientPort\")) {\n<line24>            secureClientPort = Integer.parseInt(value);\n<line25>        } else if (key.equals(\"secureClientPortAddress\")) {\n<line26>            secureClientPortAddress = value.trim();\n<line27>        } else if (key.equals(\"observerMasterPort\")) {\n<line28>            observerMasterPort = Integer.parseInt(value);\n<line29>        } else if (key.equals(\"clientPortListenBacklog\")) {\n<line30>            clientPortListenBacklog = Integer.parseInt(value);\n<line31>        } else if (key.equals(\"tickTime\")) {\n<line32>            tickTime = Integer.parseInt(value);\n<line33>        } else if (key.equals(\"maxClientCnxns\")) {\n<line34>            maxClientCnxns = Integer.parseInt(value);\n<line35>        } else if (key.equals(\"minSessionTimeout\")) {\n<line36>            minSessionTimeout = Integer.parseInt(value);\n<line37>        } else if (key.equals(\"maxSessionTimeout\")) {\n<line38>            maxSessionTimeout = Integer.parseInt(value);\n<line39>        } else if (key.equals(\"initLimit\")) {\n<line40>            initLimit = Integer.parseInt(value);\n<line41>        } else if (key.equals(\"syncLimit\")) {\n<line42>            syncLimit = Integer.parseInt(value);\n<line43>        } else if (key.equals(\"connectToLearnerMasterLimit\")) {\n<line44>            connectToLearnerMasterLimit = Integer.parseInt(value);\n<line45>        } else if (key.equals(\"electionAlg\")) {\n<line46>            electionAlg = Integer.parseInt(value);\n<line47>            if (electionAlg != 3) {\n<line48>                throw new ConfigException(\"Invalid electionAlg value. Only 3 is supported.\");\n<line49>            }\n<line50>        } else if (key.equals(\"quorumListenOnAllIPs\")) {\n<line51>            quorumListenOnAllIPs = parseBoolean(key, value);\n<line52>        } else if (key.equals(\"peerType\")) {\n<line53>            if (value.toLowerCase().equals(\"observer\")) {\n<line54>                peerType = LearnerType.OBSERVER;\n<line55>            } else if (value.toLowerCase().equals(\"participant\")) {\n<line56>                peerType = LearnerType.PARTICIPANT;\n<line57>            } else {\n<line58>                throw new ConfigException(\"Unrecognised peertype: \" + value);\n<line59>            }\n<line60>        } else if (key.equals(\"syncEnabled\")) {\n<line61>            syncEnabled = parseBoolean(key, value);\n<line62>        } else if (key.equals(\"dynamicConfigFile\")) {\n<line63>            dynamicConfigFileStr = value;\n<line64>        } else if (key.equals(\"autopurge.snapRetainCount\")) {\n<line65>            snapRetainCount = Integer.parseInt(value);\n<line66>        } else if (key.equals(\"autopurge.purgeInterval\")) {\n<line67>            purgeInterval = Integer.parseInt(value);\n<line68>        } else if (key.equals(\"standaloneEnabled\")) {\n<line69>            setStandaloneEnabled(parseBoolean(key, value));\n<line70>        } else if (key.equals(\"reconfigEnabled\")) {\n<line71>            setReconfigEnabled(parseBoolean(key, value));\n<line72>        } else if (key.equals(\"sslQuorum\")) {\n<line73>            sslQuorum = parseBoolean(key, value);\n<line74>        } else if (key.equals(\"portUnification\")) {\n<line75>            shouldUsePortUnification = parseBoolean(key, value);\n<line76>        } else if (key.equals(\"sslQuorumReloadCertFiles\")) {\n<line77>            sslQuorumReloadCertFiles = parseBoolean(key, value);\n<line78>        } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n<line79>            throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n<line80>        } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {\n<line81>            quorumEnableSasl = parseBoolean(key, value);\n<line82>        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {\n<line83>            quorumServerRequireSasl = parseBoolean(key, value);\n<line84>        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {\n<line85>            quorumLearnerRequireSasl = parseBoolean(key, value);\n<line86>        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {\n<line87>            quorumLearnerLoginContext = value;\n<line88>        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {\n<line89>            quorumServerLoginContext = value;\n<line90>        } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {\n<line91>            quorumServicePrincipal = value;\n<line92>        } else if (key.equals(\"quorum.cnxn.threads.size\")) {\n<line93>            quorumCnxnThreadsSize = Integer.parseInt(value);\n<line94>        } else if (key.equals(JvmPauseMonitor.INFO_THRESHOLD_KEY)) {\n<line95>            jvmPauseInfoThresholdMs = Long.parseLong(value);\n<line96>        } else if (key.equals(JvmPauseMonitor.WARN_THRESHOLD_KEY)) {\n<line97>            jvmPauseWarnThresholdMs = Long.parseLong(value);\n<line98>        } else if (key.equals(JvmPauseMonitor.SLEEP_TIME_MS_KEY)) {\n<line99>            jvmPauseSleepTimeMs = Long.parseLong(value);\n<line100>        } else if (key.equals(JvmPauseMonitor.JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY)) {\n<line101>            jvmPauseMonitorToRun = parseBoolean(key, value);\n<line102>        } else if (key.equals(\"metricsProvider.className\")) {\n<line103>            metricsProviderClassName = value;\n<line104>        } else if (key.startsWith(\"metricsProvider.\")) {\n<line105>            String keyForMetricsProvider = key.substring(16);\n<line106>            metricsProviderConfiguration.put(keyForMetricsProvider, value);\n<line107>        } else if (key.equals(\"multiAddress.enabled\")) {\n<line108>            multiAddressEnabled = parseBoolean(key, value);\n<line109>        } else if (key.equals(\"multiAddress.reachabilityCheckTimeoutMs\")) {\n<line110>            multiAddressReachabilityCheckTimeoutMs = Integer.parseInt(value);\n<line111>        } else if (key.equals(\"multiAddress.reachabilityCheckEnabled\")) {\n<line112>            multiAddressReachabilityCheckEnabled = parseBoolean(key, value);\n<line113>        } else if (key.equals(\"oraclePath\")) {\n<line114>            oraclePath = value;\n<line115>        } else {\n<line116>            System.setProperty(\"zookeeper.\" + key, value);\n<line117>        }\n<line118>    }\n<line119>    if (!quorumEnableSasl && quorumServerRequireSasl) {\n<line120>        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + \" is disabled, so cannot enable \" + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n<line121>    }\n<line122>    if (!quorumEnableSasl && quorumLearnerRequireSasl) {\n<line123>        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + \" is disabled, so cannot enable \" + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);\n<line124>    }\n<line125>    // If quorumpeer learner is not auth enabled then self won't be able to\n<line126>    // join quorum. So this condition is ensuring that the quorumpeer learner\n<line127>    // is also auth enabled while enabling quorum server require sasl.\n<line128>    if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {\n<line129>        throw new IllegalArgumentException(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED + \" is disabled, so cannot enable \" + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n<line130>    }\n<line131>    // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n<line132>    // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n<line133>    // than 3.\n<line134>    if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n<line135>        LOG.warn(\"Invalid autopurge.snapRetainCount: \" + snapRetainCount + \". Defaulting to \" + MIN_SNAP_RETAIN_COUNT);\n<line136>        snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n<line137>    }\n<line138>    if (dataDir == null) {\n<line139>        throw new IllegalArgumentException(\"dataDir is not set\");\n<line140>    }\n<line141>    if (dataLogDir == null) {\n<line142>        dataLogDir = dataDir;\n<line143>    }\n<line144>    if (clientPort == null) {\n<line145>        LOG.info(\"clientPort is not set\");\n<line146>        if (clientPortAddress != null) {\n<line147>            throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n<line148>        }\n<line149>    } else if (clientPortAddress != null) {\n<line150>        this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);\n<line151>        LOG.info(\"clientPortAddress is {}\", formatInetAddr(this.clientPortAddress));\n<line152>    } else {\n<line153>        this.clientPortAddress = new InetSocketAddress(clientPort);\n<line154>        LOG.info(\"clientPortAddress is {}\", formatInetAddr(this.clientPortAddress));\n<line155>    }\n<line156>    if (secureClientPort == null) {\n<line157>        LOG.info(\"secureClientPort is not set\");\n<line158>        if (secureClientPortAddress != null) {\n<line159>            throw new IllegalArgumentException(\"secureClientPortAddress is set but secureClientPort is not set\");\n<line160>        }\n<line161>    } else if (secureClientPortAddress != null) {\n<line162>        this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);\n<line163>        LOG.info(\"secureClientPortAddress is {}\", formatInetAddr(this.secureClientPortAddress));\n<line164>    } else {\n<line165>        this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n<line166>        LOG.info(\"secureClientPortAddress is {}\", formatInetAddr(this.secureClientPortAddress));\n<line167>    }\n<line168>    if (this.secureClientPortAddress != null) {\n<line169>        configureSSLAuth();\n<line170>    }\n<line171>    if (observerMasterPort <= 0) {\n<line172>        LOG.info(\"observerMasterPort is not set\");\n<line173>    } else {\n<line174>        this.observerMasterPort = observerMasterPort;\n<line175>        LOG.info(\"observerMasterPort is {}\", observerMasterPort);\n<line176>    }\n<line177>    if (tickTime == 0) {\n<line178>        throw new IllegalArgumentException(\"tickTime is not set\");\n<line179>    }\n<line180>    minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n<line181>    maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n<line182>    if (minSessionTimeout > maxSessionTimeout) {\n<line183>        throw new IllegalArgumentException(\"minSessionTimeout must not be larger than maxSessionTimeout\");\n<line184>    }\n<line185>    LOG.info(\"metricsProvider.className is {}\", metricsProviderClassName);\n<line186>    try {\n<line187>        Class.forName(metricsProviderClassName, false, Thread.currentThread().getContextClassLoader());\n<line188>    } catch (ClassNotFoundException error) {\n<line189>        throw new IllegalArgumentException(\"metrics provider class was not found\", error);\n<line190>    }\n<line191>    // backward compatibility - dynamic configuration in the same file as\n<line192>    // static configuration params see writeDynamicConfig()\n<line193>    if (dynamicConfigFileStr == null) {\n<line194>        setupQuorumPeerConfig(zkProp, true);\n<line195>        if (isDistributed() && isReconfigEnabled()) {\n<line196>            // we don't backup static config for standalone mode.\n<line197>            // we also don't backup if reconfig feature is disabled.\n<line198>            backupOldConfig();\n<line199>        }\n<line200>    }\n<line201>}"},{"input":"","instruction":"<line1>{\n<line2>    if (clientPortAddress != null) {\n<line3>        throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"clientPort is not set\");\n<line3>    if (clientPortAddress != null) {\n<line4>        throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);\n<line3>}","output":"<line1>{\n<line2>    this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);\n<line3>    LOG.info(\"clientPortAddress is {}\", formatInetAddr(this.clientPortAddress));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.clientPortAddress = new InetSocketAddress(clientPort);\n<line3>}","output":"<line1>{\n<line2>    this.clientPortAddress = new InetSocketAddress(clientPort);\n<line3>    LOG.info(\"clientPortAddress is {}\", formatInetAddr(this.clientPortAddress));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (secureClientPortAddress != null) {\n<line3>        throw new IllegalArgumentException(\"secureClientPortAddress is set but secureClientPort is not set\");\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"secureClientPort is not set\");\n<line3>    if (secureClientPortAddress != null) {\n<line4>        throw new IllegalArgumentException(\"secureClientPortAddress is set but secureClientPort is not set\");\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);\n<line3>}","output":"<line1>{\n<line2>    this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);\n<line3>    LOG.info(\"secureClientPortAddress is {}\", formatInetAddr(this.secureClientPortAddress));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n<line3>}","output":"<line1>{\n<line2>    this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n<line3>    LOG.info(\"secureClientPortAddress is {}\", formatInetAddr(this.secureClientPortAddress));\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"observerMasterPort is not set\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    this.observerMasterPort = observerMasterPort;\n<line3>}","output":"<line1>{\n<line2>    this.observerMasterPort = observerMasterPort;\n<line3>    LOG.info(\"observerMasterPort is {}\", observerMasterPort);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (isHierarchical) {\n<line3>        return new QuorumHierarchical(dynamicConfigProp);\n<line4>    } else {\n<line5>        /*\n<line6>             * The default QuorumVerifier is QuorumMaj\n<line7>             */\n<line8>        return new QuorumMaj(dynamicConfigProp);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (isHierarchical) {\n<line3>        return new QuorumHierarchical(dynamicConfigProp);\n<line4>    } else {\n<line5>        /*\n<line6>             * The default QuorumVerifier is QuorumMaj\n<line7>             */\n<line8>        //LOG.info(\"Defaulting to majority quorums\");\n<line9>        return new QuorumMaj(dynamicConfigProp);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>             * The default QuorumVerifier is QuorumMaj\n<line4>             */\n<line5>    return new QuorumMaj(dynamicConfigProp);\n<line6>}","output":"<line1>{\n<line2>    /*\n<line3>             * The default QuorumVerifier is QuorumMaj\n<line4>             */\n<line5>    //LOG.info(\"Defaulting to majority quorums\");\n<line6>    return new QuorumMaj(dynamicConfigProp);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean isHierarchical = false;\n<line3>    for (Entry<Object, Object> entry : dynamicConfigProp.entrySet()) {\n<line4>        String key = entry.getKey().toString().trim();\n<line5>        if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n<line6>            isHierarchical = true;\n<line7>        } else if (!configBackwardCompatibilityMode && !key.startsWith(\"server.\") && !key.equals(\"version\")) {\n<line8>            throw new ConfigException(\"Unrecognised parameter: \" + key);\n<line9>        }\n<line10>    }\n<line11>    QuorumVerifier qv = createQuorumVerifier(dynamicConfigProp, isHierarchical, oraclePath);\n<line12>    int numParticipators = qv.getVotingMembers().size();\n<line13>    int numObservers = qv.getObservingMembers().size();\n<line14>    if (numParticipators == 0) {\n<line15>        if (!standaloneEnabled) {\n<line16>            throw new IllegalArgumentException(\"standaloneEnabled = false then \" + \"number of participants should be >0\");\n<line17>        }\n<line18>        if (numObservers > 0) {\n<line19>            throw new IllegalArgumentException(\"Observers w/o participants is an invalid configuration\");\n<line20>        }\n<line21>    } else if (numParticipators == 1 && standaloneEnabled) {\n<line22>        // HBase currently adds a single server line to the config, for\n<line23>        // b/w compatibility reasons we need to keep this here. If standaloneEnabled\n<line24>        // is true, the QuorumPeerMain script will create a standalone server instead\n<line25>        // of a quorum configuration\n<line26>        if (numObservers > 0) {\n<line27>            throw new IllegalArgumentException(\"Observers w/o quorum is an invalid configuration\");\n<line28>        }\n<line29>    } else {\n<line30>        if (warnings) {\n<line31>            if (numParticipators <= 2) {\n<line32>            } else if (numParticipators % 2 == 0) {\n<line33>            }\n<line34>        }\n<line35>        for (QuorumServer s : qv.getVotingMembers().values()) {\n<line36>            if (s.electionAddr == null) {\n<line37>                throw new IllegalArgumentException(\"Missing election port for server: \" + s.id);\n<line38>            }\n<line39>        }\n<line40>    }\n<line41>    return qv;\n<line42>}","output":"<line1>{\n<line2>    boolean isHierarchical = false;\n<line3>    for (Entry<Object, Object> entry : dynamicConfigProp.entrySet()) {\n<line4>        String key = entry.getKey().toString().trim();\n<line5>        if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n<line6>            isHierarchical = true;\n<line7>        } else if (!configBackwardCompatibilityMode && !key.startsWith(\"server.\") && !key.equals(\"version\")) {\n<line8>            LOG.info(dynamicConfigProp.toString());\n<line9>            throw new ConfigException(\"Unrecognised parameter: \" + key);\n<line10>        }\n<line11>    }\n<line12>    QuorumVerifier qv = createQuorumVerifier(dynamicConfigProp, isHierarchical, oraclePath);\n<line13>    int numParticipators = qv.getVotingMembers().size();\n<line14>    int numObservers = qv.getObservingMembers().size();\n<line15>    if (numParticipators == 0) {\n<line16>        if (!standaloneEnabled) {\n<line17>            throw new IllegalArgumentException(\"standaloneEnabled = false then \" + \"number of participants should be >0\");\n<line18>        }\n<line19>        if (numObservers > 0) {\n<line20>            throw new IllegalArgumentException(\"Observers w/o participants is an invalid configuration\");\n<line21>        }\n<line22>    } else if (numParticipators == 1 && standaloneEnabled) {\n<line23>        // HBase currently adds a single server line to the config, for\n<line24>        // b/w compatibility reasons we need to keep this here. If standaloneEnabled\n<line25>        // is true, the QuorumPeerMain script will create a standalone server instead\n<line26>        // of a quorum configuration\n<line27>        LOG.error(\"Invalid configuration, only one server specified (ignoring)\");\n<line28>        if (numObservers > 0) {\n<line29>            throw new IllegalArgumentException(\"Observers w/o quorum is an invalid configuration\");\n<line30>        }\n<line31>    } else {\n<line32>        if (warnings) {\n<line33>            if (numParticipators <= 2) {\n<line34>                LOG.warn(\"No server failure will be tolerated. You need at least 3 servers.\");\n<line35>            } else if (numParticipators % 2 == 0) {\n<line36>                LOG.warn(\"Non-optimal configuration, consider an odd number of servers.\");\n<line37>            }\n<line38>        }\n<line39>        for (QuorumServer s : qv.getVotingMembers().values()) {\n<line40>            if (s.electionAddr == null) {\n<line41>                throw new IllegalArgumentException(\"Missing election port for server: \" + s.id);\n<line42>            }\n<line43>        }\n<line44>    }\n<line45>    return qv;\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    String key = entry.getKey().toString().trim();\n<line3>    if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n<line4>        isHierarchical = true;\n<line5>    } else if (!configBackwardCompatibilityMode && !key.startsWith(\"server.\") && !key.equals(\"version\")) {\n<line6>        throw new ConfigException(\"Unrecognised parameter: \" + key);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    String key = entry.getKey().toString().trim();\n<line3>    if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n<line4>        isHierarchical = true;\n<line5>    } else if (!configBackwardCompatibilityMode && !key.startsWith(\"server.\") && !key.equals(\"version\")) {\n<line6>        LOG.info(dynamicConfigProp.toString());\n<line7>        throw new ConfigException(\"Unrecognised parameter: \" + key);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new ConfigException(\"Unrecognised parameter: \" + key);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(dynamicConfigProp.toString());\n<line3>    throw new ConfigException(\"Unrecognised parameter: \" + key);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // HBase currently adds a single server line to the config, for\n<line3>    // b/w compatibility reasons we need to keep this here. If standaloneEnabled\n<line4>    // is true, the QuorumPeerMain script will create a standalone server instead\n<line5>    // of a quorum configuration\n<line6>    if (numObservers > 0) {\n<line7>        throw new IllegalArgumentException(\"Observers w/o quorum is an invalid configuration\");\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    // HBase currently adds a single server line to the config, for\n<line3>    // b/w compatibility reasons we need to keep this here. If standaloneEnabled\n<line4>    // is true, the QuorumPeerMain script will create a standalone server instead\n<line5>    // of a quorum configuration\n<line6>    LOG.error(\"Invalid configuration, only one server specified (ignoring)\");\n<line7>    if (numObservers > 0) {\n<line8>        throw new IllegalArgumentException(\"Observers w/o quorum is an invalid configuration\");\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    DEFAULT_CONCURRENT_SNAPSYNCS = Integer.getInteger(MAX_CONCURRENT_SNAPSYNCS, 10);\n<line3>    DEFAULT_CONCURRENT_DIFF_SYNCS = Integer.getInteger(MAX_CONCURRENT_DIFF_SYNCS, 100);\n<line4>}","output":"<line1>{\n<line2>    DEFAULT_CONCURRENT_SNAPSYNCS = Integer.getInteger(MAX_CONCURRENT_SNAPSYNCS, 10);\n<line3>    LOG.info(\"{} = {}\", MAX_CONCURRENT_SNAPSYNCS, DEFAULT_CONCURRENT_SNAPSYNCS);\n<line4>    DEFAULT_CONCURRENT_DIFF_SYNCS = Integer.getInteger(MAX_CONCURRENT_DIFF_SYNCS, 100);\n<line5>    LOG.info(\"{} = {}\", MAX_CONCURRENT_DIFF_SYNCS, DEFAULT_CONCURRENT_DIFF_SYNCS);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    this.maxConcurrentSnapSyncs = maxConcurrentSnapSyncs;\n<line3>    learnerSnapSyncThrottler.setMaxConcurrentSyncs(maxConcurrentSnapSyncs);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Set maxConcurrentSnapSyncs to {}\", maxConcurrentSnapSyncs);\n<line3>    this.maxConcurrentSnapSyncs = maxConcurrentSnapSyncs;\n<line4>    learnerSnapSyncThrottler.setMaxConcurrentSyncs(maxConcurrentSnapSyncs);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    this.maxConcurrentDiffSyncs = maxConcurrentDiffSyncs;\n<line3>    learnerDiffSyncThrottler.setMaxConcurrentSyncs(maxConcurrentDiffSyncs);\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Set maxConcurrentDiffSyncs to {}\", maxConcurrentDiffSyncs);\n<line3>    this.maxConcurrentDiffSyncs = maxConcurrentDiffSyncs;\n<line4>    learnerDiffSyncThrottler.setMaxConcurrentSyncs(maxConcurrentDiffSyncs);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean tracked = globalSessionTracker.trackSession(sessionId, sessionTimeout);\n<line3>    if (localSessionsEnabled && tracked) {\n<line4>        // Only do extra logging so we know what kind of session this is\n<line5>        // if we're supporting both kinds of sessions\n<line6>    }\n<line7>    return tracked;\n<line8>}","output":"<line1>{\n<line2>    boolean tracked = globalSessionTracker.trackSession(sessionId, sessionTimeout);\n<line3>    if (localSessionsEnabled && tracked) {\n<line4>        // Only do extra logging so we know what kind of session this is\n<line5>        // if we're supporting both kinds of sessions\n<line6>        LOG.info(\"Tracking global session 0x{}\", Long.toHexString(sessionId));\n<line7>    }\n<line8>    return tracked;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    // Only do extra logging so we know what kind of session this is\n<line3>    // if we're supporting both kinds of sessions\n<line4>}","output":"<line1>{\n<line2>    // Only do extra logging so we know what kind of session this is\n<line3>    // if we're supporting both kinds of sessions\n<line4>    LOG.info(\"Tracking global session 0x{}\", Long.toHexString(sessionId));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean added = globalSessionTracker.commitSession(sessionId, sessionTimeout);\n<line3>    if (added) {\n<line4>    }\n<line5>    // If the session moved before the session upgrade finished, it's\n<line6>    // possible that the session will be added to the local session\n<line7>    // again. Need to double check and remove it from local session\n<line8>    // tracker when the global session is quorum committed, otherwise the\n<line9>    // local session might be tracked both locally and on leader.\n<line10>    //\n<line11>    // This cannot totally avoid the local session being upgraded again\n<line12>    // because there is still race condition between create another upgrade\n<line13>    // request and process the createSession commit, and there is no way\n<line14>    // to know there is a on flying createSession request because it might\n<line15>    // be upgraded by other server which owns the session before move.\n<line16>    if (localSessionsEnabled) {\n<line17>        removeLocalSession(sessionId);\n<line18>        finishedUpgrading(sessionId);\n<line19>    }\n<line20>    return added;\n<line21>}","output":"<line1>{\n<line2>    boolean added = globalSessionTracker.commitSession(sessionId, sessionTimeout);\n<line3>    if (added) {\n<line4>        LOG.info(\"Committing global session 0x{}\", Long.toHexString(sessionId));\n<line5>    }\n<line6>    // If the session moved before the session upgrade finished, it's\n<line7>    // possible that the session will be added to the local session\n<line8>    // again. Need to double check and remove it from local session\n<line9>    // tracker when the global session is quorum committed, otherwise the\n<line10>    // local session might be tracked both locally and on leader.\n<line11>    //\n<line12>    // This cannot totally avoid the local session being upgraded again\n<line13>    // because there is still race condition between create another upgrade\n<line14>    // request and process the createSession commit, and there is no way\n<line15>    // to know there is a on flying createSession request because it might\n<line16>    // be upgraded by other server which owns the session before move.\n<line17>    if (localSessionsEnabled) {\n<line18>        removeLocalSession(sessionId);\n<line19>        finishedUpgrading(sessionId);\n<line20>    }\n<line21>    return added;\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Committing global session 0x{}\", Long.toHexString(sessionId));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean added = globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;\n<line3>    if (added) {\n<line4>        // Only do extra logging so we know what kind of session this is\n<line5>        // if we're supporting both kinds of sessions\n<line6>    }\n<line7>    // If the session moved before the session upgrade finished, it's\n<line8>    // possible that the session will be added to the local session\n<line9>    // again. Need to double check and remove it from local session\n<line10>    // tracker when the global session is quorum committed, otherwise the\n<line11>    // local session might be tracked both locally and on leader.\n<line12>    //\n<line13>    // This cannot totally avoid the local session being upgraded again\n<line14>    // because there is still race condition between create another upgrade\n<line15>    // request and process the createSession commit, and there is no way\n<line16>    // to know there is a on flying createSession request because it might\n<line17>    // be upgraded by other server which owns the session before move.\n<line18>    if (localSessionsEnabled) {\n<line19>        removeLocalSession(sessionId);\n<line20>        finishedUpgrading(sessionId);\n<line21>    }\n<line22>    touchTable.get().put(sessionId, sessionTimeout);\n<line23>    return added;\n<line24>}","output":"<line1>{\n<line2>    boolean added = globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;\n<line3>    if (added) {\n<line4>        // Only do extra logging so we know what kind of session this is\n<line5>        // if we're supporting both kinds of sessions\n<line6>        LOG.info(\"Committing global session 0x{}\", Long.toHexString(sessionId));\n<line7>    }\n<line8>    // If the session moved before the session upgrade finished, it's\n<line9>    // possible that the session will be added to the local session\n<line10>    // again. Need to double check and remove it from local session\n<line11>    // tracker when the global session is quorum committed, otherwise the\n<line12>    // local session might be tracked both locally and on leader.\n<line13>    //\n<line14>    // This cannot totally avoid the local session being upgraded again\n<line15>    // because there is still race condition between create another upgrade\n<line16>    // request and process the createSession commit, and there is no way\n<line17>    // to know there is a on flying createSession request because it might\n<line18>    // be upgraded by other server which owns the session before move.\n<line19>    if (localSessionsEnabled) {\n<line20>        removeLocalSession(sessionId);\n<line21>        finishedUpgrading(sessionId);\n<line22>    }\n<line23>    touchTable.get().put(sessionId, sessionTimeout);\n<line24>    return added;\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    // Only do extra logging so we know what kind of session this is\n<line3>    // if we're supporting both kinds of sessions\n<line4>}","output":"<line1>{\n<line2>    // Only do extra logging so we know what kind of session this is\n<line3>    // if we're supporting both kinds of sessions\n<line4>    LOG.info(\"Committing global session 0x{}\", Long.toHexString(sessionId));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        super.shutdown();\n<line7>    } catch (Exception e) {\n<line8>    }\n<line9>    try {\n<line10>        if (syncProcessor != null) {\n<line11>            syncProcessor.shutdown();\n<line12>        }\n<line13>    } catch (Exception e) {\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    if (!canShutdown()) {\n<line3>        LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line4>        return;\n<line5>    }\n<line6>    LOG.info(\"Shutting down\");\n<line7>    try {\n<line8>        super.shutdown();\n<line9>    } catch (Exception e) {\n<line10>        LOG.warn(\"Ignoring unexpected exception during shutdown\", e);\n<line11>    }\n<line12>    try {\n<line13>        if (syncProcessor != null) {\n<line14>            syncProcessor.shutdown();\n<line15>        }\n<line16>    } catch (Exception e) {\n<line17>        LOG.warn(\"Ignoring unexpected exception in syncprocessor shutdown\", e);\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"ZooKeeper server is not running, so not proceeding to shutdown!\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    byte[] litmus = new byte[5];\n<line3>    int oldTimeout = -1;\n<line4>    int bytesRead = 0;\n<line5>    int newTimeout = x509Util.getSslHandshakeTimeoutMillis();\n<line6>    try {\n<line7>        oldTimeout = prependableSocket.getSoTimeout();\n<line8>        prependableSocket.setSoTimeout(newTimeout);\n<line9>        bytesRead = prependableSocket.getInputStream().read(litmus, 0, litmus.length);\n<line10>    } catch (SocketTimeoutException e) {\n<line11>        // Didn't read anything within the timeout, fallthrough and assume the connection is plaintext.\n<line12>    } finally {\n<line13>        // restore socket timeout to the old value\n<line14>        try {\n<line15>            if (oldTimeout != -1) {\n<line16>                prependableSocket.setSoTimeout(oldTimeout);\n<line17>            }\n<line18>        } catch (Exception e) {\n<line19>        }\n<line20>    }\n<line21>    if (bytesRead < 0) {\n<line22>        // Got a EOF right away, definitely not using TLS. Fallthrough.\n<line23>        bytesRead = 0;\n<line24>    }\n<line25>    if (bytesRead == litmus.length && SslHandler.isEncrypted(Unpooled.wrappedBuffer(litmus))) {\n<line26>        try {\n<line27>            sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);\n<line28>        } catch (X509Exception e) {\n<line29>            throw new IOException(\"failed to create SSL context\", e);\n<line30>        }\n<line31>        prependableSocket = null;\n<line32>        mode = Mode.TLS;\n<line33>    } else if (allowInsecureConnection) {\n<line34>        prependableSocket.prependToInputStream(litmus, 0, bytesRead);\n<line35>        mode = Mode.PLAINTEXT;\n<line36>    } else {\n<line37>        prependableSocket.close();\n<line38>        mode = Mode.PLAINTEXT;\n<line39>        throw new IOException(\"Blocked insecure connection attempt\");\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    byte[] litmus = new byte[5];\n<line3>    int oldTimeout = -1;\n<line4>    int bytesRead = 0;\n<line5>    int newTimeout = x509Util.getSslHandshakeTimeoutMillis();\n<line6>    try {\n<line7>        oldTimeout = prependableSocket.getSoTimeout();\n<line8>        prependableSocket.setSoTimeout(newTimeout);\n<line9>        bytesRead = prependableSocket.getInputStream().read(litmus, 0, litmus.length);\n<line10>    } catch (SocketTimeoutException e) {\n<line11>        // Didn't read anything within the timeout, fallthrough and assume the connection is plaintext.\n<line12>        LOG.warn(\"Socket mode detection timed out after {} ms, assuming PLAINTEXT\", newTimeout);\n<line13>    } finally {\n<line14>        // restore socket timeout to the old value\n<line15>        try {\n<line16>            if (oldTimeout != -1) {\n<line17>                prependableSocket.setSoTimeout(oldTimeout);\n<line18>            }\n<line19>        } catch (Exception e) {\n<line20>            LOG.warn(\"Failed to restore old socket timeout value of {} ms\", oldTimeout, e);\n<line21>        }\n<line22>    }\n<line23>    if (bytesRead < 0) {\n<line24>        // Got a EOF right away, definitely not using TLS. Fallthrough.\n<line25>        bytesRead = 0;\n<line26>    }\n<line27>    if (bytesRead == litmus.length && SslHandler.isEncrypted(Unpooled.wrappedBuffer(litmus))) {\n<line28>        try {\n<line29>            sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);\n<line30>        } catch (X509Exception e) {\n<line31>            throw new IOException(\"failed to create SSL context\", e);\n<line32>        }\n<line33>        prependableSocket = null;\n<line34>        mode = Mode.TLS;\n<line35>        LOG.info(\"Accepted TLS connection from {} - {} - {}\", sslSocket.getRemoteSocketAddress(), sslSocket.getSession().getProtocol(), sslSocket.getSession().getCipherSuite());\n<line36>    } else if (allowInsecureConnection) {\n<line37>        prependableSocket.prependToInputStream(litmus, 0, bytesRead);\n<line38>        mode = Mode.PLAINTEXT;\n<line39>        LOG.info(\"Accepted plaintext connection from {}\", prependableSocket.getRemoteSocketAddress());\n<line40>    } else {\n<line41>        prependableSocket.close();\n<line42>        mode = Mode.PLAINTEXT;\n<line43>        throw new IOException(\"Blocked insecure connection attempt\");\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);\n<line4>    } catch (X509Exception e) {\n<line5>        throw new IOException(\"failed to create SSL context\", e);\n<line6>    }\n<line7>    prependableSocket = null;\n<line8>    mode = Mode.TLS;\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);\n<line4>    } catch (X509Exception e) {\n<line5>        throw new IOException(\"failed to create SSL context\", e);\n<line6>    }\n<line7>    prependableSocket = null;\n<line8>    mode = Mode.TLS;\n<line9>    LOG.info(\"Accepted TLS connection from {} - {} - {}\", sslSocket.getRemoteSocketAddress(), sslSocket.getSession().getProtocol(), sslSocket.getSession().getCipherSuite());\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    prependableSocket.prependToInputStream(litmus, 0, bytesRead);\n<line3>    mode = Mode.PLAINTEXT;\n<line4>}","output":"<line1>{\n<line2>    prependableSocket.prependToInputStream(litmus, 0, bytesRead);\n<line3>    mode = Mode.PLAINTEXT;\n<line4>    LOG.info(\"Accepted plaintext connection from {}\", prependableSocket.getRemoteSocketAddress());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    int newCount;\n<line3>    synchronized (countSyncObject) {\n<line4>        syncInProgress--;\n<line5>        newCount = syncInProgress;\n<line6>        countSyncObject.notify();\n<line7>    }\n<line8>    if (newCount < 0) {\n<line9>        String errorMsg = \"endSync() called incorrectly; current sync count is \" + newCount;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    int newCount;\n<line3>    synchronized (countSyncObject) {\n<line4>        syncInProgress--;\n<line5>        newCount = syncInProgress;\n<line6>        countSyncObject.notify();\n<line7>    }\n<line8>    if (newCount < 0) {\n<line9>        String errorMsg = \"endSync() called incorrectly; current sync count is \" + newCount;\n<line10>        LOG.error(errorMsg);\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    String errorMsg = \"endSync() called incorrectly; current sync count is \" + newCount;\n<line3>}","output":"<line1>{\n<line2>    String errorMsg = \"endSync() called incorrectly; current sync count is \" + newCount;\n<line3>    LOG.error(errorMsg);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    reconnectDelayMs = Long.getLong(OBSERVER_RECONNECT_DELAY_MS, 0);\n<line3>    observerElectionDelayMs = Long.getLong(OBSERVER_ELECTION_DELAY_MS, 200);\n<line4>}","output":"<line1>{\n<line2>    reconnectDelayMs = Long.getLong(OBSERVER_RECONNECT_DELAY_MS, 0);\n<line3>    LOG.info(\"{} = {}\", OBSERVER_RECONNECT_DELAY_MS, reconnectDelayMs);\n<line4>    observerElectionDelayMs = Long.getLong(OBSERVER_ELECTION_DELAY_MS, 200);\n<line5>    LOG.info(\"{} = {}\", OBSERVER_ELECTION_DELAY_MS, observerElectionDelayMs);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n<line3>    long connectTime = 0;\n<line4>    boolean completedSync = false;\n<line5>    try {\n<line6>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line7>        QuorumServer master = findLearnerMaster();\n<line8>        try {\n<line9>            connectToLeader(master.addr, master.hostname);\n<line10>            connectTime = System.currentTimeMillis();\n<line11>            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n<line12>            if (self.isReconfigStateChange()) {\n<line13>                throw new Exception(\"learned about role change\");\n<line14>            }\n<line15>            final long startTime = Time.currentElapsedTime();\n<line16>            self.setLeaderAddressAndId(master.addr, master.getId());\n<line17>            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line18>            syncWithLeader(newLeaderZxid);\n<line19>            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line20>            completedSync = true;\n<line21>            final long syncTime = Time.currentElapsedTime() - startTime;\n<line22>            ServerMetrics.getMetrics().OBSERVER_SYNC_TIME.add(syncTime);\n<line23>            QuorumPacket qp = new QuorumPacket();\n<line24>            while (this.isRunning() && nextLearnerMaster.get() == null) {\n<line25>                readPacket(qp);\n<line26>                processPacket(qp);\n<line27>            }\n<line28>        } catch (Exception e) {\n<line29>            closeSocket();\n<line30>            // clear pending revalidations\n<line31>            pendingRevalidations.clear();\n<line32>        }\n<line33>    } finally {\n<line34>        currentLearnerMaster = null;\n<line35>        zk.unregisterJMX(this);\n<line36>        if (connectTime != 0) {\n<line37>            long connectionDuration = System.currentTimeMillis() - connectTime;\n<line38>            messageTracker.dumpToLog(leaderAddr.toString());\n<line39>        }\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n<line3>    long connectTime = 0;\n<line4>    boolean completedSync = false;\n<line5>    try {\n<line6>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);\n<line7>        QuorumServer master = findLearnerMaster();\n<line8>        try {\n<line9>            connectToLeader(master.addr, master.hostname);\n<line10>            connectTime = System.currentTimeMillis();\n<line11>            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n<line12>            if (self.isReconfigStateChange()) {\n<line13>                throw new Exception(\"learned about role change\");\n<line14>            }\n<line15>            final long startTime = Time.currentElapsedTime();\n<line16>            self.setLeaderAddressAndId(master.addr, master.getId());\n<line17>            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n<line18>            syncWithLeader(newLeaderZxid);\n<line19>            self.setZabState(QuorumPeer.ZabState.BROADCAST);\n<line20>            completedSync = true;\n<line21>            final long syncTime = Time.currentElapsedTime() - startTime;\n<line22>            ServerMetrics.getMetrics().OBSERVER_SYNC_TIME.add(syncTime);\n<line23>            QuorumPacket qp = new QuorumPacket();\n<line24>            while (this.isRunning() && nextLearnerMaster.get() == null) {\n<line25>                readPacket(qp);\n<line26>                processPacket(qp);\n<line27>            }\n<line28>        } catch (Exception e) {\n<line29>            LOG.warn(\"Exception when observing the leader\", e);\n<line30>            closeSocket();\n<line31>            // clear pending revalidations\n<line32>            pendingRevalidations.clear();\n<line33>        }\n<line34>    } finally {\n<line35>        currentLearnerMaster = null;\n<line36>        zk.unregisterJMX(this);\n<line37>        if (connectTime != 0) {\n<line38>            long connectionDuration = System.currentTimeMillis() - connectTime;\n<line39>            LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n<line40>            messageTracker.dumpToLog(leaderAddr.toString());\n<line41>        }\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    currentLearnerMaster = null;\n<line3>    zk.unregisterJMX(this);\n<line4>    if (connectTime != 0) {\n<line5>        long connectionDuration = System.currentTimeMillis() - connectTime;\n<line6>        messageTracker.dumpToLog(leaderAddr.toString());\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    currentLearnerMaster = null;\n<line3>    zk.unregisterJMX(this);\n<line4>    if (connectTime != 0) {\n<line5>        long connectionDuration = System.currentTimeMillis() - connectTime;\n<line6>        LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n<line7>        messageTracker.dumpToLog(leaderAddr.toString());\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    long connectionDuration = System.currentTimeMillis() - connectTime;\n<line3>    messageTracker.dumpToLog(leaderAddr.toString());\n<line4>}","output":"<line1>{\n<line2>    long connectionDuration = System.currentTimeMillis() - connectTime;\n<line3>    LOG.info(\"Disconnected from leader (with address: {}). Was connected for {}ms. Sync state: {}\", leaderAddr, connectionDuration, completedSync);\n<line4>    messageTracker.dumpToLog(leaderAddr.toString());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumPeer.QuorumServer prescribedLearnerMaster = nextLearnerMaster.getAndSet(null);\n<line3>    if (prescribedLearnerMaster != null && self.validateLearnerMaster(Long.toString(prescribedLearnerMaster.id)) == null) {\n<line4>        prescribedLearnerMaster = null;\n<line5>    }\n<line6>    final QuorumPeer.QuorumServer master = (prescribedLearnerMaster == null) ? self.findLearnerMaster(findLeader()) : prescribedLearnerMaster;\n<line7>    currentLearnerMaster = master;\n<line8>    if (master == null) {\n<line9>    } else {\n<line10>    }\n<line11>    return master;\n<line12>}","output":"<line1>{\n<line2>    QuorumPeer.QuorumServer prescribedLearnerMaster = nextLearnerMaster.getAndSet(null);\n<line3>    if (prescribedLearnerMaster != null && self.validateLearnerMaster(Long.toString(prescribedLearnerMaster.id)) == null) {\n<line4>        LOG.warn(\"requested next learner master {} is no longer valid\", prescribedLearnerMaster);\n<line5>        prescribedLearnerMaster = null;\n<line6>    }\n<line7>    final QuorumPeer.QuorumServer master = (prescribedLearnerMaster == null) ? self.findLearnerMaster(findLeader()) : prescribedLearnerMaster;\n<line8>    currentLearnerMaster = master;\n<line9>    if (master == null) {\n<line10>        LOG.warn(\"No learner master found\");\n<line11>    } else {\n<line12>        LOG.info(\"Observing new leader sid={} addr={}\", master.id, master.addr);\n<line13>    }\n<line14>    return master;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Observing new leader sid={} addr={}\", master.id, master.addr);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    TxnLogEntry logEntry;\n<line3>    TxnHeader hdr;\n<line4>    TxnDigest digest;\n<line5>    Record txn;\n<line6>    switch(qp.getType()) {\n<line7>        case Leader.PING:\n<line8>            ping(qp);\n<line9>            break;\n<line10>        case Leader.PROPOSAL:\n<line11>            break;\n<line12>        case Leader.COMMIT:\n<line13>            break;\n<line14>        case Leader.UPTODATE:\n<line15>            break;\n<line16>        case Leader.REVALIDATE:\n<line17>            revalidate(qp);\n<line18>            break;\n<line19>        case Leader.SYNC:\n<line20>            ((ObserverZooKeeperServer) zk).sync();\n<line21>            break;\n<line22>        case Leader.INFORM:\n<line23>            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);\n<line24>            logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line25>            hdr = logEntry.getHeader();\n<line26>            txn = logEntry.getTxn();\n<line27>            digest = logEntry.getDigest();\n<line28>            Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);\n<line29>            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);\n<line30>            request.setTxnDigest(digest);\n<line31>            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;\n<line32>            obs.commitRequest(request);\n<line33>            break;\n<line34>        case Leader.INFORMANDACTIVATE:\n<line35>            // get new designated leader from (current) leader's message\n<line36>            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line37>            long suggestedLeaderId = buffer.getLong();\n<line38>            byte[] remainingdata = new byte[buffer.remaining()];\n<line39>            buffer.get(remainingdata);\n<line40>            logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line41>            hdr = logEntry.getHeader();\n<line42>            txn = logEntry.getTxn();\n<line43>            digest = logEntry.getDigest();\n<line44>            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData(), UTF_8));\n<line45>            request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);\n<line46>            request.setTxnDigest(digest);\n<line47>            obs = (ObserverZooKeeperServer) zk;\n<line48>            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line49>            obs.commitRequest(request);\n<line50>            if (majorChange) {\n<line51>                throw new Exception(\"changes proposed in reconfig\");\n<line52>            }\n<line53>            break;\n<line54>        default:\n<line55>            break;\n<line56>    }\n<line57>}","output":"<line1>{\n<line2>    TxnLogEntry logEntry;\n<line3>    TxnHeader hdr;\n<line4>    TxnDigest digest;\n<line5>    Record txn;\n<line6>    switch(qp.getType()) {\n<line7>        case Leader.PING:\n<line8>            ping(qp);\n<line9>            break;\n<line10>        case Leader.PROPOSAL:\n<line11>            LOG.warn(\"Ignoring proposal\");\n<line12>            break;\n<line13>        case Leader.COMMIT:\n<line14>            LOG.warn(\"Ignoring commit\");\n<line15>            break;\n<line16>        case Leader.UPTODATE:\n<line17>            LOG.error(\"Received an UPTODATE message after Observer started\");\n<line18>            break;\n<line19>        case Leader.REVALIDATE:\n<line20>            revalidate(qp);\n<line21>            break;\n<line22>        case Leader.SYNC:\n<line23>            ((ObserverZooKeeperServer) zk).sync();\n<line24>            break;\n<line25>        case Leader.INFORM:\n<line26>            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);\n<line27>            logEntry = SerializeUtils.deserializeTxn(qp.getData());\n<line28>            hdr = logEntry.getHeader();\n<line29>            txn = logEntry.getTxn();\n<line30>            digest = logEntry.getDigest();\n<line31>            Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);\n<line32>            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);\n<line33>            request.setTxnDigest(digest);\n<line34>            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;\n<line35>            obs.commitRequest(request);\n<line36>            break;\n<line37>        case Leader.INFORMANDACTIVATE:\n<line38>            // get new designated leader from (current) leader's message\n<line39>            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());\n<line40>            long suggestedLeaderId = buffer.getLong();\n<line41>            byte[] remainingdata = new byte[buffer.remaining()];\n<line42>            buffer.get(remainingdata);\n<line43>            logEntry = SerializeUtils.deserializeTxn(remainingdata);\n<line44>            hdr = logEntry.getHeader();\n<line45>            txn = logEntry.getTxn();\n<line46>            digest = logEntry.getDigest();\n<line47>            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData(), UTF_8));\n<line48>            request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);\n<line49>            request.setTxnDigest(digest);\n<line50>            obs = (ObserverZooKeeperServer) zk;\n<line51>            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n<line52>            obs.commitRequest(request);\n<line53>            if (majorChange) {\n<line54>                throw new Exception(\"changes proposed in reconfig\");\n<line55>            }\n<line56>            break;\n<line57>        default:\n<line58>            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n<line59>            break;\n<line60>    }\n<line61>}"},{"input":"","instruction":"<line1>{\n<line2>    super.shutdown();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"shutdown Observer\");\n<line3>    super.shutdown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (delayValueMs > 0) {\n<line3>        long randomDelay = ThreadLocalRandom.current().nextLong(delayValueMs);\n<line4>        try {\n<line5>            Thread.sleep(randomDelay);\n<line6>        } catch (InterruptedException e) {\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (delayValueMs > 0) {\n<line3>        long randomDelay = ThreadLocalRandom.current().nextLong(delayValueMs);\n<line4>        LOG.info(\"Waiting for {} ms before reconnecting with the leader\", randomDelay);\n<line5>        try {\n<line6>            Thread.sleep(randomDelay);\n<line7>        } catch (InterruptedException e) {\n<line8>            LOG.warn(\"Interrupted while waiting\", e);\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    long randomDelay = ThreadLocalRandom.current().nextLong(delayValueMs);\n<line3>    try {\n<line4>        Thread.sleep(randomDelay);\n<line5>    } catch (InterruptedException e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    long randomDelay = ThreadLocalRandom.current().nextLong(delayValueMs);\n<line3>    LOG.info(\"Waiting for {} ms before reconnecting with the leader\", randomDelay);\n<line4>    try {\n<line5>        Thread.sleep(randomDelay);\n<line6>    } catch (InterruptedException e) {\n<line7>        LOG.warn(\"Interrupted while waiting\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    final QuorumPeer.QuorumServer server = self.validateLearnerMaster(learnerMaster);\n<line3>    if (server == null) {\n<line4>        return false;\n<line5>    } else if (server.equals(currentLearnerMaster)) {\n<line6>        return true;\n<line7>    } else {\n<line8>        nextLearnerMaster.set(server);\n<line9>        return true;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    final QuorumPeer.QuorumServer server = self.validateLearnerMaster(learnerMaster);\n<line3>    if (server == null) {\n<line4>        return false;\n<line5>    } else if (server.equals(currentLearnerMaster)) {\n<line6>        LOG.info(\"Already connected to requested learner master sid={} addr={}\", server.id, server.addr);\n<line7>        return true;\n<line8>    } else {\n<line9>        LOG.info(\"Requesting disconnect and reconnect to new learner master sid={} addr={}\", server.id, server.addr);\n<line10>        nextLearnerMaster.set(server);\n<line11>        return true;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    return true;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Already connected to requested learner master sid={} addr={}\", server.id, server.addr);\n<line3>    return true;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    nextLearnerMaster.set(server);\n<line3>    return true;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Requesting disconnect and reconnect to new learner master sid={} addr={}\", server.id, server.addr);\n<line3>    nextLearnerMaster.set(server);\n<line4>    return true;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    observerElectionDelayMs = electionDelayMs;\n<line3>}","output":"<line1>{\n<line2>    observerElectionDelayMs = electionDelayMs;\n<line3>    LOG.info(\"{} = {}\", OBSERVER_ELECTION_DELAY_MS, observerElectionDelayMs);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (!finished) {\n<line4>            Request request = queuedRequests.take();\n<line5>            // log request\n<line6>                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n<line7>                if (request.type == OpCode.ping) {\n<line8>                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;\n<line9>                }\n<line10>                ZooTrace.logRequest(LOG, traceMask, 'R', request, \"\");\n<line11>            }\n<line12>            if (Request.requestOfDeath == request) {\n<line13>                break;\n<line14>            }\n<line15>            // filter read requests\n<line16>            switch(request.type) {\n<line17>                case OpCode.sync:\n<line18>                case OpCode.create:\n<line19>                case OpCode.create2:\n<line20>                case OpCode.createTTL:\n<line21>                case OpCode.createContainer:\n<line22>                case OpCode.delete:\n<line23>                case OpCode.deleteContainer:\n<line24>                case OpCode.setData:\n<line25>                case OpCode.reconfig:\n<line26>                case OpCode.setACL:\n<line27>                case OpCode.multi:\n<line28>                case OpCode.check:\n<line29>                    sendErrorResponse(request);\n<line30>                    continue;\n<line31>                case OpCode.closeSession:\n<line32>                case OpCode.createSession:\n<line33>                    if (!request.isLocalSession()) {\n<line34>                        sendErrorResponse(request);\n<line35>                        continue;\n<line36>                    }\n<line37>            }\n<line38>            // proceed to the next processor\n<line39>            if (nextProcessor != null) {\n<line40>                nextProcessor.processRequest(request);\n<line41>            }\n<line42>        }\n<line43>    } catch (Exception e) {\n<line44>        handleException(this.getName(), e);\n<line45>    }\n<line46>}","output":"<line1>{\n<line2>    try {\n<line3>        while (!finished) {\n<line4>            Request request = queuedRequests.take();\n<line5>            // log request\n<line6>            if (LOG.isTraceEnabled()) {\n<line7>                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n<line8>                if (request.type == OpCode.ping) {\n<line9>                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;\n<line10>                }\n<line11>                ZooTrace.logRequest(LOG, traceMask, 'R', request, \"\");\n<line12>            }\n<line13>            if (Request.requestOfDeath == request) {\n<line14>                break;\n<line15>            }\n<line16>            // filter read requests\n<line17>            switch(request.type) {\n<line18>                case OpCode.sync:\n<line19>                case OpCode.create:\n<line20>                case OpCode.create2:\n<line21>                case OpCode.createTTL:\n<line22>                case OpCode.createContainer:\n<line23>                case OpCode.delete:\n<line24>                case OpCode.deleteContainer:\n<line25>                case OpCode.setData:\n<line26>                case OpCode.reconfig:\n<line27>                case OpCode.setACL:\n<line28>                case OpCode.multi:\n<line29>                case OpCode.check:\n<line30>                    sendErrorResponse(request);\n<line31>                    continue;\n<line32>                case OpCode.closeSession:\n<line33>                case OpCode.createSession:\n<line34>                    if (!request.isLocalSession()) {\n<line35>                        sendErrorResponse(request);\n<line36>                        continue;\n<line37>                    }\n<line38>            }\n<line39>            // proceed to the next processor\n<line40>            if (nextProcessor != null) {\n<line41>                nextProcessor.processRequest(request);\n<line42>            }\n<line43>        }\n<line44>    } catch (Exception e) {\n<line45>        handleException(this.getName(), e);\n<line46>    }\n<line47>    LOG.info(\"ReadOnlyRequestProcessor exited loop!\");\n<line48>}"},{"input":"","instruction":"<line1>{\n<line2>    ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase().getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());\n<line3>    try {\n<line4>        request.cnxn.sendResponse(hdr, null, null);\n<line5>    } catch (IOException e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase().getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());\n<line3>    try {\n<line4>        request.cnxn.sendResponse(hdr, null, null);\n<line5>    } catch (IOException e) {\n<line6>        LOG.error(\"IO exception while sending response\", e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"IO exception while sending response\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (pendingTxns.size() == 0) {\n<line3>        return;\n<line4>    }\n<line5>    long firstElementZxid = pendingTxns.element().zxid;\n<line6>    if (firstElementZxid != zxid) {\n<line7>        ServiceUtils.requestSystemExit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());\n<line8>    }\n<line9>    Request request = pendingTxns.remove();\n<line10>    request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);\n<line11>    commitProcessor.commit(request);\n<line12>}","output":"<line1>{\n<line2>    if (pendingTxns.size() == 0) {\n<line3>        LOG.warn(\"Committing \" + Long.toHexString(zxid) + \" without seeing txn\");\n<line4>        return;\n<line5>    }\n<line6>    long firstElementZxid = pendingTxns.element().zxid;\n<line7>    if (firstElementZxid != zxid) {\n<line8>        LOG.error(\"Committing zxid 0x\" + Long.toHexString(zxid) + \" but next pending txn 0x\" + Long.toHexString(firstElementZxid));\n<line9>        ServiceUtils.requestSystemExit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());\n<line10>    }\n<line11>    Request request = pendingTxns.remove();\n<line12>    request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);\n<line13>    commitProcessor.commit(request);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    ServiceUtils.requestSystemExit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Committing zxid 0x\" + Long.toHexString(zxid) + \" but next pending txn 0x\" + Long.toHexString(firstElementZxid));\n<line3>    ServiceUtils.requestSystemExit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    minNotificationInterval = Integer.getInteger(MIN_NOTIFICATION_INTERVAL, minNotificationInterval);\n<line3>    maxNotificationInterval = Integer.getInteger(MAX_NOTIFICATION_INTERVAL, maxNotificationInterval);\n<line4>}","output":"<line1>{\n<line2>    minNotificationInterval = Integer.getInteger(MIN_NOTIFICATION_INTERVAL, minNotificationInterval);\n<line3>    LOG.info(\"{} = {} ms\", MIN_NOTIFICATION_INTERVAL, minNotificationInterval);\n<line4>    maxNotificationInterval = Integer.getInteger(MAX_NOTIFICATION_INTERVAL, maxNotificationInterval);\n<line5>    LOG.info(\"{} = {} ms\", MAX_NOTIFICATION_INTERVAL, maxNotificationInterval);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    Message response;\n<line3>    while (!stop) {\n<line4>        // Sleeps on receive\n<line5>        try {\n<line6>            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line7>            if (response == null) {\n<line8>                continue;\n<line9>            }\n<line10>            final int capacity = response.buffer.capacity();\n<line11>            // The current protocol and two previous generations all send at least 28 bytes\n<line12>            if (capacity < 28) {\n<line13>                continue;\n<line14>            }\n<line15>            // this is the backwardCompatibility mode in place before ZK-107\n<line16>            // It is for a version of the protocol in which we didn't send peer epoch\n<line17>            // With peer epoch and version the message became 40 bytes\n<line18>            boolean backCompatibility28 = (capacity == 28);\n<line19>            // this is the backwardCompatibility mode for no version information\n<line20>            boolean backCompatibility40 = (capacity == 40);\n<line21>            response.buffer.clear();\n<line22>            // Instantiate Notification and set its attributes\n<line23>            Notification n = new Notification();\n<line24>            int rstate = response.buffer.getInt();\n<line25>            long rleader = response.buffer.getLong();\n<line26>            long rzxid = response.buffer.getLong();\n<line27>            long relectionEpoch = response.buffer.getLong();\n<line28>            long rpeerepoch;\n<line29>            int version = 0x0;\n<line30>            QuorumVerifier rqv = null;\n<line31>            try {\n<line32>                if (!backCompatibility28) {\n<line33>                    rpeerepoch = response.buffer.getLong();\n<line34>                    if (!backCompatibility40) {\n<line35>                        /*\n<line36>                                     * Version added in 3.4.6\n<line37>                                     */\n<line38>                        version = response.buffer.getInt();\n<line39>                    } else {\n<line40>                    }\n<line41>                } else {\n<line42>                    rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line43>                }\n<line44>                // check if we have a version that includes config. If so extract config info from message.\n<line45>                if (version > 0x1) {\n<line46>                    int configLength = response.buffer.getInt();\n<line47>                    // we want to avoid errors caused by the allocation of a byte array with negative length\n<line48>                    // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line49>                    if (configLength < 0 || configLength > capacity) {\n<line50>                        throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line51>                    }\n<line52>                    byte[] b = new byte[configLength];\n<line53>                    response.buffer.get(b);\n<line54>                    synchronized (self) {\n<line55>                        try {\n<line56>                            rqv = self.configFromString(new String(b, UTF_8));\n<line57>                            QuorumVerifier curQV = self.getQuorumVerifier();\n<line58>                            if (rqv.getVersion() > curQV.getVersion()) {\n<line59>                                if (self.getPeerState() == ServerState.LOOKING) {\n<line60>                                    self.processReconfig(rqv, null, null, false);\n<line61>                                    if (!rqv.equals(curQV)) {\n<line62>                                        self.shuttingDownLE = true;\n<line63>                                        self.getElectionAlg().shutdown();\n<line64>                                        break;\n<line65>                                    }\n<line66>                                } else {\n<line67>                                }\n<line68>                            }\n<line69>                        } catch (IOException | ConfigException e) {\n<line70>                        }\n<line71>                    }\n<line72>                } else {\n<line73>                }\n<line74>            } catch (BufferUnderflowException | IOException e) {\n<line75>                continue;\n<line76>            }\n<line77>            /*\n<line78>                         * If it is from a non-voting server (such as an observer or\n<line79>                         * a non-voting follower), respond right away.\n<line80>                         */\n<line81>            if (!validVoter(response.sid)) {\n<line82>                Vote current = self.getCurrentVote();\n<line83>                QuorumVerifier qv = self.getQuorumVerifier();\n<line84>                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes(UTF_8));\n<line85>                sendqueue.offer(notmsg);\n<line86>            } else {\n<line87>                // Receive new message\n<line88>                // State of peer that sent this message\n<line89>                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line90>                switch(rstate) {\n<line91>                    case 0:\n<line92>                        ackstate = QuorumPeer.ServerState.LOOKING;\n<line93>                        break;\n<line94>                    case 1:\n<line95>                        ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line96>                        break;\n<line97>                    case 2:\n<line98>                        ackstate = QuorumPeer.ServerState.LEADING;\n<line99>                        break;\n<line100>                    case 3:\n<line101>                        ackstate = QuorumPeer.ServerState.OBSERVING;\n<line102>                        break;\n<line103>                    default:\n<line104>                        continue;\n<line105>                }\n<line106>                n.leader = rleader;\n<line107>                n.zxid = rzxid;\n<line108>                n.electionEpoch = relectionEpoch;\n<line109>                n.state = ackstate;\n<line110>                n.sid = response.sid;\n<line111>                n.peerEpoch = rpeerepoch;\n<line112>                n.version = version;\n<line113>                n.qv = rqv;\n<line114>                /*\n<line115>                             * Print notification info\n<line116>                             */\n<line117>                /*\n<line118>                             * If this server is looking, then send proposed leader\n<line119>                             */\n<line120>                if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line121>                    recvqueue.offer(n);\n<line122>                    /*\n<line123>                                 * Send a notification back if the peer that sent this\n<line124>                                 * message is also looking and its logical clock is\n<line125>                                 * lagging behind.\n<line126>                                 */\n<line127>                    if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line128>                        Vote v = getVote();\n<line129>                        QuorumVerifier qv = self.getQuorumVerifier();\n<line130>                        ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line131>                        sendqueue.offer(notmsg);\n<line132>                    }\n<line133>                } else {\n<line134>                    /*\n<line135>                                 * If this server is not looking, but the one that sent the ack\n<line136>                                 * is looking, then send back what it believes to be the leader.\n<line137>                                 */\n<line138>                    Vote current = self.getCurrentVote();\n<line139>                    if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line140>                        if (self.leader != null) {\n<line141>                            if (leadingVoteSet != null) {\n<line142>                                self.leader.setLeadingVoteSet(leadingVoteSet);\n<line143>                                leadingVoteSet = null;\n<line144>                            }\n<line145>                            self.leader.reportLookingSid(response.sid);\n<line146>                        }\n<line147>                        QuorumVerifier qv = self.getQuorumVerifier();\n<line148>                        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line149>                        sendqueue.offer(notmsg);\n<line150>                    }\n<line151>                }\n<line152>            }\n<line153>        } catch (InterruptedException e) {\n<line154>        }\n<line155>    }\n<line156>}","output":"<line1>{\n<line2>    Message response;\n<line3>    while (!stop) {\n<line4>        // Sleeps on receive\n<line5>        try {\n<line6>            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line7>            if (response == null) {\n<line8>                continue;\n<line9>            }\n<line10>            final int capacity = response.buffer.capacity();\n<line11>            // The current protocol and two previous generations all send at least 28 bytes\n<line12>            if (capacity < 28) {\n<line13>                LOG.error(\"Got a short response from server {}: {}\", response.sid, capacity);\n<line14>                continue;\n<line15>            }\n<line16>            // this is the backwardCompatibility mode in place before ZK-107\n<line17>            // It is for a version of the protocol in which we didn't send peer epoch\n<line18>            // With peer epoch and version the message became 40 bytes\n<line19>            boolean backCompatibility28 = (capacity == 28);\n<line20>            // this is the backwardCompatibility mode for no version information\n<line21>            boolean backCompatibility40 = (capacity == 40);\n<line22>            response.buffer.clear();\n<line23>            // Instantiate Notification and set its attributes\n<line24>            Notification n = new Notification();\n<line25>            int rstate = response.buffer.getInt();\n<line26>            long rleader = response.buffer.getLong();\n<line27>            long rzxid = response.buffer.getLong();\n<line28>            long relectionEpoch = response.buffer.getLong();\n<line29>            long rpeerepoch;\n<line30>            int version = 0x0;\n<line31>            QuorumVerifier rqv = null;\n<line32>            try {\n<line33>                if (!backCompatibility28) {\n<line34>                    rpeerepoch = response.buffer.getLong();\n<line35>                    if (!backCompatibility40) {\n<line36>                        /*\n<line37>                                     * Version added in 3.4.6\n<line38>                                     */\n<line39>                        version = response.buffer.getInt();\n<line40>                    } else {\n<line41>                        LOG.info(\"Backward compatibility mode (36 bits), server id: {}\", response.sid);\n<line42>                    }\n<line43>                } else {\n<line44>                    LOG.info(\"Backward compatibility mode (28 bits), server id: {}\", response.sid);\n<line45>                    rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line46>                }\n<line47>                // check if we have a version that includes config. If so extract config info from message.\n<line48>                if (version > 0x1) {\n<line49>                    int configLength = response.buffer.getInt();\n<line50>                    // we want to avoid errors caused by the allocation of a byte array with negative length\n<line51>                    // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line52>                    if (configLength < 0 || configLength > capacity) {\n<line53>                        throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line54>                    }\n<line55>                    byte[] b = new byte[configLength];\n<line56>                    response.buffer.get(b);\n<line57>                    synchronized (self) {\n<line58>                        try {\n<line59>                            rqv = self.configFromString(new String(b, UTF_8));\n<line60>                            QuorumVerifier curQV = self.getQuorumVerifier();\n<line61>                            if (rqv.getVersion() > curQV.getVersion()) {\n<line62>                                LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line63>                                if (self.getPeerState() == ServerState.LOOKING) {\n<line64>                                    LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line65>                                    self.processReconfig(rqv, null, null, false);\n<line66>                                    if (!rqv.equals(curQV)) {\n<line67>                                        LOG.info(\"restarting leader election\");\n<line68>                                        self.shuttingDownLE = true;\n<line69>                                        self.getElectionAlg().shutdown();\n<line70>                                        break;\n<line71>                                    }\n<line72>                                } else {\n<line73>                                    LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line74>                                }\n<line75>                            }\n<line76>                        } catch (IOException | ConfigException e) {\n<line77>                            LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line78>                        }\n<line79>                    }\n<line80>                } else {\n<line81>                    LOG.info(\"Backward compatibility mode (before reconfig), server id: {}\", response.sid);\n<line82>                }\n<line83>            } catch (BufferUnderflowException | IOException e) {\n<line84>                LOG.warn(\"Skipping the processing of a partial / malformed response message sent by sid={} (message length: {})\", response.sid, capacity, e);\n<line85>                continue;\n<line86>            }\n<line87>            /*\n<line88>                         * If it is from a non-voting server (such as an observer or\n<line89>                         * a non-voting follower), respond right away.\n<line90>                         */\n<line91>            if (!validVoter(response.sid)) {\n<line92>                Vote current = self.getCurrentVote();\n<line93>                QuorumVerifier qv = self.getQuorumVerifier();\n<line94>                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes(UTF_8));\n<line95>                sendqueue.offer(notmsg);\n<line96>            } else {\n<line97>                // Receive new message\n<line98>                LOG.debug(\"Receive new notification message. My id = {}\", self.getMyId());\n<line99>                // State of peer that sent this message\n<line100>                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line101>                switch(rstate) {\n<line102>                    case 0:\n<line103>                        ackstate = QuorumPeer.ServerState.LOOKING;\n<line104>                        break;\n<line105>                    case 1:\n<line106>                        ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line107>                        break;\n<line108>                    case 2:\n<line109>                        ackstate = QuorumPeer.ServerState.LEADING;\n<line110>                        break;\n<line111>                    case 3:\n<line112>                        ackstate = QuorumPeer.ServerState.OBSERVING;\n<line113>                        break;\n<line114>                    default:\n<line115>                        continue;\n<line116>                }\n<line117>                n.leader = rleader;\n<line118>                n.zxid = rzxid;\n<line119>                n.electionEpoch = relectionEpoch;\n<line120>                n.state = ackstate;\n<line121>                n.sid = response.sid;\n<line122>                n.peerEpoch = rpeerepoch;\n<line123>                n.version = version;\n<line124>                n.qv = rqv;\n<line125>                /*\n<line126>                             * Print notification info\n<line127>                             */\n<line128>                LOG.info(\"Notification: my state:{}; n.sid:{}, n.state:{}, n.leader:{}, n.round:0x{}, \" + \"n.peerEpoch:0x{}, n.zxid:0x{}, message format version:0x{}, n.config version:0x{}\", self.getPeerState(), n.sid, n.state, n.leader, Long.toHexString(n.electionEpoch), Long.toHexString(n.peerEpoch), Long.toHexString(n.zxid), Long.toHexString(n.version), (n.qv != null ? (Long.toHexString(n.qv.getVersion())) : \"0\"));\n<line129>                /*\n<line130>                             * If this server is looking, then send proposed leader\n<line131>                             */\n<line132>                if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line133>                    recvqueue.offer(n);\n<line134>                    /*\n<line135>                                 * Send a notification back if the peer that sent this\n<line136>                                 * message is also looking and its logical clock is\n<line137>                                 * lagging behind.\n<line138>                                 */\n<line139>                    if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line140>                        Vote v = getVote();\n<line141>                        QuorumVerifier qv = self.getQuorumVerifier();\n<line142>                        ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line143>                        sendqueue.offer(notmsg);\n<line144>                    }\n<line145>                } else {\n<line146>                    /*\n<line147>                                 * If this server is not looking, but the one that sent the ack\n<line148>                                 * is looking, then send back what it believes to be the leader.\n<line149>                                 */\n<line150>                    Vote current = self.getCurrentVote();\n<line151>                    if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line152>                        if (self.leader != null) {\n<line153>                            if (leadingVoteSet != null) {\n<line154>                                self.leader.setLeadingVoteSet(leadingVoteSet);\n<line155>                                leadingVoteSet = null;\n<line156>                            }\n<line157>                            self.leader.reportLookingSid(response.sid);\n<line158>                        }\n<line159>                        LOG.debug(\"Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}\", self.getMyId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line160>                        QuorumVerifier qv = self.getQuorumVerifier();\n<line161>                        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line162>                        sendqueue.offer(notmsg);\n<line163>                    }\n<line164>                }\n<line165>            }\n<line166>        } catch (InterruptedException e) {\n<line167>            LOG.warn(\"Interrupted Exception while waiting for new message\", e);\n<line168>        }\n<line169>    }\n<line170>    LOG.info(\"WorkerReceiver is down\");\n<line171>}"},{"input":"","instruction":"<line1>{\n<line2>    // Sleeps on receive\n<line3>    try {\n<line4>        response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line5>        if (response == null) {\n<line6>            continue;\n<line7>        }\n<line8>        final int capacity = response.buffer.capacity();\n<line9>        // The current protocol and two previous generations all send at least 28 bytes\n<line10>        if (capacity < 28) {\n<line11>            continue;\n<line12>        }\n<line13>        // this is the backwardCompatibility mode in place before ZK-107\n<line14>        // It is for a version of the protocol in which we didn't send peer epoch\n<line15>        // With peer epoch and version the message became 40 bytes\n<line16>        boolean backCompatibility28 = (capacity == 28);\n<line17>        // this is the backwardCompatibility mode for no version information\n<line18>        boolean backCompatibility40 = (capacity == 40);\n<line19>        response.buffer.clear();\n<line20>        // Instantiate Notification and set its attributes\n<line21>        Notification n = new Notification();\n<line22>        int rstate = response.buffer.getInt();\n<line23>        long rleader = response.buffer.getLong();\n<line24>        long rzxid = response.buffer.getLong();\n<line25>        long relectionEpoch = response.buffer.getLong();\n<line26>        long rpeerepoch;\n<line27>        int version = 0x0;\n<line28>        QuorumVerifier rqv = null;\n<line29>        try {\n<line30>            if (!backCompatibility28) {\n<line31>                rpeerepoch = response.buffer.getLong();\n<line32>                if (!backCompatibility40) {\n<line33>                    /*\n<line34>                                     * Version added in 3.4.6\n<line35>                                     */\n<line36>                    version = response.buffer.getInt();\n<line37>                } else {\n<line38>                }\n<line39>            } else {\n<line40>                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line41>            }\n<line42>            // check if we have a version that includes config. If so extract config info from message.\n<line43>            if (version > 0x1) {\n<line44>                int configLength = response.buffer.getInt();\n<line45>                // we want to avoid errors caused by the allocation of a byte array with negative length\n<line46>                // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line47>                if (configLength < 0 || configLength > capacity) {\n<line48>                    throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line49>                }\n<line50>                byte[] b = new byte[configLength];\n<line51>                response.buffer.get(b);\n<line52>                synchronized (self) {\n<line53>                    try {\n<line54>                        rqv = self.configFromString(new String(b, UTF_8));\n<line55>                        QuorumVerifier curQV = self.getQuorumVerifier();\n<line56>                        if (rqv.getVersion() > curQV.getVersion()) {\n<line57>                            if (self.getPeerState() == ServerState.LOOKING) {\n<line58>                                self.processReconfig(rqv, null, null, false);\n<line59>                                if (!rqv.equals(curQV)) {\n<line60>                                    self.shuttingDownLE = true;\n<line61>                                    self.getElectionAlg().shutdown();\n<line62>                                    break;\n<line63>                                }\n<line64>                            } else {\n<line65>                            }\n<line66>                        }\n<line67>                    } catch (IOException | ConfigException e) {\n<line68>                    }\n<line69>                }\n<line70>            } else {\n<line71>            }\n<line72>        } catch (BufferUnderflowException | IOException e) {\n<line73>            continue;\n<line74>        }\n<line75>        /*\n<line76>                         * If it is from a non-voting server (such as an observer or\n<line77>                         * a non-voting follower), respond right away.\n<line78>                         */\n<line79>        if (!validVoter(response.sid)) {\n<line80>            Vote current = self.getCurrentVote();\n<line81>            QuorumVerifier qv = self.getQuorumVerifier();\n<line82>            ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes(UTF_8));\n<line83>            sendqueue.offer(notmsg);\n<line84>        } else {\n<line85>            // Receive new message\n<line86>            // State of peer that sent this message\n<line87>            QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line88>            switch(rstate) {\n<line89>                case 0:\n<line90>                    ackstate = QuorumPeer.ServerState.LOOKING;\n<line91>                    break;\n<line92>                case 1:\n<line93>                    ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line94>                    break;\n<line95>                case 2:\n<line96>                    ackstate = QuorumPeer.ServerState.LEADING;\n<line97>                    break;\n<line98>                case 3:\n<line99>                    ackstate = QuorumPeer.ServerState.OBSERVING;\n<line100>                    break;\n<line101>                default:\n<line102>                    continue;\n<line103>            }\n<line104>            n.leader = rleader;\n<line105>            n.zxid = rzxid;\n<line106>            n.electionEpoch = relectionEpoch;\n<line107>            n.state = ackstate;\n<line108>            n.sid = response.sid;\n<line109>            n.peerEpoch = rpeerepoch;\n<line110>            n.version = version;\n<line111>            n.qv = rqv;\n<line112>            /*\n<line113>                             * Print notification info\n<line114>                             */\n<line115>            /*\n<line116>                             * If this server is looking, then send proposed leader\n<line117>                             */\n<line118>            if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line119>                recvqueue.offer(n);\n<line120>                /*\n<line121>                                 * Send a notification back if the peer that sent this\n<line122>                                 * message is also looking and its logical clock is\n<line123>                                 * lagging behind.\n<line124>                                 */\n<line125>                if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line126>                    Vote v = getVote();\n<line127>                    QuorumVerifier qv = self.getQuorumVerifier();\n<line128>                    ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line129>                    sendqueue.offer(notmsg);\n<line130>                }\n<line131>            } else {\n<line132>                /*\n<line133>                                 * If this server is not looking, but the one that sent the ack\n<line134>                                 * is looking, then send back what it believes to be the leader.\n<line135>                                 */\n<line136>                Vote current = self.getCurrentVote();\n<line137>                if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line138>                    if (self.leader != null) {\n<line139>                        if (leadingVoteSet != null) {\n<line140>                            self.leader.setLeadingVoteSet(leadingVoteSet);\n<line141>                            leadingVoteSet = null;\n<line142>                        }\n<line143>                        self.leader.reportLookingSid(response.sid);\n<line144>                    }\n<line145>                    QuorumVerifier qv = self.getQuorumVerifier();\n<line146>                    ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line147>                    sendqueue.offer(notmsg);\n<line148>                }\n<line149>            }\n<line150>        }\n<line151>    } catch (InterruptedException e) {\n<line152>    }\n<line153>}","output":"<line1>{\n<line2>    // Sleeps on receive\n<line3>    try {\n<line4>        response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line5>        if (response == null) {\n<line6>            continue;\n<line7>        }\n<line8>        final int capacity = response.buffer.capacity();\n<line9>        // The current protocol and two previous generations all send at least 28 bytes\n<line10>        if (capacity < 28) {\n<line11>            LOG.error(\"Got a short response from server {}: {}\", response.sid, capacity);\n<line12>            continue;\n<line13>        }\n<line14>        // this is the backwardCompatibility mode in place before ZK-107\n<line15>        // It is for a version of the protocol in which we didn't send peer epoch\n<line16>        // With peer epoch and version the message became 40 bytes\n<line17>        boolean backCompatibility28 = (capacity == 28);\n<line18>        // this is the backwardCompatibility mode for no version information\n<line19>        boolean backCompatibility40 = (capacity == 40);\n<line20>        response.buffer.clear();\n<line21>        // Instantiate Notification and set its attributes\n<line22>        Notification n = new Notification();\n<line23>        int rstate = response.buffer.getInt();\n<line24>        long rleader = response.buffer.getLong();\n<line25>        long rzxid = response.buffer.getLong();\n<line26>        long relectionEpoch = response.buffer.getLong();\n<line27>        long rpeerepoch;\n<line28>        int version = 0x0;\n<line29>        QuorumVerifier rqv = null;\n<line30>        try {\n<line31>            if (!backCompatibility28) {\n<line32>                rpeerepoch = response.buffer.getLong();\n<line33>                if (!backCompatibility40) {\n<line34>                    /*\n<line35>                                     * Version added in 3.4.6\n<line36>                                     */\n<line37>                    version = response.buffer.getInt();\n<line38>                } else {\n<line39>                    LOG.info(\"Backward compatibility mode (36 bits), server id: {}\", response.sid);\n<line40>                }\n<line41>            } else {\n<line42>                LOG.info(\"Backward compatibility mode (28 bits), server id: {}\", response.sid);\n<line43>                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line44>            }\n<line45>            // check if we have a version that includes config. If so extract config info from message.\n<line46>            if (version > 0x1) {\n<line47>                int configLength = response.buffer.getInt();\n<line48>                // we want to avoid errors caused by the allocation of a byte array with negative length\n<line49>                // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line50>                if (configLength < 0 || configLength > capacity) {\n<line51>                    throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line52>                }\n<line53>                byte[] b = new byte[configLength];\n<line54>                response.buffer.get(b);\n<line55>                synchronized (self) {\n<line56>                    try {\n<line57>                        rqv = self.configFromString(new String(b, UTF_8));\n<line58>                        QuorumVerifier curQV = self.getQuorumVerifier();\n<line59>                        if (rqv.getVersion() > curQV.getVersion()) {\n<line60>                            LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line61>                            if (self.getPeerState() == ServerState.LOOKING) {\n<line62>                                LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line63>                                self.processReconfig(rqv, null, null, false);\n<line64>                                if (!rqv.equals(curQV)) {\n<line65>                                    LOG.info(\"restarting leader election\");\n<line66>                                    self.shuttingDownLE = true;\n<line67>                                    self.getElectionAlg().shutdown();\n<line68>                                    break;\n<line69>                                }\n<line70>                            } else {\n<line71>                                LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line72>                            }\n<line73>                        }\n<line74>                    } catch (IOException | ConfigException e) {\n<line75>                        LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line76>                    }\n<line77>                }\n<line78>            } else {\n<line79>                LOG.info(\"Backward compatibility mode (before reconfig), server id: {}\", response.sid);\n<line80>            }\n<line81>        } catch (BufferUnderflowException | IOException e) {\n<line82>            LOG.warn(\"Skipping the processing of a partial / malformed response message sent by sid={} (message length: {})\", response.sid, capacity, e);\n<line83>            continue;\n<line84>        }\n<line85>        /*\n<line86>                         * If it is from a non-voting server (such as an observer or\n<line87>                         * a non-voting follower), respond right away.\n<line88>                         */\n<line89>        if (!validVoter(response.sid)) {\n<line90>            Vote current = self.getCurrentVote();\n<line91>            QuorumVerifier qv = self.getQuorumVerifier();\n<line92>            ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes(UTF_8));\n<line93>            sendqueue.offer(notmsg);\n<line94>        } else {\n<line95>            // Receive new message\n<line96>            LOG.debug(\"Receive new notification message. My id = {}\", self.getMyId());\n<line97>            // State of peer that sent this message\n<line98>            QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line99>            switch(rstate) {\n<line100>                case 0:\n<line101>                    ackstate = QuorumPeer.ServerState.LOOKING;\n<line102>                    break;\n<line103>                case 1:\n<line104>                    ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line105>                    break;\n<line106>                case 2:\n<line107>                    ackstate = QuorumPeer.ServerState.LEADING;\n<line108>                    break;\n<line109>                case 3:\n<line110>                    ackstate = QuorumPeer.ServerState.OBSERVING;\n<line111>                    break;\n<line112>                default:\n<line113>                    continue;\n<line114>            }\n<line115>            n.leader = rleader;\n<line116>            n.zxid = rzxid;\n<line117>            n.electionEpoch = relectionEpoch;\n<line118>            n.state = ackstate;\n<line119>            n.sid = response.sid;\n<line120>            n.peerEpoch = rpeerepoch;\n<line121>            n.version = version;\n<line122>            n.qv = rqv;\n<line123>            /*\n<line124>                             * Print notification info\n<line125>                             */\n<line126>            LOG.info(\"Notification: my state:{}; n.sid:{}, n.state:{}, n.leader:{}, n.round:0x{}, \" + \"n.peerEpoch:0x{}, n.zxid:0x{}, message format version:0x{}, n.config version:0x{}\", self.getPeerState(), n.sid, n.state, n.leader, Long.toHexString(n.electionEpoch), Long.toHexString(n.peerEpoch), Long.toHexString(n.zxid), Long.toHexString(n.version), (n.qv != null ? (Long.toHexString(n.qv.getVersion())) : \"0\"));\n<line127>            /*\n<line128>                             * If this server is looking, then send proposed leader\n<line129>                             */\n<line130>            if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line131>                recvqueue.offer(n);\n<line132>                /*\n<line133>                                 * Send a notification back if the peer that sent this\n<line134>                                 * message is also looking and its logical clock is\n<line135>                                 * lagging behind.\n<line136>                                 */\n<line137>                if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line138>                    Vote v = getVote();\n<line139>                    QuorumVerifier qv = self.getQuorumVerifier();\n<line140>                    ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line141>                    sendqueue.offer(notmsg);\n<line142>                }\n<line143>            } else {\n<line144>                /*\n<line145>                                 * If this server is not looking, but the one that sent the ack\n<line146>                                 * is looking, then send back what it believes to be the leader.\n<line147>                                 */\n<line148>                Vote current = self.getCurrentVote();\n<line149>                if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line150>                    if (self.leader != null) {\n<line151>                        if (leadingVoteSet != null) {\n<line152>                            self.leader.setLeadingVoteSet(leadingVoteSet);\n<line153>                            leadingVoteSet = null;\n<line154>                        }\n<line155>                        self.leader.reportLookingSid(response.sid);\n<line156>                    }\n<line157>                    LOG.debug(\"Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}\", self.getMyId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line158>                    QuorumVerifier qv = self.getQuorumVerifier();\n<line159>                    ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line160>                    sendqueue.offer(notmsg);\n<line161>                }\n<line162>            }\n<line163>        }\n<line164>    } catch (InterruptedException e) {\n<line165>        LOG.warn(\"Interrupted Exception while waiting for new message\", e);\n<line166>    }\n<line167>}"},{"input":"","instruction":"<line1>{\n<line2>    response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line3>    if (response == null) {\n<line4>        continue;\n<line5>    }\n<line6>    final int capacity = response.buffer.capacity();\n<line7>    // The current protocol and two previous generations all send at least 28 bytes\n<line8>    if (capacity < 28) {\n<line9>        continue;\n<line10>    }\n<line11>    // this is the backwardCompatibility mode in place before ZK-107\n<line12>    // It is for a version of the protocol in which we didn't send peer epoch\n<line13>    // With peer epoch and version the message became 40 bytes\n<line14>    boolean backCompatibility28 = (capacity == 28);\n<line15>    // this is the backwardCompatibility mode for no version information\n<line16>    boolean backCompatibility40 = (capacity == 40);\n<line17>    response.buffer.clear();\n<line18>    // Instantiate Notification and set its attributes\n<line19>    Notification n = new Notification();\n<line20>    int rstate = response.buffer.getInt();\n<line21>    long rleader = response.buffer.getLong();\n<line22>    long rzxid = response.buffer.getLong();\n<line23>    long relectionEpoch = response.buffer.getLong();\n<line24>    long rpeerepoch;\n<line25>    int version = 0x0;\n<line26>    QuorumVerifier rqv = null;\n<line27>    try {\n<line28>        if (!backCompatibility28) {\n<line29>            rpeerepoch = response.buffer.getLong();\n<line30>            if (!backCompatibility40) {\n<line31>                /*\n<line32>                                     * Version added in 3.4.6\n<line33>                                     */\n<line34>                version = response.buffer.getInt();\n<line35>            } else {\n<line36>            }\n<line37>        } else {\n<line38>            rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line39>        }\n<line40>        // check if we have a version that includes config. If so extract config info from message.\n<line41>        if (version > 0x1) {\n<line42>            int configLength = response.buffer.getInt();\n<line43>            // we want to avoid errors caused by the allocation of a byte array with negative length\n<line44>            // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line45>            if (configLength < 0 || configLength > capacity) {\n<line46>                throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line47>            }\n<line48>            byte[] b = new byte[configLength];\n<line49>            response.buffer.get(b);\n<line50>            synchronized (self) {\n<line51>                try {\n<line52>                    rqv = self.configFromString(new String(b, UTF_8));\n<line53>                    QuorumVerifier curQV = self.getQuorumVerifier();\n<line54>                    if (rqv.getVersion() > curQV.getVersion()) {\n<line55>                        if (self.getPeerState() == ServerState.LOOKING) {\n<line56>                            self.processReconfig(rqv, null, null, false);\n<line57>                            if (!rqv.equals(curQV)) {\n<line58>                                self.shuttingDownLE = true;\n<line59>                                self.getElectionAlg().shutdown();\n<line60>                                break;\n<line61>                            }\n<line62>                        } else {\n<line63>                        }\n<line64>                    }\n<line65>                } catch (IOException | ConfigException e) {\n<line66>                }\n<line67>            }\n<line68>        } else {\n<line69>        }\n<line70>    } catch (BufferUnderflowException | IOException e) {\n<line71>        continue;\n<line72>    }\n<line73>    /*\n<line74>                         * If it is from a non-voting server (such as an observer or\n<line75>                         * a non-voting follower), respond right away.\n<line76>                         */\n<line77>    if (!validVoter(response.sid)) {\n<line78>        Vote current = self.getCurrentVote();\n<line79>        QuorumVerifier qv = self.getQuorumVerifier();\n<line80>        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes(UTF_8));\n<line81>        sendqueue.offer(notmsg);\n<line82>    } else {\n<line83>        // Receive new message\n<line84>        // State of peer that sent this message\n<line85>        QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line86>        switch(rstate) {\n<line87>            case 0:\n<line88>                ackstate = QuorumPeer.ServerState.LOOKING;\n<line89>                break;\n<line90>            case 1:\n<line91>                ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line92>                break;\n<line93>            case 2:\n<line94>                ackstate = QuorumPeer.ServerState.LEADING;\n<line95>                break;\n<line96>            case 3:\n<line97>                ackstate = QuorumPeer.ServerState.OBSERVING;\n<line98>                break;\n<line99>            default:\n<line100>                continue;\n<line101>        }\n<line102>        n.leader = rleader;\n<line103>        n.zxid = rzxid;\n<line104>        n.electionEpoch = relectionEpoch;\n<line105>        n.state = ackstate;\n<line106>        n.sid = response.sid;\n<line107>        n.peerEpoch = rpeerepoch;\n<line108>        n.version = version;\n<line109>        n.qv = rqv;\n<line110>        /*\n<line111>                             * Print notification info\n<line112>                             */\n<line113>        /*\n<line114>                             * If this server is looking, then send proposed leader\n<line115>                             */\n<line116>        if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line117>            recvqueue.offer(n);\n<line118>            /*\n<line119>                                 * Send a notification back if the peer that sent this\n<line120>                                 * message is also looking and its logical clock is\n<line121>                                 * lagging behind.\n<line122>                                 */\n<line123>            if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line124>                Vote v = getVote();\n<line125>                QuorumVerifier qv = self.getQuorumVerifier();\n<line126>                ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line127>                sendqueue.offer(notmsg);\n<line128>            }\n<line129>        } else {\n<line130>            /*\n<line131>                                 * If this server is not looking, but the one that sent the ack\n<line132>                                 * is looking, then send back what it believes to be the leader.\n<line133>                                 */\n<line134>            Vote current = self.getCurrentVote();\n<line135>            if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line136>                if (self.leader != null) {\n<line137>                    if (leadingVoteSet != null) {\n<line138>                        self.leader.setLeadingVoteSet(leadingVoteSet);\n<line139>                        leadingVoteSet = null;\n<line140>                    }\n<line141>                    self.leader.reportLookingSid(response.sid);\n<line142>                }\n<line143>                QuorumVerifier qv = self.getQuorumVerifier();\n<line144>                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line145>                sendqueue.offer(notmsg);\n<line146>            }\n<line147>        }\n<line148>    }\n<line149>}","output":"<line1>{\n<line2>    response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n<line3>    if (response == null) {\n<line4>        continue;\n<line5>    }\n<line6>    final int capacity = response.buffer.capacity();\n<line7>    // The current protocol and two previous generations all send at least 28 bytes\n<line8>    if (capacity < 28) {\n<line9>        LOG.error(\"Got a short response from server {}: {}\", response.sid, capacity);\n<line10>        continue;\n<line11>    }\n<line12>    // this is the backwardCompatibility mode in place before ZK-107\n<line13>    // It is for a version of the protocol in which we didn't send peer epoch\n<line14>    // With peer epoch and version the message became 40 bytes\n<line15>    boolean backCompatibility28 = (capacity == 28);\n<line16>    // this is the backwardCompatibility mode for no version information\n<line17>    boolean backCompatibility40 = (capacity == 40);\n<line18>    response.buffer.clear();\n<line19>    // Instantiate Notification and set its attributes\n<line20>    Notification n = new Notification();\n<line21>    int rstate = response.buffer.getInt();\n<line22>    long rleader = response.buffer.getLong();\n<line23>    long rzxid = response.buffer.getLong();\n<line24>    long relectionEpoch = response.buffer.getLong();\n<line25>    long rpeerepoch;\n<line26>    int version = 0x0;\n<line27>    QuorumVerifier rqv = null;\n<line28>    try {\n<line29>        if (!backCompatibility28) {\n<line30>            rpeerepoch = response.buffer.getLong();\n<line31>            if (!backCompatibility40) {\n<line32>                /*\n<line33>                                     * Version added in 3.4.6\n<line34>                                     */\n<line35>                version = response.buffer.getInt();\n<line36>            } else {\n<line37>                LOG.info(\"Backward compatibility mode (36 bits), server id: {}\", response.sid);\n<line38>            }\n<line39>        } else {\n<line40>            LOG.info(\"Backward compatibility mode (28 bits), server id: {}\", response.sid);\n<line41>            rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line42>        }\n<line43>        // check if we have a version that includes config. If so extract config info from message.\n<line44>        if (version > 0x1) {\n<line45>            int configLength = response.buffer.getInt();\n<line46>            // we want to avoid errors caused by the allocation of a byte array with negative length\n<line47>            // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line48>            if (configLength < 0 || configLength > capacity) {\n<line49>                throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line50>            }\n<line51>            byte[] b = new byte[configLength];\n<line52>            response.buffer.get(b);\n<line53>            synchronized (self) {\n<line54>                try {\n<line55>                    rqv = self.configFromString(new String(b, UTF_8));\n<line56>                    QuorumVerifier curQV = self.getQuorumVerifier();\n<line57>                    if (rqv.getVersion() > curQV.getVersion()) {\n<line58>                        LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line59>                        if (self.getPeerState() == ServerState.LOOKING) {\n<line60>                            LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line61>                            self.processReconfig(rqv, null, null, false);\n<line62>                            if (!rqv.equals(curQV)) {\n<line63>                                LOG.info(\"restarting leader election\");\n<line64>                                self.shuttingDownLE = true;\n<line65>                                self.getElectionAlg().shutdown();\n<line66>                                break;\n<line67>                            }\n<line68>                        } else {\n<line69>                            LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line70>                        }\n<line71>                    }\n<line72>                } catch (IOException | ConfigException e) {\n<line73>                    LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line74>                }\n<line75>            }\n<line76>        } else {\n<line77>            LOG.info(\"Backward compatibility mode (before reconfig), server id: {}\", response.sid);\n<line78>        }\n<line79>    } catch (BufferUnderflowException | IOException e) {\n<line80>        LOG.warn(\"Skipping the processing of a partial / malformed response message sent by sid={} (message length: {})\", response.sid, capacity, e);\n<line81>        continue;\n<line82>    }\n<line83>    /*\n<line84>                         * If it is from a non-voting server (such as an observer or\n<line85>                         * a non-voting follower), respond right away.\n<line86>                         */\n<line87>    if (!validVoter(response.sid)) {\n<line88>        Vote current = self.getCurrentVote();\n<line89>        QuorumVerifier qv = self.getQuorumVerifier();\n<line90>        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes(UTF_8));\n<line91>        sendqueue.offer(notmsg);\n<line92>    } else {\n<line93>        // Receive new message\n<line94>        LOG.debug(\"Receive new notification message. My id = {}\", self.getMyId());\n<line95>        // State of peer that sent this message\n<line96>        QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line97>        switch(rstate) {\n<line98>            case 0:\n<line99>                ackstate = QuorumPeer.ServerState.LOOKING;\n<line100>                break;\n<line101>            case 1:\n<line102>                ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line103>                break;\n<line104>            case 2:\n<line105>                ackstate = QuorumPeer.ServerState.LEADING;\n<line106>                break;\n<line107>            case 3:\n<line108>                ackstate = QuorumPeer.ServerState.OBSERVING;\n<line109>                break;\n<line110>            default:\n<line111>                continue;\n<line112>        }\n<line113>        n.leader = rleader;\n<line114>        n.zxid = rzxid;\n<line115>        n.electionEpoch = relectionEpoch;\n<line116>        n.state = ackstate;\n<line117>        n.sid = response.sid;\n<line118>        n.peerEpoch = rpeerepoch;\n<line119>        n.version = version;\n<line120>        n.qv = rqv;\n<line121>        /*\n<line122>                             * Print notification info\n<line123>                             */\n<line124>        LOG.info(\"Notification: my state:{}; n.sid:{}, n.state:{}, n.leader:{}, n.round:0x{}, \" + \"n.peerEpoch:0x{}, n.zxid:0x{}, message format version:0x{}, n.config version:0x{}\", self.getPeerState(), n.sid, n.state, n.leader, Long.toHexString(n.electionEpoch), Long.toHexString(n.peerEpoch), Long.toHexString(n.zxid), Long.toHexString(n.version), (n.qv != null ? (Long.toHexString(n.qv.getVersion())) : \"0\"));\n<line125>        /*\n<line126>                             * If this server is looking, then send proposed leader\n<line127>                             */\n<line128>        if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line129>            recvqueue.offer(n);\n<line130>            /*\n<line131>                                 * Send a notification back if the peer that sent this\n<line132>                                 * message is also looking and its logical clock is\n<line133>                                 * lagging behind.\n<line134>                                 */\n<line135>            if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line136>                Vote v = getVote();\n<line137>                QuorumVerifier qv = self.getQuorumVerifier();\n<line138>                ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line139>                sendqueue.offer(notmsg);\n<line140>            }\n<line141>        } else {\n<line142>            /*\n<line143>                                 * If this server is not looking, but the one that sent the ack\n<line144>                                 * is looking, then send back what it believes to be the leader.\n<line145>                                 */\n<line146>            Vote current = self.getCurrentVote();\n<line147>            if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line148>                if (self.leader != null) {\n<line149>                    if (leadingVoteSet != null) {\n<line150>                        self.leader.setLeadingVoteSet(leadingVoteSet);\n<line151>                        leadingVoteSet = null;\n<line152>                    }\n<line153>                    self.leader.reportLookingSid(response.sid);\n<line154>                }\n<line155>                LOG.debug(\"Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}\", self.getMyId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line156>                QuorumVerifier qv = self.getQuorumVerifier();\n<line157>                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line158>                sendqueue.offer(notmsg);\n<line159>            }\n<line160>        }\n<line161>    }\n<line162>}"},{"input":"","instruction":"<line1>{\n<line2>    continue;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Got a short response from server {}: {}\", response.sid, capacity);\n<line3>    continue;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!backCompatibility28) {\n<line3>        rpeerepoch = response.buffer.getLong();\n<line4>        if (!backCompatibility40) {\n<line5>            /*\n<line6>                                     * Version added in 3.4.6\n<line7>                                     */\n<line8>            version = response.buffer.getInt();\n<line9>        } else {\n<line10>        }\n<line11>    } else {\n<line12>        rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line13>    }\n<line14>    // check if we have a version that includes config. If so extract config info from message.\n<line15>    if (version > 0x1) {\n<line16>        int configLength = response.buffer.getInt();\n<line17>        // we want to avoid errors caused by the allocation of a byte array with negative length\n<line18>        // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line19>        if (configLength < 0 || configLength > capacity) {\n<line20>            throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line21>        }\n<line22>        byte[] b = new byte[configLength];\n<line23>        response.buffer.get(b);\n<line24>        synchronized (self) {\n<line25>            try {\n<line26>                rqv = self.configFromString(new String(b, UTF_8));\n<line27>                QuorumVerifier curQV = self.getQuorumVerifier();\n<line28>                if (rqv.getVersion() > curQV.getVersion()) {\n<line29>                    if (self.getPeerState() == ServerState.LOOKING) {\n<line30>                        self.processReconfig(rqv, null, null, false);\n<line31>                        if (!rqv.equals(curQV)) {\n<line32>                            self.shuttingDownLE = true;\n<line33>                            self.getElectionAlg().shutdown();\n<line34>                            break;\n<line35>                        }\n<line36>                    } else {\n<line37>                    }\n<line38>                }\n<line39>            } catch (IOException | ConfigException e) {\n<line40>            }\n<line41>        }\n<line42>    } else {\n<line43>    }\n<line44>}","output":"<line1>{\n<line2>    if (!backCompatibility28) {\n<line3>        rpeerepoch = response.buffer.getLong();\n<line4>        if (!backCompatibility40) {\n<line5>            /*\n<line6>                                     * Version added in 3.4.6\n<line7>                                     */\n<line8>            version = response.buffer.getInt();\n<line9>        } else {\n<line10>            LOG.info(\"Backward compatibility mode (36 bits), server id: {}\", response.sid);\n<line11>        }\n<line12>    } else {\n<line13>        LOG.info(\"Backward compatibility mode (28 bits), server id: {}\", response.sid);\n<line14>        rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line15>    }\n<line16>    // check if we have a version that includes config. If so extract config info from message.\n<line17>    if (version > 0x1) {\n<line18>        int configLength = response.buffer.getInt();\n<line19>        // we want to avoid errors caused by the allocation of a byte array with negative length\n<line20>        // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line21>        if (configLength < 0 || configLength > capacity) {\n<line22>            throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line23>        }\n<line24>        byte[] b = new byte[configLength];\n<line25>        response.buffer.get(b);\n<line26>        synchronized (self) {\n<line27>            try {\n<line28>                rqv = self.configFromString(new String(b, UTF_8));\n<line29>                QuorumVerifier curQV = self.getQuorumVerifier();\n<line30>                if (rqv.getVersion() > curQV.getVersion()) {\n<line31>                    LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line32>                    if (self.getPeerState() == ServerState.LOOKING) {\n<line33>                        LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line34>                        self.processReconfig(rqv, null, null, false);\n<line35>                        if (!rqv.equals(curQV)) {\n<line36>                            LOG.info(\"restarting leader election\");\n<line37>                            self.shuttingDownLE = true;\n<line38>                            self.getElectionAlg().shutdown();\n<line39>                            break;\n<line40>                        }\n<line41>                    } else {\n<line42>                        LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line43>                    }\n<line44>                }\n<line45>            } catch (IOException | ConfigException e) {\n<line46>                LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line47>            }\n<line48>        }\n<line49>    } else {\n<line50>        LOG.info(\"Backward compatibility mode (before reconfig), server id: {}\", response.sid);\n<line51>    }\n<line52>}"},{"input":"","instruction":"<line1>{\n<line2>    rpeerepoch = response.buffer.getLong();\n<line3>    if (!backCompatibility40) {\n<line4>        /*\n<line5>                                     * Version added in 3.4.6\n<line6>                                     */\n<line7>        version = response.buffer.getInt();\n<line8>    } else {\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    rpeerepoch = response.buffer.getLong();\n<line3>    if (!backCompatibility40) {\n<line4>        /*\n<line5>                                     * Version added in 3.4.6\n<line6>                                     */\n<line7>        version = response.buffer.getInt();\n<line8>    } else {\n<line9>        LOG.info(\"Backward compatibility mode (36 bits), server id: {}\", response.sid);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Backward compatibility mode (36 bits), server id: {}\", response.sid);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Backward compatibility mode (28 bits), server id: {}\", response.sid);\n<line3>    rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int configLength = response.buffer.getInt();\n<line3>    // we want to avoid errors caused by the allocation of a byte array with negative length\n<line4>    // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line5>    if (configLength < 0 || configLength > capacity) {\n<line6>        throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line7>    }\n<line8>    byte[] b = new byte[configLength];\n<line9>    response.buffer.get(b);\n<line10>    synchronized (self) {\n<line11>        try {\n<line12>            rqv = self.configFromString(new String(b, UTF_8));\n<line13>            QuorumVerifier curQV = self.getQuorumVerifier();\n<line14>            if (rqv.getVersion() > curQV.getVersion()) {\n<line15>                if (self.getPeerState() == ServerState.LOOKING) {\n<line16>                    self.processReconfig(rqv, null, null, false);\n<line17>                    if (!rqv.equals(curQV)) {\n<line18>                        self.shuttingDownLE = true;\n<line19>                        self.getElectionAlg().shutdown();\n<line20>                        break;\n<line21>                    }\n<line22>                } else {\n<line23>                }\n<line24>            }\n<line25>        } catch (IOException | ConfigException e) {\n<line26>        }\n<line27>    }\n<line28>}","output":"<line1>{\n<line2>    int configLength = response.buffer.getInt();\n<line3>    // we want to avoid errors caused by the allocation of a byte array with negative length\n<line4>    // (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)\n<line5>    if (configLength < 0 || configLength > capacity) {\n<line6>        throw new IOException(String.format(\"Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d\", response.sid, capacity, version, configLength));\n<line7>    }\n<line8>    byte[] b = new byte[configLength];\n<line9>    response.buffer.get(b);\n<line10>    synchronized (self) {\n<line11>        try {\n<line12>            rqv = self.configFromString(new String(b, UTF_8));\n<line13>            QuorumVerifier curQV = self.getQuorumVerifier();\n<line14>            if (rqv.getVersion() > curQV.getVersion()) {\n<line15>                LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line16>                if (self.getPeerState() == ServerState.LOOKING) {\n<line17>                    LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line18>                    self.processReconfig(rqv, null, null, false);\n<line19>                    if (!rqv.equals(curQV)) {\n<line20>                        LOG.info(\"restarting leader election\");\n<line21>                        self.shuttingDownLE = true;\n<line22>                        self.getElectionAlg().shutdown();\n<line23>                        break;\n<line24>                    }\n<line25>                } else {\n<line26>                    LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line27>                }\n<line28>            }\n<line29>        } catch (IOException | ConfigException e) {\n<line30>            LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line31>        }\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        rqv = self.configFromString(new String(b, UTF_8));\n<line4>        QuorumVerifier curQV = self.getQuorumVerifier();\n<line5>        if (rqv.getVersion() > curQV.getVersion()) {\n<line6>            if (self.getPeerState() == ServerState.LOOKING) {\n<line7>                self.processReconfig(rqv, null, null, false);\n<line8>                if (!rqv.equals(curQV)) {\n<line9>                    self.shuttingDownLE = true;\n<line10>                    self.getElectionAlg().shutdown();\n<line11>                    break;\n<line12>                }\n<line13>            } else {\n<line14>            }\n<line15>        }\n<line16>    } catch (IOException | ConfigException e) {\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    try {\n<line3>        rqv = self.configFromString(new String(b, UTF_8));\n<line4>        QuorumVerifier curQV = self.getQuorumVerifier();\n<line5>        if (rqv.getVersion() > curQV.getVersion()) {\n<line6>            LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line7>            if (self.getPeerState() == ServerState.LOOKING) {\n<line8>                LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line9>                self.processReconfig(rqv, null, null, false);\n<line10>                if (!rqv.equals(curQV)) {\n<line11>                    LOG.info(\"restarting leader election\");\n<line12>                    self.shuttingDownLE = true;\n<line13>                    self.getElectionAlg().shutdown();\n<line14>                    break;\n<line15>                }\n<line16>            } else {\n<line17>                LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line18>            }\n<line19>        }\n<line20>    } catch (IOException | ConfigException e) {\n<line21>        LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    rqv = self.configFromString(new String(b, UTF_8));\n<line3>    QuorumVerifier curQV = self.getQuorumVerifier();\n<line4>    if (rqv.getVersion() > curQV.getVersion()) {\n<line5>        if (self.getPeerState() == ServerState.LOOKING) {\n<line6>            self.processReconfig(rqv, null, null, false);\n<line7>            if (!rqv.equals(curQV)) {\n<line8>                self.shuttingDownLE = true;\n<line9>                self.getElectionAlg().shutdown();\n<line10>                break;\n<line11>            }\n<line12>        } else {\n<line13>        }\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    rqv = self.configFromString(new String(b, UTF_8));\n<line3>    QuorumVerifier curQV = self.getQuorumVerifier();\n<line4>    if (rqv.getVersion() > curQV.getVersion()) {\n<line5>        LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line6>        if (self.getPeerState() == ServerState.LOOKING) {\n<line7>            LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line8>            self.processReconfig(rqv, null, null, false);\n<line9>            if (!rqv.equals(curQV)) {\n<line10>                LOG.info(\"restarting leader election\");\n<line11>                self.shuttingDownLE = true;\n<line12>                self.getElectionAlg().shutdown();\n<line13>                break;\n<line14>            }\n<line15>        } else {\n<line16>            LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.getPeerState() == ServerState.LOOKING) {\n<line3>        self.processReconfig(rqv, null, null, false);\n<line4>        if (!rqv.equals(curQV)) {\n<line5>            self.shuttingDownLE = true;\n<line6>            self.getElectionAlg().shutdown();\n<line7>            break;\n<line8>        }\n<line9>    } else {\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.info(\"{} Received version: {} my version: {}\", self.getMyId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line3>    if (self.getPeerState() == ServerState.LOOKING) {\n<line4>        LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line5>        self.processReconfig(rqv, null, null, false);\n<line6>        if (!rqv.equals(curQV)) {\n<line7>            LOG.info(\"restarting leader election\");\n<line8>            self.shuttingDownLE = true;\n<line9>            self.getElectionAlg().shutdown();\n<line10>            break;\n<line11>        }\n<line12>    } else {\n<line13>        LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    self.processReconfig(rqv, null, null, false);\n<line3>    if (!rqv.equals(curQV)) {\n<line4>        self.shuttingDownLE = true;\n<line5>        self.getElectionAlg().shutdown();\n<line6>        break;\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.debug(\"Invoking processReconfig(), state: {}\", self.getServerState());\n<line3>    self.processReconfig(rqv, null, null, false);\n<line4>    if (!rqv.equals(curQV)) {\n<line5>        LOG.info(\"restarting leader election\");\n<line6>        self.shuttingDownLE = true;\n<line7>        self.getElectionAlg().shutdown();\n<line8>        break;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    self.shuttingDownLE = true;\n<line3>    self.getElectionAlg().shutdown();\n<line4>    break;\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"restarting leader election\");\n<line3>    self.shuttingDownLE = true;\n<line4>    self.getElectionAlg().shutdown();\n<line5>    break;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Skip processReconfig(), state: {}\", self.getServerState());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Something went wrong while processing config received from {}\", response.sid);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Backward compatibility mode (before reconfig), server id: {}\", response.sid);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // Receive new message\n<line3>    // State of peer that sent this message\n<line4>    QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line5>    switch(rstate) {\n<line6>        case 0:\n<line7>            ackstate = QuorumPeer.ServerState.LOOKING;\n<line8>            break;\n<line9>        case 1:\n<line10>            ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line11>            break;\n<line12>        case 2:\n<line13>            ackstate = QuorumPeer.ServerState.LEADING;\n<line14>            break;\n<line15>        case 3:\n<line16>            ackstate = QuorumPeer.ServerState.OBSERVING;\n<line17>            break;\n<line18>        default:\n<line19>            continue;\n<line20>    }\n<line21>    n.leader = rleader;\n<line22>    n.zxid = rzxid;\n<line23>    n.electionEpoch = relectionEpoch;\n<line24>    n.state = ackstate;\n<line25>    n.sid = response.sid;\n<line26>    n.peerEpoch = rpeerepoch;\n<line27>    n.version = version;\n<line28>    n.qv = rqv;\n<line29>    /*\n<line30>                             * Print notification info\n<line31>                             */\n<line32>    /*\n<line33>                             * If this server is looking, then send proposed leader\n<line34>                             */\n<line35>    if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line36>        recvqueue.offer(n);\n<line37>        /*\n<line38>                                 * Send a notification back if the peer that sent this\n<line39>                                 * message is also looking and its logical clock is\n<line40>                                 * lagging behind.\n<line41>                                 */\n<line42>        if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line43>            Vote v = getVote();\n<line44>            QuorumVerifier qv = self.getQuorumVerifier();\n<line45>            ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line46>            sendqueue.offer(notmsg);\n<line47>        }\n<line48>    } else {\n<line49>        /*\n<line50>                                 * If this server is not looking, but the one that sent the ack\n<line51>                                 * is looking, then send back what it believes to be the leader.\n<line52>                                 */\n<line53>        Vote current = self.getCurrentVote();\n<line54>        if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line55>            if (self.leader != null) {\n<line56>                if (leadingVoteSet != null) {\n<line57>                    self.leader.setLeadingVoteSet(leadingVoteSet);\n<line58>                    leadingVoteSet = null;\n<line59>                }\n<line60>                self.leader.reportLookingSid(response.sid);\n<line61>            }\n<line62>            QuorumVerifier qv = self.getQuorumVerifier();\n<line63>            ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line64>            sendqueue.offer(notmsg);\n<line65>        }\n<line66>    }\n<line67>}","output":"<line1>{\n<line2>    // Receive new message\n<line3>    LOG.debug(\"Receive new notification message. My id = {}\", self.getMyId());\n<line4>    // State of peer that sent this message\n<line5>    QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;\n<line6>    switch(rstate) {\n<line7>        case 0:\n<line8>            ackstate = QuorumPeer.ServerState.LOOKING;\n<line9>            break;\n<line10>        case 1:\n<line11>            ackstate = QuorumPeer.ServerState.FOLLOWING;\n<line12>            break;\n<line13>        case 2:\n<line14>            ackstate = QuorumPeer.ServerState.LEADING;\n<line15>            break;\n<line16>        case 3:\n<line17>            ackstate = QuorumPeer.ServerState.OBSERVING;\n<line18>            break;\n<line19>        default:\n<line20>            continue;\n<line21>    }\n<line22>    n.leader = rleader;\n<line23>    n.zxid = rzxid;\n<line24>    n.electionEpoch = relectionEpoch;\n<line25>    n.state = ackstate;\n<line26>    n.sid = response.sid;\n<line27>    n.peerEpoch = rpeerepoch;\n<line28>    n.version = version;\n<line29>    n.qv = rqv;\n<line30>    /*\n<line31>                             * Print notification info\n<line32>                             */\n<line33>    LOG.info(\"Notification: my state:{}; n.sid:{}, n.state:{}, n.leader:{}, n.round:0x{}, \" + \"n.peerEpoch:0x{}, n.zxid:0x{}, message format version:0x{}, n.config version:0x{}\", self.getPeerState(), n.sid, n.state, n.leader, Long.toHexString(n.electionEpoch), Long.toHexString(n.peerEpoch), Long.toHexString(n.zxid), Long.toHexString(n.version), (n.qv != null ? (Long.toHexString(n.qv.getVersion())) : \"0\"));\n<line34>    /*\n<line35>                             * If this server is looking, then send proposed leader\n<line36>                             */\n<line37>    if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {\n<line38>        recvqueue.offer(n);\n<line39>        /*\n<line40>                                 * Send a notification back if the peer that sent this\n<line41>                                 * message is also looking and its logical clock is\n<line42>                                 * lagging behind.\n<line43>                                 */\n<line44>        if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {\n<line45>            Vote v = getVote();\n<line46>            QuorumVerifier qv = self.getQuorumVerifier();\n<line47>            ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());\n<line48>            sendqueue.offer(notmsg);\n<line49>        }\n<line50>    } else {\n<line51>        /*\n<line52>                                 * If this server is not looking, but the one that sent the ack\n<line53>                                 * is looking, then send back what it believes to be the leader.\n<line54>                                 */\n<line55>        Vote current = self.getCurrentVote();\n<line56>        if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line57>            if (self.leader != null) {\n<line58>                if (leadingVoteSet != null) {\n<line59>                    self.leader.setLeadingVoteSet(leadingVoteSet);\n<line60>                    leadingVoteSet = null;\n<line61>                }\n<line62>                self.leader.reportLookingSid(response.sid);\n<line63>            }\n<line64>            LOG.debug(\"Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}\", self.getMyId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line65>            QuorumVerifier qv = self.getQuorumVerifier();\n<line66>            ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line67>            sendqueue.offer(notmsg);\n<line68>        }\n<line69>    }\n<line70>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                                 * If this server is not looking, but the one that sent the ack\n<line4>                                 * is looking, then send back what it believes to be the leader.\n<line5>                                 */\n<line6>    Vote current = self.getCurrentVote();\n<line7>    if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line8>        if (self.leader != null) {\n<line9>            if (leadingVoteSet != null) {\n<line10>                self.leader.setLeadingVoteSet(leadingVoteSet);\n<line11>                leadingVoteSet = null;\n<line12>            }\n<line13>            self.leader.reportLookingSid(response.sid);\n<line14>        }\n<line15>        QuorumVerifier qv = self.getQuorumVerifier();\n<line16>        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line17>        sendqueue.offer(notmsg);\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    /*\n<line3>                                 * If this server is not looking, but the one that sent the ack\n<line4>                                 * is looking, then send back what it believes to be the leader.\n<line5>                                 */\n<line6>    Vote current = self.getCurrentVote();\n<line7>    if (ackstate == QuorumPeer.ServerState.LOOKING) {\n<line8>        if (self.leader != null) {\n<line9>            if (leadingVoteSet != null) {\n<line10>                self.leader.setLeadingVoteSet(leadingVoteSet);\n<line11>                leadingVoteSet = null;\n<line12>            }\n<line13>            self.leader.reportLookingSid(response.sid);\n<line14>        }\n<line15>        LOG.debug(\"Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}\", self.getMyId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line16>        QuorumVerifier qv = self.getQuorumVerifier();\n<line17>        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line18>        sendqueue.offer(notmsg);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.leader != null) {\n<line3>        if (leadingVoteSet != null) {\n<line4>            self.leader.setLeadingVoteSet(leadingVoteSet);\n<line5>            leadingVoteSet = null;\n<line6>        }\n<line7>        self.leader.reportLookingSid(response.sid);\n<line8>    }\n<line9>    QuorumVerifier qv = self.getQuorumVerifier();\n<line10>    ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line11>    sendqueue.offer(notmsg);\n<line12>}","output":"<line1>{\n<line2>    if (self.leader != null) {\n<line3>        if (leadingVoteSet != null) {\n<line4>            self.leader.setLeadingVoteSet(leadingVoteSet);\n<line5>            leadingVoteSet = null;\n<line6>        }\n<line7>        self.leader.reportLookingSid(response.sid);\n<line8>    }\n<line9>    LOG.debug(\"Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}\", self.getMyId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));\n<line10>    QuorumVerifier qv = self.getQuorumVerifier();\n<line11>    ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());\n<line12>    sendqueue.offer(notmsg);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    while (!stop) {\n<line3>        try {\n<line4>            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);\n<line5>            if (m == null) {\n<line6>                continue;\n<line7>            }\n<line8>            process(m);\n<line9>        } catch (InterruptedException e) {\n<line10>            break;\n<line11>        }\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    while (!stop) {\n<line3>        try {\n<line4>            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);\n<line5>            if (m == null) {\n<line6>                continue;\n<line7>            }\n<line8>            process(m);\n<line9>        } catch (InterruptedException e) {\n<line10>            break;\n<line11>        }\n<line12>    }\n<line13>    LOG.info(\"WorkerSender is down\");\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    recvqueue.clear();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"About to leave FLE instance: leader={}, zxid=0x{}, my id={}, my state={}\", v.getId(), Long.toHexString(v.getZxid()), self.getMyId(), self.getPeerState());\n<line3>    recvqueue.clear();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    stop = true;\n<line3>    proposedLeader = -1;\n<line4>    proposedZxid = -1;\n<line5>    leadingVoteSet = null;\n<line6>    manager.halt();\n<line7>    messenger.halt();\n<line8>}","output":"<line1>{\n<line2>    stop = true;\n<line3>    proposedLeader = -1;\n<line4>    proposedZxid = -1;\n<line5>    leadingVoteSet = null;\n<line6>    LOG.debug(\"Shutting down connection manager\");\n<line7>    manager.halt();\n<line8>    LOG.debug(\"Shutting down messenger\");\n<line9>    messenger.halt();\n<line10>    LOG.debug(\"FLE is down\");\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    for (long sid : self.getCurrentAndNextConfigVoters()) {\n<line3>        QuorumVerifier qv = self.getQuorumVerifier();\n<line4>        ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes(UTF_8));\n<line5>        sendqueue.offer(notmsg);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    for (long sid : self.getCurrentAndNextConfigVoters()) {\n<line3>        QuorumVerifier qv = self.getQuorumVerifier();\n<line4>        ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes(UTF_8));\n<line5>        LOG.debug(\"Sending Notification: {} (n.leader), 0x{} (n.zxid), 0x{} (n.peerEpoch), 0x{} (n.round), {} (recipient),\" + \" {} (myid) \", proposedLeader, Long.toHexString(proposedZxid), Long.toHexString(proposedEpoch), Long.toHexString(logicalclock.get()), sid, self.getMyId());\n<line6>        sendqueue.offer(notmsg);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    QuorumVerifier qv = self.getQuorumVerifier();\n<line3>    ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes(UTF_8));\n<line4>    sendqueue.offer(notmsg);\n<line5>}","output":"<line1>{\n<line2>    QuorumVerifier qv = self.getQuorumVerifier();\n<line3>    ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes(UTF_8));\n<line4>    LOG.debug(\"Sending Notification: {} (n.leader), 0x{} (n.zxid), 0x{} (n.peerEpoch), 0x{} (n.round), {} (recipient),\" + \" {} (myid) \", proposedLeader, Long.toHexString(proposedZxid), Long.toHexString(proposedEpoch), Long.toHexString(logicalclock.get()), sid, self.getMyId());\n<line5>    sendqueue.offer(notmsg);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.getQuorumVerifier().getWeight(newId) == 0) {\n<line3>        return false;\n<line4>    }\n<line5>    /*\n<line6>         * We return true if one of the following three cases hold:\n<line7>         * 1- New epoch is higher\n<line8>         * 2- New epoch is the same as current epoch, but new zxid is higher\n<line9>         * 3- New epoch is the same as current epoch, new zxid is the same\n<line10>         *  as current zxid, but server id is higher.\n<line11>         */\n<line12>    return ((newEpoch > curEpoch) || ((newEpoch == curEpoch) && ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));\n<line13>}","output":"<line1>{\n<line2>    LOG.debug(\"id: {}, proposed id: {}, zxid: 0x{}, proposed zxid: 0x{}, epoch: 0x{}, proposed epoch: 0x{}\", newId, curId, Long.toHexString(newZxid), Long.toHexString(curZxid), Long.toHexString(newEpoch), Long.toHexString(curEpoch));\n<line3>    if (self.getQuorumVerifier().getWeight(newId) == 0) {\n<line4>        return false;\n<line5>    }\n<line6>    /*\n<line7>         * We return true if one of the following three cases hold:\n<line8>         * 1- New epoch is higher\n<line9>         * 2- New epoch is the same as current epoch, but new zxid is higher\n<line10>         * 3- New epoch is the same as current epoch, new zxid is the same\n<line11>         *  as current zxid, but server id is higher.\n<line12>         */\n<line13>    return ((newEpoch > curEpoch) || ((newEpoch == curEpoch) && ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    proposedLeader = leader;\n<line3>    proposedZxid = zxid;\n<line4>    proposedEpoch = epoch;\n<line5>}","output":"<line1>{\n<line2>    LOG.debug(\"Updating proposal: {} (newleader), 0x{} (newzxid), {} (oldleader), 0x{} (oldzxid)\", leader, Long.toHexString(zxid), proposedLeader, Long.toHexString(proposedZxid));\n<line3>    proposedLeader = leader;\n<line4>    proposedZxid = zxid;\n<line5>    proposedEpoch = epoch;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    if (self.getLearnerType() == LearnerType.PARTICIPANT) {\n<line3>        return ServerState.FOLLOWING;\n<line4>    } else {\n<line5>        return ServerState.OBSERVING;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    if (self.getLearnerType() == LearnerType.PARTICIPANT) {\n<line3>        LOG.debug(\"I am a participant: {}\", self.getMyId());\n<line4>        return ServerState.FOLLOWING;\n<line5>    } else {\n<line6>        LOG.debug(\"I am an observer: {}\", self.getMyId());\n<line7>        return ServerState.OBSERVING;\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    return ServerState.FOLLOWING;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"I am a participant: {}\", self.getMyId());\n<line3>    return ServerState.FOLLOWING;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return ServerState.OBSERVING;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"I am an observer: {}\", self.getMyId());\n<line3>    return ServerState.OBSERVING;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        self.jmxLeaderElectionBean = new LeaderElectionBean();\n<line4>        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);\n<line5>    } catch (Exception e) {\n<line6>        self.jmxLeaderElectionBean = null;\n<line7>    }\n<line8>    self.start_fle = Time.currentElapsedTime();\n<line9>    try {\n<line10>        /*\n<line11>             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset\n<line12>             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority\n<line13>             * of participants has voted for it.\n<line14>             */\n<line15>        Map<Long, Vote> recvset = new HashMap<>();\n<line16>        /*\n<line17>             * The votes from previous leader elections, as well as the votes from the current leader election are\n<line18>             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.\n<line19>             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use\n<line20>             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than\n<line21>             * the electionEpoch of the received notifications) in a leader election.\n<line22>             */\n<line23>        Map<Long, Vote> outofelection = new HashMap<>();\n<line24>        int notTimeout = minNotificationInterval;\n<line25>        synchronized (this) {\n<line26>            logicalclock.incrementAndGet();\n<line27>            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line28>        }\n<line29>        sendNotifications();\n<line30>        SyncedLearnerTracker voteSet = null;\n<line31>        /*\n<line32>             * Loop in which we exchange notifications until we find a leader\n<line33>             */\n<line34>        while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {\n<line35>            /*\n<line36>                 * Remove next notification from queue, times out after 2 times\n<line37>                 * the termination time\n<line38>                 */\n<line39>            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n<line40>            /*\n<line41>                 * Sends more notifications if haven't received enough.\n<line42>                 * Otherwise processes new notification.\n<line43>                 */\n<line44>            if (n == null) {\n<line45>                if (manager.haveDelivered()) {\n<line46>                    sendNotifications();\n<line47>                } else {\n<line48>                    manager.connectAll();\n<line49>                }\n<line50>                /*\n<line51>                     * Exponential backoff\n<line52>                     */\n<line53>                notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line54>                /*\n<line55>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line56>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line57>                     *\n<line58>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line59>                     * which is in a configuration of 2 instances.\n<line60>                     * */\n<line61>                if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line62>                    setPeerState(proposedLeader, voteSet);\n<line63>                    Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line64>                    leaveInstance(endVote);\n<line65>                    return endVote;\n<line66>                }\n<line67>            } else if (validVoter(n.sid) && validVoter(n.leader)) {\n<line68>                /*\n<line69>                     * Only proceed if the vote comes from a replica in the current or next\n<line70>                     * voting view for a replica in the current or next voting view.\n<line71>                     */\n<line72>                switch(n.state) {\n<line73>                    case LOOKING:\n<line74>                        if (getInitLastLoggedZxid() == -1) {\n<line75>                            break;\n<line76>                        }\n<line77>                        if (n.zxid == -1) {\n<line78>                            break;\n<line79>                        }\n<line80>                        // If notification > current, replace and send messages out\n<line81>                        if (n.electionEpoch > logicalclock.get()) {\n<line82>                            logicalclock.set(n.electionEpoch);\n<line83>                            recvset.clear();\n<line84>                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line85>                                updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line86>                            } else {\n<line87>                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line88>                            }\n<line89>                            sendNotifications();\n<line90>                        } else if (n.electionEpoch < logicalclock.get()) {\n<line91>                            break;\n<line92>                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line93>                            updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line94>                            sendNotifications();\n<line95>                        }\n<line96>                        // don't care about the version if it's in LOOKING state\n<line97>                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line98>                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line99>                        if (voteSet.hasAllQuorums()) {\n<line100>                            // Verify if there is any change in the proposed leader\n<line101>                            while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line102>                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line103>                                    recvqueue.put(n);\n<line104>                                    break;\n<line105>                                }\n<line106>                            }\n<line107>                            /*\n<line108>                             * This predicate is true once we don't read any new\n<line109>                             * relevant message from the reception queue\n<line110>                             */\n<line111>                            if (n == null) {\n<line112>                                setPeerState(proposedLeader, voteSet);\n<line113>                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line114>                                leaveInstance(endVote);\n<line115>                                return endVote;\n<line116>                            }\n<line117>                        }\n<line118>                        break;\n<line119>                    case OBSERVING:\n<line120>                        break;\n<line121>                    /*\n<line122>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line123>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line124>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line125>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line126>                        * is generated.\n<line127>                        *\n<line128>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line129>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line130>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line131>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line132>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line133>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line134>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line135>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line136>                        *\n<line137>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line138>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line139>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line140>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line141>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line142>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line143>                        *\n<line144>                        *\n<line145>                        * */\n<line146>                    case FOLLOWING:\n<line147>                        /*\n<line148>                        * To avoid duplicate codes\n<line149>                        * */\n<line150>                        Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line151>                        if (resultFN == null) {\n<line152>                            break;\n<line153>                        } else {\n<line154>                            return resultFN;\n<line155>                        }\n<line156>                    case LEADING:\n<line157>                        /*\n<line158>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line159>                        * a null pointer, ask Oracle whether to follow this leader.\n<line160>                        * */\n<line161>                        Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line162>                        if (resultLN == null) {\n<line163>                            break;\n<line164>                        } else {\n<line165>                            return resultLN;\n<line166>                        }\n<line167>                    default:\n<line168>                        break;\n<line169>                }\n<line170>            } else {\n<line171>                if (!validVoter(n.leader)) {\n<line172>                }\n<line173>                if (!validVoter(n.sid)) {\n<line174>                }\n<line175>            }\n<line176>        }\n<line177>        return null;\n<line178>    } finally {\n<line179>        try {\n<line180>            if (self.jmxLeaderElectionBean != null) {\n<line181>                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n<line182>            }\n<line183>        } catch (Exception e) {\n<line184>        }\n<line185>        self.jmxLeaderElectionBean = null;\n<line186>    }\n<line187>}","output":"<line1>{\n<line2>    try {\n<line3>        self.jmxLeaderElectionBean = new LeaderElectionBean();\n<line4>        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);\n<line5>    } catch (Exception e) {\n<line6>        LOG.warn(\"Failed to register with JMX\", e);\n<line7>        self.jmxLeaderElectionBean = null;\n<line8>    }\n<line9>    self.start_fle = Time.currentElapsedTime();\n<line10>    try {\n<line11>        /*\n<line12>             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset\n<line13>             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority\n<line14>             * of participants has voted for it.\n<line15>             */\n<line16>        Map<Long, Vote> recvset = new HashMap<>();\n<line17>        /*\n<line18>             * The votes from previous leader elections, as well as the votes from the current leader election are\n<line19>             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.\n<line20>             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use\n<line21>             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than\n<line22>             * the electionEpoch of the received notifications) in a leader election.\n<line23>             */\n<line24>        Map<Long, Vote> outofelection = new HashMap<>();\n<line25>        int notTimeout = minNotificationInterval;\n<line26>        synchronized (this) {\n<line27>            logicalclock.incrementAndGet();\n<line28>            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line29>        }\n<line30>        LOG.info(\"New election. My id = {}, proposed zxid=0x{}\", self.getMyId(), Long.toHexString(proposedZxid));\n<line31>        sendNotifications();\n<line32>        SyncedLearnerTracker voteSet = null;\n<line33>        /*\n<line34>             * Loop in which we exchange notifications until we find a leader\n<line35>             */\n<line36>        while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {\n<line37>            /*\n<line38>                 * Remove next notification from queue, times out after 2 times\n<line39>                 * the termination time\n<line40>                 */\n<line41>            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n<line42>            /*\n<line43>                 * Sends more notifications if haven't received enough.\n<line44>                 * Otherwise processes new notification.\n<line45>                 */\n<line46>            if (n == null) {\n<line47>                if (manager.haveDelivered()) {\n<line48>                    sendNotifications();\n<line49>                } else {\n<line50>                    manager.connectAll();\n<line51>                }\n<line52>                /*\n<line53>                     * Exponential backoff\n<line54>                     */\n<line55>                notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line56>                /*\n<line57>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line58>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line59>                     *\n<line60>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line61>                     * which is in a configuration of 2 instances.\n<line62>                     * */\n<line63>                if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line64>                    setPeerState(proposedLeader, voteSet);\n<line65>                    Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line66>                    leaveInstance(endVote);\n<line67>                    return endVote;\n<line68>                }\n<line69>                LOG.info(\"Notification time out: {} ms\", notTimeout);\n<line70>            } else if (validVoter(n.sid) && validVoter(n.leader)) {\n<line71>                /*\n<line72>                     * Only proceed if the vote comes from a replica in the current or next\n<line73>                     * voting view for a replica in the current or next voting view.\n<line74>                     */\n<line75>                switch(n.state) {\n<line76>                    case LOOKING:\n<line77>                        if (getInitLastLoggedZxid() == -1) {\n<line78>                            LOG.debug(\"Ignoring notification as our zxid is -1\");\n<line79>                            break;\n<line80>                        }\n<line81>                        if (n.zxid == -1) {\n<line82>                            LOG.debug(\"Ignoring notification from member with -1 zxid {}\", n.sid);\n<line83>                            break;\n<line84>                        }\n<line85>                        // If notification > current, replace and send messages out\n<line86>                        if (n.electionEpoch > logicalclock.get()) {\n<line87>                            logicalclock.set(n.electionEpoch);\n<line88>                            recvset.clear();\n<line89>                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line90>                                updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line91>                            } else {\n<line92>                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line93>                            }\n<line94>                            sendNotifications();\n<line95>                        } else if (n.electionEpoch < logicalclock.get()) {\n<line96>                            LOG.debug(\"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}\", Long.toHexString(n.electionEpoch), Long.toHexString(logicalclock.get()));\n<line97>                            break;\n<line98>                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line99>                            updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line100>                            sendNotifications();\n<line101>                        }\n<line102>                        LOG.debug(\"Adding vote: from={}, proposed leader={}, proposed zxid=0x{}, proposed election epoch=0x{}\", n.sid, n.leader, Long.toHexString(n.zxid), Long.toHexString(n.electionEpoch));\n<line103>                        // don't care about the version if it's in LOOKING state\n<line104>                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line105>                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line106>                        if (voteSet.hasAllQuorums()) {\n<line107>                            // Verify if there is any change in the proposed leader\n<line108>                            while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line109>                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line110>                                    recvqueue.put(n);\n<line111>                                    break;\n<line112>                                }\n<line113>                            }\n<line114>                            /*\n<line115>                             * This predicate is true once we don't read any new\n<line116>                             * relevant message from the reception queue\n<line117>                             */\n<line118>                            if (n == null) {\n<line119>                                setPeerState(proposedLeader, voteSet);\n<line120>                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line121>                                leaveInstance(endVote);\n<line122>                                return endVote;\n<line123>                            }\n<line124>                        }\n<line125>                        break;\n<line126>                    case OBSERVING:\n<line127>                        LOG.debug(\"Notification from observer: {}\", n.sid);\n<line128>                        break;\n<line129>                    /*\n<line130>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line131>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line132>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line133>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line134>                        * is generated.\n<line135>                        *\n<line136>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line137>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line138>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line139>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line140>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line141>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line142>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line143>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line144>                        *\n<line145>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line146>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line147>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line148>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line149>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line150>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line151>                        *\n<line152>                        *\n<line153>                        * */\n<line154>                    case FOLLOWING:\n<line155>                        /*\n<line156>                        * To avoid duplicate codes\n<line157>                        * */\n<line158>                        Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line159>                        if (resultFN == null) {\n<line160>                            break;\n<line161>                        } else {\n<line162>                            return resultFN;\n<line163>                        }\n<line164>                    case LEADING:\n<line165>                        /*\n<line166>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line167>                        * a null pointer, ask Oracle whether to follow this leader.\n<line168>                        * */\n<line169>                        Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line170>                        if (resultLN == null) {\n<line171>                            break;\n<line172>                        } else {\n<line173>                            return resultLN;\n<line174>                        }\n<line175>                    default:\n<line176>                        LOG.warn(\"Notification state unrecognized: {} (n.state), {}(n.sid)\", n.state, n.sid);\n<line177>                        break;\n<line178>                }\n<line179>            } else {\n<line180>                if (!validVoter(n.leader)) {\n<line181>                    LOG.warn(\"Ignoring notification for non-cluster member sid {} from sid {}\", n.leader, n.sid);\n<line182>                }\n<line183>                if (!validVoter(n.sid)) {\n<line184>                    LOG.warn(\"Ignoring notification for sid {} from non-quorum member sid {}\", n.leader, n.sid);\n<line185>                }\n<line186>            }\n<line187>        }\n<line188>        return null;\n<line189>    } finally {\n<line190>        try {\n<line191>            if (self.jmxLeaderElectionBean != null) {\n<line192>                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n<line193>            }\n<line194>        } catch (Exception e) {\n<line195>            LOG.warn(\"Failed to unregister with JMX\", e);\n<line196>        }\n<line197>        self.jmxLeaderElectionBean = null;\n<line198>        LOG.debug(\"Number of connection processing threads: {}\", manager.getConnectionThreadCount());\n<line199>    }\n<line200>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset\n<line4>             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority\n<line5>             * of participants has voted for it.\n<line6>             */\n<line7>    Map<Long, Vote> recvset = new HashMap<>();\n<line8>    /*\n<line9>             * The votes from previous leader elections, as well as the votes from the current leader election are\n<line10>             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.\n<line11>             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use\n<line12>             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than\n<line13>             * the electionEpoch of the received notifications) in a leader election.\n<line14>             */\n<line15>    Map<Long, Vote> outofelection = new HashMap<>();\n<line16>    int notTimeout = minNotificationInterval;\n<line17>    synchronized (this) {\n<line18>        logicalclock.incrementAndGet();\n<line19>        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line20>    }\n<line21>    sendNotifications();\n<line22>    SyncedLearnerTracker voteSet = null;\n<line23>    /*\n<line24>             * Loop in which we exchange notifications until we find a leader\n<line25>             */\n<line26>    while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {\n<line27>        /*\n<line28>                 * Remove next notification from queue, times out after 2 times\n<line29>                 * the termination time\n<line30>                 */\n<line31>        Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n<line32>        /*\n<line33>                 * Sends more notifications if haven't received enough.\n<line34>                 * Otherwise processes new notification.\n<line35>                 */\n<line36>        if (n == null) {\n<line37>            if (manager.haveDelivered()) {\n<line38>                sendNotifications();\n<line39>            } else {\n<line40>                manager.connectAll();\n<line41>            }\n<line42>            /*\n<line43>                     * Exponential backoff\n<line44>                     */\n<line45>            notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line46>            /*\n<line47>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line48>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line49>                     *\n<line50>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line51>                     * which is in a configuration of 2 instances.\n<line52>                     * */\n<line53>            if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line54>                setPeerState(proposedLeader, voteSet);\n<line55>                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line56>                leaveInstance(endVote);\n<line57>                return endVote;\n<line58>            }\n<line59>        } else if (validVoter(n.sid) && validVoter(n.leader)) {\n<line60>            /*\n<line61>                     * Only proceed if the vote comes from a replica in the current or next\n<line62>                     * voting view for a replica in the current or next voting view.\n<line63>                     */\n<line64>            switch(n.state) {\n<line65>                case LOOKING:\n<line66>                    if (getInitLastLoggedZxid() == -1) {\n<line67>                        break;\n<line68>                    }\n<line69>                    if (n.zxid == -1) {\n<line70>                        break;\n<line71>                    }\n<line72>                    // If notification > current, replace and send messages out\n<line73>                    if (n.electionEpoch > logicalclock.get()) {\n<line74>                        logicalclock.set(n.electionEpoch);\n<line75>                        recvset.clear();\n<line76>                        if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line77>                            updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line78>                        } else {\n<line79>                            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line80>                        }\n<line81>                        sendNotifications();\n<line82>                    } else if (n.electionEpoch < logicalclock.get()) {\n<line83>                        break;\n<line84>                    } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line85>                        updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line86>                        sendNotifications();\n<line87>                    }\n<line88>                    // don't care about the version if it's in LOOKING state\n<line89>                    recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line90>                    voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line91>                    if (voteSet.hasAllQuorums()) {\n<line92>                        // Verify if there is any change in the proposed leader\n<line93>                        while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line94>                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line95>                                recvqueue.put(n);\n<line96>                                break;\n<line97>                            }\n<line98>                        }\n<line99>                        /*\n<line100>                             * This predicate is true once we don't read any new\n<line101>                             * relevant message from the reception queue\n<line102>                             */\n<line103>                        if (n == null) {\n<line104>                            setPeerState(proposedLeader, voteSet);\n<line105>                            Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line106>                            leaveInstance(endVote);\n<line107>                            return endVote;\n<line108>                        }\n<line109>                    }\n<line110>                    break;\n<line111>                case OBSERVING:\n<line112>                    break;\n<line113>                /*\n<line114>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line115>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line116>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line117>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line118>                        * is generated.\n<line119>                        *\n<line120>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line121>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line122>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line123>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line124>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line125>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line126>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line127>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line128>                        *\n<line129>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line130>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line131>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line132>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line133>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line134>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line135>                        *\n<line136>                        *\n<line137>                        * */\n<line138>                case FOLLOWING:\n<line139>                    /*\n<line140>                        * To avoid duplicate codes\n<line141>                        * */\n<line142>                    Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line143>                    if (resultFN == null) {\n<line144>                        break;\n<line145>                    } else {\n<line146>                        return resultFN;\n<line147>                    }\n<line148>                case LEADING:\n<line149>                    /*\n<line150>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line151>                        * a null pointer, ask Oracle whether to follow this leader.\n<line152>                        * */\n<line153>                    Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line154>                    if (resultLN == null) {\n<line155>                        break;\n<line156>                    } else {\n<line157>                        return resultLN;\n<line158>                    }\n<line159>                default:\n<line160>                    break;\n<line161>            }\n<line162>        } else {\n<line163>            if (!validVoter(n.leader)) {\n<line164>            }\n<line165>            if (!validVoter(n.sid)) {\n<line166>            }\n<line167>        }\n<line168>    }\n<line169>    return null;\n<line170>}","output":"<line1>{\n<line2>    /*\n<line3>             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset\n<line4>             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority\n<line5>             * of participants has voted for it.\n<line6>             */\n<line7>    Map<Long, Vote> recvset = new HashMap<>();\n<line8>    /*\n<line9>             * The votes from previous leader elections, as well as the votes from the current leader election are\n<line10>             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.\n<line11>             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use\n<line12>             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than\n<line13>             * the electionEpoch of the received notifications) in a leader election.\n<line14>             */\n<line15>    Map<Long, Vote> outofelection = new HashMap<>();\n<line16>    int notTimeout = minNotificationInterval;\n<line17>    synchronized (this) {\n<line18>        logicalclock.incrementAndGet();\n<line19>        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line20>    }\n<line21>    LOG.info(\"New election. My id = {}, proposed zxid=0x{}\", self.getMyId(), Long.toHexString(proposedZxid));\n<line22>    sendNotifications();\n<line23>    SyncedLearnerTracker voteSet = null;\n<line24>    /*\n<line25>             * Loop in which we exchange notifications until we find a leader\n<line26>             */\n<line27>    while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {\n<line28>        /*\n<line29>                 * Remove next notification from queue, times out after 2 times\n<line30>                 * the termination time\n<line31>                 */\n<line32>        Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n<line33>        /*\n<line34>                 * Sends more notifications if haven't received enough.\n<line35>                 * Otherwise processes new notification.\n<line36>                 */\n<line37>        if (n == null) {\n<line38>            if (manager.haveDelivered()) {\n<line39>                sendNotifications();\n<line40>            } else {\n<line41>                manager.connectAll();\n<line42>            }\n<line43>            /*\n<line44>                     * Exponential backoff\n<line45>                     */\n<line46>            notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line47>            /*\n<line48>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line49>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line50>                     *\n<line51>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line52>                     * which is in a configuration of 2 instances.\n<line53>                     * */\n<line54>            if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line55>                setPeerState(proposedLeader, voteSet);\n<line56>                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line57>                leaveInstance(endVote);\n<line58>                return endVote;\n<line59>            }\n<line60>            LOG.info(\"Notification time out: {} ms\", notTimeout);\n<line61>        } else if (validVoter(n.sid) && validVoter(n.leader)) {\n<line62>            /*\n<line63>                     * Only proceed if the vote comes from a replica in the current or next\n<line64>                     * voting view for a replica in the current or next voting view.\n<line65>                     */\n<line66>            switch(n.state) {\n<line67>                case LOOKING:\n<line68>                    if (getInitLastLoggedZxid() == -1) {\n<line69>                        LOG.debug(\"Ignoring notification as our zxid is -1\");\n<line70>                        break;\n<line71>                    }\n<line72>                    if (n.zxid == -1) {\n<line73>                        LOG.debug(\"Ignoring notification from member with -1 zxid {}\", n.sid);\n<line74>                        break;\n<line75>                    }\n<line76>                    // If notification > current, replace and send messages out\n<line77>                    if (n.electionEpoch > logicalclock.get()) {\n<line78>                        logicalclock.set(n.electionEpoch);\n<line79>                        recvset.clear();\n<line80>                        if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line81>                            updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line82>                        } else {\n<line83>                            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line84>                        }\n<line85>                        sendNotifications();\n<line86>                    } else if (n.electionEpoch < logicalclock.get()) {\n<line87>                        LOG.debug(\"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}\", Long.toHexString(n.electionEpoch), Long.toHexString(logicalclock.get()));\n<line88>                        break;\n<line89>                    } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line90>                        updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line91>                        sendNotifications();\n<line92>                    }\n<line93>                    LOG.debug(\"Adding vote: from={}, proposed leader={}, proposed zxid=0x{}, proposed election epoch=0x{}\", n.sid, n.leader, Long.toHexString(n.zxid), Long.toHexString(n.electionEpoch));\n<line94>                    // don't care about the version if it's in LOOKING state\n<line95>                    recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line96>                    voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line97>                    if (voteSet.hasAllQuorums()) {\n<line98>                        // Verify if there is any change in the proposed leader\n<line99>                        while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line100>                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line101>                                recvqueue.put(n);\n<line102>                                break;\n<line103>                            }\n<line104>                        }\n<line105>                        /*\n<line106>                             * This predicate is true once we don't read any new\n<line107>                             * relevant message from the reception queue\n<line108>                             */\n<line109>                        if (n == null) {\n<line110>                            setPeerState(proposedLeader, voteSet);\n<line111>                            Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line112>                            leaveInstance(endVote);\n<line113>                            return endVote;\n<line114>                        }\n<line115>                    }\n<line116>                    break;\n<line117>                case OBSERVING:\n<line118>                    LOG.debug(\"Notification from observer: {}\", n.sid);\n<line119>                    break;\n<line120>                /*\n<line121>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line122>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line123>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line124>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line125>                        * is generated.\n<line126>                        *\n<line127>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line128>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line129>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line130>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line131>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line132>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line133>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line134>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line135>                        *\n<line136>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line137>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line138>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line139>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line140>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line141>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line142>                        *\n<line143>                        *\n<line144>                        * */\n<line145>                case FOLLOWING:\n<line146>                    /*\n<line147>                        * To avoid duplicate codes\n<line148>                        * */\n<line149>                    Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line150>                    if (resultFN == null) {\n<line151>                        break;\n<line152>                    } else {\n<line153>                        return resultFN;\n<line154>                    }\n<line155>                case LEADING:\n<line156>                    /*\n<line157>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line158>                        * a null pointer, ask Oracle whether to follow this leader.\n<line159>                        * */\n<line160>                    Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line161>                    if (resultLN == null) {\n<line162>                        break;\n<line163>                    } else {\n<line164>                        return resultLN;\n<line165>                    }\n<line166>                default:\n<line167>                    LOG.warn(\"Notification state unrecognized: {} (n.state), {}(n.sid)\", n.state, n.sid);\n<line168>                    break;\n<line169>            }\n<line170>        } else {\n<line171>            if (!validVoter(n.leader)) {\n<line172>                LOG.warn(\"Ignoring notification for non-cluster member sid {} from sid {}\", n.leader, n.sid);\n<line173>            }\n<line174>            if (!validVoter(n.sid)) {\n<line175>                LOG.warn(\"Ignoring notification for sid {} from non-quorum member sid {}\", n.leader, n.sid);\n<line176>            }\n<line177>        }\n<line178>    }\n<line179>    return null;\n<line180>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                 * Remove next notification from queue, times out after 2 times\n<line4>                 * the termination time\n<line5>                 */\n<line6>    Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n<line7>    /*\n<line8>                 * Sends more notifications if haven't received enough.\n<line9>                 * Otherwise processes new notification.\n<line10>                 */\n<line11>    if (n == null) {\n<line12>        if (manager.haveDelivered()) {\n<line13>            sendNotifications();\n<line14>        } else {\n<line15>            manager.connectAll();\n<line16>        }\n<line17>        /*\n<line18>                     * Exponential backoff\n<line19>                     */\n<line20>        notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line21>        /*\n<line22>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line23>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line24>                     *\n<line25>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line26>                     * which is in a configuration of 2 instances.\n<line27>                     * */\n<line28>        if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line29>            setPeerState(proposedLeader, voteSet);\n<line30>            Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line31>            leaveInstance(endVote);\n<line32>            return endVote;\n<line33>        }\n<line34>    } else if (validVoter(n.sid) && validVoter(n.leader)) {\n<line35>        /*\n<line36>                     * Only proceed if the vote comes from a replica in the current or next\n<line37>                     * voting view for a replica in the current or next voting view.\n<line38>                     */\n<line39>        switch(n.state) {\n<line40>            case LOOKING:\n<line41>                if (getInitLastLoggedZxid() == -1) {\n<line42>                    break;\n<line43>                }\n<line44>                if (n.zxid == -1) {\n<line45>                    break;\n<line46>                }\n<line47>                // If notification > current, replace and send messages out\n<line48>                if (n.electionEpoch > logicalclock.get()) {\n<line49>                    logicalclock.set(n.electionEpoch);\n<line50>                    recvset.clear();\n<line51>                    if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line52>                        updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line53>                    } else {\n<line54>                        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line55>                    }\n<line56>                    sendNotifications();\n<line57>                } else if (n.electionEpoch < logicalclock.get()) {\n<line58>                    break;\n<line59>                } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line60>                    updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line61>                    sendNotifications();\n<line62>                }\n<line63>                // don't care about the version if it's in LOOKING state\n<line64>                recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line65>                voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line66>                if (voteSet.hasAllQuorums()) {\n<line67>                    // Verify if there is any change in the proposed leader\n<line68>                    while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line69>                        if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line70>                            recvqueue.put(n);\n<line71>                            break;\n<line72>                        }\n<line73>                    }\n<line74>                    /*\n<line75>                             * This predicate is true once we don't read any new\n<line76>                             * relevant message from the reception queue\n<line77>                             */\n<line78>                    if (n == null) {\n<line79>                        setPeerState(proposedLeader, voteSet);\n<line80>                        Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line81>                        leaveInstance(endVote);\n<line82>                        return endVote;\n<line83>                    }\n<line84>                }\n<line85>                break;\n<line86>            case OBSERVING:\n<line87>                break;\n<line88>            /*\n<line89>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line90>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line91>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line92>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line93>                        * is generated.\n<line94>                        *\n<line95>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line96>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line97>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line98>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line99>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line100>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line101>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line102>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line103>                        *\n<line104>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line105>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line106>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line107>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line108>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line109>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line110>                        *\n<line111>                        *\n<line112>                        * */\n<line113>            case FOLLOWING:\n<line114>                /*\n<line115>                        * To avoid duplicate codes\n<line116>                        * */\n<line117>                Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line118>                if (resultFN == null) {\n<line119>                    break;\n<line120>                } else {\n<line121>                    return resultFN;\n<line122>                }\n<line123>            case LEADING:\n<line124>                /*\n<line125>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line126>                        * a null pointer, ask Oracle whether to follow this leader.\n<line127>                        * */\n<line128>                Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line129>                if (resultLN == null) {\n<line130>                    break;\n<line131>                } else {\n<line132>                    return resultLN;\n<line133>                }\n<line134>            default:\n<line135>                break;\n<line136>        }\n<line137>    } else {\n<line138>        if (!validVoter(n.leader)) {\n<line139>        }\n<line140>        if (!validVoter(n.sid)) {\n<line141>        }\n<line142>    }\n<line143>}","output":"<line1>{\n<line2>    /*\n<line3>                 * Remove next notification from queue, times out after 2 times\n<line4>                 * the termination time\n<line5>                 */\n<line6>    Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);\n<line7>    /*\n<line8>                 * Sends more notifications if haven't received enough.\n<line9>                 * Otherwise processes new notification.\n<line10>                 */\n<line11>    if (n == null) {\n<line12>        if (manager.haveDelivered()) {\n<line13>            sendNotifications();\n<line14>        } else {\n<line15>            manager.connectAll();\n<line16>        }\n<line17>        /*\n<line18>                     * Exponential backoff\n<line19>                     */\n<line20>        notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line21>        /*\n<line22>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line23>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line24>                     *\n<line25>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line26>                     * which is in a configuration of 2 instances.\n<line27>                     * */\n<line28>        if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line29>            setPeerState(proposedLeader, voteSet);\n<line30>            Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line31>            leaveInstance(endVote);\n<line32>            return endVote;\n<line33>        }\n<line34>        LOG.info(\"Notification time out: {} ms\", notTimeout);\n<line35>    } else if (validVoter(n.sid) && validVoter(n.leader)) {\n<line36>        /*\n<line37>                     * Only proceed if the vote comes from a replica in the current or next\n<line38>                     * voting view for a replica in the current or next voting view.\n<line39>                     */\n<line40>        switch(n.state) {\n<line41>            case LOOKING:\n<line42>                if (getInitLastLoggedZxid() == -1) {\n<line43>                    LOG.debug(\"Ignoring notification as our zxid is -1\");\n<line44>                    break;\n<line45>                }\n<line46>                if (n.zxid == -1) {\n<line47>                    LOG.debug(\"Ignoring notification from member with -1 zxid {}\", n.sid);\n<line48>                    break;\n<line49>                }\n<line50>                // If notification > current, replace and send messages out\n<line51>                if (n.electionEpoch > logicalclock.get()) {\n<line52>                    logicalclock.set(n.electionEpoch);\n<line53>                    recvset.clear();\n<line54>                    if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line55>                        updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line56>                    } else {\n<line57>                        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line58>                    }\n<line59>                    sendNotifications();\n<line60>                } else if (n.electionEpoch < logicalclock.get()) {\n<line61>                    LOG.debug(\"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}\", Long.toHexString(n.electionEpoch), Long.toHexString(logicalclock.get()));\n<line62>                    break;\n<line63>                } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line64>                    updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line65>                    sendNotifications();\n<line66>                }\n<line67>                LOG.debug(\"Adding vote: from={}, proposed leader={}, proposed zxid=0x{}, proposed election epoch=0x{}\", n.sid, n.leader, Long.toHexString(n.zxid), Long.toHexString(n.electionEpoch));\n<line68>                // don't care about the version if it's in LOOKING state\n<line69>                recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line70>                voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line71>                if (voteSet.hasAllQuorums()) {\n<line72>                    // Verify if there is any change in the proposed leader\n<line73>                    while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line74>                        if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line75>                            recvqueue.put(n);\n<line76>                            break;\n<line77>                        }\n<line78>                    }\n<line79>                    /*\n<line80>                             * This predicate is true once we don't read any new\n<line81>                             * relevant message from the reception queue\n<line82>                             */\n<line83>                    if (n == null) {\n<line84>                        setPeerState(proposedLeader, voteSet);\n<line85>                        Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line86>                        leaveInstance(endVote);\n<line87>                        return endVote;\n<line88>                    }\n<line89>                }\n<line90>                break;\n<line91>            case OBSERVING:\n<line92>                LOG.debug(\"Notification from observer: {}\", n.sid);\n<line93>                break;\n<line94>            /*\n<line95>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line96>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line97>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line98>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line99>                        * is generated.\n<line100>                        *\n<line101>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line102>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line103>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line104>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line105>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line106>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line107>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line108>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line109>                        *\n<line110>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line111>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line112>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line113>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line114>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line115>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line116>                        *\n<line117>                        *\n<line118>                        * */\n<line119>            case FOLLOWING:\n<line120>                /*\n<line121>                        * To avoid duplicate codes\n<line122>                        * */\n<line123>                Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line124>                if (resultFN == null) {\n<line125>                    break;\n<line126>                } else {\n<line127>                    return resultFN;\n<line128>                }\n<line129>            case LEADING:\n<line130>                /*\n<line131>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line132>                        * a null pointer, ask Oracle whether to follow this leader.\n<line133>                        * */\n<line134>                Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line135>                if (resultLN == null) {\n<line136>                    break;\n<line137>                } else {\n<line138>                    return resultLN;\n<line139>                }\n<line140>            default:\n<line141>                LOG.warn(\"Notification state unrecognized: {} (n.state), {}(n.sid)\", n.state, n.sid);\n<line142>                break;\n<line143>        }\n<line144>    } else {\n<line145>        if (!validVoter(n.leader)) {\n<line146>            LOG.warn(\"Ignoring notification for non-cluster member sid {} from sid {}\", n.leader, n.sid);\n<line147>        }\n<line148>        if (!validVoter(n.sid)) {\n<line149>            LOG.warn(\"Ignoring notification for sid {} from non-quorum member sid {}\", n.leader, n.sid);\n<line150>        }\n<line151>    }\n<line152>}"},{"input":"","instruction":"<line1>{\n<line2>    if (manager.haveDelivered()) {\n<line3>        sendNotifications();\n<line4>    } else {\n<line5>        manager.connectAll();\n<line6>    }\n<line7>    /*\n<line8>                     * Exponential backoff\n<line9>                     */\n<line10>    notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line11>    /*\n<line12>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line13>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line14>                     *\n<line15>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line16>                     * which is in a configuration of 2 instances.\n<line17>                     * */\n<line18>    if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line19>        setPeerState(proposedLeader, voteSet);\n<line20>        Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line21>        leaveInstance(endVote);\n<line22>        return endVote;\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    if (manager.haveDelivered()) {\n<line3>        sendNotifications();\n<line4>    } else {\n<line5>        manager.connectAll();\n<line6>    }\n<line7>    /*\n<line8>                     * Exponential backoff\n<line9>                     */\n<line10>    notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);\n<line11>    /*\n<line12>                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from\n<line13>                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens\n<line14>                     *\n<line15>                     * The leader election algorithm does not provide the ability of electing a leader from a single instance\n<line16>                     * which is in a configuration of 2 instances.\n<line17>                     * */\n<line18>    if (self.getQuorumVerifier() instanceof QuorumOracleMaj && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {\n<line19>        setPeerState(proposedLeader, voteSet);\n<line20>        Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line21>        leaveInstance(endVote);\n<line22>        return endVote;\n<line23>    }\n<line24>    LOG.info(\"Notification time out: {} ms\", notTimeout);\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>                     * Only proceed if the vote comes from a replica in the current or next\n<line4>                     * voting view for a replica in the current or next voting view.\n<line5>                     */\n<line6>    switch(n.state) {\n<line7>        case LOOKING:\n<line8>            if (getInitLastLoggedZxid() == -1) {\n<line9>                break;\n<line10>            }\n<line11>            if (n.zxid == -1) {\n<line12>                break;\n<line13>            }\n<line14>            // If notification > current, replace and send messages out\n<line15>            if (n.electionEpoch > logicalclock.get()) {\n<line16>                logicalclock.set(n.electionEpoch);\n<line17>                recvset.clear();\n<line18>                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line19>                    updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line20>                } else {\n<line21>                    updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line22>                }\n<line23>                sendNotifications();\n<line24>            } else if (n.electionEpoch < logicalclock.get()) {\n<line25>                break;\n<line26>            } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line27>                updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line28>                sendNotifications();\n<line29>            }\n<line30>            // don't care about the version if it's in LOOKING state\n<line31>            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line32>            voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line33>            if (voteSet.hasAllQuorums()) {\n<line34>                // Verify if there is any change in the proposed leader\n<line35>                while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line36>                    if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line37>                        recvqueue.put(n);\n<line38>                        break;\n<line39>                    }\n<line40>                }\n<line41>                /*\n<line42>                             * This predicate is true once we don't read any new\n<line43>                             * relevant message from the reception queue\n<line44>                             */\n<line45>                if (n == null) {\n<line46>                    setPeerState(proposedLeader, voteSet);\n<line47>                    Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line48>                    leaveInstance(endVote);\n<line49>                    return endVote;\n<line50>                }\n<line51>            }\n<line52>            break;\n<line53>        case OBSERVING:\n<line54>            break;\n<line55>        /*\n<line56>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line57>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line58>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line59>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line60>                        * is generated.\n<line61>                        *\n<line62>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line63>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line64>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line65>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line66>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line67>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line68>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line69>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line70>                        *\n<line71>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line72>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line73>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line74>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line75>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line76>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line77>                        *\n<line78>                        *\n<line79>                        * */\n<line80>        case FOLLOWING:\n<line81>            /*\n<line82>                        * To avoid duplicate codes\n<line83>                        * */\n<line84>            Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line85>            if (resultFN == null) {\n<line86>                break;\n<line87>            } else {\n<line88>                return resultFN;\n<line89>            }\n<line90>        case LEADING:\n<line91>            /*\n<line92>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line93>                        * a null pointer, ask Oracle whether to follow this leader.\n<line94>                        * */\n<line95>            Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line96>            if (resultLN == null) {\n<line97>                break;\n<line98>            } else {\n<line99>                return resultLN;\n<line100>            }\n<line101>        default:\n<line102>            break;\n<line103>    }\n<line104>}","output":"<line1>{\n<line2>    /*\n<line3>                     * Only proceed if the vote comes from a replica in the current or next\n<line4>                     * voting view for a replica in the current or next voting view.\n<line5>                     */\n<line6>    switch(n.state) {\n<line7>        case LOOKING:\n<line8>            if (getInitLastLoggedZxid() == -1) {\n<line9>                LOG.debug(\"Ignoring notification as our zxid is -1\");\n<line10>                break;\n<line11>            }\n<line12>            if (n.zxid == -1) {\n<line13>                LOG.debug(\"Ignoring notification from member with -1 zxid {}\", n.sid);\n<line14>                break;\n<line15>            }\n<line16>            // If notification > current, replace and send messages out\n<line17>            if (n.electionEpoch > logicalclock.get()) {\n<line18>                logicalclock.set(n.electionEpoch);\n<line19>                recvset.clear();\n<line20>                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n<line21>                    updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line22>                } else {\n<line23>                    updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n<line24>                }\n<line25>                sendNotifications();\n<line26>            } else if (n.electionEpoch < logicalclock.get()) {\n<line27>                LOG.debug(\"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}\", Long.toHexString(n.electionEpoch), Long.toHexString(logicalclock.get()));\n<line28>                break;\n<line29>            } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line30>                updateProposal(n.leader, n.zxid, n.peerEpoch);\n<line31>                sendNotifications();\n<line32>            }\n<line33>            LOG.debug(\"Adding vote: from={}, proposed leader={}, proposed zxid=0x{}, proposed election epoch=0x{}\", n.sid, n.leader, Long.toHexString(n.zxid), Long.toHexString(n.electionEpoch));\n<line34>            // don't care about the version if it's in LOOKING state\n<line35>            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n<line36>            voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));\n<line37>            if (voteSet.hasAllQuorums()) {\n<line38>                // Verify if there is any change in the proposed leader\n<line39>                while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {\n<line40>                    if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {\n<line41>                        recvqueue.put(n);\n<line42>                        break;\n<line43>                    }\n<line44>                }\n<line45>                /*\n<line46>                             * This predicate is true once we don't read any new\n<line47>                             * relevant message from the reception queue\n<line48>                             */\n<line49>                if (n == null) {\n<line50>                    setPeerState(proposedLeader, voteSet);\n<line51>                    Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);\n<line52>                    leaveInstance(endVote);\n<line53>                    return endVote;\n<line54>                }\n<line55>            }\n<line56>            break;\n<line57>        case OBSERVING:\n<line58>            LOG.debug(\"Notification from observer: {}\", n.sid);\n<line59>            break;\n<line60>        /*\n<line61>                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.\n<line62>                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to\n<line63>                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows\n<line64>                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader\n<line65>                        * is generated.\n<line66>                        *\n<line67>                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node\n<line68>                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when\n<line69>                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,\n<line70>                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is\n<line71>                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle\n<line72>                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the\n<line73>                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.\n<line74>                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.\n<line75>                        *\n<line76>                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a\n<line77>                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to\n<line78>                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that\n<line79>                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.\n<line80>                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.\n<line81>                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.\n<line82>                        *\n<line83>                        *\n<line84>                        * */\n<line85>        case FOLLOWING:\n<line86>            /*\n<line87>                        * To avoid duplicate codes\n<line88>                        * */\n<line89>            Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line90>            if (resultFN == null) {\n<line91>                break;\n<line92>            } else {\n<line93>                return resultFN;\n<line94>            }\n<line95>        case LEADING:\n<line96>            /*\n<line97>                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns\n<line98>                        * a null pointer, ask Oracle whether to follow this leader.\n<line99>                        * */\n<line100>            Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);\n<line101>            if (resultLN == null) {\n<line102>                break;\n<line103>            } else {\n<line104>                return resultLN;\n<line105>            }\n<line106>        default:\n<line107>            LOG.warn(\"Notification state unrecognized: {} (n.state), {}(n.sid)\", n.state, n.sid);\n<line108>            break;\n<line109>    }\n<line110>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring notification as our zxid is -1\");\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring notification from member with -1 zxid {}\", n.sid);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}\", Long.toHexString(n.electionEpoch), Long.toHexString(logicalclock.get()));\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (self.jmxLeaderElectionBean != null) {\n<line4>            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n<line5>        }\n<line6>    } catch (Exception e) {\n<line7>    }\n<line8>    self.jmxLeaderElectionBean = null;\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        if (self.jmxLeaderElectionBean != null) {\n<line4>            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n<line5>        }\n<line6>    } catch (Exception e) {\n<line7>        LOG.warn(\"Failed to unregister with JMX\", e);\n<line8>    }\n<line9>    self.jmxLeaderElectionBean = null;\n<line10>    LOG.debug(\"Number of connection processing threads: {}\", manager.getConnectionThreadCount());\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>        *\n<line4>        * In a two-node configuration, a recovery nodes cannot locate a leader because of the lack of the majority in the voteset.\n<line5>        * Therefore, it is the time for Oracle to take place as a tight breaker.\n<line6>        *\n<line7>        * */\n<line8>    Vote result = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line9>    if (result == null) {\n<line10>        /*\n<line11>            * Ask Oracle to see if it is okay to follow this leader.\n<line12>            *\n<line13>            * We don't need the CheckLeader() because itself cannot be a leader candidate\n<line14>            * */\n<line15>        if (self.getQuorumVerifier().getNeedOracle() && !self.getQuorumVerifier().askOracle()) {\n<line16>            setPeerState(n.leader, voteSet);\n<line17>            Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n<line18>            leaveInstance(endVote);\n<line19>            return endVote;\n<line20>        } else {\n<line21>            return null;\n<line22>        }\n<line23>    } else {\n<line24>        return result;\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    /*\n<line3>        *\n<line4>        * In a two-node configuration, a recovery nodes cannot locate a leader because of the lack of the majority in the voteset.\n<line5>        * Therefore, it is the time for Oracle to take place as a tight breaker.\n<line6>        *\n<line7>        * */\n<line8>    Vote result = receivedFollowingNotification(recvset, outofelection, voteSet, n);\n<line9>    if (result == null) {\n<line10>        /*\n<line11>            * Ask Oracle to see if it is okay to follow this leader.\n<line12>            *\n<line13>            * We don't need the CheckLeader() because itself cannot be a leader candidate\n<line14>            * */\n<line15>        if (self.getQuorumVerifier().getNeedOracle() && !self.getQuorumVerifier().askOracle()) {\n<line16>            LOG.info(\"Oracle indicates to follow\");\n<line17>            setPeerState(n.leader, voteSet);\n<line18>            Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n<line19>            leaveInstance(endVote);\n<line20>            return endVote;\n<line21>        } else {\n<line22>            LOG.info(\"Oracle indicates not to follow\");\n<line23>            return null;\n<line24>        }\n<line25>    } else {\n<line26>        return result;\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>            * Ask Oracle to see if it is okay to follow this leader.\n<line4>            *\n<line5>            * We don't need the CheckLeader() because itself cannot be a leader candidate\n<line6>            * */\n<line7>    if (self.getQuorumVerifier().getNeedOracle() && !self.getQuorumVerifier().askOracle()) {\n<line8>        setPeerState(n.leader, voteSet);\n<line9>        Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n<line10>        leaveInstance(endVote);\n<line11>        return endVote;\n<line12>    } else {\n<line13>        return null;\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    /*\n<line3>            * Ask Oracle to see if it is okay to follow this leader.\n<line4>            *\n<line5>            * We don't need the CheckLeader() because itself cannot be a leader candidate\n<line6>            * */\n<line7>    if (self.getQuorumVerifier().getNeedOracle() && !self.getQuorumVerifier().askOracle()) {\n<line8>        LOG.info(\"Oracle indicates to follow\");\n<line9>        setPeerState(n.leader, voteSet);\n<line10>        Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n<line11>        leaveInstance(endVote);\n<line12>        return endVote;\n<line13>    } else {\n<line14>        LOG.info(\"Oracle indicates not to follow\");\n<line15>        return null;\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    setPeerState(n.leader, voteSet);\n<line3>    Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n<line4>    leaveInstance(endVote);\n<line5>    return endVote;\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Oracle indicates to follow\");\n<line3>    setPeerState(n.leader, voteSet);\n<line4>    Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n<line5>    leaveInstance(endVote);\n<line6>    return endVote;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Oracle indicates not to follow\");\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!p.containsKey(\"dataDir\")) {\n<line3>        p.put(\"dataDir\", baseDir.resolve(\"data\").toAbsolutePath().toString());\n<line4>    }\n<line5>    Path configFile = Files.createTempFile(baseDir, \"zookeeper.configuration\", \".properties\");\n<line6>    try (OutputStream oo = Files.newOutputStream(configFile)) {\n<line7>        p.store(oo, \"Automatically generated at every-boot\");\n<line8>    }\n<line9>    this.exitHandler = exitHandler;\n<line10>    config = new QuorumPeerConfig();\n<line11>    config.parse(configFile.toAbsolutePath().toString());\n<line12>    for (Map.Entry<Long, QuorumPeer.QuorumServer> server : config.getServers().entrySet()) {\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    if (!p.containsKey(\"dataDir\")) {\n<line3>        p.put(\"dataDir\", baseDir.resolve(\"data\").toAbsolutePath().toString());\n<line4>    }\n<line5>    Path configFile = Files.createTempFile(baseDir, \"zookeeper.configuration\", \".properties\");\n<line6>    try (OutputStream oo = Files.newOutputStream(configFile)) {\n<line7>        p.store(oo, \"Automatically generated at every-boot\");\n<line8>    }\n<line9>    this.exitHandler = exitHandler;\n<line10>    LOG.info(\"Current configuration is at {}\", configFile.toAbsolutePath());\n<line11>    config = new QuorumPeerConfig();\n<line12>    config.parse(configFile.toAbsolutePath().toString());\n<line13>    LOG.info(\"ServerID:\" + config.getServerId());\n<line14>    LOG.info(\"DataDir:\" + config.getDataDir());\n<line15>    LOG.info(\"Servers:\" + config.getServers());\n<line16>    LOG.info(\"ElectionPort:\" + config.getElectionPort());\n<line17>    LOG.info(\"SyncLimit:\" + config.getSyncLimit());\n<line18>    LOG.info(\"PeerType:\" + config.getPeerType());\n<line19>    LOG.info(\"Distributed:\" + config.isDistributed());\n<line20>    LOG.info(\"SyncEnabled:\" + config.getSyncEnabled());\n<line21>    LOG.info(\"MetricsProviderClassName:\" + config.getMetricsProviderClassName());\n<line22>    for (Map.Entry<Long, QuorumPeer.QuorumServer> server : config.getServers().entrySet()) {\n<line23>        LOG.info(\"Server: \" + server.getKey() + \" -> addr \" + server.getValue().addr + \" elect \" + server.getValue().electionAddr + \" id=\" + server.getValue().id + \" type \" + server.getValue().type);\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Server: \" + server.getKey() + \" -> addr \" + server.getValue().addr + \" elect \" + server.getValue().electionAddr + \" id=\" + server.getValue().id + \" type \" + server.getValue().type);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    switch(exitHandler) {\n<line3>        case EXIT:\n<line4>            ServiceUtils.setSystemExitProcedure(ServiceUtils.SYSTEM_EXIT);\n<line5>            break;\n<line6>        case LOG_ONLY:\n<line7>            ServiceUtils.setSystemExitProcedure(ServiceUtils.LOG_ONLY);\n<line8>            break;\n<line9>        default:\n<line10>            ServiceUtils.setSystemExitProcedure(ServiceUtils.SYSTEM_EXIT);\n<line11>            break;\n<line12>    }\n<line13>    final CompletableFuture<String> started = new CompletableFuture<>();\n<line14>    if (config.getServers().size() > 1 || config.isDistributed()) {\n<line15>        maincluster = new QuorumPeerMain() {\n<line16>\n<line17>            protected QuorumPeer getQuorumPeer() throws SaslException {\n<line18>                return new QuorumPeer() {\n<line19>\n<line20>                    @Override\n<line21>                    public void start() {\n<line22>                        super.start();\n<line23>                        boundClientPort = getClientPort();\n<line24>                        boundSecureClientPort = getSecureClientPort();\n<line25>                        started.complete(null);\n<line26>                    }\n<line27>                };\n<line28>            }\n<line29>        };\n<line30>        // Start and schedule the the purge task\n<line31>        purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line32>        purgeMgr.start();\n<line33>        thread = new Thread(\"zkservermainrunner\") {\n<line34>\n<line35>            @Override\n<line36>            public void run() {\n<line37>                try {\n<line38>                    maincluster.runFromConfig(config);\n<line39>                    maincluster.close();\n<line40>                    if (!stopping) {\n<line41>                        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line42>                    }\n<line43>                } catch (Throwable t) {\n<line44>                    maincluster.close();\n<line45>                    if (!stopping) {\n<line46>                        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line47>                    }\n<line48>                }\n<line49>            }\n<line50>        };\n<line51>        thread.start();\n<line52>    } else {\n<line53>        mainsingle = new ZooKeeperServerMain() {\n<line54>\n<line55>            @Override\n<line56>            public void serverStarted() {\n<line57>                boundClientPort = getClientPort();\n<line58>                boundSecureClientPort = getSecureClientPort();\n<line59>                started.complete(null);\n<line60>            }\n<line61>        };\n<line62>        purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line63>        purgeMgr.start();\n<line64>        thread = new Thread(\"zkservermainrunner\") {\n<line65>\n<line66>            @Override\n<line67>            public void run() {\n<line68>                try {\n<line69>                    ServerConfig cc = new ServerConfig();\n<line70>                    cc.readFrom(config);\n<line71>                    mainsingle.runFromConfig(cc);\n<line72>                    if (!stopping) {\n<line73>                        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line74>                    }\n<line75>                } catch (Throwable t) {\n<line76>                    mainsingle.close();\n<line77>                    if (!stopping) {\n<line78>                        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line79>                    }\n<line80>                }\n<line81>            }\n<line82>        };\n<line83>        thread.start();\n<line84>    }\n<line85>    try {\n<line86>        started.get(startupTimeout, TimeUnit.MILLISECONDS);\n<line87>    } catch (TimeoutException err) {\n<line88>        close();\n<line89>        throw err;\n<line90>    }\n<line91>}","output":"<line1>{\n<line2>    switch(exitHandler) {\n<line3>        case EXIT:\n<line4>            ServiceUtils.setSystemExitProcedure(ServiceUtils.SYSTEM_EXIT);\n<line5>            break;\n<line6>        case LOG_ONLY:\n<line7>            ServiceUtils.setSystemExitProcedure(ServiceUtils.LOG_ONLY);\n<line8>            break;\n<line9>        default:\n<line10>            ServiceUtils.setSystemExitProcedure(ServiceUtils.SYSTEM_EXIT);\n<line11>            break;\n<line12>    }\n<line13>    final CompletableFuture<String> started = new CompletableFuture<>();\n<line14>    if (config.getServers().size() > 1 || config.isDistributed()) {\n<line15>        LOG.info(\"Running ZK Server in single Quorum MODE\");\n<line16>        maincluster = new QuorumPeerMain() {\n<line17>\n<line18>            protected QuorumPeer getQuorumPeer() throws SaslException {\n<line19>                return new QuorumPeer() {\n<line20>\n<line21>                    @Override\n<line22>                    public void start() {\n<line23>                        super.start();\n<line24>                        boundClientPort = getClientPort();\n<line25>                        boundSecureClientPort = getSecureClientPort();\n<line26>                        LOG.info(\"ZK Server {} started\", this);\n<line27>                        started.complete(null);\n<line28>                    }\n<line29>                };\n<line30>            }\n<line31>        };\n<line32>        // Start and schedule the the purge task\n<line33>        purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line34>        purgeMgr.start();\n<line35>        thread = new Thread(\"zkservermainrunner\") {\n<line36>\n<line37>            @Override\n<line38>            public void run() {\n<line39>                try {\n<line40>                    maincluster.runFromConfig(config);\n<line41>                    maincluster.close();\n<line42>                    LOG.info(\"ZK server died. Requsting stop on JVM\");\n<line43>                    if (!stopping) {\n<line44>                        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line45>                    }\n<line46>                } catch (Throwable t) {\n<line47>                    LOG.error(\"error during server lifecycle\", t);\n<line48>                    maincluster.close();\n<line49>                    if (!stopping) {\n<line50>                        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line51>                    }\n<line52>                }\n<line53>            }\n<line54>        };\n<line55>        thread.start();\n<line56>    } else {\n<line57>        LOG.info(\"Running ZK Server in single STANDALONE MODE\");\n<line58>        mainsingle = new ZooKeeperServerMain() {\n<line59>\n<line60>            @Override\n<line61>            public void serverStarted() {\n<line62>                LOG.info(\"ZK Server started\");\n<line63>                boundClientPort = getClientPort();\n<line64>                boundSecureClientPort = getSecureClientPort();\n<line65>                started.complete(null);\n<line66>            }\n<line67>        };\n<line68>        purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line69>        purgeMgr.start();\n<line70>        thread = new Thread(\"zkservermainrunner\") {\n<line71>\n<line72>            @Override\n<line73>            public void run() {\n<line74>                try {\n<line75>                    ServerConfig cc = new ServerConfig();\n<line76>                    cc.readFrom(config);\n<line77>                    LOG.info(\"ZK server starting\");\n<line78>                    mainsingle.runFromConfig(cc);\n<line79>                    LOG.info(\"ZK server died. Requesting stop on JVM\");\n<line80>                    if (!stopping) {\n<line81>                        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line82>                    }\n<line83>                } catch (Throwable t) {\n<line84>                    LOG.error(\"error during server lifecycle\", t);\n<line85>                    mainsingle.close();\n<line86>                    if (!stopping) {\n<line87>                        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line88>                    }\n<line89>                }\n<line90>            }\n<line91>        };\n<line92>        thread.start();\n<line93>    }\n<line94>    try {\n<line95>        started.get(startupTimeout, TimeUnit.MILLISECONDS);\n<line96>    } catch (TimeoutException err) {\n<line97>        LOG.info(\"Startup timed out, trying to close\");\n<line98>        close();\n<line99>        throw err;\n<line100>    }\n<line101>}"},{"input":"","instruction":"<line1>{\n<line2>    maincluster = new QuorumPeerMain() {\n<line3>\n<line4>        protected QuorumPeer getQuorumPeer() throws SaslException {\n<line5>            return new QuorumPeer() {\n<line6>\n<line7>                @Override\n<line8>                public void start() {\n<line9>                    super.start();\n<line10>                    boundClientPort = getClientPort();\n<line11>                    boundSecureClientPort = getSecureClientPort();\n<line12>                    started.complete(null);\n<line13>                }\n<line14>            };\n<line15>        }\n<line16>    };\n<line17>    // Start and schedule the the purge task\n<line18>    purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line19>    purgeMgr.start();\n<line20>    thread = new Thread(\"zkservermainrunner\") {\n<line21>\n<line22>        @Override\n<line23>        public void run() {\n<line24>            try {\n<line25>                maincluster.runFromConfig(config);\n<line26>                maincluster.close();\n<line27>                if (!stopping) {\n<line28>                    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line29>                }\n<line30>            } catch (Throwable t) {\n<line31>                maincluster.close();\n<line32>                if (!stopping) {\n<line33>                    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line34>                }\n<line35>            }\n<line36>        }\n<line37>    };\n<line38>    thread.start();\n<line39>}","output":"<line1>{\n<line2>    LOG.info(\"Running ZK Server in single Quorum MODE\");\n<line3>    maincluster = new QuorumPeerMain() {\n<line4>\n<line5>        protected QuorumPeer getQuorumPeer() throws SaslException {\n<line6>            return new QuorumPeer() {\n<line7>\n<line8>                @Override\n<line9>                public void start() {\n<line10>                    super.start();\n<line11>                    boundClientPort = getClientPort();\n<line12>                    boundSecureClientPort = getSecureClientPort();\n<line13>                    LOG.info(\"ZK Server {} started\", this);\n<line14>                    started.complete(null);\n<line15>                }\n<line16>            };\n<line17>        }\n<line18>    };\n<line19>    // Start and schedule the the purge task\n<line20>    purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line21>    purgeMgr.start();\n<line22>    thread = new Thread(\"zkservermainrunner\") {\n<line23>\n<line24>        @Override\n<line25>        public void run() {\n<line26>            try {\n<line27>                maincluster.runFromConfig(config);\n<line28>                maincluster.close();\n<line29>                LOG.info(\"ZK server died. Requsting stop on JVM\");\n<line30>                if (!stopping) {\n<line31>                    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line32>                }\n<line33>            } catch (Throwable t) {\n<line34>                LOG.error(\"error during server lifecycle\", t);\n<line35>                maincluster.close();\n<line36>                if (!stopping) {\n<line37>                    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line38>                }\n<line39>            }\n<line40>        }\n<line41>    };\n<line42>    thread.start();\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    return new QuorumPeer() {\n<line3>\n<line4>        @Override\n<line5>        public void start() {\n<line6>            super.start();\n<line7>            boundClientPort = getClientPort();\n<line8>            boundSecureClientPort = getSecureClientPort();\n<line9>            started.complete(null);\n<line10>        }\n<line11>    };\n<line12>}","output":"<line1>{\n<line2>    return new QuorumPeer() {\n<line3>\n<line4>        @Override\n<line5>        public void start() {\n<line6>            super.start();\n<line7>            boundClientPort = getClientPort();\n<line8>            boundSecureClientPort = getSecureClientPort();\n<line9>            LOG.info(\"ZK Server {} started\", this);\n<line10>            started.complete(null);\n<line11>        }\n<line12>    };\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    super.start();\n<line3>    boundClientPort = getClientPort();\n<line4>    boundSecureClientPort = getSecureClientPort();\n<line5>    started.complete(null);\n<line6>}","output":"<line1>{\n<line2>    super.start();\n<line3>    boundClientPort = getClientPort();\n<line4>    boundSecureClientPort = getSecureClientPort();\n<line5>    LOG.info(\"ZK Server {} started\", this);\n<line6>    started.complete(null);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        maincluster.runFromConfig(config);\n<line4>        maincluster.close();\n<line5>        if (!stopping) {\n<line6>            ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line7>        }\n<line8>    } catch (Throwable t) {\n<line9>        maincluster.close();\n<line10>        if (!stopping) {\n<line11>            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line12>        }\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    try {\n<line3>        maincluster.runFromConfig(config);\n<line4>        maincluster.close();\n<line5>        LOG.info(\"ZK server died. Requsting stop on JVM\");\n<line6>        if (!stopping) {\n<line7>            ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line8>        }\n<line9>    } catch (Throwable t) {\n<line10>        LOG.error(\"error during server lifecycle\", t);\n<line11>        maincluster.close();\n<line12>        if (!stopping) {\n<line13>            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line14>        }\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    maincluster.runFromConfig(config);\n<line3>    maincluster.close();\n<line4>    if (!stopping) {\n<line5>        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    maincluster.runFromConfig(config);\n<line3>    maincluster.close();\n<line4>    LOG.info(\"ZK server died. Requsting stop on JVM\");\n<line5>    if (!stopping) {\n<line6>        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    maincluster.close();\n<line3>    if (!stopping) {\n<line4>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.error(\"error during server lifecycle\", t);\n<line3>    maincluster.close();\n<line4>    if (!stopping) {\n<line5>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    mainsingle = new ZooKeeperServerMain() {\n<line3>\n<line4>        @Override\n<line5>        public void serverStarted() {\n<line6>            boundClientPort = getClientPort();\n<line7>            boundSecureClientPort = getSecureClientPort();\n<line8>            started.complete(null);\n<line9>        }\n<line10>    };\n<line11>    purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line12>    purgeMgr.start();\n<line13>    thread = new Thread(\"zkservermainrunner\") {\n<line14>\n<line15>        @Override\n<line16>        public void run() {\n<line17>            try {\n<line18>                ServerConfig cc = new ServerConfig();\n<line19>                cc.readFrom(config);\n<line20>                mainsingle.runFromConfig(cc);\n<line21>                if (!stopping) {\n<line22>                    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line23>                }\n<line24>            } catch (Throwable t) {\n<line25>                mainsingle.close();\n<line26>                if (!stopping) {\n<line27>                    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line28>                }\n<line29>            }\n<line30>        }\n<line31>    };\n<line32>    thread.start();\n<line33>}","output":"<line1>{\n<line2>    LOG.info(\"Running ZK Server in single STANDALONE MODE\");\n<line3>    mainsingle = new ZooKeeperServerMain() {\n<line4>\n<line5>        @Override\n<line6>        public void serverStarted() {\n<line7>            LOG.info(\"ZK Server started\");\n<line8>            boundClientPort = getClientPort();\n<line9>            boundSecureClientPort = getSecureClientPort();\n<line10>            started.complete(null);\n<line11>        }\n<line12>    };\n<line13>    purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());\n<line14>    purgeMgr.start();\n<line15>    thread = new Thread(\"zkservermainrunner\") {\n<line16>\n<line17>        @Override\n<line18>        public void run() {\n<line19>            try {\n<line20>                ServerConfig cc = new ServerConfig();\n<line21>                cc.readFrom(config);\n<line22>                LOG.info(\"ZK server starting\");\n<line23>                mainsingle.runFromConfig(cc);\n<line24>                LOG.info(\"ZK server died. Requesting stop on JVM\");\n<line25>                if (!stopping) {\n<line26>                    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line27>                }\n<line28>            } catch (Throwable t) {\n<line29>                LOG.error(\"error during server lifecycle\", t);\n<line30>                mainsingle.close();\n<line31>                if (!stopping) {\n<line32>                    ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line33>                }\n<line34>            }\n<line35>        }\n<line36>    };\n<line37>    thread.start();\n<line38>}"},{"input":"","instruction":"<line1>{\n<line2>    boundClientPort = getClientPort();\n<line3>    boundSecureClientPort = getSecureClientPort();\n<line4>    started.complete(null);\n<line5>}","output":"<line1>{\n<line2>    LOG.info(\"ZK Server started\");\n<line3>    boundClientPort = getClientPort();\n<line4>    boundSecureClientPort = getSecureClientPort();\n<line5>    started.complete(null);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        ServerConfig cc = new ServerConfig();\n<line4>        cc.readFrom(config);\n<line5>        mainsingle.runFromConfig(cc);\n<line6>        if (!stopping) {\n<line7>            ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line8>        }\n<line9>    } catch (Throwable t) {\n<line10>        mainsingle.close();\n<line11>        if (!stopping) {\n<line12>            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line13>        }\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    try {\n<line3>        ServerConfig cc = new ServerConfig();\n<line4>        cc.readFrom(config);\n<line5>        LOG.info(\"ZK server starting\");\n<line6>        mainsingle.runFromConfig(cc);\n<line7>        LOG.info(\"ZK server died. Requesting stop on JVM\");\n<line8>        if (!stopping) {\n<line9>            ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line10>        }\n<line11>    } catch (Throwable t) {\n<line12>        LOG.error(\"error during server lifecycle\", t);\n<line13>        mainsingle.close();\n<line14>        if (!stopping) {\n<line15>            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    ServerConfig cc = new ServerConfig();\n<line3>    cc.readFrom(config);\n<line4>    mainsingle.runFromConfig(cc);\n<line5>    if (!stopping) {\n<line6>        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    ServerConfig cc = new ServerConfig();\n<line3>    cc.readFrom(config);\n<line4>    LOG.info(\"ZK server starting\");\n<line5>    mainsingle.runFromConfig(cc);\n<line6>    LOG.info(\"ZK server died. Requesting stop on JVM\");\n<line7>    if (!stopping) {\n<line8>        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    mainsingle.close();\n<line3>    if (!stopping) {\n<line4>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.error(\"error during server lifecycle\", t);\n<line3>    mainsingle.close();\n<line4>    if (!stopping) {\n<line5>        ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    close();\n<line3>    throw err;\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Startup timed out, trying to close\");\n<line3>    close();\n<line4>    throw err;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    stopping = true;\n<line3>    if (mainsingle != null) {\n<line4>        mainsingle.close();\n<line5>    }\n<line6>    if (maincluster != null) {\n<line7>        maincluster.close();\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Stopping ZK Server\");\n<line3>    stopping = true;\n<line4>    if (mainsingle != null) {\n<line5>        mainsingle.close();\n<line6>    }\n<line7>    if (maincluster != null) {\n<line8>        maincluster.close();\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n<line3>        if (request.type == OpCode.ping) {\n<line4>            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line5>        }\n<line6>        ZooTrace.logRequest(LOG, traceMask, 'E', request, \"\");\n<line7>    }\n<line8>    ProcessTxnResult rc = null;\n<line9>    if (!request.isThrottled()) {\n<line10>        rc = applyRequest(request);\n<line11>    }\n<line12>    if (request.cnxn == null) {\n<line13>        return;\n<line14>    }\n<line15>    ServerCnxn cnxn = request.cnxn;\n<line16>    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line17>    String lastOp = \"NA\";\n<line18>    // Notify ZooKeeperServer that the request has finished so that it can\n<line19>    // update any request accounting/throttling limits\n<line20>    zks.decInProcess();\n<line21>    zks.requestFinished(request);\n<line22>    Code err = Code.OK;\n<line23>    Record rsp = null;\n<line24>    String path = null;\n<line25>    int responseSize = 0;\n<line26>    try {\n<line27>        if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n<line28>            AuditHelper.addAuditLog(request, rc, true);\n<line29>            /*\n<line30>                 * When local session upgrading is disabled, leader will\n<line31>                 * reject the ephemeral node creation due to session expire.\n<line32>                 * However, if this is the follower that issue the request,\n<line33>                 * it will have the correct error code, so we should use that\n<line34>                 * and report to user\n<line35>                 */\n<line36>            if (request.getException() != null) {\n<line37>                throw request.getException();\n<line38>            } else {\n<line39>                throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));\n<line40>            }\n<line41>        }\n<line42>        KeeperException ke = request.getException();\n<line43>        if (ke instanceof SessionMovedException) {\n<line44>            throw ke;\n<line45>        }\n<line46>        if (ke != null && request.type != OpCode.multi) {\n<line47>            throw ke;\n<line48>        }\n<line49>        if (request.isStale()) {\n<line50>            ServerMetrics.getMetrics().STALE_REPLIES.add(1);\n<line51>        }\n<line52>        if (request.isThrottled()) {\n<line53>            throw KeeperException.create(Code.THROTTLEDOP);\n<line54>        }\n<line55>        AuditHelper.addAuditLog(request, rc);\n<line56>        switch(request.type) {\n<line57>            case OpCode.ping:\n<line58>                {\n<line59>                    lastOp = \"PING\";\n<line60>                    updateStats(request, lastOp, lastZxid);\n<line61>                    responseSize = cnxn.sendResponse(new ReplyHeader(ClientCnxn.PING_XID, lastZxid, 0), null, \"response\");\n<line62>                    return;\n<line63>                }\n<line64>            case OpCode.createSession:\n<line65>                {\n<line66>                    lastOp = \"SESS\";\n<line67>                    updateStats(request, lastOp, lastZxid);\n<line68>                    zks.finishSessionInit(request.cnxn, true);\n<line69>                    return;\n<line70>                }\n<line71>            case OpCode.multi:\n<line72>                {\n<line73>                    lastOp = \"MULT\";\n<line74>                    rsp = new MultiResponse();\n<line75>                    for (ProcessTxnResult subTxnResult : rc.multiResult) {\n<line76>                        OpResult subResult;\n<line77>                        switch(subTxnResult.type) {\n<line78>                            case OpCode.check:\n<line79>                                subResult = new CheckResult();\n<line80>                                break;\n<line81>                            case OpCode.create:\n<line82>                                subResult = new CreateResult(subTxnResult.path);\n<line83>                                break;\n<line84>                            case OpCode.create2:\n<line85>                            case OpCode.createTTL:\n<line86>                            case OpCode.createContainer:\n<line87>                                subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n<line88>                                break;\n<line89>                            case OpCode.delete:\n<line90>                            case OpCode.deleteContainer:\n<line91>                                subResult = new DeleteResult();\n<line92>                                break;\n<line93>                            case OpCode.setData:\n<line94>                                subResult = new SetDataResult(subTxnResult.stat);\n<line95>                                break;\n<line96>                            case OpCode.error:\n<line97>                                subResult = new ErrorResult(subTxnResult.err);\n<line98>                                if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {\n<line99>                                    throw new SessionMovedException();\n<line100>                                }\n<line101>                                break;\n<line102>                            default:\n<line103>                                throw new IOException(\"Invalid type of op\");\n<line104>                        }\n<line105>                        ((MultiResponse) rsp).add(subResult);\n<line106>                    }\n<line107>                    break;\n<line108>                }\n<line109>            case OpCode.multiRead:\n<line110>                {\n<line111>                    lastOp = \"MLTR\";\n<line112>                    MultiOperationRecord multiReadRecord = request.readRequestRecord(MultiOperationRecord::new);\n<line113>                    rsp = new MultiResponse();\n<line114>                    OpResult subResult;\n<line115>                    for (Op readOp : multiReadRecord) {\n<line116>                        try {\n<line117>                            Record rec;\n<line118>                            switch(readOp.getType()) {\n<line119>                                case OpCode.getChildren:\n<line120>                                    rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line121>                                    subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());\n<line122>                                    break;\n<line123>                                case OpCode.getData:\n<line124>                                    rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line125>                                    GetDataResponse gdr = (GetDataResponse) rec;\n<line126>                                    subResult = new GetDataResult(gdr.getData(), gdr.getStat());\n<line127>                                    break;\n<line128>                                default:\n<line129>                                    throw new IOException(\"Invalid type of readOp\");\n<line130>                            }\n<line131>                        } catch (KeeperException e) {\n<line132>                            subResult = new ErrorResult(e.code().intValue());\n<line133>                        }\n<line134>                        ((MultiResponse) rsp).add(subResult);\n<line135>                    }\n<line136>                    break;\n<line137>                }\n<line138>            case OpCode.create:\n<line139>                {\n<line140>                    lastOp = \"CREA\";\n<line141>                    rsp = new CreateResponse(rc.path);\n<line142>                    err = Code.get(rc.err);\n<line143>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line144>                    break;\n<line145>                }\n<line146>            case OpCode.create2:\n<line147>            case OpCode.createTTL:\n<line148>            case OpCode.createContainer:\n<line149>                {\n<line150>                    lastOp = \"CREA\";\n<line151>                    rsp = new Create2Response(rc.path, rc.stat);\n<line152>                    err = Code.get(rc.err);\n<line153>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line154>                    break;\n<line155>                }\n<line156>            case OpCode.delete:\n<line157>            case OpCode.deleteContainer:\n<line158>                {\n<line159>                    lastOp = \"DELE\";\n<line160>                    err = Code.get(rc.err);\n<line161>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line162>                    break;\n<line163>                }\n<line164>            case OpCode.setData:\n<line165>                {\n<line166>                    lastOp = \"SETD\";\n<line167>                    rsp = new SetDataResponse(rc.stat);\n<line168>                    err = Code.get(rc.err);\n<line169>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line170>                    break;\n<line171>                }\n<line172>            case OpCode.reconfig:\n<line173>                {\n<line174>                    lastOp = \"RECO\";\n<line175>                    rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(UTF_8), rc.stat);\n<line176>                    err = Code.get(rc.err);\n<line177>                    break;\n<line178>                }\n<line179>            case OpCode.setACL:\n<line180>                {\n<line181>                    lastOp = \"SETA\";\n<line182>                    rsp = new SetACLResponse(rc.stat);\n<line183>                    err = Code.get(rc.err);\n<line184>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line185>                    break;\n<line186>                }\n<line187>            case OpCode.closeSession:\n<line188>                {\n<line189>                    lastOp = \"CLOS\";\n<line190>                    err = Code.get(rc.err);\n<line191>                    break;\n<line192>                }\n<line193>            case OpCode.sync:\n<line194>                {\n<line195>                    lastOp = \"SYNC\";\n<line196>                    SyncRequest syncRequest = request.readRequestRecord(SyncRequest::new);\n<line197>                    rsp = new SyncResponse(syncRequest.getPath());\n<line198>                    requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());\n<line199>                    break;\n<line200>                }\n<line201>            case OpCode.check:\n<line202>                {\n<line203>                    lastOp = \"CHEC\";\n<line204>                    rsp = new SetDataResponse(rc.stat);\n<line205>                    err = Code.get(rc.err);\n<line206>                    break;\n<line207>                }\n<line208>            case OpCode.exists:\n<line209>                {\n<line210>                    lastOp = \"EXIS\";\n<line211>                    ExistsRequest existsRequest = request.readRequestRecord(ExistsRequest::new);\n<line212>                    path = existsRequest.getPath();\n<line213>                    if (path.indexOf('\\0') != -1) {\n<line214>                        throw new KeeperException.BadArgumentsException();\n<line215>                    }\n<line216>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line217>                    if (n != null) {\n<line218>                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line219>                    }\n<line220>                    Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);\n<line221>                    rsp = new ExistsResponse(stat);\n<line222>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line223>                    break;\n<line224>                }\n<line225>            case OpCode.getData:\n<line226>                {\n<line227>                    lastOp = \"GETD\";\n<line228>                    GetDataRequest getDataRequest = request.readRequestRecord(GetDataRequest::new);\n<line229>                    path = getDataRequest.getPath();\n<line230>                    rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);\n<line231>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line232>                    break;\n<line233>                }\n<line234>            case OpCode.setWatches:\n<line235>                {\n<line236>                    lastOp = \"SETW\";\n<line237>                    SetWatches setWatches = request.readRequestRecord(SetWatches::new);\n<line238>                    long relativeZxid = setWatches.getRelativeZxid();\n<line239>                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), Collections.emptyList(), Collections.emptyList(), cnxn);\n<line240>                    break;\n<line241>                }\n<line242>            case OpCode.setWatches2:\n<line243>                {\n<line244>                    lastOp = \"STW2\";\n<line245>                    SetWatches2 setWatches = request.readRequestRecord(SetWatches2::new);\n<line246>                    long relativeZxid = setWatches.getRelativeZxid();\n<line247>                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), setWatches.getPersistentWatches(), setWatches.getPersistentRecursiveWatches(), cnxn);\n<line248>                    break;\n<line249>                }\n<line250>            case OpCode.addWatch:\n<line251>                {\n<line252>                    lastOp = \"ADDW\";\n<line253>                    AddWatchRequest addWatcherRequest = request.readRequestRecord(AddWatchRequest::new);\n<line254>                    zks.getZKDatabase().addWatch(addWatcherRequest.getPath(), cnxn, addWatcherRequest.getMode());\n<line255>                    rsp = new ErrorResponse(0);\n<line256>                    break;\n<line257>                }\n<line258>            case OpCode.getACL:\n<line259>                {\n<line260>                    lastOp = \"GETA\";\n<line261>                    GetACLRequest getACLRequest = request.readRequestRecord(GetACLRequest::new);\n<line262>                    path = getACLRequest.getPath();\n<line263>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line264>                    if (n == null) {\n<line265>                        throw new KeeperException.NoNodeException();\n<line266>                    }\n<line267>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line268>                    Stat stat = new Stat();\n<line269>                    List<ACL> acl = zks.getZKDatabase().getACL(path, stat);\n<line270>                    requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());\n<line271>                    try {\n<line272>                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line273>                        rsp = new GetACLResponse(acl, stat);\n<line274>                    } catch (KeeperException.NoAuthException e) {\n<line275>                        List<ACL> acl1 = new ArrayList<>(acl.size());\n<line276>                        for (ACL a : acl) {\n<line277>                            if (\"digest\".equals(a.getId().getScheme())) {\n<line278>                                Id id = a.getId();\n<line279>                                Id id1 = new Id(id.getScheme(), id.getId().replaceAll(\":.*\", \":x\"));\n<line280>                                acl1.add(new ACL(a.getPerms(), id1));\n<line281>                            } else {\n<line282>                                acl1.add(a);\n<line283>                            }\n<line284>                        }\n<line285>                        rsp = new GetACLResponse(acl1, stat);\n<line286>                    }\n<line287>                    break;\n<line288>                }\n<line289>            case OpCode.getChildren:\n<line290>                {\n<line291>                    lastOp = \"GETC\";\n<line292>                    GetChildrenRequest getChildrenRequest = request.readRequestRecord(GetChildrenRequest::new);\n<line293>                    path = getChildrenRequest.getPath();\n<line294>                    rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);\n<line295>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line296>                    break;\n<line297>                }\n<line298>            case OpCode.getAllChildrenNumber:\n<line299>                {\n<line300>                    lastOp = \"GETACN\";\n<line301>                    GetAllChildrenNumberRequest getAllChildrenNumberRequest = request.readRequestRecord(GetAllChildrenNumberRequest::new);\n<line302>                    path = getAllChildrenNumberRequest.getPath();\n<line303>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line304>                    if (n == null) {\n<line305>                        throw new KeeperException.NoNodeException();\n<line306>                    }\n<line307>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line308>                    int number = zks.getZKDatabase().getAllChildrenNumber(path);\n<line309>                    rsp = new GetAllChildrenNumberResponse(number);\n<line310>                    break;\n<line311>                }\n<line312>            case OpCode.getChildren2:\n<line313>                {\n<line314>                    lastOp = \"GETC\";\n<line315>                    GetChildren2Request getChildren2Request = request.readRequestRecord(GetChildren2Request::new);\n<line316>                    Stat stat = new Stat();\n<line317>                    path = getChildren2Request.getPath();\n<line318>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line319>                    if (n == null) {\n<line320>                        throw new KeeperException.NoNodeException();\n<line321>                    }\n<line322>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line323>                    List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);\n<line324>                    rsp = new GetChildren2Response(children, stat);\n<line325>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line326>                    break;\n<line327>                }\n<line328>            case OpCode.checkWatches:\n<line329>                {\n<line330>                    lastOp = \"CHKW\";\n<line331>                    CheckWatchesRequest checkWatches = request.readRequestRecord(CheckWatchesRequest::new);\n<line332>                    WatcherType type = WatcherType.fromInt(checkWatches.getType());\n<line333>                    path = checkWatches.getPath();\n<line334>                    boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);\n<line335>                    if (!containsWatcher) {\n<line336>                        String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line337>                        throw new KeeperException.NoWatcherException(msg);\n<line338>                    }\n<line339>                    requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());\n<line340>                    break;\n<line341>                }\n<line342>            case OpCode.removeWatches:\n<line343>                {\n<line344>                    lastOp = \"REMW\";\n<line345>                    RemoveWatchesRequest removeWatches = request.readRequestRecord(RemoveWatchesRequest::new);\n<line346>                    WatcherType type = WatcherType.fromInt(removeWatches.getType());\n<line347>                    path = removeWatches.getPath();\n<line348>                    boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);\n<line349>                    if (!removed) {\n<line350>                        String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line351>                        throw new KeeperException.NoWatcherException(msg);\n<line352>                    }\n<line353>                    requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());\n<line354>                    break;\n<line355>                }\n<line356>            case OpCode.whoAmI:\n<line357>                {\n<line358>                    lastOp = \"HOMI\";\n<line359>                    rsp = new WhoAmIResponse(AuthUtil.getClientInfos(request.authInfo));\n<line360>                    break;\n<line361>                }\n<line362>            case OpCode.getEphemerals:\n<line363>                {\n<line364>                    lastOp = \"GETE\";\n<line365>                    GetEphemeralsRequest getEphemerals = request.readRequestRecord(GetEphemeralsRequest::new);\n<line366>                    String prefixPath = getEphemerals.getPrefixPath();\n<line367>                    Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);\n<line368>                    List<String> ephemerals = new ArrayList<>();\n<line369>                    if (prefixPath == null || prefixPath.trim().isEmpty() || \"/\".equals(prefixPath.trim())) {\n<line370>                        ephemerals.addAll(allEphems);\n<line371>                    } else {\n<line372>                        for (String p : allEphems) {\n<line373>                            if (p.startsWith(prefixPath)) {\n<line374>                                ephemerals.add(p);\n<line375>                            }\n<line376>                        }\n<line377>                    }\n<line378>                    rsp = new GetEphemeralsResponse(ephemerals);\n<line379>                    break;\n<line380>                }\n<line381>        }\n<line382>    } catch (SessionMovedException e) {\n<line383>        // session moved is a connection level error, we need to tear\n<line384>        // down the connection otw ZOOKEEPER-710 might happen\n<line385>        // ie client on slow follower starts to renew session, fails\n<line386>        // before this completes, then tries the fast follower (leader)\n<line387>        // and is successful, however the initial renew is then\n<line388>        // successfully fwd/processed by the leader and as a result\n<line389>        // the client and leader disagree on where the client is most\n<line390>        // recently attached (and therefore invalid SESSION MOVED generated)\n<line391>        cnxn.sendCloseSession();\n<line392>        return;\n<line393>    } catch (KeeperException e) {\n<line394>        err = e.code();\n<line395>    } catch (Exception e) {\n<line396>        // log at error level as we are returning a marshalling\n<line397>        // error to the user\n<line398>        String digest = request.requestDigest();\n<line399>        err = Code.MARSHALLINGERROR;\n<line400>    }\n<line401>    ReplyHeader hdr = new ReplyHeader(request.cxid, lastZxid, err.intValue());\n<line402>    updateStats(request, lastOp, lastZxid);\n<line403>    try {\n<line404>        if (path == null || rsp == null) {\n<line405>            responseSize = cnxn.sendResponse(hdr, rsp, \"response\");\n<line406>        } else {\n<line407>            int opCode = request.type;\n<line408>            Stat stat = null;\n<line409>            // Serialized read and get children responses could be cached by the connection\n<line410>            // object. Cache entries are identified by their path and last modified zxid,\n<line411>            // so these values are passed along with the response.\n<line412>            switch(opCode) {\n<line413>                case OpCode.getData:\n<line414>                    {\n<line415>                        GetDataResponse getDataResponse = (GetDataResponse) rsp;\n<line416>                        stat = getDataResponse.getStat();\n<line417>                        responseSize = cnxn.sendResponse(hdr, rsp, \"response\", path, stat, opCode);\n<line418>                        break;\n<line419>                    }\n<line420>                case OpCode.getChildren2:\n<line421>                    {\n<line422>                        GetChildren2Response getChildren2Response = (GetChildren2Response) rsp;\n<line423>                        stat = getChildren2Response.getStat();\n<line424>                        responseSize = cnxn.sendResponse(hdr, rsp, \"response\", path, stat, opCode);\n<line425>                        break;\n<line426>                    }\n<line427>                default:\n<line428>                    responseSize = cnxn.sendResponse(hdr, rsp, \"response\");\n<line429>            }\n<line430>        }\n<line431>        if (request.type == OpCode.closeSession) {\n<line432>            cnxn.sendCloseSession();\n<line433>        }\n<line434>    } catch (IOException e) {\n<line435>    } finally {\n<line436>        ServerMetrics.getMetrics().RESPONSE_BYTES.add(responseSize);\n<line437>    }\n<line438>}","output":"<line1>{\n<line2>    LOG.debug(\"Processing request:: {}\", request);\n<line3>    if (LOG.isTraceEnabled()) {\n<line4>        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n<line5>        if (request.type == OpCode.ping) {\n<line6>            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n<line7>        }\n<line8>        ZooTrace.logRequest(LOG, traceMask, 'E', request, \"\");\n<line9>    }\n<line10>    ProcessTxnResult rc = null;\n<line11>    if (!request.isThrottled()) {\n<line12>        rc = applyRequest(request);\n<line13>    }\n<line14>    if (request.cnxn == null) {\n<line15>        return;\n<line16>    }\n<line17>    ServerCnxn cnxn = request.cnxn;\n<line18>    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n<line19>    String lastOp = \"NA\";\n<line20>    // Notify ZooKeeperServer that the request has finished so that it can\n<line21>    // update any request accounting/throttling limits\n<line22>    zks.decInProcess();\n<line23>    zks.requestFinished(request);\n<line24>    Code err = Code.OK;\n<line25>    Record rsp = null;\n<line26>    String path = null;\n<line27>    int responseSize = 0;\n<line28>    try {\n<line29>        if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n<line30>            AuditHelper.addAuditLog(request, rc, true);\n<line31>            /*\n<line32>                 * When local session upgrading is disabled, leader will\n<line33>                 * reject the ephemeral node creation due to session expire.\n<line34>                 * However, if this is the follower that issue the request,\n<line35>                 * it will have the correct error code, so we should use that\n<line36>                 * and report to user\n<line37>                 */\n<line38>            if (request.getException() != null) {\n<line39>                throw request.getException();\n<line40>            } else {\n<line41>                throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));\n<line42>            }\n<line43>        }\n<line44>        KeeperException ke = request.getException();\n<line45>        if (ke instanceof SessionMovedException) {\n<line46>            throw ke;\n<line47>        }\n<line48>        if (ke != null && request.type != OpCode.multi) {\n<line49>            throw ke;\n<line50>        }\n<line51>        LOG.debug(\"{}\", request);\n<line52>        if (request.isStale()) {\n<line53>            ServerMetrics.getMetrics().STALE_REPLIES.add(1);\n<line54>        }\n<line55>        if (request.isThrottled()) {\n<line56>            throw KeeperException.create(Code.THROTTLEDOP);\n<line57>        }\n<line58>        AuditHelper.addAuditLog(request, rc);\n<line59>        switch(request.type) {\n<line60>            case OpCode.ping:\n<line61>                {\n<line62>                    lastOp = \"PING\";\n<line63>                    updateStats(request, lastOp, lastZxid);\n<line64>                    responseSize = cnxn.sendResponse(new ReplyHeader(ClientCnxn.PING_XID, lastZxid, 0), null, \"response\");\n<line65>                    return;\n<line66>                }\n<line67>            case OpCode.createSession:\n<line68>                {\n<line69>                    lastOp = \"SESS\";\n<line70>                    updateStats(request, lastOp, lastZxid);\n<line71>                    zks.finishSessionInit(request.cnxn, true);\n<line72>                    return;\n<line73>                }\n<line74>            case OpCode.multi:\n<line75>                {\n<line76>                    lastOp = \"MULT\";\n<line77>                    rsp = new MultiResponse();\n<line78>                    for (ProcessTxnResult subTxnResult : rc.multiResult) {\n<line79>                        OpResult subResult;\n<line80>                        switch(subTxnResult.type) {\n<line81>                            case OpCode.check:\n<line82>                                subResult = new CheckResult();\n<line83>                                break;\n<line84>                            case OpCode.create:\n<line85>                                subResult = new CreateResult(subTxnResult.path);\n<line86>                                break;\n<line87>                            case OpCode.create2:\n<line88>                            case OpCode.createTTL:\n<line89>                            case OpCode.createContainer:\n<line90>                                subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n<line91>                                break;\n<line92>                            case OpCode.delete:\n<line93>                            case OpCode.deleteContainer:\n<line94>                                subResult = new DeleteResult();\n<line95>                                break;\n<line96>                            case OpCode.setData:\n<line97>                                subResult = new SetDataResult(subTxnResult.stat);\n<line98>                                break;\n<line99>                            case OpCode.error:\n<line100>                                subResult = new ErrorResult(subTxnResult.err);\n<line101>                                if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {\n<line102>                                    throw new SessionMovedException();\n<line103>                                }\n<line104>                                break;\n<line105>                            default:\n<line106>                                throw new IOException(\"Invalid type of op\");\n<line107>                        }\n<line108>                        ((MultiResponse) rsp).add(subResult);\n<line109>                    }\n<line110>                    break;\n<line111>                }\n<line112>            case OpCode.multiRead:\n<line113>                {\n<line114>                    lastOp = \"MLTR\";\n<line115>                    MultiOperationRecord multiReadRecord = request.readRequestRecord(MultiOperationRecord::new);\n<line116>                    rsp = new MultiResponse();\n<line117>                    OpResult subResult;\n<line118>                    for (Op readOp : multiReadRecord) {\n<line119>                        try {\n<line120>                            Record rec;\n<line121>                            switch(readOp.getType()) {\n<line122>                                case OpCode.getChildren:\n<line123>                                    rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line124>                                    subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());\n<line125>                                    break;\n<line126>                                case OpCode.getData:\n<line127>                                    rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line128>                                    GetDataResponse gdr = (GetDataResponse) rec;\n<line129>                                    subResult = new GetDataResult(gdr.getData(), gdr.getStat());\n<line130>                                    break;\n<line131>                                default:\n<line132>                                    throw new IOException(\"Invalid type of readOp\");\n<line133>                            }\n<line134>                        } catch (KeeperException e) {\n<line135>                            subResult = new ErrorResult(e.code().intValue());\n<line136>                        }\n<line137>                        ((MultiResponse) rsp).add(subResult);\n<line138>                    }\n<line139>                    break;\n<line140>                }\n<line141>            case OpCode.create:\n<line142>                {\n<line143>                    lastOp = \"CREA\";\n<line144>                    rsp = new CreateResponse(rc.path);\n<line145>                    err = Code.get(rc.err);\n<line146>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line147>                    break;\n<line148>                }\n<line149>            case OpCode.create2:\n<line150>            case OpCode.createTTL:\n<line151>            case OpCode.createContainer:\n<line152>                {\n<line153>                    lastOp = \"CREA\";\n<line154>                    rsp = new Create2Response(rc.path, rc.stat);\n<line155>                    err = Code.get(rc.err);\n<line156>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line157>                    break;\n<line158>                }\n<line159>            case OpCode.delete:\n<line160>            case OpCode.deleteContainer:\n<line161>                {\n<line162>                    lastOp = \"DELE\";\n<line163>                    err = Code.get(rc.err);\n<line164>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line165>                    break;\n<line166>                }\n<line167>            case OpCode.setData:\n<line168>                {\n<line169>                    lastOp = \"SETD\";\n<line170>                    rsp = new SetDataResponse(rc.stat);\n<line171>                    err = Code.get(rc.err);\n<line172>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line173>                    break;\n<line174>                }\n<line175>            case OpCode.reconfig:\n<line176>                {\n<line177>                    lastOp = \"RECO\";\n<line178>                    rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(UTF_8), rc.stat);\n<line179>                    err = Code.get(rc.err);\n<line180>                    break;\n<line181>                }\n<line182>            case OpCode.setACL:\n<line183>                {\n<line184>                    lastOp = \"SETA\";\n<line185>                    rsp = new SetACLResponse(rc.stat);\n<line186>                    err = Code.get(rc.err);\n<line187>                    requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line188>                    break;\n<line189>                }\n<line190>            case OpCode.closeSession:\n<line191>                {\n<line192>                    lastOp = \"CLOS\";\n<line193>                    err = Code.get(rc.err);\n<line194>                    break;\n<line195>                }\n<line196>            case OpCode.sync:\n<line197>                {\n<line198>                    lastOp = \"SYNC\";\n<line199>                    SyncRequest syncRequest = request.readRequestRecord(SyncRequest::new);\n<line200>                    rsp = new SyncResponse(syncRequest.getPath());\n<line201>                    requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());\n<line202>                    break;\n<line203>                }\n<line204>            case OpCode.check:\n<line205>                {\n<line206>                    lastOp = \"CHEC\";\n<line207>                    rsp = new SetDataResponse(rc.stat);\n<line208>                    err = Code.get(rc.err);\n<line209>                    break;\n<line210>                }\n<line211>            case OpCode.exists:\n<line212>                {\n<line213>                    lastOp = \"EXIS\";\n<line214>                    ExistsRequest existsRequest = request.readRequestRecord(ExistsRequest::new);\n<line215>                    path = existsRequest.getPath();\n<line216>                    if (path.indexOf('\\0') != -1) {\n<line217>                        throw new KeeperException.BadArgumentsException();\n<line218>                    }\n<line219>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line220>                    if (n != null) {\n<line221>                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line222>                    }\n<line223>                    Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);\n<line224>                    rsp = new ExistsResponse(stat);\n<line225>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line226>                    break;\n<line227>                }\n<line228>            case OpCode.getData:\n<line229>                {\n<line230>                    lastOp = \"GETD\";\n<line231>                    GetDataRequest getDataRequest = request.readRequestRecord(GetDataRequest::new);\n<line232>                    path = getDataRequest.getPath();\n<line233>                    rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);\n<line234>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line235>                    break;\n<line236>                }\n<line237>            case OpCode.setWatches:\n<line238>                {\n<line239>                    lastOp = \"SETW\";\n<line240>                    SetWatches setWatches = request.readRequestRecord(SetWatches::new);\n<line241>                    long relativeZxid = setWatches.getRelativeZxid();\n<line242>                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), Collections.emptyList(), Collections.emptyList(), cnxn);\n<line243>                    break;\n<line244>                }\n<line245>            case OpCode.setWatches2:\n<line246>                {\n<line247>                    lastOp = \"STW2\";\n<line248>                    SetWatches2 setWatches = request.readRequestRecord(SetWatches2::new);\n<line249>                    long relativeZxid = setWatches.getRelativeZxid();\n<line250>                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), setWatches.getPersistentWatches(), setWatches.getPersistentRecursiveWatches(), cnxn);\n<line251>                    break;\n<line252>                }\n<line253>            case OpCode.addWatch:\n<line254>                {\n<line255>                    lastOp = \"ADDW\";\n<line256>                    AddWatchRequest addWatcherRequest = request.readRequestRecord(AddWatchRequest::new);\n<line257>                    zks.getZKDatabase().addWatch(addWatcherRequest.getPath(), cnxn, addWatcherRequest.getMode());\n<line258>                    rsp = new ErrorResponse(0);\n<line259>                    break;\n<line260>                }\n<line261>            case OpCode.getACL:\n<line262>                {\n<line263>                    lastOp = \"GETA\";\n<line264>                    GetACLRequest getACLRequest = request.readRequestRecord(GetACLRequest::new);\n<line265>                    path = getACLRequest.getPath();\n<line266>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line267>                    if (n == null) {\n<line268>                        throw new KeeperException.NoNodeException();\n<line269>                    }\n<line270>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line271>                    Stat stat = new Stat();\n<line272>                    List<ACL> acl = zks.getZKDatabase().getACL(path, stat);\n<line273>                    requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());\n<line274>                    try {\n<line275>                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line276>                        rsp = new GetACLResponse(acl, stat);\n<line277>                    } catch (KeeperException.NoAuthException e) {\n<line278>                        List<ACL> acl1 = new ArrayList<>(acl.size());\n<line279>                        for (ACL a : acl) {\n<line280>                            if (\"digest\".equals(a.getId().getScheme())) {\n<line281>                                Id id = a.getId();\n<line282>                                Id id1 = new Id(id.getScheme(), id.getId().replaceAll(\":.*\", \":x\"));\n<line283>                                acl1.add(new ACL(a.getPerms(), id1));\n<line284>                            } else {\n<line285>                                acl1.add(a);\n<line286>                            }\n<line287>                        }\n<line288>                        rsp = new GetACLResponse(acl1, stat);\n<line289>                    }\n<line290>                    break;\n<line291>                }\n<line292>            case OpCode.getChildren:\n<line293>                {\n<line294>                    lastOp = \"GETC\";\n<line295>                    GetChildrenRequest getChildrenRequest = request.readRequestRecord(GetChildrenRequest::new);\n<line296>                    path = getChildrenRequest.getPath();\n<line297>                    rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);\n<line298>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line299>                    break;\n<line300>                }\n<line301>            case OpCode.getAllChildrenNumber:\n<line302>                {\n<line303>                    lastOp = \"GETACN\";\n<line304>                    GetAllChildrenNumberRequest getAllChildrenNumberRequest = request.readRequestRecord(GetAllChildrenNumberRequest::new);\n<line305>                    path = getAllChildrenNumberRequest.getPath();\n<line306>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line307>                    if (n == null) {\n<line308>                        throw new KeeperException.NoNodeException();\n<line309>                    }\n<line310>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line311>                    int number = zks.getZKDatabase().getAllChildrenNumber(path);\n<line312>                    rsp = new GetAllChildrenNumberResponse(number);\n<line313>                    break;\n<line314>                }\n<line315>            case OpCode.getChildren2:\n<line316>                {\n<line317>                    lastOp = \"GETC\";\n<line318>                    GetChildren2Request getChildren2Request = request.readRequestRecord(GetChildren2Request::new);\n<line319>                    Stat stat = new Stat();\n<line320>                    path = getChildren2Request.getPath();\n<line321>                    DataNode n = zks.getZKDatabase().getNode(path);\n<line322>                    if (n == null) {\n<line323>                        throw new KeeperException.NoNodeException();\n<line324>                    }\n<line325>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line326>                    List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);\n<line327>                    rsp = new GetChildren2Response(children, stat);\n<line328>                    requestPathMetricsCollector.registerRequest(request.type, path);\n<line329>                    break;\n<line330>                }\n<line331>            case OpCode.checkWatches:\n<line332>                {\n<line333>                    lastOp = \"CHKW\";\n<line334>                    CheckWatchesRequest checkWatches = request.readRequestRecord(CheckWatchesRequest::new);\n<line335>                    WatcherType type = WatcherType.fromInt(checkWatches.getType());\n<line336>                    path = checkWatches.getPath();\n<line337>                    boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);\n<line338>                    if (!containsWatcher) {\n<line339>                        String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line340>                        throw new KeeperException.NoWatcherException(msg);\n<line341>                    }\n<line342>                    requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());\n<line343>                    break;\n<line344>                }\n<line345>            case OpCode.removeWatches:\n<line346>                {\n<line347>                    lastOp = \"REMW\";\n<line348>                    RemoveWatchesRequest removeWatches = request.readRequestRecord(RemoveWatchesRequest::new);\n<line349>                    WatcherType type = WatcherType.fromInt(removeWatches.getType());\n<line350>                    path = removeWatches.getPath();\n<line351>                    boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);\n<line352>                    if (!removed) {\n<line353>                        String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line354>                        throw new KeeperException.NoWatcherException(msg);\n<line355>                    }\n<line356>                    requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());\n<line357>                    break;\n<line358>                }\n<line359>            case OpCode.whoAmI:\n<line360>                {\n<line361>                    lastOp = \"HOMI\";\n<line362>                    rsp = new WhoAmIResponse(AuthUtil.getClientInfos(request.authInfo));\n<line363>                    break;\n<line364>                }\n<line365>            case OpCode.getEphemerals:\n<line366>                {\n<line367>                    lastOp = \"GETE\";\n<line368>                    GetEphemeralsRequest getEphemerals = request.readRequestRecord(GetEphemeralsRequest::new);\n<line369>                    String prefixPath = getEphemerals.getPrefixPath();\n<line370>                    Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);\n<line371>                    List<String> ephemerals = new ArrayList<>();\n<line372>                    if (prefixPath == null || prefixPath.trim().isEmpty() || \"/\".equals(prefixPath.trim())) {\n<line373>                        ephemerals.addAll(allEphems);\n<line374>                    } else {\n<line375>                        for (String p : allEphems) {\n<line376>                            if (p.startsWith(prefixPath)) {\n<line377>                                ephemerals.add(p);\n<line378>                            }\n<line379>                        }\n<line380>                    }\n<line381>                    rsp = new GetEphemeralsResponse(ephemerals);\n<line382>                    break;\n<line383>                }\n<line384>        }\n<line385>    } catch (SessionMovedException e) {\n<line386>        // session moved is a connection level error, we need to tear\n<line387>        // down the connection otw ZOOKEEPER-710 might happen\n<line388>        // ie client on slow follower starts to renew session, fails\n<line389>        // before this completes, then tries the fast follower (leader)\n<line390>        // and is successful, however the initial renew is then\n<line391>        // successfully fwd/processed by the leader and as a result\n<line392>        // the client and leader disagree on where the client is most\n<line393>        // recently attached (and therefore invalid SESSION MOVED generated)\n<line394>        cnxn.sendCloseSession();\n<line395>        return;\n<line396>    } catch (KeeperException e) {\n<line397>        err = e.code();\n<line398>    } catch (Exception e) {\n<line399>        // log at error level as we are returning a marshalling\n<line400>        // error to the user\n<line401>        LOG.error(\"Failed to process {}\", request, e);\n<line402>        String digest = request.requestDigest();\n<line403>        LOG.error(\"Dumping request buffer for request type {}: 0x{}\", Request.op2String(request.type), digest);\n<line404>        err = Code.MARSHALLINGERROR;\n<line405>    }\n<line406>    ReplyHeader hdr = new ReplyHeader(request.cxid, lastZxid, err.intValue());\n<line407>    updateStats(request, lastOp, lastZxid);\n<line408>    try {\n<line409>        if (path == null || rsp == null) {\n<line410>            responseSize = cnxn.sendResponse(hdr, rsp, \"response\");\n<line411>        } else {\n<line412>            int opCode = request.type;\n<line413>            Stat stat = null;\n<line414>            // Serialized read and get children responses could be cached by the connection\n<line415>            // object. Cache entries are identified by their path and last modified zxid,\n<line416>            // so these values are passed along with the response.\n<line417>            switch(opCode) {\n<line418>                case OpCode.getData:\n<line419>                    {\n<line420>                        GetDataResponse getDataResponse = (GetDataResponse) rsp;\n<line421>                        stat = getDataResponse.getStat();\n<line422>                        responseSize = cnxn.sendResponse(hdr, rsp, \"response\", path, stat, opCode);\n<line423>                        break;\n<line424>                    }\n<line425>                case OpCode.getChildren2:\n<line426>                    {\n<line427>                        GetChildren2Response getChildren2Response = (GetChildren2Response) rsp;\n<line428>                        stat = getChildren2Response.getStat();\n<line429>                        responseSize = cnxn.sendResponse(hdr, rsp, \"response\", path, stat, opCode);\n<line430>                        break;\n<line431>                    }\n<line432>                default:\n<line433>                    responseSize = cnxn.sendResponse(hdr, rsp, \"response\");\n<line434>            }\n<line435>        }\n<line436>        if (request.type == OpCode.closeSession) {\n<line437>            cnxn.sendCloseSession();\n<line438>        }\n<line439>    } catch (IOException e) {\n<line440>        LOG.error(\"FIXMSG\", e);\n<line441>    } finally {\n<line442>        ServerMetrics.getMetrics().RESPONSE_BYTES.add(responseSize);\n<line443>    }\n<line444>}"},{"input":"","instruction":"<line1>{\n<line2>    if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n<line3>        AuditHelper.addAuditLog(request, rc, true);\n<line4>        /*\n<line5>                 * When local session upgrading is disabled, leader will\n<line6>                 * reject the ephemeral node creation due to session expire.\n<line7>                 * However, if this is the follower that issue the request,\n<line8>                 * it will have the correct error code, so we should use that\n<line9>                 * and report to user\n<line10>                 */\n<line11>        if (request.getException() != null) {\n<line12>            throw request.getException();\n<line13>        } else {\n<line14>            throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));\n<line15>        }\n<line16>    }\n<line17>    KeeperException ke = request.getException();\n<line18>    if (ke instanceof SessionMovedException) {\n<line19>        throw ke;\n<line20>    }\n<line21>    if (ke != null && request.type != OpCode.multi) {\n<line22>        throw ke;\n<line23>    }\n<line24>    if (request.isStale()) {\n<line25>        ServerMetrics.getMetrics().STALE_REPLIES.add(1);\n<line26>    }\n<line27>    if (request.isThrottled()) {\n<line28>        throw KeeperException.create(Code.THROTTLEDOP);\n<line29>    }\n<line30>    AuditHelper.addAuditLog(request, rc);\n<line31>    switch(request.type) {\n<line32>        case OpCode.ping:\n<line33>            {\n<line34>                lastOp = \"PING\";\n<line35>                updateStats(request, lastOp, lastZxid);\n<line36>                responseSize = cnxn.sendResponse(new ReplyHeader(ClientCnxn.PING_XID, lastZxid, 0), null, \"response\");\n<line37>                return;\n<line38>            }\n<line39>        case OpCode.createSession:\n<line40>            {\n<line41>                lastOp = \"SESS\";\n<line42>                updateStats(request, lastOp, lastZxid);\n<line43>                zks.finishSessionInit(request.cnxn, true);\n<line44>                return;\n<line45>            }\n<line46>        case OpCode.multi:\n<line47>            {\n<line48>                lastOp = \"MULT\";\n<line49>                rsp = new MultiResponse();\n<line50>                for (ProcessTxnResult subTxnResult : rc.multiResult) {\n<line51>                    OpResult subResult;\n<line52>                    switch(subTxnResult.type) {\n<line53>                        case OpCode.check:\n<line54>                            subResult = new CheckResult();\n<line55>                            break;\n<line56>                        case OpCode.create:\n<line57>                            subResult = new CreateResult(subTxnResult.path);\n<line58>                            break;\n<line59>                        case OpCode.create2:\n<line60>                        case OpCode.createTTL:\n<line61>                        case OpCode.createContainer:\n<line62>                            subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n<line63>                            break;\n<line64>                        case OpCode.delete:\n<line65>                        case OpCode.deleteContainer:\n<line66>                            subResult = new DeleteResult();\n<line67>                            break;\n<line68>                        case OpCode.setData:\n<line69>                            subResult = new SetDataResult(subTxnResult.stat);\n<line70>                            break;\n<line71>                        case OpCode.error:\n<line72>                            subResult = new ErrorResult(subTxnResult.err);\n<line73>                            if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {\n<line74>                                throw new SessionMovedException();\n<line75>                            }\n<line76>                            break;\n<line77>                        default:\n<line78>                            throw new IOException(\"Invalid type of op\");\n<line79>                    }\n<line80>                    ((MultiResponse) rsp).add(subResult);\n<line81>                }\n<line82>                break;\n<line83>            }\n<line84>        case OpCode.multiRead:\n<line85>            {\n<line86>                lastOp = \"MLTR\";\n<line87>                MultiOperationRecord multiReadRecord = request.readRequestRecord(MultiOperationRecord::new);\n<line88>                rsp = new MultiResponse();\n<line89>                OpResult subResult;\n<line90>                for (Op readOp : multiReadRecord) {\n<line91>                    try {\n<line92>                        Record rec;\n<line93>                        switch(readOp.getType()) {\n<line94>                            case OpCode.getChildren:\n<line95>                                rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line96>                                subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());\n<line97>                                break;\n<line98>                            case OpCode.getData:\n<line99>                                rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line100>                                GetDataResponse gdr = (GetDataResponse) rec;\n<line101>                                subResult = new GetDataResult(gdr.getData(), gdr.getStat());\n<line102>                                break;\n<line103>                            default:\n<line104>                                throw new IOException(\"Invalid type of readOp\");\n<line105>                        }\n<line106>                    } catch (KeeperException e) {\n<line107>                        subResult = new ErrorResult(e.code().intValue());\n<line108>                    }\n<line109>                    ((MultiResponse) rsp).add(subResult);\n<line110>                }\n<line111>                break;\n<line112>            }\n<line113>        case OpCode.create:\n<line114>            {\n<line115>                lastOp = \"CREA\";\n<line116>                rsp = new CreateResponse(rc.path);\n<line117>                err = Code.get(rc.err);\n<line118>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line119>                break;\n<line120>            }\n<line121>        case OpCode.create2:\n<line122>        case OpCode.createTTL:\n<line123>        case OpCode.createContainer:\n<line124>            {\n<line125>                lastOp = \"CREA\";\n<line126>                rsp = new Create2Response(rc.path, rc.stat);\n<line127>                err = Code.get(rc.err);\n<line128>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line129>                break;\n<line130>            }\n<line131>        case OpCode.delete:\n<line132>        case OpCode.deleteContainer:\n<line133>            {\n<line134>                lastOp = \"DELE\";\n<line135>                err = Code.get(rc.err);\n<line136>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line137>                break;\n<line138>            }\n<line139>        case OpCode.setData:\n<line140>            {\n<line141>                lastOp = \"SETD\";\n<line142>                rsp = new SetDataResponse(rc.stat);\n<line143>                err = Code.get(rc.err);\n<line144>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line145>                break;\n<line146>            }\n<line147>        case OpCode.reconfig:\n<line148>            {\n<line149>                lastOp = \"RECO\";\n<line150>                rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(UTF_8), rc.stat);\n<line151>                err = Code.get(rc.err);\n<line152>                break;\n<line153>            }\n<line154>        case OpCode.setACL:\n<line155>            {\n<line156>                lastOp = \"SETA\";\n<line157>                rsp = new SetACLResponse(rc.stat);\n<line158>                err = Code.get(rc.err);\n<line159>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line160>                break;\n<line161>            }\n<line162>        case OpCode.closeSession:\n<line163>            {\n<line164>                lastOp = \"CLOS\";\n<line165>                err = Code.get(rc.err);\n<line166>                break;\n<line167>            }\n<line168>        case OpCode.sync:\n<line169>            {\n<line170>                lastOp = \"SYNC\";\n<line171>                SyncRequest syncRequest = request.readRequestRecord(SyncRequest::new);\n<line172>                rsp = new SyncResponse(syncRequest.getPath());\n<line173>                requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());\n<line174>                break;\n<line175>            }\n<line176>        case OpCode.check:\n<line177>            {\n<line178>                lastOp = \"CHEC\";\n<line179>                rsp = new SetDataResponse(rc.stat);\n<line180>                err = Code.get(rc.err);\n<line181>                break;\n<line182>            }\n<line183>        case OpCode.exists:\n<line184>            {\n<line185>                lastOp = \"EXIS\";\n<line186>                ExistsRequest existsRequest = request.readRequestRecord(ExistsRequest::new);\n<line187>                path = existsRequest.getPath();\n<line188>                if (path.indexOf('\\0') != -1) {\n<line189>                    throw new KeeperException.BadArgumentsException();\n<line190>                }\n<line191>                DataNode n = zks.getZKDatabase().getNode(path);\n<line192>                if (n != null) {\n<line193>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line194>                }\n<line195>                Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);\n<line196>                rsp = new ExistsResponse(stat);\n<line197>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line198>                break;\n<line199>            }\n<line200>        case OpCode.getData:\n<line201>            {\n<line202>                lastOp = \"GETD\";\n<line203>                GetDataRequest getDataRequest = request.readRequestRecord(GetDataRequest::new);\n<line204>                path = getDataRequest.getPath();\n<line205>                rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);\n<line206>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line207>                break;\n<line208>            }\n<line209>        case OpCode.setWatches:\n<line210>            {\n<line211>                lastOp = \"SETW\";\n<line212>                SetWatches setWatches = request.readRequestRecord(SetWatches::new);\n<line213>                long relativeZxid = setWatches.getRelativeZxid();\n<line214>                zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), Collections.emptyList(), Collections.emptyList(), cnxn);\n<line215>                break;\n<line216>            }\n<line217>        case OpCode.setWatches2:\n<line218>            {\n<line219>                lastOp = \"STW2\";\n<line220>                SetWatches2 setWatches = request.readRequestRecord(SetWatches2::new);\n<line221>                long relativeZxid = setWatches.getRelativeZxid();\n<line222>                zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), setWatches.getPersistentWatches(), setWatches.getPersistentRecursiveWatches(), cnxn);\n<line223>                break;\n<line224>            }\n<line225>        case OpCode.addWatch:\n<line226>            {\n<line227>                lastOp = \"ADDW\";\n<line228>                AddWatchRequest addWatcherRequest = request.readRequestRecord(AddWatchRequest::new);\n<line229>                zks.getZKDatabase().addWatch(addWatcherRequest.getPath(), cnxn, addWatcherRequest.getMode());\n<line230>                rsp = new ErrorResponse(0);\n<line231>                break;\n<line232>            }\n<line233>        case OpCode.getACL:\n<line234>            {\n<line235>                lastOp = \"GETA\";\n<line236>                GetACLRequest getACLRequest = request.readRequestRecord(GetACLRequest::new);\n<line237>                path = getACLRequest.getPath();\n<line238>                DataNode n = zks.getZKDatabase().getNode(path);\n<line239>                if (n == null) {\n<line240>                    throw new KeeperException.NoNodeException();\n<line241>                }\n<line242>                zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line243>                Stat stat = new Stat();\n<line244>                List<ACL> acl = zks.getZKDatabase().getACL(path, stat);\n<line245>                requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());\n<line246>                try {\n<line247>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line248>                    rsp = new GetACLResponse(acl, stat);\n<line249>                } catch (KeeperException.NoAuthException e) {\n<line250>                    List<ACL> acl1 = new ArrayList<>(acl.size());\n<line251>                    for (ACL a : acl) {\n<line252>                        if (\"digest\".equals(a.getId().getScheme())) {\n<line253>                            Id id = a.getId();\n<line254>                            Id id1 = new Id(id.getScheme(), id.getId().replaceAll(\":.*\", \":x\"));\n<line255>                            acl1.add(new ACL(a.getPerms(), id1));\n<line256>                        } else {\n<line257>                            acl1.add(a);\n<line258>                        }\n<line259>                    }\n<line260>                    rsp = new GetACLResponse(acl1, stat);\n<line261>                }\n<line262>                break;\n<line263>            }\n<line264>        case OpCode.getChildren:\n<line265>            {\n<line266>                lastOp = \"GETC\";\n<line267>                GetChildrenRequest getChildrenRequest = request.readRequestRecord(GetChildrenRequest::new);\n<line268>                path = getChildrenRequest.getPath();\n<line269>                rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);\n<line270>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line271>                break;\n<line272>            }\n<line273>        case OpCode.getAllChildrenNumber:\n<line274>            {\n<line275>                lastOp = \"GETACN\";\n<line276>                GetAllChildrenNumberRequest getAllChildrenNumberRequest = request.readRequestRecord(GetAllChildrenNumberRequest::new);\n<line277>                path = getAllChildrenNumberRequest.getPath();\n<line278>                DataNode n = zks.getZKDatabase().getNode(path);\n<line279>                if (n == null) {\n<line280>                    throw new KeeperException.NoNodeException();\n<line281>                }\n<line282>                zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line283>                int number = zks.getZKDatabase().getAllChildrenNumber(path);\n<line284>                rsp = new GetAllChildrenNumberResponse(number);\n<line285>                break;\n<line286>            }\n<line287>        case OpCode.getChildren2:\n<line288>            {\n<line289>                lastOp = \"GETC\";\n<line290>                GetChildren2Request getChildren2Request = request.readRequestRecord(GetChildren2Request::new);\n<line291>                Stat stat = new Stat();\n<line292>                path = getChildren2Request.getPath();\n<line293>                DataNode n = zks.getZKDatabase().getNode(path);\n<line294>                if (n == null) {\n<line295>                    throw new KeeperException.NoNodeException();\n<line296>                }\n<line297>                zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line298>                List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);\n<line299>                rsp = new GetChildren2Response(children, stat);\n<line300>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line301>                break;\n<line302>            }\n<line303>        case OpCode.checkWatches:\n<line304>            {\n<line305>                lastOp = \"CHKW\";\n<line306>                CheckWatchesRequest checkWatches = request.readRequestRecord(CheckWatchesRequest::new);\n<line307>                WatcherType type = WatcherType.fromInt(checkWatches.getType());\n<line308>                path = checkWatches.getPath();\n<line309>                boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);\n<line310>                if (!containsWatcher) {\n<line311>                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line312>                    throw new KeeperException.NoWatcherException(msg);\n<line313>                }\n<line314>                requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());\n<line315>                break;\n<line316>            }\n<line317>        case OpCode.removeWatches:\n<line318>            {\n<line319>                lastOp = \"REMW\";\n<line320>                RemoveWatchesRequest removeWatches = request.readRequestRecord(RemoveWatchesRequest::new);\n<line321>                WatcherType type = WatcherType.fromInt(removeWatches.getType());\n<line322>                path = removeWatches.getPath();\n<line323>                boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);\n<line324>                if (!removed) {\n<line325>                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line326>                    throw new KeeperException.NoWatcherException(msg);\n<line327>                }\n<line328>                requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());\n<line329>                break;\n<line330>            }\n<line331>        case OpCode.whoAmI:\n<line332>            {\n<line333>                lastOp = \"HOMI\";\n<line334>                rsp = new WhoAmIResponse(AuthUtil.getClientInfos(request.authInfo));\n<line335>                break;\n<line336>            }\n<line337>        case OpCode.getEphemerals:\n<line338>            {\n<line339>                lastOp = \"GETE\";\n<line340>                GetEphemeralsRequest getEphemerals = request.readRequestRecord(GetEphemeralsRequest::new);\n<line341>                String prefixPath = getEphemerals.getPrefixPath();\n<line342>                Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);\n<line343>                List<String> ephemerals = new ArrayList<>();\n<line344>                if (prefixPath == null || prefixPath.trim().isEmpty() || \"/\".equals(prefixPath.trim())) {\n<line345>                    ephemerals.addAll(allEphems);\n<line346>                } else {\n<line347>                    for (String p : allEphems) {\n<line348>                        if (p.startsWith(prefixPath)) {\n<line349>                            ephemerals.add(p);\n<line350>                        }\n<line351>                    }\n<line352>                }\n<line353>                rsp = new GetEphemeralsResponse(ephemerals);\n<line354>                break;\n<line355>            }\n<line356>    }\n<line357>}","output":"<line1>{\n<line2>    if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n<line3>        AuditHelper.addAuditLog(request, rc, true);\n<line4>        /*\n<line5>                 * When local session upgrading is disabled, leader will\n<line6>                 * reject the ephemeral node creation due to session expire.\n<line7>                 * However, if this is the follower that issue the request,\n<line8>                 * it will have the correct error code, so we should use that\n<line9>                 * and report to user\n<line10>                 */\n<line11>        if (request.getException() != null) {\n<line12>            throw request.getException();\n<line13>        } else {\n<line14>            throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));\n<line15>        }\n<line16>    }\n<line17>    KeeperException ke = request.getException();\n<line18>    if (ke instanceof SessionMovedException) {\n<line19>        throw ke;\n<line20>    }\n<line21>    if (ke != null && request.type != OpCode.multi) {\n<line22>        throw ke;\n<line23>    }\n<line24>    LOG.debug(\"{}\", request);\n<line25>    if (request.isStale()) {\n<line26>        ServerMetrics.getMetrics().STALE_REPLIES.add(1);\n<line27>    }\n<line28>    if (request.isThrottled()) {\n<line29>        throw KeeperException.create(Code.THROTTLEDOP);\n<line30>    }\n<line31>    AuditHelper.addAuditLog(request, rc);\n<line32>    switch(request.type) {\n<line33>        case OpCode.ping:\n<line34>            {\n<line35>                lastOp = \"PING\";\n<line36>                updateStats(request, lastOp, lastZxid);\n<line37>                responseSize = cnxn.sendResponse(new ReplyHeader(ClientCnxn.PING_XID, lastZxid, 0), null, \"response\");\n<line38>                return;\n<line39>            }\n<line40>        case OpCode.createSession:\n<line41>            {\n<line42>                lastOp = \"SESS\";\n<line43>                updateStats(request, lastOp, lastZxid);\n<line44>                zks.finishSessionInit(request.cnxn, true);\n<line45>                return;\n<line46>            }\n<line47>        case OpCode.multi:\n<line48>            {\n<line49>                lastOp = \"MULT\";\n<line50>                rsp = new MultiResponse();\n<line51>                for (ProcessTxnResult subTxnResult : rc.multiResult) {\n<line52>                    OpResult subResult;\n<line53>                    switch(subTxnResult.type) {\n<line54>                        case OpCode.check:\n<line55>                            subResult = new CheckResult();\n<line56>                            break;\n<line57>                        case OpCode.create:\n<line58>                            subResult = new CreateResult(subTxnResult.path);\n<line59>                            break;\n<line60>                        case OpCode.create2:\n<line61>                        case OpCode.createTTL:\n<line62>                        case OpCode.createContainer:\n<line63>                            subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n<line64>                            break;\n<line65>                        case OpCode.delete:\n<line66>                        case OpCode.deleteContainer:\n<line67>                            subResult = new DeleteResult();\n<line68>                            break;\n<line69>                        case OpCode.setData:\n<line70>                            subResult = new SetDataResult(subTxnResult.stat);\n<line71>                            break;\n<line72>                        case OpCode.error:\n<line73>                            subResult = new ErrorResult(subTxnResult.err);\n<line74>                            if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {\n<line75>                                throw new SessionMovedException();\n<line76>                            }\n<line77>                            break;\n<line78>                        default:\n<line79>                            throw new IOException(\"Invalid type of op\");\n<line80>                    }\n<line81>                    ((MultiResponse) rsp).add(subResult);\n<line82>                }\n<line83>                break;\n<line84>            }\n<line85>        case OpCode.multiRead:\n<line86>            {\n<line87>                lastOp = \"MLTR\";\n<line88>                MultiOperationRecord multiReadRecord = request.readRequestRecord(MultiOperationRecord::new);\n<line89>                rsp = new MultiResponse();\n<line90>                OpResult subResult;\n<line91>                for (Op readOp : multiReadRecord) {\n<line92>                    try {\n<line93>                        Record rec;\n<line94>                        switch(readOp.getType()) {\n<line95>                            case OpCode.getChildren:\n<line96>                                rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line97>                                subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());\n<line98>                                break;\n<line99>                            case OpCode.getData:\n<line100>                                rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);\n<line101>                                GetDataResponse gdr = (GetDataResponse) rec;\n<line102>                                subResult = new GetDataResult(gdr.getData(), gdr.getStat());\n<line103>                                break;\n<line104>                            default:\n<line105>                                throw new IOException(\"Invalid type of readOp\");\n<line106>                        }\n<line107>                    } catch (KeeperException e) {\n<line108>                        subResult = new ErrorResult(e.code().intValue());\n<line109>                    }\n<line110>                    ((MultiResponse) rsp).add(subResult);\n<line111>                }\n<line112>                break;\n<line113>            }\n<line114>        case OpCode.create:\n<line115>            {\n<line116>                lastOp = \"CREA\";\n<line117>                rsp = new CreateResponse(rc.path);\n<line118>                err = Code.get(rc.err);\n<line119>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line120>                break;\n<line121>            }\n<line122>        case OpCode.create2:\n<line123>        case OpCode.createTTL:\n<line124>        case OpCode.createContainer:\n<line125>            {\n<line126>                lastOp = \"CREA\";\n<line127>                rsp = new Create2Response(rc.path, rc.stat);\n<line128>                err = Code.get(rc.err);\n<line129>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line130>                break;\n<line131>            }\n<line132>        case OpCode.delete:\n<line133>        case OpCode.deleteContainer:\n<line134>            {\n<line135>                lastOp = \"DELE\";\n<line136>                err = Code.get(rc.err);\n<line137>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line138>                break;\n<line139>            }\n<line140>        case OpCode.setData:\n<line141>            {\n<line142>                lastOp = \"SETD\";\n<line143>                rsp = new SetDataResponse(rc.stat);\n<line144>                err = Code.get(rc.err);\n<line145>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line146>                break;\n<line147>            }\n<line148>        case OpCode.reconfig:\n<line149>            {\n<line150>                lastOp = \"RECO\";\n<line151>                rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(UTF_8), rc.stat);\n<line152>                err = Code.get(rc.err);\n<line153>                break;\n<line154>            }\n<line155>        case OpCode.setACL:\n<line156>            {\n<line157>                lastOp = \"SETA\";\n<line158>                rsp = new SetACLResponse(rc.stat);\n<line159>                err = Code.get(rc.err);\n<line160>                requestPathMetricsCollector.registerRequest(request.type, rc.path);\n<line161>                break;\n<line162>            }\n<line163>        case OpCode.closeSession:\n<line164>            {\n<line165>                lastOp = \"CLOS\";\n<line166>                err = Code.get(rc.err);\n<line167>                break;\n<line168>            }\n<line169>        case OpCode.sync:\n<line170>            {\n<line171>                lastOp = \"SYNC\";\n<line172>                SyncRequest syncRequest = request.readRequestRecord(SyncRequest::new);\n<line173>                rsp = new SyncResponse(syncRequest.getPath());\n<line174>                requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());\n<line175>                break;\n<line176>            }\n<line177>        case OpCode.check:\n<line178>            {\n<line179>                lastOp = \"CHEC\";\n<line180>                rsp = new SetDataResponse(rc.stat);\n<line181>                err = Code.get(rc.err);\n<line182>                break;\n<line183>            }\n<line184>        case OpCode.exists:\n<line185>            {\n<line186>                lastOp = \"EXIS\";\n<line187>                ExistsRequest existsRequest = request.readRequestRecord(ExistsRequest::new);\n<line188>                path = existsRequest.getPath();\n<line189>                if (path.indexOf('\\0') != -1) {\n<line190>                    throw new KeeperException.BadArgumentsException();\n<line191>                }\n<line192>                DataNode n = zks.getZKDatabase().getNode(path);\n<line193>                if (n != null) {\n<line194>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line195>                }\n<line196>                Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);\n<line197>                rsp = new ExistsResponse(stat);\n<line198>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line199>                break;\n<line200>            }\n<line201>        case OpCode.getData:\n<line202>            {\n<line203>                lastOp = \"GETD\";\n<line204>                GetDataRequest getDataRequest = request.readRequestRecord(GetDataRequest::new);\n<line205>                path = getDataRequest.getPath();\n<line206>                rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);\n<line207>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line208>                break;\n<line209>            }\n<line210>        case OpCode.setWatches:\n<line211>            {\n<line212>                lastOp = \"SETW\";\n<line213>                SetWatches setWatches = request.readRequestRecord(SetWatches::new);\n<line214>                long relativeZxid = setWatches.getRelativeZxid();\n<line215>                zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), Collections.emptyList(), Collections.emptyList(), cnxn);\n<line216>                break;\n<line217>            }\n<line218>        case OpCode.setWatches2:\n<line219>            {\n<line220>                lastOp = \"STW2\";\n<line221>                SetWatches2 setWatches = request.readRequestRecord(SetWatches2::new);\n<line222>                long relativeZxid = setWatches.getRelativeZxid();\n<line223>                zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), setWatches.getPersistentWatches(), setWatches.getPersistentRecursiveWatches(), cnxn);\n<line224>                break;\n<line225>            }\n<line226>        case OpCode.addWatch:\n<line227>            {\n<line228>                lastOp = \"ADDW\";\n<line229>                AddWatchRequest addWatcherRequest = request.readRequestRecord(AddWatchRequest::new);\n<line230>                zks.getZKDatabase().addWatch(addWatcherRequest.getPath(), cnxn, addWatcherRequest.getMode());\n<line231>                rsp = new ErrorResponse(0);\n<line232>                break;\n<line233>            }\n<line234>        case OpCode.getACL:\n<line235>            {\n<line236>                lastOp = \"GETA\";\n<line237>                GetACLRequest getACLRequest = request.readRequestRecord(GetACLRequest::new);\n<line238>                path = getACLRequest.getPath();\n<line239>                DataNode n = zks.getZKDatabase().getNode(path);\n<line240>                if (n == null) {\n<line241>                    throw new KeeperException.NoNodeException();\n<line242>                }\n<line243>                zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line244>                Stat stat = new Stat();\n<line245>                List<ACL> acl = zks.getZKDatabase().getACL(path, stat);\n<line246>                requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());\n<line247>                try {\n<line248>                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);\n<line249>                    rsp = new GetACLResponse(acl, stat);\n<line250>                } catch (KeeperException.NoAuthException e) {\n<line251>                    List<ACL> acl1 = new ArrayList<>(acl.size());\n<line252>                    for (ACL a : acl) {\n<line253>                        if (\"digest\".equals(a.getId().getScheme())) {\n<line254>                            Id id = a.getId();\n<line255>                            Id id1 = new Id(id.getScheme(), id.getId().replaceAll(\":.*\", \":x\"));\n<line256>                            acl1.add(new ACL(a.getPerms(), id1));\n<line257>                        } else {\n<line258>                            acl1.add(a);\n<line259>                        }\n<line260>                    }\n<line261>                    rsp = new GetACLResponse(acl1, stat);\n<line262>                }\n<line263>                break;\n<line264>            }\n<line265>        case OpCode.getChildren:\n<line266>            {\n<line267>                lastOp = \"GETC\";\n<line268>                GetChildrenRequest getChildrenRequest = request.readRequestRecord(GetChildrenRequest::new);\n<line269>                path = getChildrenRequest.getPath();\n<line270>                rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);\n<line271>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line272>                break;\n<line273>            }\n<line274>        case OpCode.getAllChildrenNumber:\n<line275>            {\n<line276>                lastOp = \"GETACN\";\n<line277>                GetAllChildrenNumberRequest getAllChildrenNumberRequest = request.readRequestRecord(GetAllChildrenNumberRequest::new);\n<line278>                path = getAllChildrenNumberRequest.getPath();\n<line279>                DataNode n = zks.getZKDatabase().getNode(path);\n<line280>                if (n == null) {\n<line281>                    throw new KeeperException.NoNodeException();\n<line282>                }\n<line283>                zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line284>                int number = zks.getZKDatabase().getAllChildrenNumber(path);\n<line285>                rsp = new GetAllChildrenNumberResponse(number);\n<line286>                break;\n<line287>            }\n<line288>        case OpCode.getChildren2:\n<line289>            {\n<line290>                lastOp = \"GETC\";\n<line291>                GetChildren2Request getChildren2Request = request.readRequestRecord(GetChildren2Request::new);\n<line292>                Stat stat = new Stat();\n<line293>                path = getChildren2Request.getPath();\n<line294>                DataNode n = zks.getZKDatabase().getNode(path);\n<line295>                if (n == null) {\n<line296>                    throw new KeeperException.NoNodeException();\n<line297>                }\n<line298>                zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);\n<line299>                List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);\n<line300>                rsp = new GetChildren2Response(children, stat);\n<line301>                requestPathMetricsCollector.registerRequest(request.type, path);\n<line302>                break;\n<line303>            }\n<line304>        case OpCode.checkWatches:\n<line305>            {\n<line306>                lastOp = \"CHKW\";\n<line307>                CheckWatchesRequest checkWatches = request.readRequestRecord(CheckWatchesRequest::new);\n<line308>                WatcherType type = WatcherType.fromInt(checkWatches.getType());\n<line309>                path = checkWatches.getPath();\n<line310>                boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);\n<line311>                if (!containsWatcher) {\n<line312>                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line313>                    throw new KeeperException.NoWatcherException(msg);\n<line314>                }\n<line315>                requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());\n<line316>                break;\n<line317>            }\n<line318>        case OpCode.removeWatches:\n<line319>            {\n<line320>                lastOp = \"REMW\";\n<line321>                RemoveWatchesRequest removeWatches = request.readRequestRecord(RemoveWatchesRequest::new);\n<line322>                WatcherType type = WatcherType.fromInt(removeWatches.getType());\n<line323>                path = removeWatches.getPath();\n<line324>                boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);\n<line325>                if (!removed) {\n<line326>                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\", path, type);\n<line327>                    throw new KeeperException.NoWatcherException(msg);\n<line328>                }\n<line329>                requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());\n<line330>                break;\n<line331>            }\n<line332>        case OpCode.whoAmI:\n<line333>            {\n<line334>                lastOp = \"HOMI\";\n<line335>                rsp = new WhoAmIResponse(AuthUtil.getClientInfos(request.authInfo));\n<line336>                break;\n<line337>            }\n<line338>        case OpCode.getEphemerals:\n<line339>            {\n<line340>                lastOp = \"GETE\";\n<line341>                GetEphemeralsRequest getEphemerals = request.readRequestRecord(GetEphemeralsRequest::new);\n<line342>                String prefixPath = getEphemerals.getPrefixPath();\n<line343>                Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);\n<line344>                List<String> ephemerals = new ArrayList<>();\n<line345>                if (prefixPath == null || prefixPath.trim().isEmpty() || \"/\".equals(prefixPath.trim())) {\n<line346>                    ephemerals.addAll(allEphems);\n<line347>                } else {\n<line348>                    for (String p : allEphems) {\n<line349>                        if (p.startsWith(prefixPath)) {\n<line350>                            ephemerals.add(p);\n<line351>                        }\n<line352>                    }\n<line353>                }\n<line354>                rsp = new GetEphemeralsResponse(ephemerals);\n<line355>                break;\n<line356>            }\n<line357>    }\n<line358>}"},{"input":"","instruction":"<line1>{\n<line2>    // log at error level as we are returning a marshalling\n<line3>    // error to the user\n<line4>    String digest = request.requestDigest();\n<line5>    err = Code.MARSHALLINGERROR;\n<line6>}","output":"<line1>{\n<line2>    // log at error level as we are returning a marshalling\n<line3>    // error to the user\n<line4>    LOG.error(\"Failed to process {}\", request, e);\n<line5>    String digest = request.requestDigest();\n<line6>    LOG.error(\"Dumping request buffer for request type {}: 0x{}\", Request.op2String(request.type), digest);\n<line7>    err = Code.MARSHALLINGERROR;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"FIXMSG\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // we are the final link in the chain\n<line3>}","output":"<line1>{\n<line2>    // we are the final link in the chain\n<line3>    LOG.info(\"shutdown of request processor complete\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (this.hdr == null) {\n<line3>        return null;\n<line4>    }\n<line5>    try {\n<line6>        return Util.marshallTxnEntry(this.hdr, this.txn, this.txnDigest);\n<line7>    } catch (IOException e) {\n<line8>        return new byte[32];\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (this.hdr == null) {\n<line3>        return null;\n<line4>    }\n<line5>    try {\n<line6>        return Util.marshallTxnEntry(this.hdr, this.txn, this.txnDigest);\n<line7>    } catch (IOException e) {\n<line8>        LOG.error(\"This really should be impossible.\", e);\n<line9>        return new byte[32];\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    return new byte[32];\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"This really should be impossible.\", e);\n<line3>    return new byte[32];\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final long leastZxidToBeRetain = Util.getZxidFromName(snapShot.getName(), PREFIX_SNAPSHOT);\n<line3>    /**\n<line4>     * We delete all files with a zxid in their name that is less than leastZxidToBeRetain.\n<line5>     * This rule applies to both snapshot files as well as log files, with the following\n<line6>     * exception for log files.\n<line7>     *\n<line8>     * A log file with zxid less than X may contain transactions with zxid larger than X.  More\n<line9>     * there are no other log files with starting zxid in the interval (X-a, X].  Assuming the\n<line10>     * recoverable.  In fact, this log file may very well extend beyond snapshot.X to newer\n<line11>     * snapshot files if these newer snapshots were not accompanied by log rollover (possible in\n<line12>     * the learner state machine at the time of this writing).  We can make more precise\n<line13>     * but the complexity quickly adds up with gains only in uncommon scenarios.  It's safe and\n<line14>     * recoverability of all snapshots being retained.  We determine that log file here by\n<line15>     * calling txnLog.getSnapshotLogs().\n<line16>     */\n<line17>    final Set<File> retainedTxnLogs = new HashSet<>();\n<line18>    retainedTxnLogs.addAll(Arrays.asList(txnLog.getSnapshotLogs(leastZxidToBeRetain)));\n<line19>    /**\n<line20>     * Finds all candidates for deletion, which are files with a zxid in their name that is less\n<line21>     * than leastZxidToBeRetain.  There's an exception to this rule, as noted above.\n<line22>     */\n<line23>    class MyFileFilter implements FileFilter {\n<line24>\n<line25>        private final String prefix;\n<line26>\n<line27>        MyFileFilter(String prefix) {\n<line28>            this.prefix = prefix;\n<line29>        }\n<line30>\n<line31>        public boolean accept(File f) {\n<line32>            if (!f.getName().startsWith(prefix + \".\")) {\n<line33>                return false;\n<line34>            }\n<line35>            if (retainedTxnLogs.contains(f)) {\n<line36>                return false;\n<line37>            }\n<line38>            long fZxid = Util.getZxidFromName(f.getName(), prefix);\n<line39>            return fZxid < leastZxidToBeRetain;\n<line40>        }\n<line41>    }\n<line42>    // add all non-excluded log files\n<line43>    File[] logs = txnLog.getDataLogDir().listFiles(new MyFileFilter(PREFIX_LOG));\n<line44>    List<File> files = new ArrayList<>();\n<line45>    if (logs != null) {\n<line46>        files.addAll(Arrays.asList(logs));\n<line47>    }\n<line48>    // add all non-excluded snapshot files to the deletion list\n<line49>    File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));\n<line50>    if (snapshots != null) {\n<line51>        files.addAll(Arrays.asList(snapshots));\n<line52>    }\n<line53>    // remove the old files\n<line54>    for (File f : files) {\n<line55>        final String msg = String.format(\"Removing file: %s\\t%s\", DateFormat.getDateTimeInstance().format(f.lastModified()), f.getPath());\n<line56>        System.out.println(msg);\n<line57>        if (!f.delete()) {\n<line58>            System.err.println(\"Failed to remove \" + f.getPath());\n<line59>        }\n<line60>    }\n<line61>}","output":"<line1>{\n<line2>    final long leastZxidToBeRetain = Util.getZxidFromName(snapShot.getName(), PREFIX_SNAPSHOT);\n<line3>    /**\n<line4>     * We delete all files with a zxid in their name that is less than leastZxidToBeRetain.\n<line5>     * This rule applies to both snapshot files as well as log files, with the following\n<line6>     * exception for log files.\n<line7>     *\n<line8>     * A log file with zxid less than X may contain transactions with zxid larger than X.  More\n<line9>     * precisely, a log file named log.(X-a) may contain transactions newer than snapshot.X if\n<line10>     * there are no other log files with starting zxid in the interval (X-a, X].  Assuming the\n<line11>     * latter condition is true, log.(X-a) must be retained to ensure that snapshot.X is\n<line12>     * recoverable.  In fact, this log file may very well extend beyond snapshot.X to newer\n<line13>     * snapshot files if these newer snapshots were not accompanied by log rollover (possible in\n<line14>     * the learner state machine at the time of this writing).  We can make more precise\n<line15>     * determination of whether log.(leastZxidToBeRetain-a) for the smallest 'a' is actually\n<line16>     * needed or not (e.g. not needed if there's a log file named log.(leastZxidToBeRetain+1)),\n<line17>     * but the complexity quickly adds up with gains only in uncommon scenarios.  It's safe and\n<line18>     * simple to just preserve log.(leastZxidToBeRetain-a) for the smallest 'a' to ensure\n<line19>     * recoverability of all snapshots being retained.  We determine that log file here by\n<line20>     * calling txnLog.getSnapshotLogs().\n<line21>     */\n<line22>    final Set<File> retainedTxnLogs = new HashSet<>();\n<line23>    retainedTxnLogs.addAll(Arrays.asList(txnLog.getSnapshotLogs(leastZxidToBeRetain)));\n<line24>    /**\n<line25>     * Finds all candidates for deletion, which are files with a zxid in their name that is less\n<line26>     * than leastZxidToBeRetain.  There's an exception to this rule, as noted above.\n<line27>     */\n<line28>    class MyFileFilter implements FileFilter {\n<line29>\n<line30>        private final String prefix;\n<line31>\n<line32>        MyFileFilter(String prefix) {\n<line33>            this.prefix = prefix;\n<line34>        }\n<line35>\n<line36>        public boolean accept(File f) {\n<line37>            if (!f.getName().startsWith(prefix + \".\")) {\n<line38>                return false;\n<line39>            }\n<line40>            if (retainedTxnLogs.contains(f)) {\n<line41>                return false;\n<line42>            }\n<line43>            long fZxid = Util.getZxidFromName(f.getName(), prefix);\n<line44>            return fZxid < leastZxidToBeRetain;\n<line45>        }\n<line46>    }\n<line47>    // add all non-excluded log files\n<line48>    File[] logs = txnLog.getDataLogDir().listFiles(new MyFileFilter(PREFIX_LOG));\n<line49>    List<File> files = new ArrayList<>();\n<line50>    if (logs != null) {\n<line51>        files.addAll(Arrays.asList(logs));\n<line52>    }\n<line53>    // add all non-excluded snapshot files to the deletion list\n<line54>    File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));\n<line55>    if (snapshots != null) {\n<line56>        files.addAll(Arrays.asList(snapshots));\n<line57>    }\n<line58>    // remove the old files\n<line59>    for (File f : files) {\n<line60>        final String msg = String.format(\"Removing file: %s\\t%s\", DateFormat.getDateTimeInstance().format(f.lastModified()), f.getPath());\n<line61>        LOG.info(msg);\n<line62>        System.out.println(msg);\n<line63>        if (!f.delete()) {\n<line64>            System.err.println(\"Failed to remove \" + f.getPath());\n<line65>        }\n<line66>    }\n<line67>}"},{"input":"","instruction":"<line1>{\n<line2>    final String msg = String.format(\"Removing file: %s\\t%s\", DateFormat.getDateTimeInstance().format(f.lastModified()), f.getPath());\n<line3>    System.out.println(msg);\n<line4>    if (!f.delete()) {\n<line5>        System.err.println(\"Failed to remove \" + f.getPath());\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    final String msg = String.format(\"Removing file: %s\\t%s\", DateFormat.getDateTimeInstance().format(f.lastModified()), f.getPath());\n<line3>    LOG.info(msg);\n<line4>    System.out.println(msg);\n<line5>    if (!f.delete()) {\n<line6>        System.err.println(\"Failed to remove \" + f.getPath());\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    String realPath = Quotas.quotaPath(path);\n<line3>    try {\n<line4>        ZKUtil.visitSubTreeDFS(zk, realPath, false, (rc, quotaPath, ctx, name) -> {\n<line5>            List<String> children = new ArrayList<>();\n<line6>            try {\n<line7>                children = zk.getChildren(quotaPath, false);\n<line8>            } catch (KeeperException.NoNodeException ne) {\n<line9>                return;\n<line10>            } catch (InterruptedException | KeeperException e) {\n<line11>                e.printStackTrace();\n<line12>            }\n<line13>            if (children.size() == 0) {\n<line14>                return;\n<line15>            }\n<line16>            for (String child : children) {\n<line17>                if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n<line18>                    throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line19>                }\n<line20>            }\n<line21>        });\n<line22>    } catch (KeeperException.NoNodeException ne) {\n<line23>        // this is fine\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    String realPath = Quotas.quotaPath(path);\n<line3>    try {\n<line4>        ZKUtil.visitSubTreeDFS(zk, realPath, false, (rc, quotaPath, ctx, name) -> {\n<line5>            List<String> children = new ArrayList<>();\n<line6>            try {\n<line7>                children = zk.getChildren(quotaPath, false);\n<line8>            } catch (KeeperException.NoNodeException ne) {\n<line9>                LOG.debug(\"child removed during quota check\", ne);\n<line10>                return;\n<line11>            } catch (InterruptedException | KeeperException e) {\n<line12>                e.printStackTrace();\n<line13>            }\n<line14>            if (children.size() == 0) {\n<line15>                return;\n<line16>            }\n<line17>            for (String child : children) {\n<line18>                if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n<line19>                    throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line20>                }\n<line21>            }\n<line22>        });\n<line23>    } catch (KeeperException.NoNodeException ne) {\n<line24>        // this is fine\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    ZKUtil.visitSubTreeDFS(zk, realPath, false, (rc, quotaPath, ctx, name) -> {\n<line3>        List<String> children = new ArrayList<>();\n<line4>        try {\n<line5>            children = zk.getChildren(quotaPath, false);\n<line6>        } catch (KeeperException.NoNodeException ne) {\n<line7>            return;\n<line8>        } catch (InterruptedException | KeeperException e) {\n<line9>            e.printStackTrace();\n<line10>        }\n<line11>        if (children.size() == 0) {\n<line12>            return;\n<line13>        }\n<line14>        for (String child : children) {\n<line15>            if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n<line16>                throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line17>            }\n<line18>        }\n<line19>    });\n<line20>}","output":"<line1>{\n<line2>    ZKUtil.visitSubTreeDFS(zk, realPath, false, (rc, quotaPath, ctx, name) -> {\n<line3>        List<String> children = new ArrayList<>();\n<line4>        try {\n<line5>            children = zk.getChildren(quotaPath, false);\n<line6>        } catch (KeeperException.NoNodeException ne) {\n<line7>            LOG.debug(\"child removed during quota check\", ne);\n<line8>            return;\n<line9>        } catch (InterruptedException | KeeperException e) {\n<line10>            e.printStackTrace();\n<line11>        }\n<line12>        if (children.size() == 0) {\n<line13>            return;\n<line14>        }\n<line15>        for (String child : children) {\n<line16>            if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n<line17>                throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line18>            }\n<line19>        }\n<line20>    });\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    List<String> children = new ArrayList<>();\n<line3>    try {\n<line4>        children = zk.getChildren(quotaPath, false);\n<line5>    } catch (KeeperException.NoNodeException ne) {\n<line6>        return;\n<line7>    } catch (InterruptedException | KeeperException e) {\n<line8>        e.printStackTrace();\n<line9>    }\n<line10>    if (children.size() == 0) {\n<line11>        return;\n<line12>    }\n<line13>    for (String child : children) {\n<line14>        if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n<line15>            throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line16>        }\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    List<String> children = new ArrayList<>();\n<line3>    try {\n<line4>        children = zk.getChildren(quotaPath, false);\n<line5>    } catch (KeeperException.NoNodeException ne) {\n<line6>        LOG.debug(\"child removed during quota check\", ne);\n<line7>        return;\n<line8>    } catch (InterruptedException | KeeperException e) {\n<line9>        e.printStackTrace();\n<line10>    }\n<line11>    if (children.size() == 0) {\n<line12>        return;\n<line13>    }\n<line14>    for (String child : children) {\n<line15>        if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n<line16>            throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line17>        }\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"child removed during quota check\", ne);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final String[] splits = path.split(\"/\");\n<line3>    String quotaPath = Quotas.quotaZookeeper;\n<line4>    StringBuilder sb = new StringBuilder();\n<line5>    sb.append(quotaPath);\n<line6>    for (int i = 1; i < splits.length - 1; i++) {\n<line7>        sb.append(\"/\");\n<line8>        sb.append(splits[i]);\n<line9>        quotaPath = sb.toString();\n<line10>        List<String> children = null;\n<line11>        try {\n<line12>            children = zk.getChildren(quotaPath, false);\n<line13>        } catch (KeeperException.NoNodeException ne) {\n<line14>            return;\n<line15>        }\n<line16>        if (children.size() == 0) {\n<line17>            return;\n<line18>        }\n<line19>        for (String child : children) {\n<line20>            if (!quotaPath.equals(Quotas.quotaPath(path)) && Quotas.limitNode.equals(child)) {\n<line21>                throw new IllegalArgumentException(path + \" has a parent \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line22>            }\n<line23>        }\n<line24>    }\n<line25>}","output":"<line1>{\n<line2>    final String[] splits = path.split(\"/\");\n<line3>    String quotaPath = Quotas.quotaZookeeper;\n<line4>    StringBuilder sb = new StringBuilder();\n<line5>    sb.append(quotaPath);\n<line6>    for (int i = 1; i < splits.length - 1; i++) {\n<line7>        sb.append(\"/\");\n<line8>        sb.append(splits[i]);\n<line9>        quotaPath = sb.toString();\n<line10>        List<String> children = null;\n<line11>        try {\n<line12>            children = zk.getChildren(quotaPath, false);\n<line13>        } catch (KeeperException.NoNodeException ne) {\n<line14>            LOG.debug(\"child removed during quota check\", ne);\n<line15>            return;\n<line16>        }\n<line17>        if (children.size() == 0) {\n<line18>            return;\n<line19>        }\n<line20>        for (String child : children) {\n<line21>            if (!quotaPath.equals(Quotas.quotaPath(path)) && Quotas.limitNode.equals(child)) {\n<line22>                throw new IllegalArgumentException(path + \" has a parent \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line23>            }\n<line24>        }\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    sb.append(\"/\");\n<line3>    sb.append(splits[i]);\n<line4>    quotaPath = sb.toString();\n<line5>    List<String> children = null;\n<line6>    try {\n<line7>        children = zk.getChildren(quotaPath, false);\n<line8>    } catch (KeeperException.NoNodeException ne) {\n<line9>        return;\n<line10>    }\n<line11>    if (children.size() == 0) {\n<line12>        return;\n<line13>    }\n<line14>    for (String child : children) {\n<line15>        if (!quotaPath.equals(Quotas.quotaPath(path)) && Quotas.limitNode.equals(child)) {\n<line16>            throw new IllegalArgumentException(path + \" has a parent \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line17>        }\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    sb.append(\"/\");\n<line3>    sb.append(splits[i]);\n<line4>    quotaPath = sb.toString();\n<line5>    List<String> children = null;\n<line6>    try {\n<line7>        children = zk.getChildren(quotaPath, false);\n<line8>    } catch (KeeperException.NoNodeException ne) {\n<line9>        LOG.debug(\"child removed during quota check\", ne);\n<line10>        return;\n<line11>    }\n<line12>    if (children.size() == 0) {\n<line13>        return;\n<line14>    }\n<line15>    for (String child : children) {\n<line16>        if (!quotaPath.equals(Quotas.quotaPath(path)) && Quotas.limitNode.equals(child)) {\n<line17>            throw new IllegalArgumentException(path + \" has a parent \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n<line18>        }\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"child removed during quota check\", ne);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    clientCnxn.eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));\n<line3>    clientCnxn.eventThread.queueEventOfDeath();\n<line4>    clientCnxn.state = ZooKeeper.States.CLOSED;\n<line5>    clientCnxn.sendThread.getClientCnxnSocket().onClosing();\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"injectSessionExpiration() called\");\n<line3>    clientCnxn.eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));\n<line4>    clientCnxn.eventThread.queueEventOfDeath();\n<line5>    clientCnxn.state = ZooKeeper.States.CLOSED;\n<line6>    clientCnxn.sendThread.getClientCnxnSocket().onClosing();\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    clientCnxn.eventThread.queueEvent(event);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"queueEvent() called: {}\", event);\n<line3>    clientCnxn.eventThread.queueEvent(event);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    clientCnxn.sendThread.testableCloseSocket();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"closeSocket() called\");\n<line3>    clientCnxn.sendThread.testableCloseSocket();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // Client-initiated renegotiation in TLS is unsafe and\n<line3>    // allows MITM attacks, so we should disable it unless\n<line4>    // it was explicitly enabled by the user.\n<line5>    // A brief summary of the issue can be found at\n<line6>    // https://www.ietf.org/proceedings/76/slides/tls-7.pdf\n<line7>    if (System.getProperty(REJECT_CLIENT_RENEGOTIATION_PROPERTY) == null) {\n<line8>        System.setProperty(REJECT_CLIENT_RENEGOTIATION_PROPERTY, Boolean.TRUE.toString());\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    // Client-initiated renegotiation in TLS is unsafe and\n<line3>    // allows MITM attacks, so we should disable it unless\n<line4>    // it was explicitly enabled by the user.\n<line5>    // A brief summary of the issue can be found at\n<line6>    // https://www.ietf.org/proceedings/76/slides/tls-7.pdf\n<line7>    if (System.getProperty(REJECT_CLIENT_RENEGOTIATION_PROPERTY) == null) {\n<line8>        LOG.info(\"Setting -D {}=true to disable client-initiated TLS renegotiation\", REJECT_CLIENT_RENEGOTIATION_PROPERTY);\n<line9>        System.setProperty(REJECT_CLIENT_RENEGOTIATION_PROPERTY, Boolean.TRUE.toString());\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    System.setProperty(REJECT_CLIENT_RENEGOTIATION_PROPERTY, Boolean.TRUE.toString());\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Setting -D {}=true to disable client-initiated TLS renegotiation\", REJECT_CLIENT_RENEGOTIATION_PROPERTY);\n<line3>    System.setProperty(REJECT_CLIENT_RENEGOTIATION_PROPERTY, Boolean.TRUE.toString());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String defaultProtocol = TLS_1_2;\n<line3>    List<String> supported = new ArrayList<>();\n<line4>    try {\n<line5>        supported = Arrays.asList(SSLContext.getDefault().getSupportedSSLParameters().getProtocols());\n<line6>        if (supported.contains(TLS_1_3)) {\n<line7>            defaultProtocol = TLS_1_3;\n<line8>        }\n<line9>    } catch (NoSuchAlgorithmException e) {\n<line10>        // Ignore.\n<line11>    }\n<line12>    return defaultProtocol;\n<line13>}","output":"<line1>{\n<line2>    String defaultProtocol = TLS_1_2;\n<line3>    List<String> supported = new ArrayList<>();\n<line4>    try {\n<line5>        supported = Arrays.asList(SSLContext.getDefault().getSupportedSSLParameters().getProtocols());\n<line6>        if (supported.contains(TLS_1_3)) {\n<line7>            defaultProtocol = TLS_1_3;\n<line8>        }\n<line9>    } catch (NoSuchAlgorithmException e) {\n<line10>        // Ignore.\n<line11>    }\n<line12>    LOG.info(\"Default TLS protocol is {}, supported TLS protocols are {}\", defaultProtocol, supported);\n<line13>    return defaultProtocol;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        SSLContextAndOptions ctx = getDefaultSSLContextAndOptions();\n<line4>        return ctx.getHandshakeDetectionTimeoutMillis();\n<line5>    } catch (SSLContextException e) {\n<line6>        return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line7>    } catch (Exception e) {\n<line8>        return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    try {\n<line3>        SSLContextAndOptions ctx = getDefaultSSLContextAndOptions();\n<line4>        return ctx.getHandshakeDetectionTimeoutMillis();\n<line5>    } catch (SSLContextException e) {\n<line6>        LOG.error(\"Error creating SSL context and options\", e);\n<line7>        return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line8>    } catch (Exception e) {\n<line9>        LOG.error(\"Error parsing config property {}\", getSslHandshakeDetectionTimeoutMillisProperty(), e);\n<line10>        return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error creating SSL context and options\", e);\n<line3>    return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error parsing config property {}\", getSslHandshakeDetectionTimeoutMillisProperty(), e);\n<line3>    return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    final String supplierContextClassName = config.getProperty(sslContextSupplierClassProperty);\n<line3>    if (supplierContextClassName != null) {\n<line4>        try {\n<line5>            Class<?> sslContextClass = Class.forName(supplierContextClassName);\n<line6>            Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();\n<line7>            return new SSLContextAndOptions(this, config, sslContextSupplier.get());\n<line8>        } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {\n<line9>            throw new SSLContextException(\"Could not retrieve the SSLContext from supplier source '\" + supplierContextClassName + \"' provided in the property '\" + sslContextSupplierClassProperty + \"'\", e);\n<line10>        }\n<line11>    } else {\n<line12>        return createSSLContextAndOptionsFromConfig(config);\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    final String supplierContextClassName = config.getProperty(sslContextSupplierClassProperty);\n<line3>    if (supplierContextClassName != null) {\n<line4>        LOG.debug(\"Loading SSLContext supplier from property '{}'\", sslContextSupplierClassProperty);\n<line5>        try {\n<line6>            Class<?> sslContextClass = Class.forName(supplierContextClassName);\n<line7>            Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();\n<line8>            return new SSLContextAndOptions(this, config, sslContextSupplier.get());\n<line9>        } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {\n<line10>            throw new SSLContextException(\"Could not retrieve the SSLContext from supplier source '\" + supplierContextClassName + \"' provided in the property '\" + sslContextSupplierClassProperty + \"'\", e);\n<line11>        }\n<line12>    } else {\n<line13>        return createSSLContextAndOptionsFromConfig(config);\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Class<?> sslContextClass = Class.forName(supplierContextClassName);\n<line4>        Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();\n<line5>        return new SSLContextAndOptions(this, config, sslContextSupplier.get());\n<line6>    } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {\n<line7>        throw new SSLContextException(\"Could not retrieve the SSLContext from supplier source '\" + supplierContextClassName + \"' provided in the property '\" + sslContextSupplierClassProperty + \"'\", e);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.debug(\"Loading SSLContext supplier from property '{}'\", sslContextSupplierClassProperty);\n<line3>    try {\n<line4>        Class<?> sslContextClass = Class.forName(supplierContextClassName);\n<line5>        Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();\n<line6>        return new SSLContextAndOptions(this, config, sslContextSupplier.get());\n<line7>    } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {\n<line8>        throw new SSLContextException(\"Could not retrieve the SSLContext from supplier source '\" + supplierContextClassName + \"' provided in the property '\" + sslContextSupplierClassProperty + \"'\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (trustStorePassword == null) {\n<line3>        trustStorePassword = \"\";\n<line4>    }\n<line5>    try {\n<line6>        KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);\n<line7>        PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());\n<line8>        if (crlEnabled || ocspEnabled) {\n<line9>            pbParams.setRevocationEnabled(true);\n<line10>            System.setProperty(\"com.sun.net.ssl.checkRevocation\", \"true\");\n<line11>            System.setProperty(\"com.sun.security.enableCRLDP\", \"true\");\n<line12>            if (ocspEnabled) {\n<line13>                Security.setProperty(\"ocsp.enable\", \"true\");\n<line14>            }\n<line15>        } else {\n<line16>            pbParams.setRevocationEnabled(false);\n<line17>        }\n<line18>        // Revocation checking is only supported with the PKIX algorithm\n<line19>        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n<line20>        tmf.init(new CertPathTrustManagerParameters(pbParams));\n<line21>        for (final TrustManager tm : tmf.getTrustManagers()) {\n<line22>            if (tm instanceof X509ExtendedTrustManager) {\n<line23>                if (fipsMode) {\n<line24>                    }\n<line25>                    return (X509TrustManager) tm;\n<line26>                }\n<line27>                }\n<line28>                return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line29>            }\n<line30>        }\n<line31>        throw new TrustManagerException(\"Couldn't find X509TrustManager\");\n<line32>    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {\n<line33>        throw new TrustManagerException(e);\n<line34>    }\n<line35>}","output":"<line1>{\n<line2>    if (trustStorePassword == null) {\n<line3>        trustStorePassword = \"\";\n<line4>    }\n<line5>    try {\n<line6>        KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);\n<line7>        PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());\n<line8>        if (crlEnabled || ocspEnabled) {\n<line9>            pbParams.setRevocationEnabled(true);\n<line10>            System.setProperty(\"com.sun.net.ssl.checkRevocation\", \"true\");\n<line11>            System.setProperty(\"com.sun.security.enableCRLDP\", \"true\");\n<line12>            if (ocspEnabled) {\n<line13>                Security.setProperty(\"ocsp.enable\", \"true\");\n<line14>            }\n<line15>        } else {\n<line16>            pbParams.setRevocationEnabled(false);\n<line17>        }\n<line18>        // Revocation checking is only supported with the PKIX algorithm\n<line19>        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n<line20>        tmf.init(new CertPathTrustManagerParameters(pbParams));\n<line21>        for (final TrustManager tm : tmf.getTrustManagers()) {\n<line22>            if (tm instanceof X509ExtendedTrustManager) {\n<line23>                if (fipsMode) {\n<line24>                    if (LOG.isDebugEnabled()) {\n<line25>                        LOG.debug(\"FIPS mode is ON: selecting standard x509 trust manager {}\", tm);\n<line26>                    }\n<line27>                    return (X509TrustManager) tm;\n<line28>                }\n<line29>                if (LOG.isDebugEnabled()) {\n<line30>                    LOG.debug(\"FIPS mode is OFF: creating ZKTrustManager\");\n<line31>                }\n<line32>                return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line33>            }\n<line34>        }\n<line35>        throw new TrustManagerException(\"Couldn't find X509TrustManager\");\n<line36>    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {\n<line37>        throw new TrustManagerException(e);\n<line38>    }\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);\n<line3>    PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());\n<line4>    if (crlEnabled || ocspEnabled) {\n<line5>        pbParams.setRevocationEnabled(true);\n<line6>        System.setProperty(\"com.sun.net.ssl.checkRevocation\", \"true\");\n<line7>        System.setProperty(\"com.sun.security.enableCRLDP\", \"true\");\n<line8>        if (ocspEnabled) {\n<line9>            Security.setProperty(\"ocsp.enable\", \"true\");\n<line10>        }\n<line11>    } else {\n<line12>        pbParams.setRevocationEnabled(false);\n<line13>    }\n<line14>    // Revocation checking is only supported with the PKIX algorithm\n<line15>    TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n<line16>    tmf.init(new CertPathTrustManagerParameters(pbParams));\n<line17>    for (final TrustManager tm : tmf.getTrustManagers()) {\n<line18>        if (tm instanceof X509ExtendedTrustManager) {\n<line19>            if (fipsMode) {\n<line20>                }\n<line21>                return (X509TrustManager) tm;\n<line22>            }\n<line23>            }\n<line24>            return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line25>        }\n<line26>    }\n<line27>    throw new TrustManagerException(\"Couldn't find X509TrustManager\");\n<line28>}","output":"<line1>{\n<line2>    KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);\n<line3>    PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());\n<line4>    if (crlEnabled || ocspEnabled) {\n<line5>        pbParams.setRevocationEnabled(true);\n<line6>        System.setProperty(\"com.sun.net.ssl.checkRevocation\", \"true\");\n<line7>        System.setProperty(\"com.sun.security.enableCRLDP\", \"true\");\n<line8>        if (ocspEnabled) {\n<line9>            Security.setProperty(\"ocsp.enable\", \"true\");\n<line10>        }\n<line11>    } else {\n<line12>        pbParams.setRevocationEnabled(false);\n<line13>    }\n<line14>    // Revocation checking is only supported with the PKIX algorithm\n<line15>    TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n<line16>    tmf.init(new CertPathTrustManagerParameters(pbParams));\n<line17>    for (final TrustManager tm : tmf.getTrustManagers()) {\n<line18>        if (tm instanceof X509ExtendedTrustManager) {\n<line19>            if (fipsMode) {\n<line20>                if (LOG.isDebugEnabled()) {\n<line21>                    LOG.debug(\"FIPS mode is ON: selecting standard x509 trust manager {}\", tm);\n<line22>                }\n<line23>                return (X509TrustManager) tm;\n<line24>            }\n<line25>            if (LOG.isDebugEnabled()) {\n<line26>                LOG.debug(\"FIPS mode is OFF: creating ZKTrustManager\");\n<line27>            }\n<line28>            return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line29>        }\n<line30>    }\n<line31>    throw new TrustManagerException(\"Couldn't find X509TrustManager\");\n<line32>}"},{"input":"","instruction":"<line1>{\n<line2>    if (tm instanceof X509ExtendedTrustManager) {\n<line3>        if (fipsMode) {\n<line4>            }\n<line5>            return (X509TrustManager) tm;\n<line6>        }\n<line7>        }\n<line8>        return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (tm instanceof X509ExtendedTrustManager) {\n<line3>        if (fipsMode) {\n<line4>            if (LOG.isDebugEnabled()) {\n<line5>                LOG.debug(\"FIPS mode is ON: selecting standard x509 trust manager {}\", tm);\n<line6>            }\n<line7>            return (X509TrustManager) tm;\n<line8>        }\n<line9>        if (LOG.isDebugEnabled()) {\n<line10>            LOG.debug(\"FIPS mode is OFF: creating ZKTrustManager\");\n<line11>        }\n<line12>        return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (fipsMode) {\n<line3>        }\n<line4>        return (X509TrustManager) tm;\n<line5>    }\n<line6>    }\n<line7>    return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line8>}","output":"<line1>{\n<line2>    if (fipsMode) {\n<line3>        if (LOG.isDebugEnabled()) {\n<line4>            LOG.debug(\"FIPS mode is ON: selecting standard x509 trust manager {}\", tm);\n<line5>        }\n<line6>        return (X509TrustManager) tm;\n<line7>    }\n<line8>    if (LOG.isDebugEnabled()) {\n<line9>        LOG.debug(\"FIPS mode is OFF: creating ZKTrustManager\");\n<line10>    }\n<line11>    return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    return (X509TrustManager) tm;\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"FIPS mode is ON: selecting standard x509 trust manager {}\", tm);\n<line4>    }\n<line5>    return (X509TrustManager) tm;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"FIPS mode is ON: selecting standard x509 trust manager {}\", tm);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"FIPS mode is OFF: creating ZKTrustManager\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Objects.requireNonNull(javaVersion);\n<line3>    if (javaVersion.matches(\"\\\\d+\")) {\n<line4>        // Must be Java 9 or later\n<line5>        return DEFAULT_CIPHERS_JAVA9;\n<line6>    } else if (javaVersion.startsWith(\"1.\")) {\n<line7>        // Must be Java 1.8 or earlier\n<line8>        return DEFAULT_CIPHERS_JAVA8;\n<line9>    } else {\n<line10>        return DEFAULT_CIPHERS_JAVA8;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    Objects.requireNonNull(javaVersion);\n<line3>    if (javaVersion.matches(\"\\\\d+\")) {\n<line4>        // Must be Java 9 or later\n<line5>        LOG.debug(\"Using Java9+ optimized cipher suites for Java version {}\", javaVersion);\n<line6>        return DEFAULT_CIPHERS_JAVA9;\n<line7>    } else if (javaVersion.startsWith(\"1.\")) {\n<line8>        // Must be Java 1.8 or earlier\n<line9>        LOG.debug(\"Using Java8 optimized cipher suites for Java version {}\", javaVersion);\n<line10>        return DEFAULT_CIPHERS_JAVA8;\n<line11>    } else {\n<line12>        LOG.debug(\"Could not parse java version {}, using Java8 optimized cipher suites\", javaVersion);\n<line13>        return DEFAULT_CIPHERS_JAVA8;\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    // Must be Java 9 or later\n<line3>    return DEFAULT_CIPHERS_JAVA9;\n<line4>}","output":"<line1>{\n<line2>    // Must be Java 9 or later\n<line3>    LOG.debug(\"Using Java9+ optimized cipher suites for Java version {}\", javaVersion);\n<line4>    return DEFAULT_CIPHERS_JAVA9;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    // Must be Java 1.8 or earlier\n<line3>    return DEFAULT_CIPHERS_JAVA8;\n<line4>}","output":"<line1>{\n<line2>    // Must be Java 1.8 or earlier\n<line3>    LOG.debug(\"Using Java8 optimized cipher suites for Java version {}\", javaVersion);\n<line4>    return DEFAULT_CIPHERS_JAVA8;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    return DEFAULT_CIPHERS_JAVA8;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Could not parse java version {}, using Java8 optimized cipher suites\", javaVersion);\n<line3>    return DEFAULT_CIPHERS_JAVA8;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    ZKConfig config = new ZKConfig();\n<line3>    FileChangeWatcher newKeyStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslKeystoreLocationProperty));\n<line4>    if (newKeyStoreFileWatcher != null) {\n<line5>        // stop old watcher if there is one\n<line6>        if (keyStoreFileWatcher != null) {\n<line7>            keyStoreFileWatcher.stop();\n<line8>        }\n<line9>        keyStoreFileWatcher = newKeyStoreFileWatcher;\n<line10>        keyStoreFileWatcher.start();\n<line11>    }\n<line12>    FileChangeWatcher newTrustStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslTruststoreLocationProperty));\n<line13>    if (newTrustStoreFileWatcher != null) {\n<line14>        // stop old watcher if there is one\n<line15>        if (trustStoreFileWatcher != null) {\n<line16>            trustStoreFileWatcher.stop();\n<line17>        }\n<line18>        trustStoreFileWatcher = newTrustStoreFileWatcher;\n<line19>        trustStoreFileWatcher.start();\n<line20>    }\n<line21>}","output":"<line1>{\n<line2>    LOG.info(\"enabling cert file reloading\");\n<line3>    ZKConfig config = new ZKConfig();\n<line4>    FileChangeWatcher newKeyStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslKeystoreLocationProperty));\n<line5>    if (newKeyStoreFileWatcher != null) {\n<line6>        // stop old watcher if there is one\n<line7>        if (keyStoreFileWatcher != null) {\n<line8>            keyStoreFileWatcher.stop();\n<line9>        }\n<line10>        keyStoreFileWatcher = newKeyStoreFileWatcher;\n<line11>        keyStoreFileWatcher.start();\n<line12>    }\n<line13>    FileChangeWatcher newTrustStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslTruststoreLocationProperty));\n<line14>    if (newTrustStoreFileWatcher != null) {\n<line15>        // stop old watcher if there is one\n<line16>        if (trustStoreFileWatcher != null) {\n<line17>            trustStoreFileWatcher.stop();\n<line18>        }\n<line19>        trustStoreFileWatcher = newTrustStoreFileWatcher;\n<line20>        trustStoreFileWatcher.start();\n<line21>    }\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean shouldResetContext = false;\n<line3>    Path dirPath = filePath.getParent();\n<line4>    if (event.kind().equals(StandardWatchEventKinds.OVERFLOW)) {\n<line5>        // If we get notified about possibly missed events, reload the key store / trust store just to be sure.\n<line6>        shouldResetContext = true;\n<line7>    } else if (event.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY) || event.kind().equals(StandardWatchEventKinds.ENTRY_CREATE)) {\n<line8>        Path eventFilePath = dirPath.resolve((Path) event.context());\n<line9>        if (filePath.equals(eventFilePath)) {\n<line10>            shouldResetContext = true;\n<line11>        }\n<line12>    }\n<line13>    // Note: we don't care about delete events\n<line14>    if (shouldResetContext) {\n<line15>        try {\n<line16>            this.resetDefaultSSLContextAndOptions();\n<line17>        } catch (SSLContextException e) {\n<line18>            throw new RuntimeException(e);\n<line19>        }\n<line20>    } else {\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    boolean shouldResetContext = false;\n<line3>    Path dirPath = filePath.getParent();\n<line4>    if (event.kind().equals(StandardWatchEventKinds.OVERFLOW)) {\n<line5>        // If we get notified about possibly missed events, reload the key store / trust store just to be sure.\n<line6>        shouldResetContext = true;\n<line7>    } else if (event.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY) || event.kind().equals(StandardWatchEventKinds.ENTRY_CREATE)) {\n<line8>        Path eventFilePath = dirPath.resolve((Path) event.context());\n<line9>        if (filePath.equals(eventFilePath)) {\n<line10>            shouldResetContext = true;\n<line11>        }\n<line12>    }\n<line13>    // Note: we don't care about delete events\n<line14>    if (shouldResetContext) {\n<line15>        LOG.debug(\"Attempting to reset default SSL context after receiving watch event: {} with context: {}\", event.kind(), event.context());\n<line16>        try {\n<line17>            this.resetDefaultSSLContextAndOptions();\n<line18>        } catch (SSLContextException e) {\n<line19>            throw new RuntimeException(e);\n<line20>        }\n<line21>    } else {\n<line22>        LOG.debug(\"Ignoring watch event and keeping previous default SSL context. Event kind: {} with context: {}\", event.kind(), event.context());\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        this.resetDefaultSSLContextAndOptions();\n<line4>    } catch (SSLContextException e) {\n<line5>        throw new RuntimeException(e);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.debug(\"Attempting to reset default SSL context after receiving watch event: {} with context: {}\", event.kind(), event.context());\n<line3>    try {\n<line4>        this.resetDefaultSSLContextAndOptions();\n<line5>    } catch (SSLContextException e) {\n<line6>        throw new RuntimeException(e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring watch event and keeping previous default SSL context. Event kind: {} with context: {}\", event.kind(), event.context());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        final Certificate[] certs = session.getPeerCertificates();\n<line4>        final X509Certificate x509 = (X509Certificate) certs[0];\n<line5>        verify(host, x509);\n<line6>        return true;\n<line7>    } catch (final SSLException ex) {\n<line8>        return false;\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    try {\n<line3>        final Certificate[] certs = session.getPeerCertificates();\n<line4>        final X509Certificate x509 = (X509Certificate) certs[0];\n<line5>        verify(host, x509);\n<line6>        return true;\n<line7>    } catch (final SSLException ex) {\n<line8>        log.debug(\"Unexpected exception\", ex);\n<line9>        return false;\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    return false;\n<line3>}","output":"<line1>{\n<line2>    log.debug(\"Unexpected exception\", ex);\n<line3>    return false;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    this();\n<line3>    addConfiguration(configFile);\n<line4>}","output":"<line1>{\n<line2>    this();\n<line3>    addConfiguration(configFile);\n<line4>    LOG.info(\"ZK Config {}\", this.properties);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (null == key) {\n<line3>        throw new IllegalArgumentException(\"property key is null.\");\n<line4>    }\n<line5>    String oldValue = properties.put(key, value);\n<line6>    if (null != oldValue && !oldValue.equals(value)) {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    if (null == key) {\n<line3>        throw new IllegalArgumentException(\"property key is null.\");\n<line4>    }\n<line5>    String oldValue = properties.put(key, value);\n<line6>    if (null != oldValue && !oldValue.equals(value)) {\n<line7>        LOG.debug(\"key {}'s value {} is replaced with new value {}\", key, oldValue, value);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"key {}'s value {} is replaced with new value {}\", key, oldValue, value);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).validate(configFile);\n<line4>        Properties cfg = new Properties();\n<line5>        FileInputStream in = new FileInputStream(configFile);\n<line6>        try {\n<line7>            cfg.load(in);\n<line8>        } finally {\n<line9>            in.close();\n<line10>        }\n<line11>        parseProperties(cfg);\n<line12>    } catch (IOException | IllegalArgumentException e) {\n<line13>        throw new ConfigException(\"Error while processing \" + configFile.getAbsolutePath(), e);\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    LOG.info(\"Reading configuration from: {}\", configFile.getAbsolutePath());\n<line3>    try {\n<line4>        configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).validate(configFile);\n<line5>        Properties cfg = new Properties();\n<line6>        FileInputStream in = new FileInputStream(configFile);\n<line7>        try {\n<line8>            cfg.load(in);\n<line9>        } finally {\n<line10>            in.close();\n<line11>        }\n<line12>        parseProperties(cfg);\n<line13>    } catch (IOException | IllegalArgumentException e) {\n<line14>        LOG.error(\"Error while configuration from: {}\", configFile.getAbsolutePath(), e);\n<line15>        throw new ConfigException(\"Error while processing \" + configFile.getAbsolutePath(), e);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new ConfigException(\"Error while processing \" + configFile.getAbsolutePath(), e);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error while configuration from: {}\", configFile.getAbsolutePath(), e);\n<line3>    throw new ConfigException(\"Error while processing \" + configFile.getAbsolutePath(), e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    x509ExtendedTrustManager.checkClientTrusted(chain, authType, socket);\n<line3>    if (clientHostnameVerificationEnabled) {\n<line4>        }\n<line5>        performHostVerification(socket.getInetAddress(), chain[0]);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    x509ExtendedTrustManager.checkClientTrusted(chain, authType, socket);\n<line3>    if (clientHostnameVerificationEnabled) {\n<line4>        if (LOG.isDebugEnabled()) {\n<line5>            LOG.debug(\"Check client trusted socket.getInetAddress(): {}, {}\", socket.getInetAddress(), socket);\n<line6>        }\n<line7>        performHostVerification(socket.getInetAddress(), chain[0]);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    performHostVerification(socket.getInetAddress(), chain[0]);\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Check client trusted socket.getInetAddress(): {}, {}\", socket.getInetAddress(), socket);\n<line4>    }\n<line5>    performHostVerification(socket.getInetAddress(), chain[0]);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Check client trusted socket.getInetAddress(): {}, {}\", socket.getInetAddress(), socket);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    x509ExtendedTrustManager.checkServerTrusted(chain, authType, socket);\n<line3>    if (serverHostnameVerificationEnabled) {\n<line4>        }\n<line5>        performHostVerification(socket.getInetAddress(), chain[0]);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    x509ExtendedTrustManager.checkServerTrusted(chain, authType, socket);\n<line3>    if (serverHostnameVerificationEnabled) {\n<line4>        if (LOG.isDebugEnabled()) {\n<line5>            LOG.debug(\"Check server trusted socket.getInetAddress(): {}, {}\", socket.getInetAddress(), socket);\n<line6>        }\n<line7>        performHostVerification(socket.getInetAddress(), chain[0]);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    performHostVerification(socket.getInetAddress(), chain[0]);\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Check server trusted socket.getInetAddress(): {}, {}\", socket.getInetAddress(), socket);\n<line4>    }\n<line5>    performHostVerification(socket.getInetAddress(), chain[0]);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Check server trusted socket.getInetAddress(): {}, {}\", socket.getInetAddress(), socket);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    x509ExtendedTrustManager.checkClientTrusted(chain, authType, engine);\n<line3>    if (clientHostnameVerificationEnabled) {\n<line4>        try {\n<line5>            }\n<line6>            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line7>        } catch (UnknownHostException e) {\n<line8>            throw new CertificateException(\"Failed to verify host\", e);\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    x509ExtendedTrustManager.checkClientTrusted(chain, authType, engine);\n<line3>    if (clientHostnameVerificationEnabled) {\n<line4>        try {\n<line5>            if (LOG.isDebugEnabled()) {\n<line6>                LOG.debug(\"Check client trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line7>            }\n<line8>            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line9>        } catch (UnknownHostException e) {\n<line10>            throw new CertificateException(\"Failed to verify host\", e);\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        }\n<line4>        performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line5>    } catch (UnknownHostException e) {\n<line6>        throw new CertificateException(\"Failed to verify host\", e);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        if (LOG.isDebugEnabled()) {\n<line4>            LOG.debug(\"Check client trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line5>        }\n<line6>        performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line7>    } catch (UnknownHostException e) {\n<line8>        throw new CertificateException(\"Failed to verify host\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Check client trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line4>    }\n<line5>    performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Check client trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    x509ExtendedTrustManager.checkServerTrusted(chain, authType, engine);\n<line3>    if (serverHostnameVerificationEnabled) {\n<line4>        try {\n<line5>            }\n<line6>            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line7>        } catch (UnknownHostException e) {\n<line8>            throw new CertificateException(\"Failed to verify host\", e);\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    x509ExtendedTrustManager.checkServerTrusted(chain, authType, engine);\n<line3>    if (serverHostnameVerificationEnabled) {\n<line4>        try {\n<line5>            if (LOG.isDebugEnabled()) {\n<line6>                LOG.debug(\"Check server trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line7>            }\n<line8>            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line9>        } catch (UnknownHostException e) {\n<line10>            throw new CertificateException(\"Failed to verify host\", e);\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        }\n<line4>        performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line5>    } catch (UnknownHostException e) {\n<line6>        throw new CertificateException(\"Failed to verify host\", e);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        if (LOG.isDebugEnabled()) {\n<line4>            LOG.debug(\"Check server trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line5>        }\n<line6>        performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line7>    } catch (UnknownHostException e) {\n<line8>        throw new CertificateException(\"Failed to verify host\", e);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Check server trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line4>    }\n<line5>    performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Check server trusted engine.getPeerHost(): {}, {}\", engine.getPeerHost(), engine);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String hostAddress = \"\";\n<line3>    String hostName = \"\";\n<line4>    try {\n<line5>        hostAddress = inetAddress.getHostAddress();\n<line6>        }\n<line7>        hostnameVerifier.verify(hostAddress, certificate);\n<line8>    } catch (SSLException addressVerificationException) {\n<line9>        try {\n<line10>            hostName = inetAddress.getHostName();\n<line11>            }\n<line12>            hostnameVerifier.verify(hostName, certificate);\n<line13>        } catch (SSLException hostnameVerificationException) {\n<line14>            throw new CertificateException(\"Failed to verify both host address and host name\", hostnameVerificationException);\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    String hostAddress = \"\";\n<line3>    String hostName = \"\";\n<line4>    try {\n<line5>        hostAddress = inetAddress.getHostAddress();\n<line6>        if (LOG.isDebugEnabled()) {\n<line7>            LOG.debug(\"Trying to verify host address first: {}\", hostAddress);\n<line8>        }\n<line9>        hostnameVerifier.verify(hostAddress, certificate);\n<line10>    } catch (SSLException addressVerificationException) {\n<line11>        try {\n<line12>            hostName = inetAddress.getHostName();\n<line13>            if (LOG.isDebugEnabled()) {\n<line14>                LOG.debug(\"Failed to verify host address: {}, trying to verify host name: {}\", hostAddress, hostName);\n<line15>            }\n<line16>            hostnameVerifier.verify(hostName, certificate);\n<line17>        } catch (SSLException hostnameVerificationException) {\n<line18>            LOG.error(\"Failed to verify host address: {}\", hostAddress, addressVerificationException);\n<line19>            LOG.error(\"Failed to verify hostname: {}\", hostName, hostnameVerificationException);\n<line20>            throw new CertificateException(\"Failed to verify both host address and host name\", hostnameVerificationException);\n<line21>        }\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    hostAddress = inetAddress.getHostAddress();\n<line3>    }\n<line4>    hostnameVerifier.verify(hostAddress, certificate);\n<line5>}","output":"<line1>{\n<line2>    hostAddress = inetAddress.getHostAddress();\n<line3>    if (LOG.isDebugEnabled()) {\n<line4>        LOG.debug(\"Trying to verify host address first: {}\", hostAddress);\n<line5>    }\n<line6>    hostnameVerifier.verify(hostAddress, certificate);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Trying to verify host address first: {}\", hostAddress);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        hostName = inetAddress.getHostName();\n<line4>        }\n<line5>        hostnameVerifier.verify(hostName, certificate);\n<line6>    } catch (SSLException hostnameVerificationException) {\n<line7>        throw new CertificateException(\"Failed to verify both host address and host name\", hostnameVerificationException);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    try {\n<line3>        hostName = inetAddress.getHostName();\n<line4>        if (LOG.isDebugEnabled()) {\n<line5>            LOG.debug(\"Failed to verify host address: {}, trying to verify host name: {}\", hostAddress, hostName);\n<line6>        }\n<line7>        hostnameVerifier.verify(hostName, certificate);\n<line8>    } catch (SSLException hostnameVerificationException) {\n<line9>        LOG.error(\"Failed to verify host address: {}\", hostAddress, addressVerificationException);\n<line10>        LOG.error(\"Failed to verify hostname: {}\", hostName, hostnameVerificationException);\n<line11>        throw new CertificateException(\"Failed to verify both host address and host name\", hostnameVerificationException);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    hostName = inetAddress.getHostName();\n<line3>    }\n<line4>    hostnameVerifier.verify(hostName, certificate);\n<line5>}","output":"<line1>{\n<line2>    hostName = inetAddress.getHostName();\n<line3>    if (LOG.isDebugEnabled()) {\n<line4>        LOG.debug(\"Failed to verify host address: {}, trying to verify host name: {}\", hostAddress, hostName);\n<line5>    }\n<line6>    hostnameVerifier.verify(hostName, certificate);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Failed to verify host address: {}, trying to verify host name: {}\", hostAddress, hostName);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new CertificateException(\"Failed to verify both host address and host name\", hostnameVerificationException);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to verify host address: {}\", hostAddress, addressVerificationException);\n<line3>    LOG.error(\"Failed to verify hostname: {}\", hostName, hostnameVerificationException);\n<line4>    throw new CertificateException(\"Failed to verify both host address and host name\", hostnameVerificationException);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Set<InetAddress> validInetAddresses = new HashSet<>();\n<line4>        Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();\n<line5>        for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {\n<line6>            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n<line7>                if (inetAddress.isLinkLocalAddress()) {\n<line8>                    continue;\n<line9>                }\n<line10>                if (inetAddress.isMulticastAddress()) {\n<line11>                    continue;\n<line12>                }\n<line13>                if (inetAddress.isLoopbackAddress()) {\n<line14>                    continue;\n<line15>                }\n<line16>                validInetAddresses.add(inetAddress);\n<line17>            }\n<line18>        }\n<line19>        return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;\n<line20>    } catch (SocketException ex) {\n<line21>        return DEFAULT_INET_ADDRESS_COUNT;\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    try {\n<line3>        Set<InetAddress> validInetAddresses = new HashSet<>();\n<line4>        Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();\n<line5>        for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {\n<line6>            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n<line7>                if (inetAddress.isLinkLocalAddress()) {\n<line8>                    LOG.debug(\"Ignoring link-local InetAddress {}\", inetAddress);\n<line9>                    continue;\n<line10>                }\n<line11>                if (inetAddress.isMulticastAddress()) {\n<line12>                    LOG.debug(\"Ignoring multicast InetAddress {}\", inetAddress);\n<line13>                    continue;\n<line14>                }\n<line15>                if (inetAddress.isLoopbackAddress()) {\n<line16>                    LOG.debug(\"Ignoring loopback InetAddress {}\", inetAddress);\n<line17>                    continue;\n<line18>                }\n<line19>                validInetAddresses.add(inetAddress);\n<line20>            }\n<line21>        }\n<line22>        LOG.debug(\"Detected {} local network addresses: {}\", validInetAddresses.size(), validInetAddresses);\n<line23>        return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;\n<line24>    } catch (SocketException ex) {\n<line25>        LOG.warn(\"Failed to list all network interfaces, assuming 1\", ex);\n<line26>        return DEFAULT_INET_ADDRESS_COUNT;\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    Set<InetAddress> validInetAddresses = new HashSet<>();\n<line3>    Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();\n<line4>    for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {\n<line5>        for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n<line6>            if (inetAddress.isLinkLocalAddress()) {\n<line7>                continue;\n<line8>            }\n<line9>            if (inetAddress.isMulticastAddress()) {\n<line10>                continue;\n<line11>            }\n<line12>            if (inetAddress.isLoopbackAddress()) {\n<line13>                continue;\n<line14>            }\n<line15>            validInetAddresses.add(inetAddress);\n<line16>        }\n<line17>    }\n<line18>    return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;\n<line19>}","output":"<line1>{\n<line2>    Set<InetAddress> validInetAddresses = new HashSet<>();\n<line3>    Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();\n<line4>    for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {\n<line5>        for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n<line6>            if (inetAddress.isLinkLocalAddress()) {\n<line7>                LOG.debug(\"Ignoring link-local InetAddress {}\", inetAddress);\n<line8>                continue;\n<line9>            }\n<line10>            if (inetAddress.isMulticastAddress()) {\n<line11>                LOG.debug(\"Ignoring multicast InetAddress {}\", inetAddress);\n<line12>                continue;\n<line13>            }\n<line14>            if (inetAddress.isLoopbackAddress()) {\n<line15>                LOG.debug(\"Ignoring loopback InetAddress {}\", inetAddress);\n<line16>                continue;\n<line17>            }\n<line18>            validInetAddresses.add(inetAddress);\n<line19>        }\n<line20>    }\n<line21>    LOG.debug(\"Detected {} local network addresses: {}\", validInetAddresses.size(), validInetAddresses);\n<line22>    return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n<line3>        if (inetAddress.isLinkLocalAddress()) {\n<line4>            continue;\n<line5>        }\n<line6>        if (inetAddress.isMulticastAddress()) {\n<line7>            continue;\n<line8>        }\n<line9>        if (inetAddress.isLoopbackAddress()) {\n<line10>            continue;\n<line11>        }\n<line12>        validInetAddresses.add(inetAddress);\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n<line3>        if (inetAddress.isLinkLocalAddress()) {\n<line4>            LOG.debug(\"Ignoring link-local InetAddress {}\", inetAddress);\n<line5>            continue;\n<line6>        }\n<line7>        if (inetAddress.isMulticastAddress()) {\n<line8>            LOG.debug(\"Ignoring multicast InetAddress {}\", inetAddress);\n<line9>            continue;\n<line10>        }\n<line11>        if (inetAddress.isLoopbackAddress()) {\n<line12>            LOG.debug(\"Ignoring loopback InetAddress {}\", inetAddress);\n<line13>            continue;\n<line14>        }\n<line15>        validInetAddresses.add(inetAddress);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    if (inetAddress.isLinkLocalAddress()) {\n<line3>        continue;\n<line4>    }\n<line5>    if (inetAddress.isMulticastAddress()) {\n<line6>        continue;\n<line7>    }\n<line8>    if (inetAddress.isLoopbackAddress()) {\n<line9>        continue;\n<line10>    }\n<line11>    validInetAddresses.add(inetAddress);\n<line12>}","output":"<line1>{\n<line2>    if (inetAddress.isLinkLocalAddress()) {\n<line3>        LOG.debug(\"Ignoring link-local InetAddress {}\", inetAddress);\n<line4>        continue;\n<line5>    }\n<line6>    if (inetAddress.isMulticastAddress()) {\n<line7>        LOG.debug(\"Ignoring multicast InetAddress {}\", inetAddress);\n<line8>        continue;\n<line9>    }\n<line10>    if (inetAddress.isLoopbackAddress()) {\n<line11>        LOG.debug(\"Ignoring loopback InetAddress {}\", inetAddress);\n<line12>        continue;\n<line13>    }\n<line14>    validInetAddresses.add(inetAddress);\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    continue;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring link-local InetAddress {}\", inetAddress);\n<line3>    continue;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    continue;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring multicast InetAddress {}\", inetAddress);\n<line3>    continue;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    continue;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring loopback InetAddress {}\", inetAddress);\n<line3>    continue;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        final String secretValue = new String(Files.readAllBytes(Paths.get(pathToFile)), StandardCharsets.UTF_8);\n<line4>        if (secretValue.endsWith(System.lineSeparator())) {\n<line5>            return secretValue.substring(0, secretValue.length() - System.lineSeparator().length()).toCharArray();\n<line6>        }\n<line7>        return secretValue.toCharArray();\n<line8>    } catch (final Throwable e) {\n<line9>        throw new IllegalStateException(\"Exception occurred when reading secret from file \" + pathToFile, e);\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.info(\"Reading secret from {}\", pathToFile);\n<line3>    try {\n<line4>        final String secretValue = new String(Files.readAllBytes(Paths.get(pathToFile)), StandardCharsets.UTF_8);\n<line5>        if (secretValue.endsWith(System.lineSeparator())) {\n<line6>            return secretValue.substring(0, secretValue.length() - System.lineSeparator().length()).toCharArray();\n<line7>        }\n<line8>        return secretValue.toCharArray();\n<line9>    } catch (final Throwable e) {\n<line10>        LOG.error(\"Exception occurred when reading secret from file {}\", pathToFile, e);\n<line11>        throw new IllegalStateException(\"Exception occurred when reading secret from file \" + pathToFile, e);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new IllegalStateException(\"Exception occurred when reading secret from file \" + pathToFile, e);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Exception occurred when reading secret from file {}\", pathToFile, e);\n<line3>    throw new IllegalStateException(\"Exception occurred when reading secret from file \" + pathToFile, e);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    Objects.requireNonNull(path, \"Path cannot be null\");\n<line3>    if (path.length() == 0) {\n<line4>        throw new IllegalArgumentException(\"Invalid path: \" + path);\n<line5>    }\n<line6>    final String[] pathComponents = split(path);\n<line7>    writeLock.lock();\n<line8>    try {\n<line9>        TrieNode parent = rootNode;\n<line10>        for (final String part : pathComponents) {\n<line11>            if (parent.getChild(part) == null) {\n<line12>                // the path does not exist\n<line13>                return;\n<line14>            }\n<line15>            parent = parent.getChild(part);\n<line16>        }\n<line17>        final TrieNode realParent = parent.getParent();\n<line18>        realParent.deleteChild(parent.getValue());\n<line19>    } finally {\n<line20>        writeLock.unlock();\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    Objects.requireNonNull(path, \"Path cannot be null\");\n<line3>    if (path.length() == 0) {\n<line4>        throw new IllegalArgumentException(\"Invalid path: \" + path);\n<line5>    }\n<line6>    final String[] pathComponents = split(path);\n<line7>    writeLock.lock();\n<line8>    try {\n<line9>        TrieNode parent = rootNode;\n<line10>        for (final String part : pathComponents) {\n<line11>            if (parent.getChild(part) == null) {\n<line12>                // the path does not exist\n<line13>                return;\n<line14>            }\n<line15>            parent = parent.getChild(part);\n<line16>            LOG.debug(\"{}\", parent);\n<line17>        }\n<line18>        final TrieNode realParent = parent.getParent();\n<line19>        realParent.deleteChild(parent.getValue());\n<line20>    } finally {\n<line21>        writeLock.unlock();\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    TrieNode parent = rootNode;\n<line3>    for (final String part : pathComponents) {\n<line4>        if (parent.getChild(part) == null) {\n<line5>            // the path does not exist\n<line6>            return;\n<line7>        }\n<line8>        parent = parent.getChild(part);\n<line9>    }\n<line10>    final TrieNode realParent = parent.getParent();\n<line11>    realParent.deleteChild(parent.getValue());\n<line12>}","output":"<line1>{\n<line2>    TrieNode parent = rootNode;\n<line3>    for (final String part : pathComponents) {\n<line4>        if (parent.getChild(part) == null) {\n<line5>            // the path does not exist\n<line6>            return;\n<line7>        }\n<line8>        parent = parent.getChild(part);\n<line9>        LOG.debug(\"{}\", parent);\n<line10>    }\n<line11>    final TrieNode realParent = parent.getParent();\n<line12>    realParent.deleteChild(parent.getValue());\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (parent.getChild(part) == null) {\n<line3>        // the path does not exist\n<line4>        return;\n<line5>    }\n<line6>    parent = parent.getChild(part);\n<line7>}","output":"<line1>{\n<line2>    if (parent.getChild(part) == null) {\n<line3>        // the path does not exist\n<line4>        return;\n<line5>    }\n<line6>    parent = parent.getChild(part);\n<line7>    LOG.debug(\"{}\", parent);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    Objects.requireNonNull(path, \"Path cannot be null\");\n<line3>    if (path.length() == 0) {\n<line4>        throw new IllegalArgumentException(\"Invalid path: \" + path);\n<line5>    }\n<line6>    final String[] pathComponents = split(path);\n<line7>    readLock.lock();\n<line8>    try {\n<line9>        TrieNode parent = rootNode;\n<line10>        for (final String part : pathComponents) {\n<line11>            if (parent.getChild(part) == null) {\n<line12>                // the path does not exist\n<line13>                return false;\n<line14>            }\n<line15>            parent = parent.getChild(part);\n<line16>        }\n<line17>    } finally {\n<line18>        readLock.unlock();\n<line19>    }\n<line20>    return true;\n<line21>}","output":"<line1>{\n<line2>    Objects.requireNonNull(path, \"Path cannot be null\");\n<line3>    if (path.length() == 0) {\n<line4>        throw new IllegalArgumentException(\"Invalid path: \" + path);\n<line5>    }\n<line6>    final String[] pathComponents = split(path);\n<line7>    readLock.lock();\n<line8>    try {\n<line9>        TrieNode parent = rootNode;\n<line10>        for (final String part : pathComponents) {\n<line11>            if (parent.getChild(part) == null) {\n<line12>                // the path does not exist\n<line13>                return false;\n<line14>            }\n<line15>            parent = parent.getChild(part);\n<line16>            LOG.debug(\"{}\", parent);\n<line17>        }\n<line18>    } finally {\n<line19>        readLock.unlock();\n<line20>    }\n<line21>    return true;\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>    TrieNode parent = rootNode;\n<line3>    for (final String part : pathComponents) {\n<line4>        if (parent.getChild(part) == null) {\n<line5>            // the path does not exist\n<line6>            return false;\n<line7>        }\n<line8>        parent = parent.getChild(part);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    TrieNode parent = rootNode;\n<line3>    for (final String part : pathComponents) {\n<line4>        if (parent.getChild(part) == null) {\n<line5>            // the path does not exist\n<line6>            return false;\n<line7>        }\n<line8>        parent = parent.getChild(part);\n<line9>        LOG.debug(\"{}\", parent);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    if (parent.getChild(part) == null) {\n<line3>        // the path does not exist\n<line4>        return false;\n<line5>    }\n<line6>    parent = parent.getChild(part);\n<line7>}","output":"<line1>{\n<line2>    if (parent.getChild(part) == null) {\n<line3>        // the path does not exist\n<line4>        return false;\n<line5>    }\n<line6>    parent = parent.getChild(part);\n<line7>    LOG.debug(\"{}\", parent);\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    Objects.requireNonNull(path, \"Path cannot be null\");\n<line3>    final String[] pathComponents = split(path);\n<line4>    readLock.lock();\n<line5>    try {\n<line6>        TrieNode parent = rootNode;\n<line7>        TrieNode deepestPropertyNode = null;\n<line8>        for (final String element : pathComponents) {\n<line9>            parent = parent.getChild(element);\n<line10>            if (parent == null) {\n<line11>                break;\n<line12>            }\n<line13>            if (parent.hasProperty()) {\n<line14>                deepestPropertyNode = parent;\n<line15>            }\n<line16>        }\n<line17>        if (deepestPropertyNode == null) {\n<line18>            return \"/\";\n<line19>        }\n<line20>        final Deque<String> treePath = new ArrayDeque<>();\n<line21>        TrieNode node = deepestPropertyNode;\n<line22>        while (node != this.rootNode) {\n<line23>            treePath.offerFirst(node.getValue());\n<line24>            node = node.parent;\n<line25>        }\n<line26>        return \"/\" + String.join(\"/\", treePath);\n<line27>    } finally {\n<line28>        readLock.unlock();\n<line29>    }\n<line30>}","output":"<line1>{\n<line2>    Objects.requireNonNull(path, \"Path cannot be null\");\n<line3>    final String[] pathComponents = split(path);\n<line4>    readLock.lock();\n<line5>    try {\n<line6>        TrieNode parent = rootNode;\n<line7>        TrieNode deepestPropertyNode = null;\n<line8>        for (final String element : pathComponents) {\n<line9>            parent = parent.getChild(element);\n<line10>            if (parent == null) {\n<line11>                LOG.debug(\"{}\", element);\n<line12>                break;\n<line13>            }\n<line14>            if (parent.hasProperty()) {\n<line15>                deepestPropertyNode = parent;\n<line16>            }\n<line17>        }\n<line18>        if (deepestPropertyNode == null) {\n<line19>            return \"/\";\n<line20>        }\n<line21>        final Deque<String> treePath = new ArrayDeque<>();\n<line22>        TrieNode node = deepestPropertyNode;\n<line23>        while (node != this.rootNode) {\n<line24>            treePath.offerFirst(node.getValue());\n<line25>            node = node.parent;\n<line26>        }\n<line27>        return \"/\" + String.join(\"/\", treePath);\n<line28>    } finally {\n<line29>        readLock.unlock();\n<line30>    }\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    TrieNode parent = rootNode;\n<line3>    TrieNode deepestPropertyNode = null;\n<line4>    for (final String element : pathComponents) {\n<line5>        parent = parent.getChild(element);\n<line6>        if (parent == null) {\n<line7>            break;\n<line8>        }\n<line9>        if (parent.hasProperty()) {\n<line10>            deepestPropertyNode = parent;\n<line11>        }\n<line12>    }\n<line13>    if (deepestPropertyNode == null) {\n<line14>        return \"/\";\n<line15>    }\n<line16>    final Deque<String> treePath = new ArrayDeque<>();\n<line17>    TrieNode node = deepestPropertyNode;\n<line18>    while (node != this.rootNode) {\n<line19>        treePath.offerFirst(node.getValue());\n<line20>        node = node.parent;\n<line21>    }\n<line22>    return \"/\" + String.join(\"/\", treePath);\n<line23>}","output":"<line1>{\n<line2>    TrieNode parent = rootNode;\n<line3>    TrieNode deepestPropertyNode = null;\n<line4>    for (final String element : pathComponents) {\n<line5>        parent = parent.getChild(element);\n<line6>        if (parent == null) {\n<line7>            LOG.debug(\"{}\", element);\n<line8>            break;\n<line9>        }\n<line10>        if (parent.hasProperty()) {\n<line11>            deepestPropertyNode = parent;\n<line12>        }\n<line13>    }\n<line14>    if (deepestPropertyNode == null) {\n<line15>        return \"/\";\n<line16>    }\n<line17>    final Deque<String> treePath = new ArrayDeque<>();\n<line18>    TrieNode node = deepestPropertyNode;\n<line19>    while (node != this.rootNode) {\n<line20>        treePath.offerFirst(node.getValue());\n<line21>        node = node.parent;\n<line22>    }\n<line23>    return \"/\" + String.join(\"/\", treePath);\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    parent = parent.getChild(element);\n<line3>    if (parent == null) {\n<line4>        break;\n<line5>    }\n<line6>    if (parent.hasProperty()) {\n<line7>        deepestPropertyNode = parent;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    parent = parent.getChild(element);\n<line3>    if (parent == null) {\n<line4>        LOG.debug(\"{}\", element);\n<line5>        break;\n<line6>    }\n<line7>    if (parent.hasProperty()) {\n<line8>        deepestPropertyNode = parent;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"{}\", element);\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    return new DelegatingSslContext(sslContext) {\n<line3>\n<line4>        @Override\n<line5>        protected void initEngine(SSLEngine sslEngine) {\n<line6>            SSLParameters sslParameters = sslEngine.getSSLParameters();\n<line7>            sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n<line8>            sslEngine.setSSLParameters(sslParameters);\n<line9>            }\n<line10>        }\n<line11>    };\n<line12>}","output":"<line1>{\n<line2>    return new DelegatingSslContext(sslContext) {\n<line3>\n<line4>        @Override\n<line5>        protected void initEngine(SSLEngine sslEngine) {\n<line6>            SSLParameters sslParameters = sslEngine.getSSLParameters();\n<line7>            sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n<line8>            sslEngine.setSSLParameters(sslParameters);\n<line9>            if (LOG.isDebugEnabled()) {\n<line10>                LOG.debug(\"{} hostname verification: enabled HTTPS style endpoint identification algorithm\", clientOrServer);\n<line11>            }\n<line12>        }\n<line13>    };\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    SSLParameters sslParameters = sslEngine.getSSLParameters();\n<line3>    sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n<line4>    sslEngine.setSSLParameters(sslParameters);\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    SSLParameters sslParameters = sslEngine.getSSLParameters();\n<line3>    sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n<line4>    sslEngine.setSSLParameters(sslParameters);\n<line5>    if (LOG.isDebugEnabled()) {\n<line6>        LOG.debug(\"{} hostname verification: enabled HTTPS style endpoint identification algorithm\", clientOrServer);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"{} hostname verification: enabled HTTPS style endpoint identification algorithm\", clientOrServer);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (cipherSuites != null) {\n<line3>        sslParameters.setCipherSuites(cipherSuites);\n<line4>    }\n<line5>    if (enabledProtocols != null) {\n<line6>        sslParameters.setProtocols(enabledProtocols);\n<line7>    }\n<line8>    if (!isClientSocket) {\n<line9>        switch(clientAuth) {\n<line10>            case NEED:\n<line11>                sslParameters.setNeedClientAuth(true);\n<line12>                break;\n<line13>            case WANT:\n<line14>                sslParameters.setWantClientAuth(true);\n<line15>                break;\n<line16>            default:\n<line17>                // also clears the wantClientAuth flag according to docs\n<line18>                sslParameters.setNeedClientAuth(false);\n<line19>                break;\n<line20>        }\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    if (cipherSuites != null) {\n<line3>        LOG.debug(\"Setup cipher suites for {} socket: {}\", isClientSocket ? \"client\" : \"server\", Arrays.toString(cipherSuites));\n<line4>        sslParameters.setCipherSuites(cipherSuites);\n<line5>    }\n<line6>    if (enabledProtocols != null) {\n<line7>        LOG.debug(\"Setup enabled protocols for {} socket: {}\", isClientSocket ? \"client\" : \"server\", Arrays.toString(enabledProtocols));\n<line8>        sslParameters.setProtocols(enabledProtocols);\n<line9>    }\n<line10>    if (!isClientSocket) {\n<line11>        switch(clientAuth) {\n<line12>            case NEED:\n<line13>                sslParameters.setNeedClientAuth(true);\n<line14>                break;\n<line15>            case WANT:\n<line16>                sslParameters.setWantClientAuth(true);\n<line17>                break;\n<line18>            default:\n<line19>                // also clears the wantClientAuth flag according to docs\n<line20>                sslParameters.setNeedClientAuth(false);\n<line21>                break;\n<line22>        }\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    sslParameters.setCipherSuites(cipherSuites);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Setup cipher suites for {} socket: {}\", isClientSocket ? \"client\" : \"server\", Arrays.toString(cipherSuites));\n<line3>    sslParameters.setCipherSuites(cipherSuites);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    sslParameters.setProtocols(enabledProtocols);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Setup enabled protocols for {} socket: {}\", isClientSocket ? \"client\" : \"server\", Arrays.toString(enabledProtocols));\n<line3>    sslParameters.setProtocols(enabledProtocols);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    FileSystem fs = dirPath.getFileSystem();\n<line3>    WatchService watchService = fs.newWatchService();\n<line4>    dirPath.register(watchService, new WatchEvent.Kind<?>[] { StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.OVERFLOW });\n<line5>    state = State.NEW;\n<line6>    this.watcherThread = new WatcherThread(watchService, callback);\n<line7>    this.watcherThread.setDaemon(true);\n<line8>}","output":"<line1>{\n<line2>    FileSystem fs = dirPath.getFileSystem();\n<line3>    WatchService watchService = fs.newWatchService();\n<line4>    LOG.debug(\"Registering with watch service: {}\", dirPath);\n<line5>    dirPath.register(watchService, new WatchEvent.Kind<?>[] { StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.OVERFLOW });\n<line6>    state = State.NEW;\n<line7>    this.watcherThread = new WatcherThread(watchService, callback);\n<line8>    this.watcherThread.setDaemon(true);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {\n<line4>            // stop() called shortly after start(), before\n<line5>            // this thread started running.\n<line6>            FileChangeWatcher.State state = FileChangeWatcher.this.getState();\n<line7>            if (state != FileChangeWatcher.State.STOPPING) {\n<line8>                throw new IllegalStateException(\"Unexpected state: \" + state);\n<line9>            }\n<line10>            return;\n<line11>        }\n<line12>        runLoop();\n<line13>    } catch (Exception e) {\n<line14>        throw e;\n<line15>    } finally {\n<line16>        try {\n<line17>            watchService.close();\n<line18>        } catch (IOException e) {\n<line19>        }\n<line20>        FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"{} thread started\", getName());\n<line4>        if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {\n<line5>            // stop() called shortly after start(), before\n<line6>            // this thread started running.\n<line7>            FileChangeWatcher.State state = FileChangeWatcher.this.getState();\n<line8>            if (state != FileChangeWatcher.State.STOPPING) {\n<line9>                throw new IllegalStateException(\"Unexpected state: \" + state);\n<line10>            }\n<line11>            return;\n<line12>        }\n<line13>        runLoop();\n<line14>    } catch (Exception e) {\n<line15>        LOG.warn(\"Error in runLoop()\", e);\n<line16>        throw e;\n<line17>    } finally {\n<line18>        try {\n<line19>            watchService.close();\n<line20>        } catch (IOException e) {\n<line21>            LOG.warn(\"Error closing watch service\", e);\n<line22>        }\n<line23>        LOG.info(\"{} thread finished\", getName());\n<line24>        FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {\n<line3>        // stop() called shortly after start(), before\n<line4>        // this thread started running.\n<line5>        FileChangeWatcher.State state = FileChangeWatcher.this.getState();\n<line6>        if (state != FileChangeWatcher.State.STOPPING) {\n<line7>            throw new IllegalStateException(\"Unexpected state: \" + state);\n<line8>        }\n<line9>        return;\n<line10>    }\n<line11>    runLoop();\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"{} thread started\", getName());\n<line3>    if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {\n<line4>        // stop() called shortly after start(), before\n<line5>        // this thread started running.\n<line6>        FileChangeWatcher.State state = FileChangeWatcher.this.getState();\n<line7>        if (state != FileChangeWatcher.State.STOPPING) {\n<line8>            throw new IllegalStateException(\"Unexpected state: \" + state);\n<line9>        }\n<line10>        return;\n<line11>    }\n<line12>    runLoop();\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        watchService.close();\n<line4>    } catch (IOException e) {\n<line5>    }\n<line6>    FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        watchService.close();\n<line4>    } catch (IOException e) {\n<line5>        LOG.warn(\"Error closing watch service\", e);\n<line6>    }\n<line7>    LOG.info(\"{} thread finished\", getName());\n<line8>    FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    while (FileChangeWatcher.this.getState() == FileChangeWatcher.State.RUNNING) {\n<line3>        WatchKey key;\n<line4>        try {\n<line5>            key = watchService.take();\n<line6>        } catch (InterruptedException | ClosedWatchServiceException e) {\n<line7>            break;\n<line8>        }\n<line9>        for (WatchEvent<?> event : key.pollEvents()) {\n<line10>            try {\n<line11>                callback.accept(event);\n<line12>            } catch (Throwable e) {\n<line13>            }\n<line14>        }\n<line15>        boolean isKeyValid = key.reset();\n<line16>        if (!isKeyValid) {\n<line17>            // This is likely a problem, it means that file reloading is broken, probably because the\n<line18>            // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions\n<line19>            // changed, ???).\n<line20>            // For now, we log an error and exit the watcher thread.\n<line21>            break;\n<line22>        }\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    while (FileChangeWatcher.this.getState() == FileChangeWatcher.State.RUNNING) {\n<line3>        WatchKey key;\n<line4>        try {\n<line5>            key = watchService.take();\n<line6>        } catch (InterruptedException | ClosedWatchServiceException e) {\n<line7>            LOG.debug(\"{} was interrupted and is shutting down...\", getName());\n<line8>            break;\n<line9>        }\n<line10>        for (WatchEvent<?> event : key.pollEvents()) {\n<line11>            LOG.debug(\"Got file changed event: {} with context: {}\", event.kind(), event.context());\n<line12>            try {\n<line13>                callback.accept(event);\n<line14>            } catch (Throwable e) {\n<line15>                LOG.error(\"Error from callback\", e);\n<line16>            }\n<line17>        }\n<line18>        boolean isKeyValid = key.reset();\n<line19>        if (!isKeyValid) {\n<line20>            // This is likely a problem, it means that file reloading is broken, probably because the\n<line21>            // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions\n<line22>            // changed, ???).\n<line23>            // For now, we log an error and exit the watcher thread.\n<line24>            LOG.error(\"Watch key no longer valid, maybe the directory is inaccessible?\");\n<line25>            break;\n<line26>        }\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    WatchKey key;\n<line3>    try {\n<line4>        key = watchService.take();\n<line5>    } catch (InterruptedException | ClosedWatchServiceException e) {\n<line6>        break;\n<line7>    }\n<line8>    for (WatchEvent<?> event : key.pollEvents()) {\n<line9>        try {\n<line10>            callback.accept(event);\n<line11>        } catch (Throwable e) {\n<line12>        }\n<line13>    }\n<line14>    boolean isKeyValid = key.reset();\n<line15>    if (!isKeyValid) {\n<line16>        // This is likely a problem, it means that file reloading is broken, probably because the\n<line17>        // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions\n<line18>        // changed, ???).\n<line19>        // For now, we log an error and exit the watcher thread.\n<line20>        break;\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    WatchKey key;\n<line3>    try {\n<line4>        key = watchService.take();\n<line5>    } catch (InterruptedException | ClosedWatchServiceException e) {\n<line6>        LOG.debug(\"{} was interrupted and is shutting down...\", getName());\n<line7>        break;\n<line8>    }\n<line9>    for (WatchEvent<?> event : key.pollEvents()) {\n<line10>        LOG.debug(\"Got file changed event: {} with context: {}\", event.kind(), event.context());\n<line11>        try {\n<line12>            callback.accept(event);\n<line13>        } catch (Throwable e) {\n<line14>            LOG.error(\"Error from callback\", e);\n<line15>        }\n<line16>    }\n<line17>    boolean isKeyValid = key.reset();\n<line18>    if (!isKeyValid) {\n<line19>        // This is likely a problem, it means that file reloading is broken, probably because the\n<line20>        // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions\n<line21>        // changed, ???).\n<line22>        // For now, we log an error and exit the watcher thread.\n<line23>        LOG.error(\"Watch key no longer valid, maybe the directory is inaccessible?\");\n<line24>        break;\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    break;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"{} was interrupted and is shutting down...\", getName());\n<line3>    break;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        callback.accept(event);\n<line4>    } catch (Throwable e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.debug(\"Got file changed event: {} with context: {}\", event.kind(), event.context());\n<line3>    try {\n<line4>        callback.accept(event);\n<line5>    } catch (Throwable e) {\n<line6>        LOG.error(\"Error from callback\", e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error from callback\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    // This is likely a problem, it means that file reloading is broken, probably because the\n<line3>    // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions\n<line4>    // changed, ???).\n<line5>    // For now, we log an error and exit the watcher thread.\n<line6>    break;\n<line7>}","output":"<line1>{\n<line2>    // This is likely a problem, it means that file reloading is broken, probably because the\n<line3>    // directory we are watching was deleted or otherwise became inaccessible (unmounted, permissions\n<line4>    // changed, ???).\n<line5>    // For now, we log an error and exit the watcher thread.\n<line6>    LOG.error(\"Watch key no longer valid, maybe the directory is inaccessible?\");\n<line7>    break;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    PathUtils.validatePath(pathRoot);\n<line3>    List<String> tree = listSubTreeBFS(zk, pathRoot);\n<line4>    if (batchSize > 0) {\n<line5>        return deleteInBatch(zk, tree, batchSize);\n<line6>    } else {\n<line7>        for (int i = tree.size() - 1; i >= 0; --i) {\n<line8>            //Delete the leaves first and eventually get rid of the root\n<line9>            //Delete all versions of the node with -1.\n<line10>            zk.delete(tree.get(i), -1);\n<line11>        }\n<line12>        return true;\n<line13>    }\n<line14>}","output":"<line1>{\n<line2>    PathUtils.validatePath(pathRoot);\n<line3>    List<String> tree = listSubTreeBFS(zk, pathRoot);\n<line4>    LOG.debug(\"Deleting tree: {}\", tree);\n<line5>    if (batchSize > 0) {\n<line6>        return deleteInBatch(zk, tree, batchSize);\n<line7>    } else {\n<line8>        for (int i = tree.size() - 1; i >= 0; --i) {\n<line9>            //Delete the leaves first and eventually get rid of the root\n<line10>            //Delete all versions of the node with -1.\n<line11>            zk.delete(tree.get(i), -1);\n<line12>        }\n<line13>        return true;\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    PathUtils.validatePath(pathRoot);\n<line3>    List<String> tree = listSubTreeBFS(zk, pathRoot);\n<line4>    for (int i = tree.size() - 1; i >= 0; --i) {\n<line5>        //Delete the leaves first and eventually get rid of the root\n<line6>        //Delete all versions of the node with -1.\n<line7>        zk.delete(tree.get(i), -1, cb, ctx);\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    PathUtils.validatePath(pathRoot);\n<line3>    List<String> tree = listSubTreeBFS(zk, pathRoot);\n<line4>    LOG.debug(\"Deleting tree: {}\", tree);\n<line5>    for (int i = tree.size() - 1; i >= 0; --i) {\n<line6>        //Delete the leaves first and eventually get rid of the root\n<line7>        //Delete all versions of the node with -1.\n<line8>        zk.delete(tree.get(i), -1, cb, ctx);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (auditEvent.getResult() == Result.FAILURE) {\n<line3>    } else {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (auditEvent.getResult() == Result.FAILURE) {\n<line3>        LOG.error(auditEvent.toString());\n<line4>    } else {\n<line5>        LOG.info(auditEvent.toString());\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(auditEvent.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(auditEvent.toString());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    auditEnabled = Boolean.getBoolean(AUDIT_ENABLE);\n<line3>    if (auditEnabled) {\n<line4>        //initialise only when audit logging is enabled\n<line5>        auditLogger = getAuditLogger();\n<line6>    } else {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    auditEnabled = Boolean.getBoolean(AUDIT_ENABLE);\n<line3>    if (auditEnabled) {\n<line4>        //initialise only when audit logging is enabled\n<line5>        auditLogger = getAuditLogger();\n<line6>        LOG.info(\"ZooKeeper audit is enabled.\");\n<line7>    } else {\n<line8>        LOG.info(\"ZooKeeper audit is disabled.\");\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    //initialise only when audit logging is enabled\n<line3>    auditLogger = getAuditLogger();\n<line4>}","output":"<line1>{\n<line2>    //initialise only when audit logging is enabled\n<line3>    auditLogger = getAuditLogger();\n<line4>    LOG.info(\"ZooKeeper audit is enabled.\");\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"ZooKeeper audit is disabled.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!ZKAuditProvider.isAuditEnabled()) {\n<line3>        return;\n<line4>    }\n<line5>    String op;\n<line6>    //For failed transaction rc.path is null\n<line7>    String path = txnResult.path;\n<line8>    String acls = null;\n<line9>    String createMode = null;\n<line10>    try {\n<line11>        switch(request.type) {\n<line12>            case ZooDefs.OpCode.create:\n<line13>            case ZooDefs.OpCode.create2:\n<line14>            case ZooDefs.OpCode.createContainer:\n<line15>                op = AuditConstants.OP_CREATE;\n<line16>                CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line17>                createMode = getCreateMode(createRequest);\n<line18>                if (failedTxn) {\n<line19>                    path = createRequest.getPath();\n<line20>                }\n<line21>                break;\n<line22>            case ZooDefs.OpCode.delete:\n<line23>            case ZooDefs.OpCode.deleteContainer:\n<line24>                op = AuditConstants.OP_DELETE;\n<line25>                if (failedTxn) {\n<line26>                    DeleteRequest deleteRequest = request.readRequestRecord(DeleteRequest::new);\n<line27>                    path = deleteRequest.getPath();\n<line28>                }\n<line29>                break;\n<line30>            case ZooDefs.OpCode.setData:\n<line31>                op = AuditConstants.OP_SETDATA;\n<line32>                if (failedTxn) {\n<line33>                    SetDataRequest setDataRequest = request.readRequestRecord(SetDataRequest::new);\n<line34>                    path = setDataRequest.getPath();\n<line35>                }\n<line36>                break;\n<line37>            case ZooDefs.OpCode.setACL:\n<line38>                op = AuditConstants.OP_SETACL;\n<line39>                SetACLRequest setACLRequest = request.readRequestRecord(SetACLRequest::new);\n<line40>                acls = ZKUtil.aclToString(setACLRequest.getAcl());\n<line41>                if (failedTxn) {\n<line42>                    path = setACLRequest.getPath();\n<line43>                }\n<line44>                break;\n<line45>            case ZooDefs.OpCode.multi:\n<line46>                if (failedTxn) {\n<line47>                    op = AuditConstants.OP_MULTI_OP;\n<line48>                } else {\n<line49>                    logMultiOperation(request, txnResult);\n<line50>                    //operation si already logged\n<line51>                    return;\n<line52>                }\n<line53>                break;\n<line54>            case ZooDefs.OpCode.reconfig:\n<line55>                op = AuditConstants.OP_RECONFIG;\n<line56>                break;\n<line57>            default:\n<line58>                //Not an audit log operation\n<line59>                return;\n<line60>        }\n<line61>        Result result = getResult(txnResult, failedTxn);\n<line62>        log(request, path, op, acls, createMode, result);\n<line63>    } catch (Throwable e) {\n<line64>    }\n<line65>}","output":"<line1>{\n<line2>    if (!ZKAuditProvider.isAuditEnabled()) {\n<line3>        return;\n<line4>    }\n<line5>    String op;\n<line6>    //For failed transaction rc.path is null\n<line7>    String path = txnResult.path;\n<line8>    String acls = null;\n<line9>    String createMode = null;\n<line10>    try {\n<line11>        switch(request.type) {\n<line12>            case ZooDefs.OpCode.create:\n<line13>            case ZooDefs.OpCode.create2:\n<line14>            case ZooDefs.OpCode.createContainer:\n<line15>                op = AuditConstants.OP_CREATE;\n<line16>                CreateRequest createRequest = request.readRequestRecord(CreateRequest::new);\n<line17>                createMode = getCreateMode(createRequest);\n<line18>                if (failedTxn) {\n<line19>                    path = createRequest.getPath();\n<line20>                }\n<line21>                break;\n<line22>            case ZooDefs.OpCode.delete:\n<line23>            case ZooDefs.OpCode.deleteContainer:\n<line24>                op = AuditConstants.OP_DELETE;\n<line25>                if (failedTxn) {\n<line26>                    DeleteRequest deleteRequest = request.readRequestRecord(DeleteRequest::new);\n<line27>                    path = deleteRequest.getPath();\n<line28>                }\n<line29>                break;\n<line30>            case ZooDefs.OpCode.setData:\n<line31>                op = AuditConstants.OP_SETDATA;\n<line32>                if (failedTxn) {\n<line33>                    SetDataRequest setDataRequest = request.readRequestRecord(SetDataRequest::new);\n<line34>                    path = setDataRequest.getPath();\n<line35>                }\n<line36>                break;\n<line37>            case ZooDefs.OpCode.setACL:\n<line38>                op = AuditConstants.OP_SETACL;\n<line39>                SetACLRequest setACLRequest = request.readRequestRecord(SetACLRequest::new);\n<line40>                acls = ZKUtil.aclToString(setACLRequest.getAcl());\n<line41>                if (failedTxn) {\n<line42>                    path = setACLRequest.getPath();\n<line43>                }\n<line44>                break;\n<line45>            case ZooDefs.OpCode.multi:\n<line46>                if (failedTxn) {\n<line47>                    op = AuditConstants.OP_MULTI_OP;\n<line48>                } else {\n<line49>                    logMultiOperation(request, txnResult);\n<line50>                    //operation si already logged\n<line51>                    return;\n<line52>                }\n<line53>                break;\n<line54>            case ZooDefs.OpCode.reconfig:\n<line55>                op = AuditConstants.OP_RECONFIG;\n<line56>                break;\n<line57>            default:\n<line58>                //Not an audit log operation\n<line59>                return;\n<line60>        }\n<line61>        Result result = getResult(txnResult, failedTxn);\n<line62>        log(request, path, op, acls, createMode, result);\n<line63>    } catch (Throwable e) {\n<line64>        LOG.error(\"Failed to audit log request {}\", request.type, e);\n<line65>    }\n<line66>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Failed to audit log request {}\", request.type, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        isRunning = true;\n<line4>        while (true) {\n<line5>            Object event = waitingEvents.take();\n<line6>            if (event == eventOfDeath) {\n<line7>                wasKilled = true;\n<line8>            } else {\n<line9>                processEvent(event);\n<line10>            }\n<line11>            if (wasKilled) {\n<line12>                synchronized (waitingEvents) {\n<line13>                    if (waitingEvents.isEmpty()) {\n<line14>                        isRunning = false;\n<line15>                        break;\n<line16>                    }\n<line17>                }\n<line18>            }\n<line19>        }\n<line20>    } catch (InterruptedException e) {\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    try {\n<line3>        isRunning = true;\n<line4>        while (true) {\n<line5>            Object event = waitingEvents.take();\n<line6>            if (event == eventOfDeath) {\n<line7>                wasKilled = true;\n<line8>            } else {\n<line9>                processEvent(event);\n<line10>            }\n<line11>            if (wasKilled) {\n<line12>                synchronized (waitingEvents) {\n<line13>                    if (waitingEvents.isEmpty()) {\n<line14>                        isRunning = false;\n<line15>                        break;\n<line16>                    }\n<line17>                }\n<line18>            }\n<line19>        }\n<line20>    } catch (InterruptedException e) {\n<line21>        LOG.error(\"Event thread exiting due to interruption\", e);\n<line22>    }\n<line23>    LOG.info(\"EventThread shut down for session: 0x{}\", Long.toHexString(getSessionId()));\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Event thread exiting due to interruption\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (event instanceof WatcherSetEventPair) {\n<line4>            // each watcher will process the event\n<line5>            WatcherSetEventPair pair = (WatcherSetEventPair) event;\n<line6>            for (Watcher watcher : pair.watchers) {\n<line7>                try {\n<line8>                    watcher.process(pair.event);\n<line9>                } catch (Throwable t) {\n<line10>                }\n<line11>            }\n<line12>        } else if (event instanceof LocalCallback) {\n<line13>            LocalCallback lcb = (LocalCallback) event;\n<line14>            if (lcb.cb instanceof StatCallback) {\n<line15>                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line16>            } else if (lcb.cb instanceof DataCallback) {\n<line17>                ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line18>            } else if (lcb.cb instanceof ACLCallback) {\n<line19>                ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line20>            } else if (lcb.cb instanceof ChildrenCallback) {\n<line21>                ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line22>            } else if (lcb.cb instanceof Children2Callback) {\n<line23>                ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line24>            } else if (lcb.cb instanceof StringCallback) {\n<line25>                ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line26>            } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {\n<line27>                ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);\n<line28>            } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {\n<line29>                ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);\n<line30>            } else if (lcb.cb instanceof AsyncCallback.MultiCallback) {\n<line31>                ((AsyncCallback.MultiCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, Collections.emptyList());\n<line32>            } else {\n<line33>                ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);\n<line34>            }\n<line35>        } else {\n<line36>            Packet p = (Packet) event;\n<line37>            int rc = 0;\n<line38>            String clientPath = p.clientPath;\n<line39>            if (p.replyHeader.getErr() != 0) {\n<line40>                rc = p.replyHeader.getErr();\n<line41>            }\n<line42>            if (p.cb == null) {\n<line43>            } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {\n<line44>                StatCallback cb = (StatCallback) p.cb;\n<line45>                if (rc == Code.OK.intValue()) {\n<line46>                    if (p.response instanceof ExistsResponse) {\n<line47>                        cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());\n<line48>                    } else if (p.response instanceof SetDataResponse) {\n<line49>                        cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());\n<line50>                    } else if (p.response instanceof SetACLResponse) {\n<line51>                        cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());\n<line52>                    }\n<line53>                } else {\n<line54>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line55>                }\n<line56>            } else if (p.response instanceof GetDataResponse) {\n<line57>                DataCallback cb = (DataCallback) p.cb;\n<line58>                GetDataResponse rsp = (GetDataResponse) p.response;\n<line59>                if (rc == Code.OK.intValue()) {\n<line60>                    cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());\n<line61>                } else {\n<line62>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line63>                }\n<line64>            } else if (p.response instanceof GetACLResponse) {\n<line65>                ACLCallback cb = (ACLCallback) p.cb;\n<line66>                GetACLResponse rsp = (GetACLResponse) p.response;\n<line67>                if (rc == Code.OK.intValue()) {\n<line68>                    cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());\n<line69>                } else {\n<line70>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line71>                }\n<line72>            } else if (p.response instanceof GetChildrenResponse) {\n<line73>                ChildrenCallback cb = (ChildrenCallback) p.cb;\n<line74>                GetChildrenResponse rsp = (GetChildrenResponse) p.response;\n<line75>                if (rc == Code.OK.intValue()) {\n<line76>                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());\n<line77>                } else {\n<line78>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line79>                }\n<line80>            } else if (p.response instanceof GetAllChildrenNumberResponse) {\n<line81>                AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;\n<line82>                GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;\n<line83>                if (rc == Code.OK.intValue()) {\n<line84>                    cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());\n<line85>                } else {\n<line86>                    cb.processResult(rc, clientPath, p.ctx, -1);\n<line87>                }\n<line88>            } else if (p.response instanceof GetChildren2Response) {\n<line89>                Children2Callback cb = (Children2Callback) p.cb;\n<line90>                GetChildren2Response rsp = (GetChildren2Response) p.response;\n<line91>                if (rc == Code.OK.intValue()) {\n<line92>                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());\n<line93>                } else {\n<line94>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line95>                }\n<line96>            } else if (p.response instanceof CreateResponse) {\n<line97>                StringCallback cb = (StringCallback) p.cb;\n<line98>                CreateResponse rsp = (CreateResponse) p.response;\n<line99>                if (rc == Code.OK.intValue()) {\n<line100>                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));\n<line101>                } else {\n<line102>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line103>                }\n<line104>            } else if (p.response instanceof Create2Response) {\n<line105>                Create2Callback cb = (Create2Callback) p.cb;\n<line106>                Create2Response rsp = (Create2Response) p.response;\n<line107>                if (rc == Code.OK.intValue()) {\n<line108>                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());\n<line109>                } else {\n<line110>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line111>                }\n<line112>            } else if (p.response instanceof MultiResponse) {\n<line113>                MultiCallback cb = (MultiCallback) p.cb;\n<line114>                MultiResponse rsp = (MultiResponse) p.response;\n<line115>                if (rc == Code.OK.intValue()) {\n<line116>                    List<OpResult> results = rsp.getResultList();\n<line117>                    int newRc = rc;\n<line118>                    for (OpResult result : results) {\n<line119>                        if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {\n<line120>                            break;\n<line121>                        }\n<line122>                    }\n<line123>                    cb.processResult(newRc, clientPath, p.ctx, results);\n<line124>                } else {\n<line125>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line126>                }\n<line127>            } else if (p.response instanceof GetEphemeralsResponse) {\n<line128>                EphemeralsCallback cb = (EphemeralsCallback) p.cb;\n<line129>                GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;\n<line130>                if (rc == Code.OK.intValue()) {\n<line131>                    cb.processResult(rc, p.ctx, rsp.getEphemerals());\n<line132>                } else {\n<line133>                    cb.processResult(rc, p.ctx, null);\n<line134>                }\n<line135>            } else if (p.cb instanceof VoidCallback) {\n<line136>                VoidCallback cb = (VoidCallback) p.cb;\n<line137>                cb.processResult(rc, clientPath, p.ctx);\n<line138>            }\n<line139>        }\n<line140>    } catch (Throwable t) {\n<line141>    }\n<line142>}","output":"<line1>{\n<line2>    try {\n<line3>        if (event instanceof WatcherSetEventPair) {\n<line4>            // each watcher will process the event\n<line5>            WatcherSetEventPair pair = (WatcherSetEventPair) event;\n<line6>            for (Watcher watcher : pair.watchers) {\n<line7>                try {\n<line8>                    watcher.process(pair.event);\n<line9>                } catch (Throwable t) {\n<line10>                    LOG.error(\"Error while calling watcher.\", t);\n<line11>                }\n<line12>            }\n<line13>        } else if (event instanceof LocalCallback) {\n<line14>            LocalCallback lcb = (LocalCallback) event;\n<line15>            if (lcb.cb instanceof StatCallback) {\n<line16>                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line17>            } else if (lcb.cb instanceof DataCallback) {\n<line18>                ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line19>            } else if (lcb.cb instanceof ACLCallback) {\n<line20>                ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line21>            } else if (lcb.cb instanceof ChildrenCallback) {\n<line22>                ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line23>            } else if (lcb.cb instanceof Children2Callback) {\n<line24>                ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line25>            } else if (lcb.cb instanceof StringCallback) {\n<line26>                ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line27>            } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {\n<line28>                ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);\n<line29>            } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {\n<line30>                ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);\n<line31>            } else if (lcb.cb instanceof AsyncCallback.MultiCallback) {\n<line32>                ((AsyncCallback.MultiCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, Collections.emptyList());\n<line33>            } else {\n<line34>                ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);\n<line35>            }\n<line36>        } else {\n<line37>            Packet p = (Packet) event;\n<line38>            int rc = 0;\n<line39>            String clientPath = p.clientPath;\n<line40>            if (p.replyHeader.getErr() != 0) {\n<line41>                rc = p.replyHeader.getErr();\n<line42>            }\n<line43>            if (p.cb == null) {\n<line44>                LOG.warn(\"Somehow a null cb got to EventThread!\");\n<line45>            } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {\n<line46>                StatCallback cb = (StatCallback) p.cb;\n<line47>                if (rc == Code.OK.intValue()) {\n<line48>                    if (p.response instanceof ExistsResponse) {\n<line49>                        cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());\n<line50>                    } else if (p.response instanceof SetDataResponse) {\n<line51>                        cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());\n<line52>                    } else if (p.response instanceof SetACLResponse) {\n<line53>                        cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());\n<line54>                    }\n<line55>                } else {\n<line56>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line57>                }\n<line58>            } else if (p.response instanceof GetDataResponse) {\n<line59>                DataCallback cb = (DataCallback) p.cb;\n<line60>                GetDataResponse rsp = (GetDataResponse) p.response;\n<line61>                if (rc == Code.OK.intValue()) {\n<line62>                    cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());\n<line63>                } else {\n<line64>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line65>                }\n<line66>            } else if (p.response instanceof GetACLResponse) {\n<line67>                ACLCallback cb = (ACLCallback) p.cb;\n<line68>                GetACLResponse rsp = (GetACLResponse) p.response;\n<line69>                if (rc == Code.OK.intValue()) {\n<line70>                    cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());\n<line71>                } else {\n<line72>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line73>                }\n<line74>            } else if (p.response instanceof GetChildrenResponse) {\n<line75>                ChildrenCallback cb = (ChildrenCallback) p.cb;\n<line76>                GetChildrenResponse rsp = (GetChildrenResponse) p.response;\n<line77>                if (rc == Code.OK.intValue()) {\n<line78>                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());\n<line79>                } else {\n<line80>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line81>                }\n<line82>            } else if (p.response instanceof GetAllChildrenNumberResponse) {\n<line83>                AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;\n<line84>                GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;\n<line85>                if (rc == Code.OK.intValue()) {\n<line86>                    cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());\n<line87>                } else {\n<line88>                    cb.processResult(rc, clientPath, p.ctx, -1);\n<line89>                }\n<line90>            } else if (p.response instanceof GetChildren2Response) {\n<line91>                Children2Callback cb = (Children2Callback) p.cb;\n<line92>                GetChildren2Response rsp = (GetChildren2Response) p.response;\n<line93>                if (rc == Code.OK.intValue()) {\n<line94>                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());\n<line95>                } else {\n<line96>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line97>                }\n<line98>            } else if (p.response instanceof CreateResponse) {\n<line99>                StringCallback cb = (StringCallback) p.cb;\n<line100>                CreateResponse rsp = (CreateResponse) p.response;\n<line101>                if (rc == Code.OK.intValue()) {\n<line102>                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));\n<line103>                } else {\n<line104>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line105>                }\n<line106>            } else if (p.response instanceof Create2Response) {\n<line107>                Create2Callback cb = (Create2Callback) p.cb;\n<line108>                Create2Response rsp = (Create2Response) p.response;\n<line109>                if (rc == Code.OK.intValue()) {\n<line110>                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());\n<line111>                } else {\n<line112>                    cb.processResult(rc, clientPath, p.ctx, null, null);\n<line113>                }\n<line114>            } else if (p.response instanceof MultiResponse) {\n<line115>                MultiCallback cb = (MultiCallback) p.cb;\n<line116>                MultiResponse rsp = (MultiResponse) p.response;\n<line117>                if (rc == Code.OK.intValue()) {\n<line118>                    List<OpResult> results = rsp.getResultList();\n<line119>                    int newRc = rc;\n<line120>                    for (OpResult result : results) {\n<line121>                        if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {\n<line122>                            break;\n<line123>                        }\n<line124>                    }\n<line125>                    cb.processResult(newRc, clientPath, p.ctx, results);\n<line126>                } else {\n<line127>                    cb.processResult(rc, clientPath, p.ctx, null);\n<line128>                }\n<line129>            } else if (p.response instanceof GetEphemeralsResponse) {\n<line130>                EphemeralsCallback cb = (EphemeralsCallback) p.cb;\n<line131>                GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;\n<line132>                if (rc == Code.OK.intValue()) {\n<line133>                    cb.processResult(rc, p.ctx, rsp.getEphemerals());\n<line134>                } else {\n<line135>                    cb.processResult(rc, p.ctx, null);\n<line136>                }\n<line137>            } else if (p.cb instanceof VoidCallback) {\n<line138>                VoidCallback cb = (VoidCallback) p.cb;\n<line139>                cb.processResult(rc, clientPath, p.ctx);\n<line140>            }\n<line141>        }\n<line142>    } catch (Throwable t) {\n<line143>        LOG.error(\"Unexpected throwable\", t);\n<line144>    }\n<line145>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event instanceof WatcherSetEventPair) {\n<line3>        // each watcher will process the event\n<line4>        WatcherSetEventPair pair = (WatcherSetEventPair) event;\n<line5>        for (Watcher watcher : pair.watchers) {\n<line6>            try {\n<line7>                watcher.process(pair.event);\n<line8>            } catch (Throwable t) {\n<line9>            }\n<line10>        }\n<line11>    } else if (event instanceof LocalCallback) {\n<line12>        LocalCallback lcb = (LocalCallback) event;\n<line13>        if (lcb.cb instanceof StatCallback) {\n<line14>            ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line15>        } else if (lcb.cb instanceof DataCallback) {\n<line16>            ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line17>        } else if (lcb.cb instanceof ACLCallback) {\n<line18>            ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line19>        } else if (lcb.cb instanceof ChildrenCallback) {\n<line20>            ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line21>        } else if (lcb.cb instanceof Children2Callback) {\n<line22>            ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line23>        } else if (lcb.cb instanceof StringCallback) {\n<line24>            ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line25>        } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {\n<line26>            ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);\n<line27>        } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {\n<line28>            ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);\n<line29>        } else if (lcb.cb instanceof AsyncCallback.MultiCallback) {\n<line30>            ((AsyncCallback.MultiCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, Collections.emptyList());\n<line31>        } else {\n<line32>            ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);\n<line33>        }\n<line34>    } else {\n<line35>        Packet p = (Packet) event;\n<line36>        int rc = 0;\n<line37>        String clientPath = p.clientPath;\n<line38>        if (p.replyHeader.getErr() != 0) {\n<line39>            rc = p.replyHeader.getErr();\n<line40>        }\n<line41>        if (p.cb == null) {\n<line42>        } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {\n<line43>            StatCallback cb = (StatCallback) p.cb;\n<line44>            if (rc == Code.OK.intValue()) {\n<line45>                if (p.response instanceof ExistsResponse) {\n<line46>                    cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());\n<line47>                } else if (p.response instanceof SetDataResponse) {\n<line48>                    cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());\n<line49>                } else if (p.response instanceof SetACLResponse) {\n<line50>                    cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());\n<line51>                }\n<line52>            } else {\n<line53>                cb.processResult(rc, clientPath, p.ctx, null);\n<line54>            }\n<line55>        } else if (p.response instanceof GetDataResponse) {\n<line56>            DataCallback cb = (DataCallback) p.cb;\n<line57>            GetDataResponse rsp = (GetDataResponse) p.response;\n<line58>            if (rc == Code.OK.intValue()) {\n<line59>                cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());\n<line60>            } else {\n<line61>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line62>            }\n<line63>        } else if (p.response instanceof GetACLResponse) {\n<line64>            ACLCallback cb = (ACLCallback) p.cb;\n<line65>            GetACLResponse rsp = (GetACLResponse) p.response;\n<line66>            if (rc == Code.OK.intValue()) {\n<line67>                cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());\n<line68>            } else {\n<line69>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line70>            }\n<line71>        } else if (p.response instanceof GetChildrenResponse) {\n<line72>            ChildrenCallback cb = (ChildrenCallback) p.cb;\n<line73>            GetChildrenResponse rsp = (GetChildrenResponse) p.response;\n<line74>            if (rc == Code.OK.intValue()) {\n<line75>                cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());\n<line76>            } else {\n<line77>                cb.processResult(rc, clientPath, p.ctx, null);\n<line78>            }\n<line79>        } else if (p.response instanceof GetAllChildrenNumberResponse) {\n<line80>            AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;\n<line81>            GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;\n<line82>            if (rc == Code.OK.intValue()) {\n<line83>                cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());\n<line84>            } else {\n<line85>                cb.processResult(rc, clientPath, p.ctx, -1);\n<line86>            }\n<line87>        } else if (p.response instanceof GetChildren2Response) {\n<line88>            Children2Callback cb = (Children2Callback) p.cb;\n<line89>            GetChildren2Response rsp = (GetChildren2Response) p.response;\n<line90>            if (rc == Code.OK.intValue()) {\n<line91>                cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());\n<line92>            } else {\n<line93>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line94>            }\n<line95>        } else if (p.response instanceof CreateResponse) {\n<line96>            StringCallback cb = (StringCallback) p.cb;\n<line97>            CreateResponse rsp = (CreateResponse) p.response;\n<line98>            if (rc == Code.OK.intValue()) {\n<line99>                cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));\n<line100>            } else {\n<line101>                cb.processResult(rc, clientPath, p.ctx, null);\n<line102>            }\n<line103>        } else if (p.response instanceof Create2Response) {\n<line104>            Create2Callback cb = (Create2Callback) p.cb;\n<line105>            Create2Response rsp = (Create2Response) p.response;\n<line106>            if (rc == Code.OK.intValue()) {\n<line107>                cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());\n<line108>            } else {\n<line109>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line110>            }\n<line111>        } else if (p.response instanceof MultiResponse) {\n<line112>            MultiCallback cb = (MultiCallback) p.cb;\n<line113>            MultiResponse rsp = (MultiResponse) p.response;\n<line114>            if (rc == Code.OK.intValue()) {\n<line115>                List<OpResult> results = rsp.getResultList();\n<line116>                int newRc = rc;\n<line117>                for (OpResult result : results) {\n<line118>                    if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {\n<line119>                        break;\n<line120>                    }\n<line121>                }\n<line122>                cb.processResult(newRc, clientPath, p.ctx, results);\n<line123>            } else {\n<line124>                cb.processResult(rc, clientPath, p.ctx, null);\n<line125>            }\n<line126>        } else if (p.response instanceof GetEphemeralsResponse) {\n<line127>            EphemeralsCallback cb = (EphemeralsCallback) p.cb;\n<line128>            GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;\n<line129>            if (rc == Code.OK.intValue()) {\n<line130>                cb.processResult(rc, p.ctx, rsp.getEphemerals());\n<line131>            } else {\n<line132>                cb.processResult(rc, p.ctx, null);\n<line133>            }\n<line134>        } else if (p.cb instanceof VoidCallback) {\n<line135>            VoidCallback cb = (VoidCallback) p.cb;\n<line136>            cb.processResult(rc, clientPath, p.ctx);\n<line137>        }\n<line138>    }\n<line139>}","output":"<line1>{\n<line2>    if (event instanceof WatcherSetEventPair) {\n<line3>        // each watcher will process the event\n<line4>        WatcherSetEventPair pair = (WatcherSetEventPair) event;\n<line5>        for (Watcher watcher : pair.watchers) {\n<line6>            try {\n<line7>                watcher.process(pair.event);\n<line8>            } catch (Throwable t) {\n<line9>                LOG.error(\"Error while calling watcher.\", t);\n<line10>            }\n<line11>        }\n<line12>    } else if (event instanceof LocalCallback) {\n<line13>        LocalCallback lcb = (LocalCallback) event;\n<line14>        if (lcb.cb instanceof StatCallback) {\n<line15>            ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line16>        } else if (lcb.cb instanceof DataCallback) {\n<line17>            ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line18>        } else if (lcb.cb instanceof ACLCallback) {\n<line19>            ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line20>        } else if (lcb.cb instanceof ChildrenCallback) {\n<line21>            ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line22>        } else if (lcb.cb instanceof Children2Callback) {\n<line23>            ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);\n<line24>        } else if (lcb.cb instanceof StringCallback) {\n<line25>            ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);\n<line26>        } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {\n<line27>            ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);\n<line28>        } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {\n<line29>            ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);\n<line30>        } else if (lcb.cb instanceof AsyncCallback.MultiCallback) {\n<line31>            ((AsyncCallback.MultiCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, Collections.emptyList());\n<line32>        } else {\n<line33>            ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);\n<line34>        }\n<line35>    } else {\n<line36>        Packet p = (Packet) event;\n<line37>        int rc = 0;\n<line38>        String clientPath = p.clientPath;\n<line39>        if (p.replyHeader.getErr() != 0) {\n<line40>            rc = p.replyHeader.getErr();\n<line41>        }\n<line42>        if (p.cb == null) {\n<line43>            LOG.warn(\"Somehow a null cb got to EventThread!\");\n<line44>        } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {\n<line45>            StatCallback cb = (StatCallback) p.cb;\n<line46>            if (rc == Code.OK.intValue()) {\n<line47>                if (p.response instanceof ExistsResponse) {\n<line48>                    cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());\n<line49>                } else if (p.response instanceof SetDataResponse) {\n<line50>                    cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());\n<line51>                } else if (p.response instanceof SetACLResponse) {\n<line52>                    cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());\n<line53>                }\n<line54>            } else {\n<line55>                cb.processResult(rc, clientPath, p.ctx, null);\n<line56>            }\n<line57>        } else if (p.response instanceof GetDataResponse) {\n<line58>            DataCallback cb = (DataCallback) p.cb;\n<line59>            GetDataResponse rsp = (GetDataResponse) p.response;\n<line60>            if (rc == Code.OK.intValue()) {\n<line61>                cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());\n<line62>            } else {\n<line63>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line64>            }\n<line65>        } else if (p.response instanceof GetACLResponse) {\n<line66>            ACLCallback cb = (ACLCallback) p.cb;\n<line67>            GetACLResponse rsp = (GetACLResponse) p.response;\n<line68>            if (rc == Code.OK.intValue()) {\n<line69>                cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());\n<line70>            } else {\n<line71>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line72>            }\n<line73>        } else if (p.response instanceof GetChildrenResponse) {\n<line74>            ChildrenCallback cb = (ChildrenCallback) p.cb;\n<line75>            GetChildrenResponse rsp = (GetChildrenResponse) p.response;\n<line76>            if (rc == Code.OK.intValue()) {\n<line77>                cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());\n<line78>            } else {\n<line79>                cb.processResult(rc, clientPath, p.ctx, null);\n<line80>            }\n<line81>        } else if (p.response instanceof GetAllChildrenNumberResponse) {\n<line82>            AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;\n<line83>            GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;\n<line84>            if (rc == Code.OK.intValue()) {\n<line85>                cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());\n<line86>            } else {\n<line87>                cb.processResult(rc, clientPath, p.ctx, -1);\n<line88>            }\n<line89>        } else if (p.response instanceof GetChildren2Response) {\n<line90>            Children2Callback cb = (Children2Callback) p.cb;\n<line91>            GetChildren2Response rsp = (GetChildren2Response) p.response;\n<line92>            if (rc == Code.OK.intValue()) {\n<line93>                cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());\n<line94>            } else {\n<line95>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line96>            }\n<line97>        } else if (p.response instanceof CreateResponse) {\n<line98>            StringCallback cb = (StringCallback) p.cb;\n<line99>            CreateResponse rsp = (CreateResponse) p.response;\n<line100>            if (rc == Code.OK.intValue()) {\n<line101>                cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));\n<line102>            } else {\n<line103>                cb.processResult(rc, clientPath, p.ctx, null);\n<line104>            }\n<line105>        } else if (p.response instanceof Create2Response) {\n<line106>            Create2Callback cb = (Create2Callback) p.cb;\n<line107>            Create2Response rsp = (Create2Response) p.response;\n<line108>            if (rc == Code.OK.intValue()) {\n<line109>                cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());\n<line110>            } else {\n<line111>                cb.processResult(rc, clientPath, p.ctx, null, null);\n<line112>            }\n<line113>        } else if (p.response instanceof MultiResponse) {\n<line114>            MultiCallback cb = (MultiCallback) p.cb;\n<line115>            MultiResponse rsp = (MultiResponse) p.response;\n<line116>            if (rc == Code.OK.intValue()) {\n<line117>                List<OpResult> results = rsp.getResultList();\n<line118>                int newRc = rc;\n<line119>                for (OpResult result : results) {\n<line120>                    if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {\n<line121>                        break;\n<line122>                    }\n<line123>                }\n<line124>                cb.processResult(newRc, clientPath, p.ctx, results);\n<line125>            } else {\n<line126>                cb.processResult(rc, clientPath, p.ctx, null);\n<line127>            }\n<line128>        } else if (p.response instanceof GetEphemeralsResponse) {\n<line129>            EphemeralsCallback cb = (EphemeralsCallback) p.cb;\n<line130>            GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;\n<line131>            if (rc == Code.OK.intValue()) {\n<line132>                cb.processResult(rc, p.ctx, rsp.getEphemerals());\n<line133>            } else {\n<line134>                cb.processResult(rc, p.ctx, null);\n<line135>            }\n<line136>        } else if (p.cb instanceof VoidCallback) {\n<line137>            VoidCallback cb = (VoidCallback) p.cb;\n<line138>            cb.processResult(rc, clientPath, p.ctx);\n<line139>        }\n<line140>    }\n<line141>}"},{"input":"","instruction":"<line1>{\n<line2>    // each watcher will process the event\n<line3>    WatcherSetEventPair pair = (WatcherSetEventPair) event;\n<line4>    for (Watcher watcher : pair.watchers) {\n<line5>        try {\n<line6>            watcher.process(pair.event);\n<line7>        } catch (Throwable t) {\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    // each watcher will process the event\n<line3>    WatcherSetEventPair pair = (WatcherSetEventPair) event;\n<line4>    for (Watcher watcher : pair.watchers) {\n<line5>        try {\n<line6>            watcher.process(pair.event);\n<line7>        } catch (Throwable t) {\n<line8>            LOG.error(\"Error while calling watcher.\", t);\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        watcher.process(pair.event);\n<line4>    } catch (Throwable t) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        watcher.process(pair.event);\n<line4>    } catch (Throwable t) {\n<line5>        LOG.error(\"Error while calling watcher.\", t);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Error while calling watcher.\", t);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected throwable\", t);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);\n<line3>    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);\n<line4>    ReplyHeader replyHdr = new ReplyHeader();\n<line5>    replyHdr.deserialize(bbia, \"header\");\n<line6>    switch(replyHdr.getXid()) {\n<line7>        case PING_XID:\n<line8>            return;\n<line9>        case AUTHPACKET_XID:\n<line10>            if (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {\n<line11>                changeZkState(States.AUTH_FAILED);\n<line12>                eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));\n<line13>                eventThread.queueEventOfDeath();\n<line14>            }\n<line15>            return;\n<line16>        case NOTIFICATION_XID:\n<line17>            WatcherEvent event = new WatcherEvent();\n<line18>            event.deserialize(bbia, \"response\");\n<line19>            // convert from a server path to a client path\n<line20>            if (chrootPath != null) {\n<line21>                String serverPath = event.getPath();\n<line22>                String clientPath = stripChroot(serverPath);\n<line23>                event.setPath(clientPath);\n<line24>            }\n<line25>            WatchedEvent we = new WatchedEvent(event, replyHdr.getZxid());\n<line26>            eventThread.queueEvent(we);\n<line27>            return;\n<line28>        default:\n<line29>            break;\n<line30>    }\n<line31>    // If SASL authentication is currently in progress, construct and\n<line32>    // send a response packet immediately, rather than queuing a\n<line33>    // response as with other packets.\n<line34>    if (tunnelAuthInProgress()) {\n<line35>        GetSASLRequest request = new GetSASLRequest();\n<line36>        request.deserialize(bbia, \"token\");\n<line37>        zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.this);\n<line38>        return;\n<line39>    }\n<line40>    Packet packet;\n<line41>    synchronized (pendingQueue) {\n<line42>        if (pendingQueue.size() == 0) {\n<line43>            throw new IOException(\"Nothing in the queue, but got \" + replyHdr.getXid());\n<line44>        }\n<line45>        packet = pendingQueue.remove();\n<line46>    }\n<line47>    /*\n<line48>             * Since requests are processed in order, we better get a response\n<line49>             * to the first request!\n<line50>             */\n<line51>    try {\n<line52>        if (packet.requestHeader.getXid() != replyHdr.getXid()) {\n<line53>            packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());\n<line54>            throw new IOException(\"Xid out of order. Got Xid \" + replyHdr.getXid() + \" with err \" + replyHdr.getErr() + \" expected Xid \" + packet.requestHeader.getXid() + \" for a packet with details: \" + packet);\n<line55>        }\n<line56>        packet.replyHeader.setXid(replyHdr.getXid());\n<line57>        packet.replyHeader.setErr(replyHdr.getErr());\n<line58>        packet.replyHeader.setZxid(replyHdr.getZxid());\n<line59>        if (replyHdr.getZxid() > 0) {\n<line60>            lastZxid = replyHdr.getZxid();\n<line61>        }\n<line62>        if (packet.response != null && replyHdr.getErr() == 0) {\n<line63>            packet.response.deserialize(bbia, \"response\");\n<line64>        }\n<line65>    } finally {\n<line66>        finishPacket(packet);\n<line67>    }\n<line68>}","output":"<line1>{\n<line2>    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);\n<line3>    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);\n<line4>    ReplyHeader replyHdr = new ReplyHeader();\n<line5>    replyHdr.deserialize(bbia, \"header\");\n<line6>    switch(replyHdr.getXid()) {\n<line7>        case PING_XID:\n<line8>            LOG.debug(\"Got ping response for session id: 0x{} after {}ms.\", Long.toHexString(sessionId), ((System.nanoTime() - lastPingSentNs) / 1000000));\n<line9>            return;\n<line10>        case AUTHPACKET_XID:\n<line11>            LOG.debug(\"Got auth session id: 0x{}\", Long.toHexString(sessionId));\n<line12>            if (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {\n<line13>                changeZkState(States.AUTH_FAILED);\n<line14>                eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));\n<line15>                eventThread.queueEventOfDeath();\n<line16>            }\n<line17>            return;\n<line18>        case NOTIFICATION_XID:\n<line19>            LOG.debug(\"Got notification session id: 0x{}\", Long.toHexString(sessionId));\n<line20>            WatcherEvent event = new WatcherEvent();\n<line21>            event.deserialize(bbia, \"response\");\n<line22>            // convert from a server path to a client path\n<line23>            if (chrootPath != null) {\n<line24>                String serverPath = event.getPath();\n<line25>                String clientPath = stripChroot(serverPath);\n<line26>                event.setPath(clientPath);\n<line27>            }\n<line28>            WatchedEvent we = new WatchedEvent(event, replyHdr.getZxid());\n<line29>            LOG.debug(\"Got {} for session id 0x{}\", we, Long.toHexString(sessionId));\n<line30>            eventThread.queueEvent(we);\n<line31>            return;\n<line32>        default:\n<line33>            break;\n<line34>    }\n<line35>    // If SASL authentication is currently in progress, construct and\n<line36>    // send a response packet immediately, rather than queuing a\n<line37>    // response as with other packets.\n<line38>    if (tunnelAuthInProgress()) {\n<line39>        GetSASLRequest request = new GetSASLRequest();\n<line40>        request.deserialize(bbia, \"token\");\n<line41>        zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.this);\n<line42>        return;\n<line43>    }\n<line44>    Packet packet;\n<line45>    synchronized (pendingQueue) {\n<line46>        if (pendingQueue.size() == 0) {\n<line47>            throw new IOException(\"Nothing in the queue, but got \" + replyHdr.getXid());\n<line48>        }\n<line49>        packet = pendingQueue.remove();\n<line50>    }\n<line51>    /*\n<line52>             * Since requests are processed in order, we better get a response\n<line53>             * to the first request!\n<line54>             */\n<line55>    try {\n<line56>        if (packet.requestHeader.getXid() != replyHdr.getXid()) {\n<line57>            packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());\n<line58>            throw new IOException(\"Xid out of order. Got Xid \" + replyHdr.getXid() + \" with err \" + replyHdr.getErr() + \" expected Xid \" + packet.requestHeader.getXid() + \" for a packet with details: \" + packet);\n<line59>        }\n<line60>        packet.replyHeader.setXid(replyHdr.getXid());\n<line61>        packet.replyHeader.setErr(replyHdr.getErr());\n<line62>        packet.replyHeader.setZxid(replyHdr.getZxid());\n<line63>        if (replyHdr.getZxid() > 0) {\n<line64>            lastZxid = replyHdr.getZxid();\n<line65>        }\n<line66>        if (packet.response != null && replyHdr.getErr() == 0) {\n<line67>            packet.response.deserialize(bbia, \"response\");\n<line68>        }\n<line69>        LOG.debug(\"Reading reply session id: 0x{}, packet:: {}\", Long.toHexString(sessionId), packet);\n<line70>    } finally {\n<line71>        finishPacket(packet);\n<line72>    }\n<line73>}"},{"input":"","instruction":"<line1>{\n<line2>    if (packet.requestHeader.getXid() != replyHdr.getXid()) {\n<line3>        packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());\n<line4>        throw new IOException(\"Xid out of order. Got Xid \" + replyHdr.getXid() + \" with err \" + replyHdr.getErr() + \" expected Xid \" + packet.requestHeader.getXid() + \" for a packet with details: \" + packet);\n<line5>    }\n<line6>    packet.replyHeader.setXid(replyHdr.getXid());\n<line7>    packet.replyHeader.setErr(replyHdr.getErr());\n<line8>    packet.replyHeader.setZxid(replyHdr.getZxid());\n<line9>    if (replyHdr.getZxid() > 0) {\n<line10>        lastZxid = replyHdr.getZxid();\n<line11>    }\n<line12>    if (packet.response != null && replyHdr.getErr() == 0) {\n<line13>        packet.response.deserialize(bbia, \"response\");\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    if (packet.requestHeader.getXid() != replyHdr.getXid()) {\n<line3>        packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());\n<line4>        throw new IOException(\"Xid out of order. Got Xid \" + replyHdr.getXid() + \" with err \" + replyHdr.getErr() + \" expected Xid \" + packet.requestHeader.getXid() + \" for a packet with details: \" + packet);\n<line5>    }\n<line6>    packet.replyHeader.setXid(replyHdr.getXid());\n<line7>    packet.replyHeader.setErr(replyHdr.getErr());\n<line8>    packet.replyHeader.setZxid(replyHdr.getZxid());\n<line9>    if (replyHdr.getZxid() > 0) {\n<line10>        lastZxid = replyHdr.getZxid();\n<line11>    }\n<line12>    if (packet.response != null && replyHdr.getErr() == 0) {\n<line13>        packet.response.deserialize(bbia, \"response\");\n<line14>    }\n<line15>    LOG.debug(\"Reading reply session id: 0x{}, packet:: {}\", Long.toHexString(sessionId), packet);\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    isFirstConnect = false;\n<line3>    long sessId = (seenRwServerBefore) ? sessionId : 0;\n<line4>    ConnectRequest conReq = new ConnectRequest(0, lastZxid, sessionTimeout, sessId, sessionPasswd, readOnly);\n<line5>    // We add backwards since we are pushing into the front\n<line6>    // Only send if there's a pending watch\n<line7>    if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {\n<line8>        List<String> dataWatches = watchManager.getDataWatchList();\n<line9>        List<String> existWatches = watchManager.getExistWatchList();\n<line10>        List<String> childWatches = watchManager.getChildWatchList();\n<line11>        List<String> persistentWatches = watchManager.getPersistentWatchList();\n<line12>        List<String> persistentRecursiveWatches = watchManager.getPersistentRecursiveWatchList();\n<line13>        if (!dataWatches.isEmpty() || !existWatches.isEmpty() || !childWatches.isEmpty() || !persistentWatches.isEmpty() || !persistentRecursiveWatches.isEmpty()) {\n<line14>            Iterator<String> dataWatchesIter = prependChroot(dataWatches).iterator();\n<line15>            Iterator<String> existWatchesIter = prependChroot(existWatches).iterator();\n<line16>            Iterator<String> childWatchesIter = prependChroot(childWatches).iterator();\n<line17>            Iterator<String> persistentWatchesIter = prependChroot(persistentWatches).iterator();\n<line18>            Iterator<String> persistentRecursiveWatchesIter = prependChroot(persistentRecursiveWatches).iterator();\n<line19>            long setWatchesLastZxid = lastZxid;\n<line20>            while (dataWatchesIter.hasNext() || existWatchesIter.hasNext() || childWatchesIter.hasNext() || persistentWatchesIter.hasNext() || persistentRecursiveWatchesIter.hasNext()) {\n<line21>                List<String> dataWatchesBatch = new ArrayList<>();\n<line22>                List<String> existWatchesBatch = new ArrayList<>();\n<line23>                List<String> childWatchesBatch = new ArrayList<>();\n<line24>                List<String> persistentWatchesBatch = new ArrayList<>();\n<line25>                List<String> persistentRecursiveWatchesBatch = new ArrayList<>();\n<line26>                int batchLength = 0;\n<line27>                // Note, we may exceed our max length by a bit when we add the last\n<line28>                // watch in the batch. This isn't ideal, but it makes the code simpler.\n<line29>                while (batchLength < SET_WATCHES_MAX_LENGTH) {\n<line30>                    final String watch;\n<line31>                    if (dataWatchesIter.hasNext()) {\n<line32>                        watch = dataWatchesIter.next();\n<line33>                        dataWatchesBatch.add(watch);\n<line34>                    } else if (existWatchesIter.hasNext()) {\n<line35>                        watch = existWatchesIter.next();\n<line36>                        existWatchesBatch.add(watch);\n<line37>                    } else if (childWatchesIter.hasNext()) {\n<line38>                        watch = childWatchesIter.next();\n<line39>                        childWatchesBatch.add(watch);\n<line40>                    } else if (persistentWatchesIter.hasNext()) {\n<line41>                        watch = persistentWatchesIter.next();\n<line42>                        persistentWatchesBatch.add(watch);\n<line43>                    } else if (persistentRecursiveWatchesIter.hasNext()) {\n<line44>                        watch = persistentRecursiveWatchesIter.next();\n<line45>                        persistentRecursiveWatchesBatch.add(watch);\n<line46>                    } else {\n<line47>                        break;\n<line48>                    }\n<line49>                    batchLength += watch.length();\n<line50>                }\n<line51>                Record record;\n<line52>                int opcode;\n<line53>                if (persistentWatchesBatch.isEmpty() && persistentRecursiveWatchesBatch.isEmpty()) {\n<line54>                    // maintain compatibility with older servers - if no persistent/recursive watchers\n<line55>                    // are used, use the old version of SetWatches\n<line56>                    record = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);\n<line57>                    opcode = OpCode.setWatches;\n<line58>                } else {\n<line59>                    record = new SetWatches2(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch, persistentWatchesBatch, persistentRecursiveWatchesBatch);\n<line60>                    opcode = OpCode.setWatches2;\n<line61>                }\n<line62>                RequestHeader header = new RequestHeader(ClientCnxn.SET_WATCHES_XID, opcode);\n<line63>                Packet packet = new Packet(header, new ReplyHeader(), record, null, null);\n<line64>                outgoingQueue.addFirst(packet);\n<line65>            }\n<line66>        }\n<line67>    }\n<line68>    for (AuthData id : authInfo) {\n<line69>        outgoingQueue.addFirst(new Packet(new RequestHeader(ClientCnxn.AUTHPACKET_XID, OpCode.auth), null, new AuthPacket(0, id.scheme, id.data), null, null));\n<line70>    }\n<line71>    outgoingQueue.addFirst(new Packet(null, null, conReq, null, null));\n<line72>    clientCnxnSocket.connectionPrimed();\n<line73>}","output":"<line1>{\n<line2>    LOG.info(\"Socket connection established, initiating session, client: {}, server: {}\", clientCnxnSocket.getLocalSocketAddress(), clientCnxnSocket.getRemoteSocketAddress());\n<line3>    isFirstConnect = false;\n<line4>    long sessId = (seenRwServerBefore) ? sessionId : 0;\n<line5>    ConnectRequest conReq = new ConnectRequest(0, lastZxid, sessionTimeout, sessId, sessionPasswd, readOnly);\n<line6>    // We add backwards since we are pushing into the front\n<line7>    // Only send if there's a pending watch\n<line8>    if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {\n<line9>        List<String> dataWatches = watchManager.getDataWatchList();\n<line10>        List<String> existWatches = watchManager.getExistWatchList();\n<line11>        List<String> childWatches = watchManager.getChildWatchList();\n<line12>        List<String> persistentWatches = watchManager.getPersistentWatchList();\n<line13>        List<String> persistentRecursiveWatches = watchManager.getPersistentRecursiveWatchList();\n<line14>        if (!dataWatches.isEmpty() || !existWatches.isEmpty() || !childWatches.isEmpty() || !persistentWatches.isEmpty() || !persistentRecursiveWatches.isEmpty()) {\n<line15>            Iterator<String> dataWatchesIter = prependChroot(dataWatches).iterator();\n<line16>            Iterator<String> existWatchesIter = prependChroot(existWatches).iterator();\n<line17>            Iterator<String> childWatchesIter = prependChroot(childWatches).iterator();\n<line18>            Iterator<String> persistentWatchesIter = prependChroot(persistentWatches).iterator();\n<line19>            Iterator<String> persistentRecursiveWatchesIter = prependChroot(persistentRecursiveWatches).iterator();\n<line20>            long setWatchesLastZxid = lastZxid;\n<line21>            while (dataWatchesIter.hasNext() || existWatchesIter.hasNext() || childWatchesIter.hasNext() || persistentWatchesIter.hasNext() || persistentRecursiveWatchesIter.hasNext()) {\n<line22>                List<String> dataWatchesBatch = new ArrayList<>();\n<line23>                List<String> existWatchesBatch = new ArrayList<>();\n<line24>                List<String> childWatchesBatch = new ArrayList<>();\n<line25>                List<String> persistentWatchesBatch = new ArrayList<>();\n<line26>                List<String> persistentRecursiveWatchesBatch = new ArrayList<>();\n<line27>                int batchLength = 0;\n<line28>                // Note, we may exceed our max length by a bit when we add the last\n<line29>                // watch in the batch. This isn't ideal, but it makes the code simpler.\n<line30>                while (batchLength < SET_WATCHES_MAX_LENGTH) {\n<line31>                    final String watch;\n<line32>                    if (dataWatchesIter.hasNext()) {\n<line33>                        watch = dataWatchesIter.next();\n<line34>                        dataWatchesBatch.add(watch);\n<line35>                    } else if (existWatchesIter.hasNext()) {\n<line36>                        watch = existWatchesIter.next();\n<line37>                        existWatchesBatch.add(watch);\n<line38>                    } else if (childWatchesIter.hasNext()) {\n<line39>                        watch = childWatchesIter.next();\n<line40>                        childWatchesBatch.add(watch);\n<line41>                    } else if (persistentWatchesIter.hasNext()) {\n<line42>                        watch = persistentWatchesIter.next();\n<line43>                        persistentWatchesBatch.add(watch);\n<line44>                    } else if (persistentRecursiveWatchesIter.hasNext()) {\n<line45>                        watch = persistentRecursiveWatchesIter.next();\n<line46>                        persistentRecursiveWatchesBatch.add(watch);\n<line47>                    } else {\n<line48>                        break;\n<line49>                    }\n<line50>                    batchLength += watch.length();\n<line51>                }\n<line52>                Record record;\n<line53>                int opcode;\n<line54>                if (persistentWatchesBatch.isEmpty() && persistentRecursiveWatchesBatch.isEmpty()) {\n<line55>                    // maintain compatibility with older servers - if no persistent/recursive watchers\n<line56>                    // are used, use the old version of SetWatches\n<line57>                    record = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);\n<line58>                    opcode = OpCode.setWatches;\n<line59>                } else {\n<line60>                    record = new SetWatches2(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch, persistentWatchesBatch, persistentRecursiveWatchesBatch);\n<line61>                    opcode = OpCode.setWatches2;\n<line62>                }\n<line63>                RequestHeader header = new RequestHeader(ClientCnxn.SET_WATCHES_XID, opcode);\n<line64>                Packet packet = new Packet(header, new ReplyHeader(), record, null, null);\n<line65>                outgoingQueue.addFirst(packet);\n<line66>            }\n<line67>        }\n<line68>    }\n<line69>    for (AuthData id : authInfo) {\n<line70>        outgoingQueue.addFirst(new Packet(new RequestHeader(ClientCnxn.AUTHPACKET_XID, OpCode.auth), null, new AuthPacket(0, id.scheme, id.data), null, null));\n<line71>    }\n<line72>    outgoingQueue.addFirst(new Packet(null, null, conReq, null, null));\n<line73>    clientCnxnSocket.connectionPrimed();\n<line74>    LOG.debug(\"Session establishment request sent on {}\", clientCnxnSocket.getRemoteSocketAddress());\n<line75>}"},{"input":"","instruction":"<line1>{\n<line2>    if (zooKeeperSaslClient != null) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Opening socket connection to server {}.\", addr);\n<line3>    if (zooKeeperSaslClient != null) {\n<line4>        LOG.info(\"SASL config status: {}\", zooKeeperSaslClient.getConfigStatus());\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"SASL config status: {}\", zooKeeperSaslClient.getConfigStatus());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);\n<line3>    clientCnxnSocket.updateNow();\n<line4>    clientCnxnSocket.updateLastSendAndHeard();\n<line5>    int to;\n<line6>    long lastPingRwServer = Time.currentElapsedTime();\n<line7>    //10 seconds\n<line8>    final int MAX_SEND_PING_INTERVAL = 10000;\n<line9>    InetSocketAddress serverAddress = null;\n<line10>    while (state.isAlive()) {\n<line11>        try {\n<line12>            if (!clientCnxnSocket.isConnected()) {\n<line13>                // don't re-establish connection if we are closing\n<line14>                if (closing) {\n<line15>                    break;\n<line16>                }\n<line17>                if (rwServerAddress != null) {\n<line18>                    serverAddress = rwServerAddress;\n<line19>                    rwServerAddress = null;\n<line20>                } else {\n<line21>                    serverAddress = hostProvider.next(1000);\n<line22>                }\n<line23>                onConnecting(serverAddress);\n<line24>                startConnect(serverAddress);\n<line25>                // Update now to start the connection timer right after we make a connection attempt\n<line26>                clientCnxnSocket.updateNow();\n<line27>                clientCnxnSocket.updateLastSendAndHeard();\n<line28>            }\n<line29>            if (state.isConnected()) {\n<line30>                // determine whether we need to send an AuthFailed event.\n<line31>                if (zooKeeperSaslClient != null) {\n<line32>                    boolean sendAuthEvent = false;\n<line33>                    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line34>                        try {\n<line35>                            zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line36>                        } catch (SaslException e) {\n<line37>                            changeZkState(States.AUTH_FAILED);\n<line38>                            sendAuthEvent = true;\n<line39>                        }\n<line40>                    }\n<line41>                    KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line42>                    if (authState != null) {\n<line43>                        if (authState == KeeperState.AuthFailed) {\n<line44>                            // An authentication error occurred during authentication with the Zookeeper Server.\n<line45>                            changeZkState(States.AUTH_FAILED);\n<line46>                            sendAuthEvent = true;\n<line47>                        } else {\n<line48>                            if (authState == KeeperState.SaslAuthenticated) {\n<line49>                                sendAuthEvent = true;\n<line50>                            }\n<line51>                        }\n<line52>                    }\n<line53>                    if (sendAuthEvent) {\n<line54>                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line55>                        if (state == States.AUTH_FAILED) {\n<line56>                            eventThread.queueEventOfDeath();\n<line57>                        }\n<line58>                    }\n<line59>                }\n<line60>                to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line61>            } else {\n<line62>                to = connectTimeout - clientCnxnSocket.getIdleRecv();\n<line63>            }\n<line64>            if (to <= 0) {\n<line65>                String warnInfo = String.format(\"Client session timed out, have not heard from server in %dms for session id 0x%s\", clientCnxnSocket.getIdleRecv(), Long.toHexString(sessionId));\n<line66>                throw new SessionTimeoutException(warnInfo);\n<line67>            }\n<line68>            if (state.isConnected()) {\n<line69>                //1000(1 second) is to prevent race condition missing to send the second ping\n<line70>                //also make sure not to send too many pings when readTimeout is small\n<line71>                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n<line72>                //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n<line73>                if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n<line74>                    sendPing();\n<line75>                    clientCnxnSocket.updateLastSend();\n<line76>                } else {\n<line77>                    if (timeToNextPing < to) {\n<line78>                        to = timeToNextPing;\n<line79>                    }\n<line80>                }\n<line81>            }\n<line82>            // If we are in read-only mode, seek for read/write server\n<line83>            if (state == States.CONNECTEDREADONLY) {\n<line84>                long now = Time.currentElapsedTime();\n<line85>                int idlePingRwServer = (int) (now - lastPingRwServer);\n<line86>                if (idlePingRwServer >= pingRwTimeout) {\n<line87>                    lastPingRwServer = now;\n<line88>                    idlePingRwServer = 0;\n<line89>                    pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);\n<line90>                    pingRwServer();\n<line91>                }\n<line92>                to = Math.min(to, pingRwTimeout - idlePingRwServer);\n<line93>            }\n<line94>            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n<line95>        } catch (Throwable e) {\n<line96>            if (closing) {\n<line97>                // closing so this is expected\n<line98>                }\n<line99>                break;\n<line100>            } else {\n<line101>                // At this point, there might still be new packets appended to outgoingQueue.\n<line102>                // they will be handled in next connection or cleared up if closed.\n<line103>                cleanAndNotifyState();\n<line104>            }\n<line105>        }\n<line106>    }\n<line107>    synchronized (outgoingQueue) {\n<line108>        // When it comes to this point, it guarantees that later queued\n<line109>        // packet to outgoingQueue will be notified of death.\n<line110>        cleanup();\n<line111>    }\n<line112>    clientCnxnSocket.close();\n<line113>    if (state.isAlive()) {\n<line114>        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));\n<line115>    }\n<line116>    eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));\n<line117>    Login l = loginRef.getAndSet(null);\n<line118>    if (l != null) {\n<line119>        l.shutdown();\n<line120>    }\n<line121>    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), \"SendThread exited loop for session: 0x\" + Long.toHexString(getSessionId()));\n<line122>}","output":"<line1>{\n<line2>    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);\n<line3>    clientCnxnSocket.updateNow();\n<line4>    clientCnxnSocket.updateLastSendAndHeard();\n<line5>    int to;\n<line6>    long lastPingRwServer = Time.currentElapsedTime();\n<line7>    //10 seconds\n<line8>    final int MAX_SEND_PING_INTERVAL = 10000;\n<line9>    InetSocketAddress serverAddress = null;\n<line10>    while (state.isAlive()) {\n<line11>        try {\n<line12>            if (!clientCnxnSocket.isConnected()) {\n<line13>                // don't re-establish connection if we are closing\n<line14>                if (closing) {\n<line15>                    break;\n<line16>                }\n<line17>                if (rwServerAddress != null) {\n<line18>                    serverAddress = rwServerAddress;\n<line19>                    rwServerAddress = null;\n<line20>                } else {\n<line21>                    serverAddress = hostProvider.next(1000);\n<line22>                }\n<line23>                onConnecting(serverAddress);\n<line24>                startConnect(serverAddress);\n<line25>                // Update now to start the connection timer right after we make a connection attempt\n<line26>                clientCnxnSocket.updateNow();\n<line27>                clientCnxnSocket.updateLastSendAndHeard();\n<line28>            }\n<line29>            if (state.isConnected()) {\n<line30>                // determine whether we need to send an AuthFailed event.\n<line31>                if (zooKeeperSaslClient != null) {\n<line32>                    boolean sendAuthEvent = false;\n<line33>                    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line34>                        try {\n<line35>                            zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line36>                        } catch (SaslException e) {\n<line37>                            LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line38>                            changeZkState(States.AUTH_FAILED);\n<line39>                            sendAuthEvent = true;\n<line40>                        }\n<line41>                    }\n<line42>                    KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line43>                    if (authState != null) {\n<line44>                        if (authState == KeeperState.AuthFailed) {\n<line45>                            // An authentication error occurred during authentication with the Zookeeper Server.\n<line46>                            changeZkState(States.AUTH_FAILED);\n<line47>                            sendAuthEvent = true;\n<line48>                        } else {\n<line49>                            if (authState == KeeperState.SaslAuthenticated) {\n<line50>                                sendAuthEvent = true;\n<line51>                            }\n<line52>                        }\n<line53>                    }\n<line54>                    if (sendAuthEvent) {\n<line55>                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line56>                        if (state == States.AUTH_FAILED) {\n<line57>                            eventThread.queueEventOfDeath();\n<line58>                        }\n<line59>                    }\n<line60>                }\n<line61>                to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line62>            } else {\n<line63>                to = connectTimeout - clientCnxnSocket.getIdleRecv();\n<line64>            }\n<line65>            if (to <= 0) {\n<line66>                String warnInfo = String.format(\"Client session timed out, have not heard from server in %dms for session id 0x%s\", clientCnxnSocket.getIdleRecv(), Long.toHexString(sessionId));\n<line67>                LOG.warn(warnInfo);\n<line68>                throw new SessionTimeoutException(warnInfo);\n<line69>            }\n<line70>            if (state.isConnected()) {\n<line71>                //1000(1 second) is to prevent race condition missing to send the second ping\n<line72>                //also make sure not to send too many pings when readTimeout is small\n<line73>                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n<line74>                //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n<line75>                if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n<line76>                    sendPing();\n<line77>                    clientCnxnSocket.updateLastSend();\n<line78>                } else {\n<line79>                    if (timeToNextPing < to) {\n<line80>                        to = timeToNextPing;\n<line81>                    }\n<line82>                }\n<line83>            }\n<line84>            // If we are in read-only mode, seek for read/write server\n<line85>            if (state == States.CONNECTEDREADONLY) {\n<line86>                long now = Time.currentElapsedTime();\n<line87>                int idlePingRwServer = (int) (now - lastPingRwServer);\n<line88>                if (idlePingRwServer >= pingRwTimeout) {\n<line89>                    lastPingRwServer = now;\n<line90>                    idlePingRwServer = 0;\n<line91>                    pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);\n<line92>                    pingRwServer();\n<line93>                }\n<line94>                to = Math.min(to, pingRwTimeout - idlePingRwServer);\n<line95>            }\n<line96>            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n<line97>        } catch (Throwable e) {\n<line98>            if (closing) {\n<line99>                // closing so this is expected\n<line100>                if (LOG.isDebugEnabled()) {\n<line101>                    LOG.debug(\"An exception was thrown while closing send thread for session 0x{}.\", Long.toHexString(getSessionId()), e);\n<line102>                }\n<line103>                break;\n<line104>            } else {\n<line105>                LOG.warn(\"Session 0x{} for server {}, Closing socket connection. \" + \"Attempting reconnect except it is a SessionExpiredException.\", Long.toHexString(getSessionId()), serverAddress, e);\n<line106>                // At this point, there might still be new packets appended to outgoingQueue.\n<line107>                // they will be handled in next connection or cleared up if closed.\n<line108>                cleanAndNotifyState();\n<line109>            }\n<line110>        }\n<line111>    }\n<line112>    synchronized (outgoingQueue) {\n<line113>        // When it comes to this point, it guarantees that later queued\n<line114>        // packet to outgoingQueue will be notified of death.\n<line115>        cleanup();\n<line116>    }\n<line117>    clientCnxnSocket.close();\n<line118>    if (state.isAlive()) {\n<line119>        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));\n<line120>    }\n<line121>    eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));\n<line122>    Login l = loginRef.getAndSet(null);\n<line123>    if (l != null) {\n<line124>        l.shutdown();\n<line125>    }\n<line126>    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), \"SendThread exited loop for session: 0x\" + Long.toHexString(getSessionId()));\n<line127>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (!clientCnxnSocket.isConnected()) {\n<line4>            // don't re-establish connection if we are closing\n<line5>            if (closing) {\n<line6>                break;\n<line7>            }\n<line8>            if (rwServerAddress != null) {\n<line9>                serverAddress = rwServerAddress;\n<line10>                rwServerAddress = null;\n<line11>            } else {\n<line12>                serverAddress = hostProvider.next(1000);\n<line13>            }\n<line14>            onConnecting(serverAddress);\n<line15>            startConnect(serverAddress);\n<line16>            // Update now to start the connection timer right after we make a connection attempt\n<line17>            clientCnxnSocket.updateNow();\n<line18>            clientCnxnSocket.updateLastSendAndHeard();\n<line19>        }\n<line20>        if (state.isConnected()) {\n<line21>            // determine whether we need to send an AuthFailed event.\n<line22>            if (zooKeeperSaslClient != null) {\n<line23>                boolean sendAuthEvent = false;\n<line24>                if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line25>                    try {\n<line26>                        zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line27>                    } catch (SaslException e) {\n<line28>                        changeZkState(States.AUTH_FAILED);\n<line29>                        sendAuthEvent = true;\n<line30>                    }\n<line31>                }\n<line32>                KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line33>                if (authState != null) {\n<line34>                    if (authState == KeeperState.AuthFailed) {\n<line35>                        // An authentication error occurred during authentication with the Zookeeper Server.\n<line36>                        changeZkState(States.AUTH_FAILED);\n<line37>                        sendAuthEvent = true;\n<line38>                    } else {\n<line39>                        if (authState == KeeperState.SaslAuthenticated) {\n<line40>                            sendAuthEvent = true;\n<line41>                        }\n<line42>                    }\n<line43>                }\n<line44>                if (sendAuthEvent) {\n<line45>                    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line46>                    if (state == States.AUTH_FAILED) {\n<line47>                        eventThread.queueEventOfDeath();\n<line48>                    }\n<line49>                }\n<line50>            }\n<line51>            to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line52>        } else {\n<line53>            to = connectTimeout - clientCnxnSocket.getIdleRecv();\n<line54>        }\n<line55>        if (to <= 0) {\n<line56>            String warnInfo = String.format(\"Client session timed out, have not heard from server in %dms for session id 0x%s\", clientCnxnSocket.getIdleRecv(), Long.toHexString(sessionId));\n<line57>            throw new SessionTimeoutException(warnInfo);\n<line58>        }\n<line59>        if (state.isConnected()) {\n<line60>            //1000(1 second) is to prevent race condition missing to send the second ping\n<line61>            //also make sure not to send too many pings when readTimeout is small\n<line62>            int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n<line63>            //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n<line64>            if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n<line65>                sendPing();\n<line66>                clientCnxnSocket.updateLastSend();\n<line67>            } else {\n<line68>                if (timeToNextPing < to) {\n<line69>                    to = timeToNextPing;\n<line70>                }\n<line71>            }\n<line72>        }\n<line73>        // If we are in read-only mode, seek for read/write server\n<line74>        if (state == States.CONNECTEDREADONLY) {\n<line75>            long now = Time.currentElapsedTime();\n<line76>            int idlePingRwServer = (int) (now - lastPingRwServer);\n<line77>            if (idlePingRwServer >= pingRwTimeout) {\n<line78>                lastPingRwServer = now;\n<line79>                idlePingRwServer = 0;\n<line80>                pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);\n<line81>                pingRwServer();\n<line82>            }\n<line83>            to = Math.min(to, pingRwTimeout - idlePingRwServer);\n<line84>        }\n<line85>        clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n<line86>    } catch (Throwable e) {\n<line87>        if (closing) {\n<line88>            // closing so this is expected\n<line89>            }\n<line90>            break;\n<line91>        } else {\n<line92>            // At this point, there might still be new packets appended to outgoingQueue.\n<line93>            // they will be handled in next connection or cleared up if closed.\n<line94>            cleanAndNotifyState();\n<line95>        }\n<line96>    }\n<line97>}","output":"<line1>{\n<line2>    try {\n<line3>        if (!clientCnxnSocket.isConnected()) {\n<line4>            // don't re-establish connection if we are closing\n<line5>            if (closing) {\n<line6>                break;\n<line7>            }\n<line8>            if (rwServerAddress != null) {\n<line9>                serverAddress = rwServerAddress;\n<line10>                rwServerAddress = null;\n<line11>            } else {\n<line12>                serverAddress = hostProvider.next(1000);\n<line13>            }\n<line14>            onConnecting(serverAddress);\n<line15>            startConnect(serverAddress);\n<line16>            // Update now to start the connection timer right after we make a connection attempt\n<line17>            clientCnxnSocket.updateNow();\n<line18>            clientCnxnSocket.updateLastSendAndHeard();\n<line19>        }\n<line20>        if (state.isConnected()) {\n<line21>            // determine whether we need to send an AuthFailed event.\n<line22>            if (zooKeeperSaslClient != null) {\n<line23>                boolean sendAuthEvent = false;\n<line24>                if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line25>                    try {\n<line26>                        zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line27>                    } catch (SaslException e) {\n<line28>                        LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line29>                        changeZkState(States.AUTH_FAILED);\n<line30>                        sendAuthEvent = true;\n<line31>                    }\n<line32>                }\n<line33>                KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line34>                if (authState != null) {\n<line35>                    if (authState == KeeperState.AuthFailed) {\n<line36>                        // An authentication error occurred during authentication with the Zookeeper Server.\n<line37>                        changeZkState(States.AUTH_FAILED);\n<line38>                        sendAuthEvent = true;\n<line39>                    } else {\n<line40>                        if (authState == KeeperState.SaslAuthenticated) {\n<line41>                            sendAuthEvent = true;\n<line42>                        }\n<line43>                    }\n<line44>                }\n<line45>                if (sendAuthEvent) {\n<line46>                    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line47>                    if (state == States.AUTH_FAILED) {\n<line48>                        eventThread.queueEventOfDeath();\n<line49>                    }\n<line50>                }\n<line51>            }\n<line52>            to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line53>        } else {\n<line54>            to = connectTimeout - clientCnxnSocket.getIdleRecv();\n<line55>        }\n<line56>        if (to <= 0) {\n<line57>            String warnInfo = String.format(\"Client session timed out, have not heard from server in %dms for session id 0x%s\", clientCnxnSocket.getIdleRecv(), Long.toHexString(sessionId));\n<line58>            LOG.warn(warnInfo);\n<line59>            throw new SessionTimeoutException(warnInfo);\n<line60>        }\n<line61>        if (state.isConnected()) {\n<line62>            //1000(1 second) is to prevent race condition missing to send the second ping\n<line63>            //also make sure not to send too many pings when readTimeout is small\n<line64>            int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n<line65>            //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n<line66>            if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n<line67>                sendPing();\n<line68>                clientCnxnSocket.updateLastSend();\n<line69>            } else {\n<line70>                if (timeToNextPing < to) {\n<line71>                    to = timeToNextPing;\n<line72>                }\n<line73>            }\n<line74>        }\n<line75>        // If we are in read-only mode, seek for read/write server\n<line76>        if (state == States.CONNECTEDREADONLY) {\n<line77>            long now = Time.currentElapsedTime();\n<line78>            int idlePingRwServer = (int) (now - lastPingRwServer);\n<line79>            if (idlePingRwServer >= pingRwTimeout) {\n<line80>                lastPingRwServer = now;\n<line81>                idlePingRwServer = 0;\n<line82>                pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);\n<line83>                pingRwServer();\n<line84>            }\n<line85>            to = Math.min(to, pingRwTimeout - idlePingRwServer);\n<line86>        }\n<line87>        clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n<line88>    } catch (Throwable e) {\n<line89>        if (closing) {\n<line90>            // closing so this is expected\n<line91>            if (LOG.isDebugEnabled()) {\n<line92>                LOG.debug(\"An exception was thrown while closing send thread for session 0x{}.\", Long.toHexString(getSessionId()), e);\n<line93>            }\n<line94>            break;\n<line95>        } else {\n<line96>            LOG.warn(\"Session 0x{} for server {}, Closing socket connection. \" + \"Attempting reconnect except it is a SessionExpiredException.\", Long.toHexString(getSessionId()), serverAddress, e);\n<line97>            // At this point, there might still be new packets appended to outgoingQueue.\n<line98>            // they will be handled in next connection or cleared up if closed.\n<line99>            cleanAndNotifyState();\n<line100>        }\n<line101>    }\n<line102>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!clientCnxnSocket.isConnected()) {\n<line3>        // don't re-establish connection if we are closing\n<line4>        if (closing) {\n<line5>            break;\n<line6>        }\n<line7>        if (rwServerAddress != null) {\n<line8>            serverAddress = rwServerAddress;\n<line9>            rwServerAddress = null;\n<line10>        } else {\n<line11>            serverAddress = hostProvider.next(1000);\n<line12>        }\n<line13>        onConnecting(serverAddress);\n<line14>        startConnect(serverAddress);\n<line15>        // Update now to start the connection timer right after we make a connection attempt\n<line16>        clientCnxnSocket.updateNow();\n<line17>        clientCnxnSocket.updateLastSendAndHeard();\n<line18>    }\n<line19>    if (state.isConnected()) {\n<line20>        // determine whether we need to send an AuthFailed event.\n<line21>        if (zooKeeperSaslClient != null) {\n<line22>            boolean sendAuthEvent = false;\n<line23>            if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line24>                try {\n<line25>                    zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line26>                } catch (SaslException e) {\n<line27>                    changeZkState(States.AUTH_FAILED);\n<line28>                    sendAuthEvent = true;\n<line29>                }\n<line30>            }\n<line31>            KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line32>            if (authState != null) {\n<line33>                if (authState == KeeperState.AuthFailed) {\n<line34>                    // An authentication error occurred during authentication with the Zookeeper Server.\n<line35>                    changeZkState(States.AUTH_FAILED);\n<line36>                    sendAuthEvent = true;\n<line37>                } else {\n<line38>                    if (authState == KeeperState.SaslAuthenticated) {\n<line39>                        sendAuthEvent = true;\n<line40>                    }\n<line41>                }\n<line42>            }\n<line43>            if (sendAuthEvent) {\n<line44>                eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line45>                if (state == States.AUTH_FAILED) {\n<line46>                    eventThread.queueEventOfDeath();\n<line47>                }\n<line48>            }\n<line49>        }\n<line50>        to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line51>    } else {\n<line52>        to = connectTimeout - clientCnxnSocket.getIdleRecv();\n<line53>    }\n<line54>    if (to <= 0) {\n<line55>        String warnInfo = String.format(\"Client session timed out, have not heard from server in %dms for session id 0x%s\", clientCnxnSocket.getIdleRecv(), Long.toHexString(sessionId));\n<line56>        throw new SessionTimeoutException(warnInfo);\n<line57>    }\n<line58>    if (state.isConnected()) {\n<line59>        //1000(1 second) is to prevent race condition missing to send the second ping\n<line60>        //also make sure not to send too many pings when readTimeout is small\n<line61>        int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n<line62>        //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n<line63>        if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n<line64>            sendPing();\n<line65>            clientCnxnSocket.updateLastSend();\n<line66>        } else {\n<line67>            if (timeToNextPing < to) {\n<line68>                to = timeToNextPing;\n<line69>            }\n<line70>        }\n<line71>    }\n<line72>    // If we are in read-only mode, seek for read/write server\n<line73>    if (state == States.CONNECTEDREADONLY) {\n<line74>        long now = Time.currentElapsedTime();\n<line75>        int idlePingRwServer = (int) (now - lastPingRwServer);\n<line76>        if (idlePingRwServer >= pingRwTimeout) {\n<line77>            lastPingRwServer = now;\n<line78>            idlePingRwServer = 0;\n<line79>            pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);\n<line80>            pingRwServer();\n<line81>        }\n<line82>        to = Math.min(to, pingRwTimeout - idlePingRwServer);\n<line83>    }\n<line84>    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n<line85>}","output":"<line1>{\n<line2>    if (!clientCnxnSocket.isConnected()) {\n<line3>        // don't re-establish connection if we are closing\n<line4>        if (closing) {\n<line5>            break;\n<line6>        }\n<line7>        if (rwServerAddress != null) {\n<line8>            serverAddress = rwServerAddress;\n<line9>            rwServerAddress = null;\n<line10>        } else {\n<line11>            serverAddress = hostProvider.next(1000);\n<line12>        }\n<line13>        onConnecting(serverAddress);\n<line14>        startConnect(serverAddress);\n<line15>        // Update now to start the connection timer right after we make a connection attempt\n<line16>        clientCnxnSocket.updateNow();\n<line17>        clientCnxnSocket.updateLastSendAndHeard();\n<line18>    }\n<line19>    if (state.isConnected()) {\n<line20>        // determine whether we need to send an AuthFailed event.\n<line21>        if (zooKeeperSaslClient != null) {\n<line22>            boolean sendAuthEvent = false;\n<line23>            if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line24>                try {\n<line25>                    zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line26>                } catch (SaslException e) {\n<line27>                    LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line28>                    changeZkState(States.AUTH_FAILED);\n<line29>                    sendAuthEvent = true;\n<line30>                }\n<line31>            }\n<line32>            KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line33>            if (authState != null) {\n<line34>                if (authState == KeeperState.AuthFailed) {\n<line35>                    // An authentication error occurred during authentication with the Zookeeper Server.\n<line36>                    changeZkState(States.AUTH_FAILED);\n<line37>                    sendAuthEvent = true;\n<line38>                } else {\n<line39>                    if (authState == KeeperState.SaslAuthenticated) {\n<line40>                        sendAuthEvent = true;\n<line41>                    }\n<line42>                }\n<line43>            }\n<line44>            if (sendAuthEvent) {\n<line45>                eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line46>                if (state == States.AUTH_FAILED) {\n<line47>                    eventThread.queueEventOfDeath();\n<line48>                }\n<line49>            }\n<line50>        }\n<line51>        to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line52>    } else {\n<line53>        to = connectTimeout - clientCnxnSocket.getIdleRecv();\n<line54>    }\n<line55>    if (to <= 0) {\n<line56>        String warnInfo = String.format(\"Client session timed out, have not heard from server in %dms for session id 0x%s\", clientCnxnSocket.getIdleRecv(), Long.toHexString(sessionId));\n<line57>        LOG.warn(warnInfo);\n<line58>        throw new SessionTimeoutException(warnInfo);\n<line59>    }\n<line60>    if (state.isConnected()) {\n<line61>        //1000(1 second) is to prevent race condition missing to send the second ping\n<line62>        //also make sure not to send too many pings when readTimeout is small\n<line63>        int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n<line64>        //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n<line65>        if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n<line66>            sendPing();\n<line67>            clientCnxnSocket.updateLastSend();\n<line68>        } else {\n<line69>            if (timeToNextPing < to) {\n<line70>                to = timeToNextPing;\n<line71>            }\n<line72>        }\n<line73>    }\n<line74>    // If we are in read-only mode, seek for read/write server\n<line75>    if (state == States.CONNECTEDREADONLY) {\n<line76>        long now = Time.currentElapsedTime();\n<line77>        int idlePingRwServer = (int) (now - lastPingRwServer);\n<line78>        if (idlePingRwServer >= pingRwTimeout) {\n<line79>            lastPingRwServer = now;\n<line80>            idlePingRwServer = 0;\n<line81>            pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);\n<line82>            pingRwServer();\n<line83>        }\n<line84>        to = Math.min(to, pingRwTimeout - idlePingRwServer);\n<line85>    }\n<line86>    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n<line87>}"},{"input":"","instruction":"<line1>{\n<line2>    // determine whether we need to send an AuthFailed event.\n<line3>    if (zooKeeperSaslClient != null) {\n<line4>        boolean sendAuthEvent = false;\n<line5>        if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line6>            try {\n<line7>                zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line8>            } catch (SaslException e) {\n<line9>                changeZkState(States.AUTH_FAILED);\n<line10>                sendAuthEvent = true;\n<line11>            }\n<line12>        }\n<line13>        KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line14>        if (authState != null) {\n<line15>            if (authState == KeeperState.AuthFailed) {\n<line16>                // An authentication error occurred during authentication with the Zookeeper Server.\n<line17>                changeZkState(States.AUTH_FAILED);\n<line18>                sendAuthEvent = true;\n<line19>            } else {\n<line20>                if (authState == KeeperState.SaslAuthenticated) {\n<line21>                    sendAuthEvent = true;\n<line22>                }\n<line23>            }\n<line24>        }\n<line25>        if (sendAuthEvent) {\n<line26>            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line27>            if (state == States.AUTH_FAILED) {\n<line28>                eventThread.queueEventOfDeath();\n<line29>            }\n<line30>        }\n<line31>    }\n<line32>    to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line33>}","output":"<line1>{\n<line2>    // determine whether we need to send an AuthFailed event.\n<line3>    if (zooKeeperSaslClient != null) {\n<line4>        boolean sendAuthEvent = false;\n<line5>        if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line6>            try {\n<line7>                zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line8>            } catch (SaslException e) {\n<line9>                LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line10>                changeZkState(States.AUTH_FAILED);\n<line11>                sendAuthEvent = true;\n<line12>            }\n<line13>        }\n<line14>        KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line15>        if (authState != null) {\n<line16>            if (authState == KeeperState.AuthFailed) {\n<line17>                // An authentication error occurred during authentication with the Zookeeper Server.\n<line18>                changeZkState(States.AUTH_FAILED);\n<line19>                sendAuthEvent = true;\n<line20>            } else {\n<line21>                if (authState == KeeperState.SaslAuthenticated) {\n<line22>                    sendAuthEvent = true;\n<line23>                }\n<line24>            }\n<line25>        }\n<line26>        if (sendAuthEvent) {\n<line27>            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line28>            if (state == States.AUTH_FAILED) {\n<line29>                eventThread.queueEventOfDeath();\n<line30>            }\n<line31>        }\n<line32>    }\n<line33>    to = readTimeout - clientCnxnSocket.getIdleRecv();\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    boolean sendAuthEvent = false;\n<line3>    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line4>        try {\n<line5>            zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line6>        } catch (SaslException e) {\n<line7>            changeZkState(States.AUTH_FAILED);\n<line8>            sendAuthEvent = true;\n<line9>        }\n<line10>    }\n<line11>    KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line12>    if (authState != null) {\n<line13>        if (authState == KeeperState.AuthFailed) {\n<line14>            // An authentication error occurred during authentication with the Zookeeper Server.\n<line15>            changeZkState(States.AUTH_FAILED);\n<line16>            sendAuthEvent = true;\n<line17>        } else {\n<line18>            if (authState == KeeperState.SaslAuthenticated) {\n<line19>                sendAuthEvent = true;\n<line20>            }\n<line21>        }\n<line22>    }\n<line23>    if (sendAuthEvent) {\n<line24>        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line25>        if (state == States.AUTH_FAILED) {\n<line26>            eventThread.queueEventOfDeath();\n<line27>        }\n<line28>    }\n<line29>}","output":"<line1>{\n<line2>    boolean sendAuthEvent = false;\n<line3>    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {\n<line4>        try {\n<line5>            zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line6>        } catch (SaslException e) {\n<line7>            LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line8>            changeZkState(States.AUTH_FAILED);\n<line9>            sendAuthEvent = true;\n<line10>        }\n<line11>    }\n<line12>    KeeperState authState = zooKeeperSaslClient.getKeeperState();\n<line13>    if (authState != null) {\n<line14>        if (authState == KeeperState.AuthFailed) {\n<line15>            // An authentication error occurred during authentication with the Zookeeper Server.\n<line16>            changeZkState(States.AUTH_FAILED);\n<line17>            sendAuthEvent = true;\n<line18>        } else {\n<line19>            if (authState == KeeperState.SaslAuthenticated) {\n<line20>                sendAuthEvent = true;\n<line21>            }\n<line22>        }\n<line23>    }\n<line24>    if (sendAuthEvent) {\n<line25>        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));\n<line26>        if (state == States.AUTH_FAILED) {\n<line27>            eventThread.queueEventOfDeath();\n<line28>        }\n<line29>    }\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line4>    } catch (SaslException e) {\n<line5>        changeZkState(States.AUTH_FAILED);\n<line6>        sendAuthEvent = true;\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        zooKeeperSaslClient.initialize(ClientCnxn.this);\n<line4>    } catch (SaslException e) {\n<line5>        LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line6>        changeZkState(States.AUTH_FAILED);\n<line7>        sendAuthEvent = true;\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    changeZkState(States.AUTH_FAILED);\n<line3>    sendAuthEvent = true;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"SASL authentication with Zookeeper Quorum member failed.\", e);\n<line3>    changeZkState(States.AUTH_FAILED);\n<line4>    sendAuthEvent = true;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (closing) {\n<line3>        // closing so this is expected\n<line4>        }\n<line5>        break;\n<line6>    } else {\n<line7>        // At this point, there might still be new packets appended to outgoingQueue.\n<line8>        // they will be handled in next connection or cleared up if closed.\n<line9>        cleanAndNotifyState();\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    if (closing) {\n<line3>        // closing so this is expected\n<line4>        if (LOG.isDebugEnabled()) {\n<line5>            LOG.debug(\"An exception was thrown while closing send thread for session 0x{}.\", Long.toHexString(getSessionId()), e);\n<line6>        }\n<line7>        break;\n<line8>    } else {\n<line9>        LOG.warn(\"Session 0x{} for server {}, Closing socket connection. \" + \"Attempting reconnect except it is a SessionExpiredException.\", Long.toHexString(getSessionId()), serverAddress, e);\n<line10>        // At this point, there might still be new packets appended to outgoingQueue.\n<line11>        // they will be handled in next connection or cleared up if closed.\n<line12>        cleanAndNotifyState();\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    // closing so this is expected\n<line3>    }\n<line4>    break;\n<line5>}","output":"<line1>{\n<line2>    // closing so this is expected\n<line3>    if (LOG.isDebugEnabled()) {\n<line4>        LOG.debug(\"An exception was thrown while closing send thread for session 0x{}.\", Long.toHexString(getSessionId()), e);\n<line5>    }\n<line6>    break;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"An exception was thrown while closing send thread for session 0x{}.\", Long.toHexString(getSessionId()), e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String result = null;\n<line3>    InetSocketAddress addr = hostProvider.next(0);\n<line4>    Socket sock = null;\n<line5>    BufferedReader br = null;\n<line6>    try {\n<line7>        sock = new Socket(addr.getHostString(), addr.getPort());\n<line8>        sock.setSoLinger(false, -1);\n<line9>        sock.setSoTimeout(1000);\n<line10>        sock.setTcpNoDelay(true);\n<line11>        sock.getOutputStream().write(\"isro\".getBytes());\n<line12>        sock.getOutputStream().flush();\n<line13>        sock.shutdownOutput();\n<line14>        br = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line15>        result = br.readLine();\n<line16>    } catch (ConnectException e) {\n<line17>        // ignore, this just means server is not up\n<line18>    } catch (IOException e) {\n<line19>        // some unexpected error, warn about it\n<line20>    } finally {\n<line21>        if (sock != null) {\n<line22>            try {\n<line23>                sock.close();\n<line24>            } catch (IOException e) {\n<line25>            }\n<line26>        }\n<line27>        if (br != null) {\n<line28>            try {\n<line29>                br.close();\n<line30>            } catch (IOException e) {\n<line31>            }\n<line32>        }\n<line33>    }\n<line34>    if (\"rw\".equals(result)) {\n<line35>        pingRwTimeout = minPingRwTimeout;\n<line36>        // save the found address so that it's used during the next\n<line37>        // connection attempt\n<line38>        rwServerAddress = addr;\n<line39>        throw new RWServerFoundException(\"Majority server found at \" + addr.getHostString() + \":\" + addr.getPort());\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    String result = null;\n<line3>    InetSocketAddress addr = hostProvider.next(0);\n<line4>    LOG.info(\"Checking server {} for being r/w. Timeout {}\", addr, pingRwTimeout);\n<line5>    Socket sock = null;\n<line6>    BufferedReader br = null;\n<line7>    try {\n<line8>        sock = new Socket(addr.getHostString(), addr.getPort());\n<line9>        sock.setSoLinger(false, -1);\n<line10>        sock.setSoTimeout(1000);\n<line11>        sock.setTcpNoDelay(true);\n<line12>        sock.getOutputStream().write(\"isro\".getBytes());\n<line13>        sock.getOutputStream().flush();\n<line14>        sock.shutdownOutput();\n<line15>        br = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line16>        result = br.readLine();\n<line17>    } catch (ConnectException e) {\n<line18>        // ignore, this just means server is not up\n<line19>    } catch (IOException e) {\n<line20>        // some unexpected error, warn about it\n<line21>        LOG.warn(\"Exception while seeking for r/w server.\", e);\n<line22>    } finally {\n<line23>        if (sock != null) {\n<line24>            try {\n<line25>                sock.close();\n<line26>            } catch (IOException e) {\n<line27>                LOG.warn(\"Unexpected exception\", e);\n<line28>            }\n<line29>        }\n<line30>        if (br != null) {\n<line31>            try {\n<line32>                br.close();\n<line33>            } catch (IOException e) {\n<line34>                LOG.warn(\"Unexpected exception\", e);\n<line35>            }\n<line36>        }\n<line37>    }\n<line38>    if (\"rw\".equals(result)) {\n<line39>        pingRwTimeout = minPingRwTimeout;\n<line40>        // save the found address so that it's used during the next\n<line41>        // connection attempt\n<line42>        rwServerAddress = addr;\n<line43>        throw new RWServerFoundException(\"Majority server found at \" + addr.getHostString() + \":\" + addr.getPort());\n<line44>    }\n<line45>}"},{"input":"","instruction":"<line1>{\n<line2>    negotiatedSessionTimeout = _negotiatedSessionTimeout;\n<line3>    if (negotiatedSessionTimeout <= 0) {\n<line4>        changeZkState(States.CLOSED);\n<line5>        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));\n<line6>        eventThread.queueEventOfDeath();\n<line7>        String warnInfo = String.format(\"Unable to reconnect to ZooKeeper service, session 0x%s has expired\", Long.toHexString(sessionId));\n<line8>        throw new SessionExpiredException(warnInfo);\n<line9>    }\n<line10>    if (!readOnly && isRO) {\n<line11>    }\n<line12>    readTimeout = negotiatedSessionTimeout * 2 / 3;\n<line13>    connectTimeout = negotiatedSessionTimeout / hostProvider.size();\n<line14>    hostProvider.onConnected();\n<line15>    sessionId = _sessionId;\n<line16>    sessionPasswd = _sessionPasswd;\n<line17>    changeZkState((isRO) ? States.CONNECTEDREADONLY : States.CONNECTED);\n<line18>    seenRwServerBefore |= !isRO;\n<line19>    KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;\n<line20>    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));\n<line21>}","output":"<line1>{\n<line2>    negotiatedSessionTimeout = _negotiatedSessionTimeout;\n<line3>    if (negotiatedSessionTimeout <= 0) {\n<line4>        changeZkState(States.CLOSED);\n<line5>        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));\n<line6>        eventThread.queueEventOfDeath();\n<line7>        String warnInfo = String.format(\"Unable to reconnect to ZooKeeper service, session 0x%s has expired\", Long.toHexString(sessionId));\n<line8>        LOG.warn(warnInfo);\n<line9>        throw new SessionExpiredException(warnInfo);\n<line10>    }\n<line11>    if (!readOnly && isRO) {\n<line12>        LOG.error(\"Read/write client got connected to read-only server\");\n<line13>    }\n<line14>    readTimeout = negotiatedSessionTimeout * 2 / 3;\n<line15>    connectTimeout = negotiatedSessionTimeout / hostProvider.size();\n<line16>    hostProvider.onConnected();\n<line17>    sessionId = _sessionId;\n<line18>    sessionPasswd = _sessionPasswd;\n<line19>    changeZkState((isRO) ? States.CONNECTEDREADONLY : States.CONNECTED);\n<line20>    seenRwServerBefore |= !isRO;\n<line21>    LOG.info(\"Session establishment complete on server {}, session id = 0x{}, negotiated timeout = {}{}\", clientCnxnSocket.getRemoteSocketAddress(), Long.toHexString(sessionId), negotiatedSessionTimeout, (isRO ? \" (READ-ONLY mode)\" : \"\"));\n<line22>    KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;\n<line23>    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Read/write client got connected to read-only server\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    sendThread.close();\n<line3>    try {\n<line4>        sendThread.join();\n<line5>    } catch (InterruptedException ex) {\n<line6>    }\n<line7>    eventThread.queueEventOfDeath();\n<line8>}","output":"<line1>{\n<line2>    LOG.debug(\"Disconnecting client for session: 0x{}\", Long.toHexString(getSessionId()));\n<line3>    sendThread.close();\n<line4>    try {\n<line5>        sendThread.join();\n<line6>    } catch (InterruptedException ex) {\n<line7>        LOG.warn(\"Got interrupted while waiting for the sender thread to close\", ex);\n<line8>    }\n<line9>    eventThread.queueEventOfDeath();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        RequestHeader h = new RequestHeader();\n<line4>        h.setType(ZooDefs.OpCode.closeSession);\n<line5>        submitRequest(h, null, null, null);\n<line6>    } catch (InterruptedException e) {\n<line7>        // ignore, close the send/event threads\n<line8>    } finally {\n<line9>        disconnect();\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.debug(\"Closing client for session: 0x{}\", Long.toHexString(getSessionId()));\n<line3>    try {\n<line4>        RequestHeader h = new RequestHeader();\n<line5>        h.setType(ZooDefs.OpCode.closeSession);\n<line6>        submitRequest(h, null, null, null);\n<line7>    } catch (InterruptedException e) {\n<line8>        // ignore, close the send/event threads\n<line9>    } finally {\n<line10>        disconnect();\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    long waitStartTime = Time.currentElapsedTime();\n<line3>    while (!packet.finished) {\n<line4>        packet.wait(requestTimeout);\n<line5>        if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {\n<line6>            r.setErr(Code.REQUESTTIMEOUT.intValue());\n<line7>            break;\n<line8>        }\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    long waitStartTime = Time.currentElapsedTime();\n<line3>    while (!packet.finished) {\n<line4>        packet.wait(requestTimeout);\n<line5>        if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {\n<line6>            LOG.error(\"Timeout error occurred for the packet '{}'.\", packet);\n<line7>            r.setErr(Code.REQUESTTIMEOUT.intValue());\n<line8>            break;\n<line9>        }\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    packet.wait(requestTimeout);\n<line3>    if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {\n<line4>        r.setErr(Code.REQUESTTIMEOUT.intValue());\n<line5>        break;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    packet.wait(requestTimeout);\n<line3>    if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {\n<line4>        LOG.error(\"Timeout error occurred for the packet '{}'.\", packet);\n<line5>        r.setErr(Code.REQUESTTIMEOUT.intValue());\n<line6>        break;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    r.setErr(Code.REQUESTTIMEOUT.intValue());\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Timeout error occurred for the packet '{}'.\", packet);\n<line3>    r.setErr(Code.REQUESTTIMEOUT.intValue());\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);\n<line4>    } catch (NumberFormatException e) {\n<line5>        throw e;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);\n<line4>        LOG.info(\"{} value is {}. feature enabled={}\", ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, requestTimeout, requestTimeout > 0);\n<line5>    } catch (NumberFormatException e) {\n<line6>        LOG.error(\"Configured value {} for property {} can not be parsed to long.\", clientConfig.getProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT), ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT);\n<line7>        throw e;\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);\n<line3>}","output":"<line1>{\n<line2>    requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);\n<line3>    LOG.info(\"{} value is {}. feature enabled={}\", ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, requestTimeout, requestTimeout > 0);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    throw e;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Configured value {} for property {} can not be parsed to long.\", clientConfig.getProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT), ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT);\n<line3>    throw e;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);\n<line4>    } catch (NumberFormatException e) {\n<line5>        String msg = MessageFormat.format(\"Configured value {0} for property {1} can not be parsed to int\", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);\n<line6>        throw new IOException(msg);\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);\n<line4>        LOG.info(\"{} value is {} Bytes\", ZKConfig.JUTE_MAXBUFFER, packetLen);\n<line5>    } catch (NumberFormatException e) {\n<line6>        String msg = MessageFormat.format(\"Configured value {0} for property {1} can not be parsed to int\", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);\n<line7>        LOG.error(msg);\n<line8>        throw new IOException(msg);\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);\n<line3>}","output":"<line1>{\n<line2>    packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);\n<line3>    LOG.info(\"{} value is {} Bytes\", ZKConfig.JUTE_MAXBUFFER, packetLen);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String msg = MessageFormat.format(\"Configured value {0} for property {1} can not be parsed to int\", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);\n<line3>    throw new IOException(msg);\n<line4>}","output":"<line1>{\n<line2>    String msg = MessageFormat.format(\"Configured value {0} for property {1} can not be parsed to int\", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);\n<line3>    LOG.error(msg);\n<line4>    throw new IOException(msg);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    String configuredServerPrincipal = clientConfig.getProperty(ZKClientConfig.ZOOKEEPER_SERVER_PRINCIPAL);\n<line3>    if (configuredServerPrincipal != null) {\n<line4>        // If server principal is already configured then return it\n<line5>        return configuredServerPrincipal;\n<line6>    }\n<line7>    String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME, ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);\n<line8>    String hostName = addr.getHostName();\n<line9>    boolean canonicalize = true;\n<line10>    String canonicalizeText = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT);\n<line11>    try {\n<line12>        canonicalize = Boolean.parseBoolean(canonicalizeText);\n<line13>    } catch (IllegalArgumentException ea) {\n<line14>    }\n<line15>    if (canonicalize) {\n<line16>        WrapperInetAddress ia = addr.getAddress();\n<line17>        if (ia == null) {\n<line18>            throw new IllegalArgumentException(\"Unable to canonicalize address \" + addr + \" because it's not resolvable\");\n<line19>        }\n<line20>        String canonicalHostName = ia.getCanonicalHostName();\n<line21>        //avoid using literal IP address when security check fails\n<line22>        if (!canonicalHostName.equals(ia.getHostAddress())) {\n<line23>            hostName = canonicalHostName;\n<line24>        }\n<line25>    }\n<line26>    String serverPrincipal = principalUserName + \"/\" + hostName;\n<line27>    return serverPrincipal;\n<line28>}","output":"<line1>{\n<line2>    String configuredServerPrincipal = clientConfig.getProperty(ZKClientConfig.ZOOKEEPER_SERVER_PRINCIPAL);\n<line3>    if (configuredServerPrincipal != null) {\n<line4>        // If server principal is already configured then return it\n<line5>        return configuredServerPrincipal;\n<line6>    }\n<line7>    String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME, ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);\n<line8>    String hostName = addr.getHostName();\n<line9>    boolean canonicalize = true;\n<line10>    String canonicalizeText = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT);\n<line11>    try {\n<line12>        canonicalize = Boolean.parseBoolean(canonicalizeText);\n<line13>    } catch (IllegalArgumentException ea) {\n<line14>        LOG.warn(\"Could not parse config {} \\\"{}\\\" into a boolean using default {}\", ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, canonicalizeText, canonicalize);\n<line15>    }\n<line16>    if (canonicalize) {\n<line17>        WrapperInetAddress ia = addr.getAddress();\n<line18>        if (ia == null) {\n<line19>            throw new IllegalArgumentException(\"Unable to canonicalize address \" + addr + \" because it's not resolvable\");\n<line20>        }\n<line21>        String canonicalHostName = ia.getCanonicalHostName();\n<line22>        //avoid using literal IP address when security check fails\n<line23>        if (!canonicalHostName.equals(ia.getHostAddress())) {\n<line24>            hostName = canonicalHostName;\n<line25>        }\n<line26>        LOG.debug(\"Canonicalized address to {}\", hostName);\n<line27>    }\n<line28>    String serverPrincipal = principalUserName + \"/\" + hostName;\n<line29>    return serverPrincipal;\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    WrapperInetAddress ia = addr.getAddress();\n<line3>    if (ia == null) {\n<line4>        throw new IllegalArgumentException(\"Unable to canonicalize address \" + addr + \" because it's not resolvable\");\n<line5>    }\n<line6>    String canonicalHostName = ia.getCanonicalHostName();\n<line7>    //avoid using literal IP address when security check fails\n<line8>    if (!canonicalHostName.equals(ia.getHostAddress())) {\n<line9>        hostName = canonicalHostName;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    WrapperInetAddress ia = addr.getAddress();\n<line3>    if (ia == null) {\n<line4>        throw new IllegalArgumentException(\"Unable to canonicalize address \" + addr + \" because it's not resolvable\");\n<line5>    }\n<line6>    String canonicalHostName = ia.getCanonicalHostName();\n<line7>    //avoid using literal IP address when security check fails\n<line8>    if (!canonicalHostName.equals(ia.getHostAddress())) {\n<line9>        hostName = canonicalHostName;\n<line10>    }\n<line11>    LOG.debug(\"Canonicalized address to {}\", hostName);\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    final Set<Watcher> result = new HashSet<>();\n<line3>    switch(type) {\n<line4>        case None:\n<line5>            if (defaultWatcher != null) {\n<line6>                result.add(defaultWatcher);\n<line7>            }\n<line8>            boolean clear = disableAutoWatchReset && state != Watcher.Event.KeeperState.SyncConnected;\n<line9>            synchronized (dataWatches) {\n<line10>                for (Set<Watcher> ws : dataWatches.values()) {\n<line11>                    result.addAll(ws);\n<line12>                }\n<line13>                if (clear) {\n<line14>                    dataWatches.clear();\n<line15>                }\n<line16>            }\n<line17>            synchronized (existWatches) {\n<line18>                for (Set<Watcher> ws : existWatches.values()) {\n<line19>                    result.addAll(ws);\n<line20>                }\n<line21>                if (clear) {\n<line22>                    existWatches.clear();\n<line23>                }\n<line24>            }\n<line25>            synchronized (childWatches) {\n<line26>                for (Set<Watcher> ws : childWatches.values()) {\n<line27>                    result.addAll(ws);\n<line28>                }\n<line29>                if (clear) {\n<line30>                    childWatches.clear();\n<line31>                }\n<line32>            }\n<line33>            synchronized (persistentWatches) {\n<line34>                for (Set<Watcher> ws : persistentWatches.values()) {\n<line35>                    result.addAll(ws);\n<line36>                }\n<line37>            }\n<line38>            synchronized (persistentRecursiveWatches) {\n<line39>                for (Set<Watcher> ws : persistentRecursiveWatches.values()) {\n<line40>                    result.addAll(ws);\n<line41>                }\n<line42>            }\n<line43>            return result;\n<line44>        case NodeDataChanged:\n<line45>        case NodeCreated:\n<line46>            synchronized (dataWatches) {\n<line47>                addTo(dataWatches.remove(clientPath), result);\n<line48>            }\n<line49>            synchronized (existWatches) {\n<line50>                addTo(existWatches.remove(clientPath), result);\n<line51>            }\n<line52>            addPersistentWatches(clientPath, type, result);\n<line53>            break;\n<line54>        case NodeChildrenChanged:\n<line55>            synchronized (childWatches) {\n<line56>                addTo(childWatches.remove(clientPath), result);\n<line57>            }\n<line58>            addPersistentWatches(clientPath, type, result);\n<line59>            break;\n<line60>        case NodeDeleted:\n<line61>            synchronized (dataWatches) {\n<line62>                addTo(dataWatches.remove(clientPath), result);\n<line63>            }\n<line64>            // TODO This shouldn't be needed, but just in case\n<line65>            synchronized (existWatches) {\n<line66>                Set<Watcher> list = existWatches.remove(clientPath);\n<line67>                if (list != null) {\n<line68>                    addTo(list, result);\n<line69>                }\n<line70>            }\n<line71>            synchronized (childWatches) {\n<line72>                addTo(childWatches.remove(clientPath), result);\n<line73>            }\n<line74>            addPersistentWatches(clientPath, type, result);\n<line75>            break;\n<line76>        default:\n<line77>            String errorMsg = String.format(\"Unhandled watch event type %s with state %s on path %s\", type, state, clientPath);\n<line78>            throw new RuntimeException(errorMsg);\n<line79>    }\n<line80>    return result;\n<line81>}","output":"<line1>{\n<line2>    final Set<Watcher> result = new HashSet<>();\n<line3>    switch(type) {\n<line4>        case None:\n<line5>            if (defaultWatcher != null) {\n<line6>                result.add(defaultWatcher);\n<line7>            }\n<line8>            boolean clear = disableAutoWatchReset && state != Watcher.Event.KeeperState.SyncConnected;\n<line9>            synchronized (dataWatches) {\n<line10>                for (Set<Watcher> ws : dataWatches.values()) {\n<line11>                    result.addAll(ws);\n<line12>                }\n<line13>                if (clear) {\n<line14>                    dataWatches.clear();\n<line15>                }\n<line16>            }\n<line17>            synchronized (existWatches) {\n<line18>                for (Set<Watcher> ws : existWatches.values()) {\n<line19>                    result.addAll(ws);\n<line20>                }\n<line21>                if (clear) {\n<line22>                    existWatches.clear();\n<line23>                }\n<line24>            }\n<line25>            synchronized (childWatches) {\n<line26>                for (Set<Watcher> ws : childWatches.values()) {\n<line27>                    result.addAll(ws);\n<line28>                }\n<line29>                if (clear) {\n<line30>                    childWatches.clear();\n<line31>                }\n<line32>            }\n<line33>            synchronized (persistentWatches) {\n<line34>                for (Set<Watcher> ws : persistentWatches.values()) {\n<line35>                    result.addAll(ws);\n<line36>                }\n<line37>            }\n<line38>            synchronized (persistentRecursiveWatches) {\n<line39>                for (Set<Watcher> ws : persistentRecursiveWatches.values()) {\n<line40>                    result.addAll(ws);\n<line41>                }\n<line42>            }\n<line43>            return result;\n<line44>        case NodeDataChanged:\n<line45>        case NodeCreated:\n<line46>            synchronized (dataWatches) {\n<line47>                addTo(dataWatches.remove(clientPath), result);\n<line48>            }\n<line49>            synchronized (existWatches) {\n<line50>                addTo(existWatches.remove(clientPath), result);\n<line51>            }\n<line52>            addPersistentWatches(clientPath, type, result);\n<line53>            break;\n<line54>        case NodeChildrenChanged:\n<line55>            synchronized (childWatches) {\n<line56>                addTo(childWatches.remove(clientPath), result);\n<line57>            }\n<line58>            addPersistentWatches(clientPath, type, result);\n<line59>            break;\n<line60>        case NodeDeleted:\n<line61>            synchronized (dataWatches) {\n<line62>                addTo(dataWatches.remove(clientPath), result);\n<line63>            }\n<line64>            // TODO This shouldn't be needed, but just in case\n<line65>            synchronized (existWatches) {\n<line66>                Set<Watcher> list = existWatches.remove(clientPath);\n<line67>                if (list != null) {\n<line68>                    addTo(list, result);\n<line69>                    LOG.warn(\"We are triggering an exists watch for delete! Shouldn't happen!\");\n<line70>                }\n<line71>            }\n<line72>            synchronized (childWatches) {\n<line73>                addTo(childWatches.remove(clientPath), result);\n<line74>            }\n<line75>            addPersistentWatches(clientPath, type, result);\n<line76>            break;\n<line77>        default:\n<line78>            String errorMsg = String.format(\"Unhandled watch event type %s with state %s on path %s\", type, state, clientPath);\n<line79>            LOG.error(errorMsg);\n<line80>            throw new RuntimeException(errorMsg);\n<line81>    }\n<line82>    return result;\n<line83>}"},{"input":"","instruction":"<line1>{\n<line2>    firstConnect = new CountDownLatch(1);\n<line3>    Bootstrap bootstrap = new Bootstrap().group(eventLoopGroup).channel(NettyUtils.nioOrEpollSocketChannel()).option(ChannelOption.SO_LINGER, -1).option(ChannelOption.TCP_NODELAY, true).handler(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));\n<line4>    bootstrap = configureBootstrapAllocator(bootstrap);\n<line5>    bootstrap.validate();\n<line6>    connectLock.lock();\n<line7>    try {\n<line8>        connectFuture = bootstrap.connect(addr);\n<line9>        connectFuture.addListener(new ChannelFutureListener() {\n<line10>\n<line11>            @Override\n<line12>            public void operationComplete(ChannelFuture channelFuture) throws Exception {\n<line13>                // this lock guarantees that channel won't be assigned after cleanup().\n<line14>                boolean connected = false;\n<line15>                connectLock.lock();\n<line16>                try {\n<line17>                    if (!channelFuture.isSuccess()) {\n<line18>                        return;\n<line19>                    } else if (connectFuture == null) {\n<line20>                        // If the connect attempt was cancelled but succeeded\n<line21>                        // anyway, make sure to close the channel, otherwise\n<line22>                        // we may leak a file descriptor.\n<line23>                        channelFuture.channel().close();\n<line24>                        return;\n<line25>                    }\n<line26>                    // setup channel, variables, connection, etc.\n<line27>                    channel = channelFuture.channel();\n<line28>                    disconnected.set(false);\n<line29>                    initialized = false;\n<line30>                    lenBuffer.clear();\n<line31>                    incomingBuffer = lenBuffer;\n<line32>                    sendThread.primeConnection();\n<line33>                    updateNow();\n<line34>                    updateLastSendAndHeard();\n<line35>                    if (sendThread.tunnelAuthInProgress()) {\n<line36>                        waitSasl.drainPermits();\n<line37>                        needSasl.set(true);\n<line38>                        sendPrimePacket();\n<line39>                    } else {\n<line40>                        needSasl.set(false);\n<line41>                    }\n<line42>                    connected = true;\n<line43>                } finally {\n<line44>                    connectFuture = null;\n<line45>                    connectLock.unlock();\n<line46>                    if (connected) {\n<line47>                    }\n<line48>                    // need to wake on connect success or failure to avoid\n<line49>                    // timing out ClientCnxn.SendThread which may be\n<line50>                    // blocked waiting for first connect in doTransport().\n<line51>                    wakeupCnxn();\n<line52>                    firstConnect.countDown();\n<line53>                }\n<line54>            }\n<line55>        });\n<line56>    } finally {\n<line57>        connectLock.unlock();\n<line58>    }\n<line59>}","output":"<line1>{\n<line2>    firstConnect = new CountDownLatch(1);\n<line3>    Bootstrap bootstrap = new Bootstrap().group(eventLoopGroup).channel(NettyUtils.nioOrEpollSocketChannel()).option(ChannelOption.SO_LINGER, -1).option(ChannelOption.TCP_NODELAY, true).handler(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));\n<line4>    bootstrap = configureBootstrapAllocator(bootstrap);\n<line5>    bootstrap.validate();\n<line6>    connectLock.lock();\n<line7>    try {\n<line8>        connectFuture = bootstrap.connect(addr);\n<line9>        connectFuture.addListener(new ChannelFutureListener() {\n<line10>\n<line11>            @Override\n<line12>            public void operationComplete(ChannelFuture channelFuture) throws Exception {\n<line13>                // this lock guarantees that channel won't be assigned after cleanup().\n<line14>                boolean connected = false;\n<line15>                connectLock.lock();\n<line16>                try {\n<line17>                    if (!channelFuture.isSuccess()) {\n<line18>                        LOG.warn(\"future isn't success.\", channelFuture.cause());\n<line19>                        return;\n<line20>                    } else if (connectFuture == null) {\n<line21>                        LOG.info(\"connect attempt cancelled\");\n<line22>                        // If the connect attempt was cancelled but succeeded\n<line23>                        // anyway, make sure to close the channel, otherwise\n<line24>                        // we may leak a file descriptor.\n<line25>                        channelFuture.channel().close();\n<line26>                        return;\n<line27>                    }\n<line28>                    // setup channel, variables, connection, etc.\n<line29>                    channel = channelFuture.channel();\n<line30>                    disconnected.set(false);\n<line31>                    initialized = false;\n<line32>                    lenBuffer.clear();\n<line33>                    incomingBuffer = lenBuffer;\n<line34>                    sendThread.primeConnection();\n<line35>                    updateNow();\n<line36>                    updateLastSendAndHeard();\n<line37>                    if (sendThread.tunnelAuthInProgress()) {\n<line38>                        waitSasl.drainPermits();\n<line39>                        needSasl.set(true);\n<line40>                        sendPrimePacket();\n<line41>                    } else {\n<line42>                        needSasl.set(false);\n<line43>                    }\n<line44>                    connected = true;\n<line45>                } finally {\n<line46>                    connectFuture = null;\n<line47>                    connectLock.unlock();\n<line48>                    if (connected) {\n<line49>                        LOG.info(\"channel is connected: {}\", channelFuture.channel());\n<line50>                    }\n<line51>                    // need to wake on connect success or failure to avoid\n<line52>                    // timing out ClientCnxn.SendThread which may be\n<line53>                    // blocked waiting for first connect in doTransport().\n<line54>                    wakeupCnxn();\n<line55>                    firstConnect.countDown();\n<line56>                }\n<line57>            }\n<line58>        });\n<line59>    } finally {\n<line60>        connectLock.unlock();\n<line61>    }\n<line62>}"},{"input":"","instruction":"<line1>{\n<line2>    connectFuture = bootstrap.connect(addr);\n<line3>    connectFuture.addListener(new ChannelFutureListener() {\n<line4>\n<line5>        @Override\n<line6>        public void operationComplete(ChannelFuture channelFuture) throws Exception {\n<line7>            // this lock guarantees that channel won't be assigned after cleanup().\n<line8>            boolean connected = false;\n<line9>            connectLock.lock();\n<line10>            try {\n<line11>                if (!channelFuture.isSuccess()) {\n<line12>                    return;\n<line13>                } else if (connectFuture == null) {\n<line14>                    // If the connect attempt was cancelled but succeeded\n<line15>                    // anyway, make sure to close the channel, otherwise\n<line16>                    // we may leak a file descriptor.\n<line17>                    channelFuture.channel().close();\n<line18>                    return;\n<line19>                }\n<line20>                // setup channel, variables, connection, etc.\n<line21>                channel = channelFuture.channel();\n<line22>                disconnected.set(false);\n<line23>                initialized = false;\n<line24>                lenBuffer.clear();\n<line25>                incomingBuffer = lenBuffer;\n<line26>                sendThread.primeConnection();\n<line27>                updateNow();\n<line28>                updateLastSendAndHeard();\n<line29>                if (sendThread.tunnelAuthInProgress()) {\n<line30>                    waitSasl.drainPermits();\n<line31>                    needSasl.set(true);\n<line32>                    sendPrimePacket();\n<line33>                } else {\n<line34>                    needSasl.set(false);\n<line35>                }\n<line36>                connected = true;\n<line37>            } finally {\n<line38>                connectFuture = null;\n<line39>                connectLock.unlock();\n<line40>                if (connected) {\n<line41>                }\n<line42>                // need to wake on connect success or failure to avoid\n<line43>                // timing out ClientCnxn.SendThread which may be\n<line44>                // blocked waiting for first connect in doTransport().\n<line45>                wakeupCnxn();\n<line46>                firstConnect.countDown();\n<line47>            }\n<line48>        }\n<line49>    });\n<line50>}","output":"<line1>{\n<line2>    connectFuture = bootstrap.connect(addr);\n<line3>    connectFuture.addListener(new ChannelFutureListener() {\n<line4>\n<line5>        @Override\n<line6>        public void operationComplete(ChannelFuture channelFuture) throws Exception {\n<line7>            // this lock guarantees that channel won't be assigned after cleanup().\n<line8>            boolean connected = false;\n<line9>            connectLock.lock();\n<line10>            try {\n<line11>                if (!channelFuture.isSuccess()) {\n<line12>                    LOG.warn(\"future isn't success.\", channelFuture.cause());\n<line13>                    return;\n<line14>                } else if (connectFuture == null) {\n<line15>                    LOG.info(\"connect attempt cancelled\");\n<line16>                    // If the connect attempt was cancelled but succeeded\n<line17>                    // anyway, make sure to close the channel, otherwise\n<line18>                    // we may leak a file descriptor.\n<line19>                    channelFuture.channel().close();\n<line20>                    return;\n<line21>                }\n<line22>                // setup channel, variables, connection, etc.\n<line23>                channel = channelFuture.channel();\n<line24>                disconnected.set(false);\n<line25>                initialized = false;\n<line26>                lenBuffer.clear();\n<line27>                incomingBuffer = lenBuffer;\n<line28>                sendThread.primeConnection();\n<line29>                updateNow();\n<line30>                updateLastSendAndHeard();\n<line31>                if (sendThread.tunnelAuthInProgress()) {\n<line32>                    waitSasl.drainPermits();\n<line33>                    needSasl.set(true);\n<line34>                    sendPrimePacket();\n<line35>                } else {\n<line36>                    needSasl.set(false);\n<line37>                }\n<line38>                connected = true;\n<line39>            } finally {\n<line40>                connectFuture = null;\n<line41>                connectLock.unlock();\n<line42>                if (connected) {\n<line43>                    LOG.info(\"channel is connected: {}\", channelFuture.channel());\n<line44>                }\n<line45>                // need to wake on connect success or failure to avoid\n<line46>                // timing out ClientCnxn.SendThread which may be\n<line47>                // blocked waiting for first connect in doTransport().\n<line48>                wakeupCnxn();\n<line49>                firstConnect.countDown();\n<line50>            }\n<line51>        }\n<line52>    });\n<line53>}"},{"input":"","instruction":"<line1>{\n<line2>    // this lock guarantees that channel won't be assigned after cleanup().\n<line3>    boolean connected = false;\n<line4>    connectLock.lock();\n<line5>    try {\n<line6>        if (!channelFuture.isSuccess()) {\n<line7>            return;\n<line8>        } else if (connectFuture == null) {\n<line9>            // If the connect attempt was cancelled but succeeded\n<line10>            // anyway, make sure to close the channel, otherwise\n<line11>            // we may leak a file descriptor.\n<line12>            channelFuture.channel().close();\n<line13>            return;\n<line14>        }\n<line15>        // setup channel, variables, connection, etc.\n<line16>        channel = channelFuture.channel();\n<line17>        disconnected.set(false);\n<line18>        initialized = false;\n<line19>        lenBuffer.clear();\n<line20>        incomingBuffer = lenBuffer;\n<line21>        sendThread.primeConnection();\n<line22>        updateNow();\n<line23>        updateLastSendAndHeard();\n<line24>        if (sendThread.tunnelAuthInProgress()) {\n<line25>            waitSasl.drainPermits();\n<line26>            needSasl.set(true);\n<line27>            sendPrimePacket();\n<line28>        } else {\n<line29>            needSasl.set(false);\n<line30>        }\n<line31>        connected = true;\n<line32>    } finally {\n<line33>        connectFuture = null;\n<line34>        connectLock.unlock();\n<line35>        if (connected) {\n<line36>        }\n<line37>        // need to wake on connect success or failure to avoid\n<line38>        // timing out ClientCnxn.SendThread which may be\n<line39>        // blocked waiting for first connect in doTransport().\n<line40>        wakeupCnxn();\n<line41>        firstConnect.countDown();\n<line42>    }\n<line43>}","output":"<line1>{\n<line2>    // this lock guarantees that channel won't be assigned after cleanup().\n<line3>    boolean connected = false;\n<line4>    connectLock.lock();\n<line5>    try {\n<line6>        if (!channelFuture.isSuccess()) {\n<line7>            LOG.warn(\"future isn't success.\", channelFuture.cause());\n<line8>            return;\n<line9>        } else if (connectFuture == null) {\n<line10>            LOG.info(\"connect attempt cancelled\");\n<line11>            // If the connect attempt was cancelled but succeeded\n<line12>            // anyway, make sure to close the channel, otherwise\n<line13>            // we may leak a file descriptor.\n<line14>            channelFuture.channel().close();\n<line15>            return;\n<line16>        }\n<line17>        // setup channel, variables, connection, etc.\n<line18>        channel = channelFuture.channel();\n<line19>        disconnected.set(false);\n<line20>        initialized = false;\n<line21>        lenBuffer.clear();\n<line22>        incomingBuffer = lenBuffer;\n<line23>        sendThread.primeConnection();\n<line24>        updateNow();\n<line25>        updateLastSendAndHeard();\n<line26>        if (sendThread.tunnelAuthInProgress()) {\n<line27>            waitSasl.drainPermits();\n<line28>            needSasl.set(true);\n<line29>            sendPrimePacket();\n<line30>        } else {\n<line31>            needSasl.set(false);\n<line32>        }\n<line33>        connected = true;\n<line34>    } finally {\n<line35>        connectFuture = null;\n<line36>        connectLock.unlock();\n<line37>        if (connected) {\n<line38>            LOG.info(\"channel is connected: {}\", channelFuture.channel());\n<line39>        }\n<line40>        // need to wake on connect success or failure to avoid\n<line41>        // timing out ClientCnxn.SendThread which may be\n<line42>        // blocked waiting for first connect in doTransport().\n<line43>        wakeupCnxn();\n<line44>        firstConnect.countDown();\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!channelFuture.isSuccess()) {\n<line3>        return;\n<line4>    } else if (connectFuture == null) {\n<line5>        // If the connect attempt was cancelled but succeeded\n<line6>        // anyway, make sure to close the channel, otherwise\n<line7>        // we may leak a file descriptor.\n<line8>        channelFuture.channel().close();\n<line9>        return;\n<line10>    }\n<line11>    // setup channel, variables, connection, etc.\n<line12>    channel = channelFuture.channel();\n<line13>    disconnected.set(false);\n<line14>    initialized = false;\n<line15>    lenBuffer.clear();\n<line16>    incomingBuffer = lenBuffer;\n<line17>    sendThread.primeConnection();\n<line18>    updateNow();\n<line19>    updateLastSendAndHeard();\n<line20>    if (sendThread.tunnelAuthInProgress()) {\n<line21>        waitSasl.drainPermits();\n<line22>        needSasl.set(true);\n<line23>        sendPrimePacket();\n<line24>    } else {\n<line25>        needSasl.set(false);\n<line26>    }\n<line27>    connected = true;\n<line28>}","output":"<line1>{\n<line2>    if (!channelFuture.isSuccess()) {\n<line3>        LOG.warn(\"future isn't success.\", channelFuture.cause());\n<line4>        return;\n<line5>    } else if (connectFuture == null) {\n<line6>        LOG.info(\"connect attempt cancelled\");\n<line7>        // If the connect attempt was cancelled but succeeded\n<line8>        // anyway, make sure to close the channel, otherwise\n<line9>        // we may leak a file descriptor.\n<line10>        channelFuture.channel().close();\n<line11>        return;\n<line12>    }\n<line13>    // setup channel, variables, connection, etc.\n<line14>    channel = channelFuture.channel();\n<line15>    disconnected.set(false);\n<line16>    initialized = false;\n<line17>    lenBuffer.clear();\n<line18>    incomingBuffer = lenBuffer;\n<line19>    sendThread.primeConnection();\n<line20>    updateNow();\n<line21>    updateLastSendAndHeard();\n<line22>    if (sendThread.tunnelAuthInProgress()) {\n<line23>        waitSasl.drainPermits();\n<line24>        needSasl.set(true);\n<line25>        sendPrimePacket();\n<line26>    } else {\n<line27>        needSasl.set(false);\n<line28>    }\n<line29>    connected = true;\n<line30>}"},{"input":"","instruction":"<line1>{\n<line2>    // If the connect attempt was cancelled but succeeded\n<line3>    // anyway, make sure to close the channel, otherwise\n<line4>    // we may leak a file descriptor.\n<line5>    channelFuture.channel().close();\n<line6>    return;\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"connect attempt cancelled\");\n<line3>    // If the connect attempt was cancelled but succeeded\n<line4>    // anyway, make sure to close the channel, otherwise\n<line5>    // we may leak a file descriptor.\n<line6>    channelFuture.channel().close();\n<line7>    return;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    connectFuture = null;\n<line3>    connectLock.unlock();\n<line4>    if (connected) {\n<line5>    }\n<line6>    // need to wake on connect success or failure to avoid\n<line7>    // timing out ClientCnxn.SendThread which may be\n<line8>    // blocked waiting for first connect in doTransport().\n<line9>    wakeupCnxn();\n<line10>    firstConnect.countDown();\n<line11>}","output":"<line1>{\n<line2>    connectFuture = null;\n<line3>    connectLock.unlock();\n<line4>    if (connected) {\n<line5>        LOG.info(\"channel is connected: {}\", channelFuture.channel());\n<line6>    }\n<line7>    // need to wake on connect success or failure to avoid\n<line8>    // timing out ClientCnxn.SendThread which may be\n<line9>    // blocked waiting for first connect in doTransport().\n<line10>    wakeupCnxn();\n<line11>    firstConnect.countDown();\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"channel is connected: {}\", channelFuture.channel());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (firstConnect != null) {\n<line3>        firstConnect.countDown();\n<line4>    }\n<line5>    wakeupCnxn();\n<line6>}","output":"<line1>{\n<line2>    if (firstConnect != null) {\n<line3>        firstConnect.countDown();\n<line4>    }\n<line5>    wakeupCnxn();\n<line6>    LOG.info(\"channel is told closing\");\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    if (sslContext == null) {\n<line3>        try (ClientX509Util x509Util = new ClientX509Util()) {\n<line4>            sslContext = x509Util.createNettySslContextForClient(clientConfig);\n<line5>        }\n<line6>    }\n<line7>    pipeline.addLast(\"ssl\", sslContext.newHandler(pipeline.channel().alloc(), host, port));\n<line8>}","output":"<line1>{\n<line2>    if (sslContext == null) {\n<line3>        try (ClientX509Util x509Util = new ClientX509Util()) {\n<line4>            sslContext = x509Util.createNettySslContextForClient(clientConfig);\n<line5>        }\n<line6>    }\n<line7>    pipeline.addLast(\"ssl\", sslContext.newHandler(pipeline.channel().alloc(), host, port));\n<line8>    LOG.info(\"SSL handler added for channel: {}\", pipeline.channel());\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    cleanup();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"channel is disconnected: {}\", ctx.channel());\n<line3>    cleanup();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    cleanup();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected throwable\", cause);\n<line3>    cleanup();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket sock = null;\n<line3>    BufferedReader reader = null;\n<line4>    try {\n<line5>        InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);\n<line6>        if (secure) {\n<line7>            try (X509Util x509Util = new ClientX509Util()) {\n<line8>                SSLContext sslContext = x509Util.getDefaultSSLContext();\n<line9>                SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n<line10>                SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();\n<line11>                sslSock.connect(hostaddress, timeout);\n<line12>                sslSock.startHandshake();\n<line13>                sock = sslSock;\n<line14>            }\n<line15>        } else {\n<line16>            sock = new Socket();\n<line17>            sock.connect(hostaddress, timeout);\n<line18>        }\n<line19>        sock.setSoTimeout(timeout);\n<line20>        OutputStream outstream = sock.getOutputStream();\n<line21>        outstream.write(cmd.getBytes(UTF_8));\n<line22>        outstream.flush();\n<line23>        // this replicates NC - close the output stream before reading\n<line24>        if (!secure) {\n<line25>            // SSL prohibits unilateral half-close\n<line26>            sock.shutdownOutput();\n<line27>        }\n<line28>        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line29>        StringBuilder sb = new StringBuilder();\n<line30>        String line;\n<line31>        while ((line = reader.readLine()) != null) {\n<line32>            sb.append(line).append(\"\\n\");\n<line33>        }\n<line34>        return sb.toString();\n<line35>    } catch (SocketTimeoutException e) {\n<line36>        throw new IOException(\"Exception while executing four letter word: \" + cmd, e);\n<line37>    } finally {\n<line38>        if (sock != null) {\n<line39>            sock.close();\n<line40>        }\n<line41>        if (reader != null) {\n<line42>            reader.close();\n<line43>        }\n<line44>    }\n<line45>}","output":"<line1>{\n<line2>    LOG.info(\"connecting to {} {}\", host, port);\n<line3>    Socket sock = null;\n<line4>    BufferedReader reader = null;\n<line5>    try {\n<line6>        InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);\n<line7>        if (secure) {\n<line8>            LOG.info(\"using secure socket\");\n<line9>            try (X509Util x509Util = new ClientX509Util()) {\n<line10>                SSLContext sslContext = x509Util.getDefaultSSLContext();\n<line11>                SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n<line12>                SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();\n<line13>                sslSock.connect(hostaddress, timeout);\n<line14>                sslSock.startHandshake();\n<line15>                sock = sslSock;\n<line16>            }\n<line17>        } else {\n<line18>            sock = new Socket();\n<line19>            sock.connect(hostaddress, timeout);\n<line20>        }\n<line21>        sock.setSoTimeout(timeout);\n<line22>        OutputStream outstream = sock.getOutputStream();\n<line23>        outstream.write(cmd.getBytes(UTF_8));\n<line24>        outstream.flush();\n<line25>        // this replicates NC - close the output stream before reading\n<line26>        if (!secure) {\n<line27>            // SSL prohibits unilateral half-close\n<line28>            sock.shutdownOutput();\n<line29>        }\n<line30>        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line31>        StringBuilder sb = new StringBuilder();\n<line32>        String line;\n<line33>        while ((line = reader.readLine()) != null) {\n<line34>            sb.append(line).append(\"\\n\");\n<line35>        }\n<line36>        return sb.toString();\n<line37>    } catch (SocketTimeoutException e) {\n<line38>        throw new IOException(\"Exception while executing four letter word: \" + cmd, e);\n<line39>    } finally {\n<line40>        if (sock != null) {\n<line41>            sock.close();\n<line42>        }\n<line43>        if (reader != null) {\n<line44>            reader.close();\n<line45>        }\n<line46>    }\n<line47>}"},{"input":"","instruction":"<line1>{\n<line2>    InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);\n<line3>    if (secure) {\n<line4>        try (X509Util x509Util = new ClientX509Util()) {\n<line5>            SSLContext sslContext = x509Util.getDefaultSSLContext();\n<line6>            SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n<line7>            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();\n<line8>            sslSock.connect(hostaddress, timeout);\n<line9>            sslSock.startHandshake();\n<line10>            sock = sslSock;\n<line11>        }\n<line12>    } else {\n<line13>        sock = new Socket();\n<line14>        sock.connect(hostaddress, timeout);\n<line15>    }\n<line16>    sock.setSoTimeout(timeout);\n<line17>    OutputStream outstream = sock.getOutputStream();\n<line18>    outstream.write(cmd.getBytes(UTF_8));\n<line19>    outstream.flush();\n<line20>    // this replicates NC - close the output stream before reading\n<line21>    if (!secure) {\n<line22>        // SSL prohibits unilateral half-close\n<line23>        sock.shutdownOutput();\n<line24>    }\n<line25>    reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line26>    StringBuilder sb = new StringBuilder();\n<line27>    String line;\n<line28>    while ((line = reader.readLine()) != null) {\n<line29>        sb.append(line).append(\"\\n\");\n<line30>    }\n<line31>    return sb.toString();\n<line32>}","output":"<line1>{\n<line2>    InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);\n<line3>    if (secure) {\n<line4>        LOG.info(\"using secure socket\");\n<line5>        try (X509Util x509Util = new ClientX509Util()) {\n<line6>            SSLContext sslContext = x509Util.getDefaultSSLContext();\n<line7>            SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n<line8>            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();\n<line9>            sslSock.connect(hostaddress, timeout);\n<line10>            sslSock.startHandshake();\n<line11>            sock = sslSock;\n<line12>        }\n<line13>    } else {\n<line14>        sock = new Socket();\n<line15>        sock.connect(hostaddress, timeout);\n<line16>    }\n<line17>    sock.setSoTimeout(timeout);\n<line18>    OutputStream outstream = sock.getOutputStream();\n<line19>    outstream.write(cmd.getBytes(UTF_8));\n<line20>    outstream.flush();\n<line21>    // this replicates NC - close the output stream before reading\n<line22>    if (!secure) {\n<line23>        // SSL prohibits unilateral half-close\n<line24>        sock.shutdownOutput();\n<line25>    }\n<line26>    reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n<line27>    StringBuilder sb = new StringBuilder();\n<line28>    String line;\n<line29>    while ((line = reader.readLine()) != null) {\n<line30>        sb.append(line).append(\"\\n\");\n<line31>    }\n<line32>    return sb.toString();\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    try (X509Util x509Util = new ClientX509Util()) {\n<line3>        SSLContext sslContext = x509Util.getDefaultSSLContext();\n<line4>        SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n<line5>        SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();\n<line6>        sslSock.connect(hostaddress, timeout);\n<line7>        sslSock.startHandshake();\n<line8>        sock = sslSock;\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    LOG.info(\"using secure socket\");\n<line3>    try (X509Util x509Util = new ClientX509Util()) {\n<line4>        SSLContext sslContext = x509Util.getDefaultSSLContext();\n<line5>        SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n<line6>        SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();\n<line7>        sslSock.connect(hostaddress, timeout);\n<line8>        sslSock.startHandshake();\n<line9>        sock = sslSock;\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String curHostString = address.getHostString();\n<line4>        List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));\n<line5>        if (resolvedAddresses.isEmpty()) {\n<line6>            return address;\n<line7>        }\n<line8>        Collections.shuffle(resolvedAddresses);\n<line9>        return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());\n<line10>    } catch (UnknownHostException e) {\n<line11>        return address;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    try {\n<line3>        String curHostString = address.getHostString();\n<line4>        List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));\n<line5>        if (resolvedAddresses.isEmpty()) {\n<line6>            return address;\n<line7>        }\n<line8>        Collections.shuffle(resolvedAddresses);\n<line9>        return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());\n<line10>    } catch (UnknownHostException e) {\n<line11>        LOG.error(\"Unable to resolve address: {}\", address.toString(), e);\n<line12>        return address;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    return address;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to resolve address: {}\", address.toString(), e);\n<line3>    return address;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    // processResult() is used by ClientCnxn's sendThread to respond to\n<line3>    // data[] contains the Zookeeper Server's SASL token.\n<line4>    // ctx is the ZooKeeperSaslClient object. We use this object's respondToServer() method\n<line5>    // to reply to the Zookeeper Server's SASL token\n<line6>    ZooKeeperSaslClient client = ((ClientCnxn) ctx).getZooKeeperSaslClient();\n<line7>    if (client == null) {\n<line8>        return;\n<line9>    }\n<line10>    byte[] usedata = data;\n<line11>    if (data != null) {\n<line12>    } else {\n<line13>        usedata = new byte[0];\n<line14>    }\n<line15>    client.respondToServer(usedata, (ClientCnxn) ctx);\n<line16>}","output":"<line1>{\n<line2>    // processResult() is used by ClientCnxn's sendThread to respond to\n<line3>    // data[] contains the Zookeeper Server's SASL token.\n<line4>    // ctx is the ZooKeeperSaslClient object. We use this object's respondToServer() method\n<line5>    // to reply to the Zookeeper Server's SASL token\n<line6>    ZooKeeperSaslClient client = ((ClientCnxn) ctx).getZooKeeperSaslClient();\n<line7>    if (client == null) {\n<line8>        LOG.warn(\"sasl client was unexpectedly null: cannot respond to Zookeeper server.\");\n<line9>        return;\n<line10>    }\n<line11>    byte[] usedata = data;\n<line12>    if (data != null) {\n<line13>        LOG.debug(\"ServerSaslResponseCallback(): saslToken server response: (length={})\", usedata.length);\n<line14>    } else {\n<line15>        usedata = new byte[0];\n<line16>        LOG.debug(\"ServerSaslResponseCallback(): using empty data[] as server response (length={})\", usedata.length);\n<line17>    }\n<line18>    client.respondToServer(usedata, (ClientCnxn) ctx);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"ServerSaslResponseCallback(): saslToken server response: (length={})\", usedata.length);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    usedata = new byte[0];\n<line3>}","output":"<line1>{\n<line2>    usedata = new byte[0];\n<line3>    LOG.debug(\"ServerSaslResponseCallback(): using empty data[] as server response (length={})\", usedata.length);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        if (loginRef.get() == null) {\n<line4>            // note that the login object is static: it's shared amongst all zookeeper-related connections.\n<line5>            // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n<line6>            Login l = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n<line7>            if (loginRef.compareAndSet(null, l)) {\n<line8>                l.startThreadIfNeeded();\n<line9>            }\n<line10>        }\n<line11>        return SecurityUtils.createSaslClient(loginRef.get().getSubject(), servicePrincipal, \"zookeeper\", \"zk-sasl-md5\", LOG, \"Client\");\n<line12>    } catch (LoginException e) {\n<line13>        // We throw LoginExceptions...\n<line14>        throw e;\n<line15>    } catch (Exception e) {\n<line16>        // ...but consume (with a log message) all other types of exceptions.\n<line17>        return null;\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    try {\n<line3>        if (loginRef.get() == null) {\n<line4>            LOG.debug(\"JAAS loginContext is: {}\", loginContext);\n<line5>            // note that the login object is static: it's shared amongst all zookeeper-related connections.\n<line6>            // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n<line7>            Login l = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n<line8>            if (loginRef.compareAndSet(null, l)) {\n<line9>                l.startThreadIfNeeded();\n<line10>            }\n<line11>        }\n<line12>        return SecurityUtils.createSaslClient(loginRef.get().getSubject(), servicePrincipal, \"zookeeper\", \"zk-sasl-md5\", LOG, \"Client\");\n<line13>    } catch (LoginException e) {\n<line14>        // We throw LoginExceptions...\n<line15>        throw e;\n<line16>    } catch (Exception e) {\n<line17>        // ...but consume (with a log message) all other types of exceptions.\n<line18>        LOG.error(\"Exception while trying to create SASL client.\", e);\n<line19>        return null;\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    if (loginRef.get() == null) {\n<line3>        // note that the login object is static: it's shared amongst all zookeeper-related connections.\n<line4>        // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n<line5>        Login l = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n<line6>        if (loginRef.compareAndSet(null, l)) {\n<line7>            l.startThreadIfNeeded();\n<line8>        }\n<line9>    }\n<line10>    return SecurityUtils.createSaslClient(loginRef.get().getSubject(), servicePrincipal, \"zookeeper\", \"zk-sasl-md5\", LOG, \"Client\");\n<line11>}","output":"<line1>{\n<line2>    if (loginRef.get() == null) {\n<line3>        LOG.debug(\"JAAS loginContext is: {}\", loginContext);\n<line4>        // note that the login object is static: it's shared amongst all zookeeper-related connections.\n<line5>        // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n<line6>        Login l = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n<line7>        if (loginRef.compareAndSet(null, l)) {\n<line8>            l.startThreadIfNeeded();\n<line9>        }\n<line10>    }\n<line11>    return SecurityUtils.createSaslClient(loginRef.get().getSubject(), servicePrincipal, \"zookeeper\", \"zk-sasl-md5\", LOG, \"Client\");\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    // note that the login object is static: it's shared amongst all zookeeper-related connections.\n<line3>    // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n<line4>    Login l = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n<line5>    if (loginRef.compareAndSet(null, l)) {\n<line6>        l.startThreadIfNeeded();\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.debug(\"JAAS loginContext is: {}\", loginContext);\n<line3>    // note that the login object is static: it's shared amongst all zookeeper-related connections.\n<line4>    // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n<line5>    Login l = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n<line6>    if (loginRef.compareAndSet(null, l)) {\n<line7>        l.startThreadIfNeeded();\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    // ...but consume (with a log message) all other types of exceptions.\n<line3>    return null;\n<line4>}","output":"<line1>{\n<line2>    // ...but consume (with a log message) all other types of exceptions.\n<line3>    LOG.error(\"Exception while trying to create SASL client.\", e);\n<line4>    return null;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (saslClient == null) {\n<line3>        return;\n<line4>    }\n<line5>    if (!(saslClient.isComplete())) {\n<line6>        try {\n<line7>            saslToken = createSaslToken(serverToken);\n<line8>            if (saslToken != null) {\n<line9>                sendSaslPacket(saslToken, cnxn);\n<line10>            }\n<line11>        } catch (SaslException e) {\n<line12>            saslState = SaslState.FAILED;\n<line13>            gotLastPacket = true;\n<line14>        }\n<line15>    }\n<line16>    if (saslClient.isComplete()) {\n<line17>        // GSSAPI: server sends a final packet after authentication succeeds\n<line18>        // or fails.\n<line19>        if ((serverToken == null) && (saslClient.getMechanismName().equals(\"GSSAPI\"))) {\n<line20>            gotLastPacket = true;\n<line21>        }\n<line22>        // non-GSSAPI: no final packet from server.\n<line23>        if (!saslClient.getMechanismName().equals(\"GSSAPI\")) {\n<line24>            gotLastPacket = true;\n<line25>        }\n<line26>        // SASL authentication is completed, successfully or not:\n<line27>        // enable the socket's writable flag so that any packets waiting for authentication to complete in\n<line28>        // the outgoing queue will be sent to the Zookeeper server.\n<line29>        cnxn.saslCompleted();\n<line30>    }\n<line31>}","output":"<line1>{\n<line2>    if (saslClient == null) {\n<line3>        LOG.error(\"saslClient is unexpectedly null. Cannot respond to server's SASL message; ignoring.\");\n<line4>        return;\n<line5>    }\n<line6>    if (!(saslClient.isComplete())) {\n<line7>        try {\n<line8>            saslToken = createSaslToken(serverToken);\n<line9>            if (saslToken != null) {\n<line10>                sendSaslPacket(saslToken, cnxn);\n<line11>            }\n<line12>        } catch (SaslException e) {\n<line13>            LOG.error(\"SASL authentication failed using login context '{}'.\", this.getLoginContext(), e);\n<line14>            saslState = SaslState.FAILED;\n<line15>            gotLastPacket = true;\n<line16>        }\n<line17>    }\n<line18>    if (saslClient.isComplete()) {\n<line19>        // GSSAPI: server sends a final packet after authentication succeeds\n<line20>        // or fails.\n<line21>        if ((serverToken == null) && (saslClient.getMechanismName().equals(\"GSSAPI\"))) {\n<line22>            gotLastPacket = true;\n<line23>        }\n<line24>        // non-GSSAPI: no final packet from server.\n<line25>        if (!saslClient.getMechanismName().equals(\"GSSAPI\")) {\n<line26>            gotLastPacket = true;\n<line27>        }\n<line28>        // SASL authentication is completed, successfully or not:\n<line29>        // enable the socket's writable flag so that any packets waiting for authentication to complete in\n<line30>        // the outgoing queue will be sent to the Zookeeper server.\n<line31>        cnxn.saslCompleted();\n<line32>    }\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"saslClient is unexpectedly null. Cannot respond to server's SASL message; ignoring.\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        saslToken = createSaslToken(serverToken);\n<line4>        if (saslToken != null) {\n<line5>            sendSaslPacket(saslToken, cnxn);\n<line6>        }\n<line7>    } catch (SaslException e) {\n<line8>        saslState = SaslState.FAILED;\n<line9>        gotLastPacket = true;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    try {\n<line3>        saslToken = createSaslToken(serverToken);\n<line4>        if (saslToken != null) {\n<line5>            sendSaslPacket(saslToken, cnxn);\n<line6>        }\n<line7>    } catch (SaslException e) {\n<line8>        LOG.error(\"SASL authentication failed using login context '{}'.\", this.getLoginContext(), e);\n<line9>        saslState = SaslState.FAILED;\n<line10>        gotLastPacket = true;\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    saslState = SaslState.FAILED;\n<line3>    gotLastPacket = true;\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"SASL authentication failed using login context '{}'.\", this.getLoginContext(), e);\n<line3>    saslState = SaslState.FAILED;\n<line4>    gotLastPacket = true;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (saslToken == null) {\n<line3>        // TODO: introspect about runtime environment (such as jaas.conf)\n<line4>        saslState = SaslState.FAILED;\n<line5>        throw new SaslException(\"Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.\");\n<line6>    }\n<line7>    Subject subject = login.getSubject();\n<line8>    if (subject != null) {\n<line9>        synchronized (login) {\n<line10>            try {\n<line11>                final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line12>\n<line13>                    public byte[] run() throws SaslException {\n<line14>                        return saslClient.evaluateChallenge(saslToken);\n<line15>                    }\n<line16>                });\n<line17>                return retval;\n<line18>            } catch (PrivilegedActionException e) {\n<line19>                String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line20>                // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line21>                // TODO: introspect about e: look for GSS information.\n<line22>                final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line23>                if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line24>                    error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line25>                }\n<line26>                error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line27>                saslState = SaslState.FAILED;\n<line28>                throw new SaslException(error, e);\n<line29>            }\n<line30>        }\n<line31>    } else {\n<line32>        throw new SaslException(\"Cannot make SASL token without subject defined. \" + \"For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.\");\n<line33>    }\n<line34>}","output":"<line1>{\n<line2>    if (saslToken == null) {\n<line3>        // TODO: introspect about runtime environment (such as jaas.conf)\n<line4>        saslState = SaslState.FAILED;\n<line5>        throw new SaslException(\"Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.\");\n<line6>    }\n<line7>    Subject subject = login.getSubject();\n<line8>    if (subject != null) {\n<line9>        synchronized (login) {\n<line10>            try {\n<line11>                final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line12>\n<line13>                    public byte[] run() throws SaslException {\n<line14>                        LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line15>                        return saslClient.evaluateChallenge(saslToken);\n<line16>                    }\n<line17>                });\n<line18>                return retval;\n<line19>            } catch (PrivilegedActionException e) {\n<line20>                String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line21>                // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line22>                // TODO: introspect about e: look for GSS information.\n<line23>                final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line24>                if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line25>                    error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line26>                }\n<line27>                error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line28>                LOG.error(error);\n<line29>                saslState = SaslState.FAILED;\n<line30>                throw new SaslException(error, e);\n<line31>            }\n<line32>        }\n<line33>    } else {\n<line34>        throw new SaslException(\"Cannot make SASL token without subject defined. \" + \"For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.\");\n<line35>    }\n<line36>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (login) {\n<line3>        try {\n<line4>            final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line5>\n<line6>                public byte[] run() throws SaslException {\n<line7>                    return saslClient.evaluateChallenge(saslToken);\n<line8>                }\n<line9>            });\n<line10>            return retval;\n<line11>        } catch (PrivilegedActionException e) {\n<line12>            String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line13>            // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line14>            // TODO: introspect about e: look for GSS information.\n<line15>            final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line16>            if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line17>                error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line18>            }\n<line19>            error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line20>            saslState = SaslState.FAILED;\n<line21>            throw new SaslException(error, e);\n<line22>        }\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    synchronized (login) {\n<line3>        try {\n<line4>            final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line5>\n<line6>                public byte[] run() throws SaslException {\n<line7>                    LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line8>                    return saslClient.evaluateChallenge(saslToken);\n<line9>                }\n<line10>            });\n<line11>            return retval;\n<line12>        } catch (PrivilegedActionException e) {\n<line13>            String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line14>            // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line15>            // TODO: introspect about e: look for GSS information.\n<line16>            final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line17>            if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line18>                error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line19>            }\n<line20>            error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line21>            LOG.error(error);\n<line22>            saslState = SaslState.FAILED;\n<line23>            throw new SaslException(error, e);\n<line24>        }\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line4>\n<line5>            public byte[] run() throws SaslException {\n<line6>                return saslClient.evaluateChallenge(saslToken);\n<line7>            }\n<line8>        });\n<line9>        return retval;\n<line10>    } catch (PrivilegedActionException e) {\n<line11>        String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line12>        // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line13>        // TODO: introspect about e: look for GSS information.\n<line14>        final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line15>        if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line16>            error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line17>        }\n<line18>        error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line19>        saslState = SaslState.FAILED;\n<line20>        throw new SaslException(error, e);\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    try {\n<line3>        final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line4>\n<line5>            public byte[] run() throws SaslException {\n<line6>                LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line7>                return saslClient.evaluateChallenge(saslToken);\n<line8>            }\n<line9>        });\n<line10>        return retval;\n<line11>    } catch (PrivilegedActionException e) {\n<line12>        String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line13>        // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line14>        // TODO: introspect about e: look for GSS information.\n<line15>        final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line16>        if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line17>            error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line18>        }\n<line19>        error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line20>        LOG.error(error);\n<line21>        saslState = SaslState.FAILED;\n<line22>        throw new SaslException(error, e);\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line3>\n<line4>        public byte[] run() throws SaslException {\n<line5>            return saslClient.evaluateChallenge(saslToken);\n<line6>        }\n<line7>    });\n<line8>    return retval;\n<line9>}","output":"<line1>{\n<line2>    final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {\n<line3>\n<line4>        public byte[] run() throws SaslException {\n<line5>            LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line6>            return saslClient.evaluateChallenge(saslToken);\n<line7>        }\n<line8>    });\n<line9>    return retval;\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return saslClient.evaluateChallenge(saslToken);\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"saslClient.evaluateChallenge(len={})\", saslToken.length);\n<line3>    return saslClient.evaluateChallenge(saslToken);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line3>    // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line4>    // TODO: introspect about e: look for GSS information.\n<line5>    final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line6>    if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line7>        error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line8>    }\n<line9>    error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line10>    saslState = SaslState.FAILED;\n<line11>    throw new SaslException(error, e);\n<line12>}","output":"<line1>{\n<line2>    String error = \"An error: (\" + e + \") occurred when evaluating Zookeeper Quorum Member's \" + \" received SASL token.\";\n<line3>    // Try to provide hints to use about what went wrong so they can fix their configuration.\n<line4>    // TODO: introspect about e: look for GSS information.\n<line5>    final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n<line6>    if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {\n<line7>        error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\" + \" hostname correctly. You may want to try to adding\" + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.\";\n<line8>    }\n<line9>    error += \" Zookeeper Client will go to AUTH_FAILED state.\";\n<line10>    LOG.error(error);\n<line11>    saslState = SaslState.FAILED;\n<line12>    throw new SaslException(error, e);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    GetSASLRequest request = new GetSASLRequest();\n<line3>    request.setToken(saslToken);\n<line4>    SetSASLResponse response = new SetSASLResponse();\n<line5>    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();\n<line6>    try {\n<line7>        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);\n<line8>    } catch (IOException e) {\n<line9>        throw new SaslException(\"Failed to send SASL packet to server.\", e);\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.debug(\"ClientCnxn:sendSaslPacket:length={}\", saslToken.length);\n<line3>    GetSASLRequest request = new GetSASLRequest();\n<line4>    request.setToken(saslToken);\n<line5>    SetSASLResponse response = new SetSASLResponse();\n<line6>    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();\n<line7>    try {\n<line8>        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);\n<line9>    } catch (IOException e) {\n<line10>        throw new SaslException(\"Failed to send SASL packet to server.\", e);\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    GetSASLRequest request = new GetSASLRequest();\n<line3>    request.setToken(createSaslToken());\n<line4>    SetSASLResponse response = new SetSASLResponse();\n<line5>    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();\n<line6>    try {\n<line7>        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);\n<line8>    } catch (IOException e) {\n<line9>        throw new SaslException(\"Failed to send SASL packet to server due \" + \"to IOException:\", e);\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.debug(\"ClientCnxn:sendSaslPacket:length={}\", saslToken.length);\n<line3>    GetSASLRequest request = new GetSASLRequest();\n<line4>    request.setToken(createSaslToken());\n<line5>    SetSASLResponse response = new SetSASLResponse();\n<line6>    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();\n<line7>    try {\n<line8>        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);\n<line9>    } catch (IOException e) {\n<line10>        throw new SaslException(\"Failed to send SASL packet to server due \" + \"to IOException:\", e);\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!isSASLConfigured) {\n<line3>        return false;\n<line4>    }\n<line5>    // TODO: Rather than checking a disjunction here, should be a single member\n<line6>    // variable or method in this class to determine whether the client is\n<line7>    // configured to use SASL. (see also ZOOKEEPER-1455).\n<line8>    try {\n<line9>        if ((clientConfig.getJaasConfKey() != null) || ((Configuration.getConfiguration() != null) && (Configuration.getConfiguration().getAppConfigurationEntry(clientConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT)) != null))) {\n<line10>            // Client is configured to use a valid login Configuration, so\n<line11>            // authentication is either in progress, successful, or failed.\n<line12>            // 1. Authentication hasn't finished yet: we must wait for it to do so.\n<line13>            if (!isComplete() && !isFailed()) {\n<line14>                return true;\n<line15>            }\n<line16>            // 2. SASL authentication has succeeded or failed..\n<line17>            //noinspection RedundantIfStatement\n<line18>            if (!gotLastPacket) {\n<line19>                // ..but still in progress, because there is a final SASL\n<line20>                // message from server which must be received.\n<line21>                return true;\n<line22>            }\n<line23>        }\n<line24>        // Either client is not configured to use a tunnelled authentication\n<line25>        // scheme, or tunnelled authentication has completed (successfully or\n<line26>        // not), and all server SASL messages have been received.\n<line27>        return false;\n<line28>    } catch (SecurityException e) {\n<line29>        // Thrown if the caller does not have permission to retrieve the Configuration.\n<line30>        // In this case, simply returning false is correct.\n<line31>        return false;\n<line32>    }\n<line33>}","output":"<line1>{\n<line2>    if (!isSASLConfigured) {\n<line3>        return false;\n<line4>    }\n<line5>    // TODO: Rather than checking a disjunction here, should be a single member\n<line6>    // variable or method in this class to determine whether the client is\n<line7>    // configured to use SASL. (see also ZOOKEEPER-1455).\n<line8>    try {\n<line9>        if ((clientConfig.getJaasConfKey() != null) || ((Configuration.getConfiguration() != null) && (Configuration.getConfiguration().getAppConfigurationEntry(clientConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT)) != null))) {\n<line10>            // Client is configured to use a valid login Configuration, so\n<line11>            // authentication is either in progress, successful, or failed.\n<line12>            // 1. Authentication hasn't finished yet: we must wait for it to do so.\n<line13>            if (!isComplete() && !isFailed()) {\n<line14>                return true;\n<line15>            }\n<line16>            // 2. SASL authentication has succeeded or failed..\n<line17>            //noinspection RedundantIfStatement\n<line18>            if (!gotLastPacket) {\n<line19>                // ..but still in progress, because there is a final SASL\n<line20>                // message from server which must be received.\n<line21>                return true;\n<line22>            }\n<line23>        }\n<line24>        // Either client is not configured to use a tunnelled authentication\n<line25>        // scheme, or tunnelled authentication has completed (successfully or\n<line26>        // not), and all server SASL messages have been received.\n<line27>        return false;\n<line28>    } catch (SecurityException e) {\n<line29>        // Thrown if the caller does not have permission to retrieve the Configuration.\n<line30>        // In this case, simply returning false is correct.\n<line31>        LOG.debug(\"Could not retrieve login configuration\", e);\n<line32>        return false;\n<line33>    }\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    // Thrown if the caller does not have permission to retrieve the Configuration.\n<line3>    // In this case, simply returning false is correct.\n<line4>    return false;\n<line5>}","output":"<line1>{\n<line2>    // Thrown if the caller does not have permission to retrieve the Configuration.\n<line3>    // In this case, simply returning false is correct.\n<line4>    LOG.debug(\"Could not retrieve login configuration\", e);\n<line5>    return false;\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    this.clientConfig = clientConfig != null ? clientConfig : new ZKClientConfig();\n<line3>    this.hostProvider = hostProvider;\n<line4>    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);\n<line5>    cnxn = createConnection(connectStringParser.getChrootPath(), hostProvider, sessionTimeout, this.clientConfig, watcher, getClientCnxnSocket(), canBeReadOnly);\n<line6>    cnxn.start();\n<line7>}","output":"<line1>{\n<line2>    LOG.info(\"Initiating client connection, connectString={} sessionTimeout={} watcher={}\", connectString, sessionTimeout, watcher);\n<line3>    this.clientConfig = clientConfig != null ? clientConfig : new ZKClientConfig();\n<line4>    this.hostProvider = hostProvider;\n<line5>    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);\n<line6>    cnxn = createConnection(connectStringParser.getChrootPath(), hostProvider, sessionTimeout, this.clientConfig, watcher, getClientCnxnSocket(), canBeReadOnly);\n<line7>    cnxn.start();\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    this.clientConfig = clientConfig != null ? clientConfig : new ZKClientConfig();\n<line3>    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);\n<line4>    this.hostProvider = hostProvider;\n<line5>    cnxn = new ClientCnxn(connectStringParser.getChrootPath(), hostProvider, sessionTimeout, this.clientConfig, watcher, getClientCnxnSocket(), sessionId, sessionPasswd, canBeReadOnly);\n<line6>    // since user has provided sessionId\n<line7>    cnxn.seenRwServerBefore = true;\n<line8>    cnxn.start();\n<line9>}","output":"<line1>{\n<line2>    LOG.info(\"Initiating client connection, connectString={} \" + \"sessionTimeout={} watcher={} sessionId=0x{} sessionPasswd={}\", connectString, sessionTimeout, watcher, Long.toHexString(sessionId), (sessionPasswd == null ? \"<null>\" : \"<hidden>\"));\n<line3>    this.clientConfig = clientConfig != null ? clientConfig : new ZKClientConfig();\n<line4>    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);\n<line5>    this.hostProvider = hostProvider;\n<line6>    cnxn = new ClientCnxn(connectStringParser.getChrootPath(), hostProvider, sessionTimeout, this.clientConfig, watcher, getClientCnxnSocket(), sessionId, sessionPasswd, canBeReadOnly);\n<line7>    // since user has provided sessionId\n<line8>    cnxn.seenRwServerBefore = true;\n<line9>    cnxn.start();\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!cnxn.getState().isAlive()) {\n<line3>        return;\n<line4>    }\n<line5>    try {\n<line6>        cnxn.close();\n<line7>    } catch (IOException e) {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (!cnxn.getState().isAlive()) {\n<line3>        LOG.debug(\"Close called on already closed client\");\n<line4>        return;\n<line5>    }\n<line6>    LOG.debug(\"Closing session: 0x\" + Long.toHexString(getSessionId()));\n<line7>    try {\n<line8>        cnxn.close();\n<line9>    } catch (IOException e) {\n<line10>        LOG.debug(\"Ignoring unexpected exception during close\", e);\n<line11>    }\n<line12>    LOG.info(\"Session: 0x{} closed\", Long.toHexString(getSessionId()));\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Close called on already closed client\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Ignoring unexpected exception during close\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    List<OpResult> results = new ArrayList<>();\n<line3>    boolean error = false;\n<line4>    for (Op op : ops) {\n<line5>        try {\n<line6>            op.validate();\n<line7>        } catch (IllegalArgumentException iae) {\n<line8>            ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());\n<line9>            results.add(err);\n<line10>            error = true;\n<line11>            continue;\n<line12>        } catch (KeeperException ke) {\n<line13>            ErrorResult err = new ErrorResult(ke.code().intValue());\n<line14>            results.add(err);\n<line15>            error = true;\n<line16>            continue;\n<line17>        }\n<line18>        ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());\n<line19>        results.add(err);\n<line20>    }\n<line21>    if (!error) {\n<line22>        results.clear();\n<line23>    }\n<line24>    return results;\n<line25>}","output":"<line1>{\n<line2>    List<OpResult> results = new ArrayList<>();\n<line3>    boolean error = false;\n<line4>    for (Op op : ops) {\n<line5>        try {\n<line6>            op.validate();\n<line7>        } catch (IllegalArgumentException iae) {\n<line8>            LOG.error(\"Unexpected exception\", iae);\n<line9>            ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());\n<line10>            results.add(err);\n<line11>            error = true;\n<line12>            continue;\n<line13>        } catch (KeeperException ke) {\n<line14>            LOG.error(\"Unexpected exception\", ke);\n<line15>            ErrorResult err = new ErrorResult(ke.code().intValue());\n<line16>            results.add(err);\n<line17>            error = true;\n<line18>            continue;\n<line19>        }\n<line20>        ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());\n<line21>        results.add(err);\n<line22>    }\n<line23>    if (!error) {\n<line24>        results.clear();\n<line25>    }\n<line26>    return results;\n<line27>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        op.validate();\n<line4>    } catch (IllegalArgumentException iae) {\n<line5>        ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());\n<line6>        results.add(err);\n<line7>        error = true;\n<line8>        continue;\n<line9>    } catch (KeeperException ke) {\n<line10>        ErrorResult err = new ErrorResult(ke.code().intValue());\n<line11>        results.add(err);\n<line12>        error = true;\n<line13>        continue;\n<line14>    }\n<line15>    ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());\n<line16>    results.add(err);\n<line17>}","output":"<line1>{\n<line2>    try {\n<line3>        op.validate();\n<line4>    } catch (IllegalArgumentException iae) {\n<line5>        LOG.error(\"Unexpected exception\", iae);\n<line6>        ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());\n<line7>        results.add(err);\n<line8>        error = true;\n<line9>        continue;\n<line10>    } catch (KeeperException ke) {\n<line11>        LOG.error(\"Unexpected exception\", ke);\n<line12>        ErrorResult err = new ErrorResult(ke.code().intValue());\n<line13>        results.add(err);\n<line14>        error = true;\n<line15>        continue;\n<line16>    }\n<line17>    ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());\n<line18>    results.add(err);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());\n<line3>    results.add(err);\n<line4>    error = true;\n<line5>    continue;\n<line6>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception\", iae);\n<line3>    ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());\n<line4>    results.add(err);\n<line5>    error = true;\n<line6>    continue;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    ErrorResult err = new ErrorResult(ke.code().intValue());\n<line3>    results.add(err);\n<line4>    error = true;\n<line5>    continue;\n<line6>}","output":"<line1>{\n<line2>    LOG.error(\"Unexpected exception\", ke);\n<line3>    ErrorResult err = new ErrorResult(ke.code().intValue());\n<line4>    results.add(err);\n<line5>    error = true;\n<line6>    continue;\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    for (String line : BANNER) {\n<line3>    }\n<line4>}","output":"<line1>{\n<line2>    for (String line : BANNER) {\n<line3>        log.info(line);\n<line4>    }\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    log.info(line);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n<line3>    PrintStream realStdOut = System.out;\n<line4>    System.setOut(new PrintStream(byteArrayOutputStream));\n<line5>    System.setOut(realStdOut);\n<line6>    //log to stdout for debug\n<line7>    String bufferMessage = new String(byteArrayOutputStream.toByteArray(), StandardCharsets.UTF_8);\n<line8>    Assert.assertTrue(bufferMessage.contains(testMessage));\n<line9>}","output":"<line1>{\n<line2>    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n<line3>    PrintStream realStdOut = System.out;\n<line4>    System.setOut(new PrintStream(byteArrayOutputStream));\n<line5>    LOG.info(testMessage);\n<line6>    System.setOut(realStdOut);\n<line7>    //log to stdout for debug\n<line8>    LOG.info(testMessage);\n<line9>    String bufferMessage = new String(byteArrayOutputStream.toByteArray(), StandardCharsets.UTF_8);\n<line10>    LOG.info(bufferMessage);\n<line11>    Assert.assertTrue(bufferMessage.contains(testMessage));\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    LogEntry e = null;\n<line3>    try {\n<line4>        long crcValue;\n<line5>        byte[] bytes;\n<line6>        try {\n<line7>            crcValue = logStream.readLong(\"crcvalue\");\n<line8>            bytes = logStream.readBuffer(\"txnEntry\");\n<line9>        } catch (EOFException ex) {\n<line10>            return null;\n<line11>        }\n<line12>        if (bytes.length == 0) {\n<line13>            return null;\n<line14>        }\n<line15>        Checksum crc = new Adler32();\n<line16>        crc.update(bytes, 0, bytes.length);\n<line17>        if (crcValue != crc.getValue()) {\n<line18>            throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n<line19>        }\n<line20>        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n<line21>        TxnHeader hdr = logEntry.getHeader();\n<line22>        Record r = logEntry.getTxn();\n<line23>        switch(hdr.getType()) {\n<line24>            case OpCode.createSession:\n<line25>                {\n<line26>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n<line27>                }\n<line28>                break;\n<line29>            case OpCode.closeSession:\n<line30>                {\n<line31>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n<line32>                }\n<line33>                break;\n<line34>            case OpCode.create:\n<line35>                if (r != null) {\n<line36>                    CreateTxn create = (CreateTxn) r;\n<line37>                    String path = create.getPath();\n<line38>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n<line39>                }\n<line40>                break;\n<line41>            case OpCode.setData:\n<line42>                if (r != null) {\n<line43>                    SetDataTxn set = (SetDataTxn) r;\n<line44>                    String path = set.getPath();\n<line45>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n<line46>                }\n<line47>                break;\n<line48>            case OpCode.setACL:\n<line49>                if (r != null) {\n<line50>                    SetACLTxn setacl = (SetACLTxn) r;\n<line51>                    String path = setacl.getPath();\n<line52>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n<line53>                }\n<line54>                break;\n<line55>            case OpCode.error:\n<line56>                if (r != null) {\n<line57>                    ErrorTxn error = (ErrorTxn) r;\n<line58>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n<line59>                }\n<line60>                break;\n<line61>            default:\n<line62>                break;\n<line63>        }\n<line64>        if (logStream.readByte(\"EOR\") != 'B') {\n<line65>            throw new EOFException(\"Last transaction was partial.\");\n<line66>        }\n<line67>    } catch (Exception ex) {\n<line68>        return null;\n<line69>    }\n<line70>    return e;\n<line71>}","output":"<line1>{\n<line2>    LogEntry e = null;\n<line3>    try {\n<line4>        long crcValue;\n<line5>        byte[] bytes;\n<line6>        try {\n<line7>            crcValue = logStream.readLong(\"crcvalue\");\n<line8>            bytes = logStream.readBuffer(\"txnEntry\");\n<line9>        } catch (EOFException ex) {\n<line10>            return null;\n<line11>        }\n<line12>        if (bytes.length == 0) {\n<line13>            return null;\n<line14>        }\n<line15>        Checksum crc = new Adler32();\n<line16>        crc.update(bytes, 0, bytes.length);\n<line17>        if (crcValue != crc.getValue()) {\n<line18>            throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n<line19>        }\n<line20>        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n<line21>        TxnHeader hdr = logEntry.getHeader();\n<line22>        Record r = logEntry.getTxn();\n<line23>        switch(hdr.getType()) {\n<line24>            case OpCode.createSession:\n<line25>                {\n<line26>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n<line27>                }\n<line28>                break;\n<line29>            case OpCode.closeSession:\n<line30>                {\n<line31>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n<line32>                }\n<line33>                break;\n<line34>            case OpCode.create:\n<line35>                if (r != null) {\n<line36>                    CreateTxn create = (CreateTxn) r;\n<line37>                    String path = create.getPath();\n<line38>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n<line39>                }\n<line40>                break;\n<line41>            case OpCode.setData:\n<line42>                if (r != null) {\n<line43>                    SetDataTxn set = (SetDataTxn) r;\n<line44>                    String path = set.getPath();\n<line45>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n<line46>                }\n<line47>                break;\n<line48>            case OpCode.setACL:\n<line49>                if (r != null) {\n<line50>                    SetACLTxn setacl = (SetACLTxn) r;\n<line51>                    String path = setacl.getPath();\n<line52>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n<line53>                }\n<line54>                break;\n<line55>            case OpCode.error:\n<line56>                if (r != null) {\n<line57>                    ErrorTxn error = (ErrorTxn) r;\n<line58>                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n<line59>                }\n<line60>                break;\n<line61>            default:\n<line62>                LOG.info(\"Unknown op: \" + hdr.getType());\n<line63>                break;\n<line64>        }\n<line65>        if (logStream.readByte(\"EOR\") != 'B') {\n<line66>            throw new EOFException(\"Last transaction was partial.\");\n<line67>        }\n<line68>    } catch (Exception ex) {\n<line69>        LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n<line70>        return null;\n<line71>    }\n<line72>    return e;\n<line73>}"},{"input":"","instruction":"<line1>{\n<line2>    long crcValue;\n<line3>    byte[] bytes;\n<line4>    try {\n<line5>        crcValue = logStream.readLong(\"crcvalue\");\n<line6>        bytes = logStream.readBuffer(\"txnEntry\");\n<line7>    } catch (EOFException ex) {\n<line8>        return null;\n<line9>    }\n<line10>    if (bytes.length == 0) {\n<line11>        return null;\n<line12>    }\n<line13>    Checksum crc = new Adler32();\n<line14>    crc.update(bytes, 0, bytes.length);\n<line15>    if (crcValue != crc.getValue()) {\n<line16>        throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n<line17>    }\n<line18>    TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n<line19>    TxnHeader hdr = logEntry.getHeader();\n<line20>    Record r = logEntry.getTxn();\n<line21>    switch(hdr.getType()) {\n<line22>        case OpCode.createSession:\n<line23>            {\n<line24>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n<line25>            }\n<line26>            break;\n<line27>        case OpCode.closeSession:\n<line28>            {\n<line29>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n<line30>            }\n<line31>            break;\n<line32>        case OpCode.create:\n<line33>            if (r != null) {\n<line34>                CreateTxn create = (CreateTxn) r;\n<line35>                String path = create.getPath();\n<line36>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n<line37>            }\n<line38>            break;\n<line39>        case OpCode.setData:\n<line40>            if (r != null) {\n<line41>                SetDataTxn set = (SetDataTxn) r;\n<line42>                String path = set.getPath();\n<line43>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n<line44>            }\n<line45>            break;\n<line46>        case OpCode.setACL:\n<line47>            if (r != null) {\n<line48>                SetACLTxn setacl = (SetACLTxn) r;\n<line49>                String path = setacl.getPath();\n<line50>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n<line51>            }\n<line52>            break;\n<line53>        case OpCode.error:\n<line54>            if (r != null) {\n<line55>                ErrorTxn error = (ErrorTxn) r;\n<line56>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n<line57>            }\n<line58>            break;\n<line59>        default:\n<line60>            break;\n<line61>    }\n<line62>    if (logStream.readByte(\"EOR\") != 'B') {\n<line63>        throw new EOFException(\"Last transaction was partial.\");\n<line64>    }\n<line65>}","output":"<line1>{\n<line2>    long crcValue;\n<line3>    byte[] bytes;\n<line4>    try {\n<line5>        crcValue = logStream.readLong(\"crcvalue\");\n<line6>        bytes = logStream.readBuffer(\"txnEntry\");\n<line7>    } catch (EOFException ex) {\n<line8>        return null;\n<line9>    }\n<line10>    if (bytes.length == 0) {\n<line11>        return null;\n<line12>    }\n<line13>    Checksum crc = new Adler32();\n<line14>    crc.update(bytes, 0, bytes.length);\n<line15>    if (crcValue != crc.getValue()) {\n<line16>        throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n<line17>    }\n<line18>    TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n<line19>    TxnHeader hdr = logEntry.getHeader();\n<line20>    Record r = logEntry.getTxn();\n<line21>    switch(hdr.getType()) {\n<line22>        case OpCode.createSession:\n<line23>            {\n<line24>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n<line25>            }\n<line26>            break;\n<line27>        case OpCode.closeSession:\n<line28>            {\n<line29>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n<line30>            }\n<line31>            break;\n<line32>        case OpCode.create:\n<line33>            if (r != null) {\n<line34>                CreateTxn create = (CreateTxn) r;\n<line35>                String path = create.getPath();\n<line36>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n<line37>            }\n<line38>            break;\n<line39>        case OpCode.setData:\n<line40>            if (r != null) {\n<line41>                SetDataTxn set = (SetDataTxn) r;\n<line42>                String path = set.getPath();\n<line43>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n<line44>            }\n<line45>            break;\n<line46>        case OpCode.setACL:\n<line47>            if (r != null) {\n<line48>                SetACLTxn setacl = (SetACLTxn) r;\n<line49>                String path = setacl.getPath();\n<line50>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n<line51>            }\n<line52>            break;\n<line53>        case OpCode.error:\n<line54>            if (r != null) {\n<line55>                ErrorTxn error = (ErrorTxn) r;\n<line56>                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n<line57>            }\n<line58>            break;\n<line59>        default:\n<line60>            LOG.info(\"Unknown op: \" + hdr.getType());\n<line61>            break;\n<line62>    }\n<line63>    if (logStream.readByte(\"EOR\") != 'B') {\n<line64>        throw new EOFException(\"Last transaction was partial.\");\n<line65>    }\n<line66>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    long starttime = 0;\n<line3>    long endtime = 0;\n<line4>    long period = 0;\n<line5>    FilterOp fo = null;\n<line6>    starttime = request.getNumber(\"start\", 0);\n<line7>    endtime = request.getNumber(\"end\", 0);\n<line8>    period = request.getNumber(\"period\", 0);\n<line9>    String filterstr = request.getString(\"filter\", \"\");\n<line10>    if (filterstr.length() > 0) {\n<line11>        fo = new FilterParser(filterstr).parse();\n<line12>    }\n<line13>    if (starttime == 0) {\n<line14>        starttime = source.getStartTime();\n<line15>    }\n<line16>    if (endtime == 0) {\n<line17>        if (period > 0) {\n<line18>            endtime = starttime + period;\n<line19>        } else {\n<line20>            endtime = starttime + DEFAULT_PERIOD;\n<line21>        }\n<line22>    }\n<line23>    }\n<line24>    LogIterator iterator = (fo != null) ? source.iterator(starttime, endtime, fo) : source.iterator(starttime, endtime);\n<line25>    return new JsonGenerator(iterator).toString();\n<line26>}","output":"<line1>{\n<line2>    long starttime = 0;\n<line3>    long endtime = 0;\n<line4>    long period = 0;\n<line5>    FilterOp fo = null;\n<line6>    starttime = request.getNumber(\"start\", 0);\n<line7>    endtime = request.getNumber(\"end\", 0);\n<line8>    period = request.getNumber(\"period\", 0);\n<line9>    String filterstr = request.getString(\"filter\", \"\");\n<line10>    if (filterstr.length() > 0) {\n<line11>        fo = new FilterParser(filterstr).parse();\n<line12>    }\n<line13>    if (starttime == 0) {\n<line14>        starttime = source.getStartTime();\n<line15>    }\n<line16>    if (endtime == 0) {\n<line17>        if (period > 0) {\n<line18>            endtime = starttime + period;\n<line19>        } else {\n<line20>            endtime = starttime + DEFAULT_PERIOD;\n<line21>        }\n<line22>    }\n<line23>    if (LOG.isDebugEnabled()) {\n<line24>        LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", period=\" + period + \")\");\n<line25>    }\n<line26>    LogIterator iterator = (fo != null) ? source.iterator(starttime, endtime, fo) : source.iterator(starttime, endtime);\n<line27>    return new JsonGenerator(iterator).toString();\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", period=\" + period + \")\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String output = \"\";\n<line3>    long starttime = 0;\n<line4>    long endtime = 0;\n<line5>    long period = 0;\n<line6>    starttime = request.getNumber(\"start\", 0);\n<line7>    endtime = request.getNumber(\"end\", 0);\n<line8>    period = request.getNumber(\"period\", 0);\n<line9>    if (starttime == 0) {\n<line10>        starttime = source.getStartTime();\n<line11>    }\n<line12>    if (endtime == 0) {\n<line13>        if (period > 0) {\n<line14>            endtime = starttime + period;\n<line15>        } else {\n<line16>            endtime = source.getEndTime();\n<line17>        }\n<line18>    }\n<line19>    long size = 0;\n<line20>    LogIterator iter = source.iterator(starttime, endtime);\n<line21>    size = iter.size();\n<line22>    ObjectMapper mapper = new ObjectMapper();\n<line23>    JsonNode data = mapper.createObjectNode();\n<line24>    ((ObjectNode) data).put(\"startTime\", starttime);\n<line25>    ((ObjectNode) data).put(\"endTime\", endtime);\n<line26>    ((ObjectNode) data).put(\"numEntries\", iter.size());\n<line27>    }\n<line28>    iter.close();\n<line29>    String jsonString = mapper.writer(new MinimalPrettyPrinter()).writeValueAsString(data);\n<line30>    return jsonString;\n<line31>}","output":"<line1>{\n<line2>    String output = \"\";\n<line3>    long starttime = 0;\n<line4>    long endtime = 0;\n<line5>    long period = 0;\n<line6>    starttime = request.getNumber(\"start\", 0);\n<line7>    endtime = request.getNumber(\"end\", 0);\n<line8>    period = request.getNumber(\"period\", 0);\n<line9>    if (starttime == 0) {\n<line10>        starttime = source.getStartTime();\n<line11>    }\n<line12>    if (endtime == 0) {\n<line13>        if (period > 0) {\n<line14>            endtime = starttime + period;\n<line15>        } else {\n<line16>            endtime = source.getEndTime();\n<line17>        }\n<line18>    }\n<line19>    long size = 0;\n<line20>    LogIterator iter = source.iterator(starttime, endtime);\n<line21>    size = iter.size();\n<line22>    ObjectMapper mapper = new ObjectMapper();\n<line23>    JsonNode data = mapper.createObjectNode();\n<line24>    ((ObjectNode) data).put(\"startTime\", starttime);\n<line25>    ((ObjectNode) data).put(\"endTime\", endtime);\n<line26>    ((ObjectNode) data).put(\"numEntries\", iter.size());\n<line27>    if (LOG.isDebugEnabled()) {\n<line28>        LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", numEntries=\" + size + \")\");\n<line29>    }\n<line30>    iter.close();\n<line31>    String jsonString = mapper.writer(new MinimalPrettyPrinter()).writeValueAsString(data);\n<line32>    return jsonString;\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", numEntries=\" + size + \")\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        try {\n<line4>            while (true) {\n<line5>                String line = in.readLine();\n<line6>                if (line == null) {\n<line7>                    break;\n<line8>                }\n<line9>                Matcher m = src.timep.matcher(line);\n<line10>                if (m.lookingAt()) {\n<line11>                    if (buf.length() > 0) {\n<line12>                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n<line13>                        buf = line;\n<line14>                        return e;\n<line15>                    }\n<line16>                    buf = line;\n<line17>                } else if (buf.length() > 0) {\n<line18>                    buf += line + \"\\n\";\n<line19>                }\n<line20>            }\n<line21>        } catch (EOFException eof) {\n<line22>            // ignore, we've simply come to the end of the file\n<line23>        }\n<line24>        if (buf.length() > 0) {\n<line25>            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n<line26>            buf = \"\";\n<line27>            return e;\n<line28>        }\n<line29>    } catch (Exception e) {\n<line30>        return null;\n<line31>    }\n<line32>    return null;\n<line33>}","output":"<line1>{\n<line2>    try {\n<line3>        try {\n<line4>            while (true) {\n<line5>                String line = in.readLine();\n<line6>                if (line == null) {\n<line7>                    break;\n<line8>                }\n<line9>                Matcher m = src.timep.matcher(line);\n<line10>                if (m.lookingAt()) {\n<line11>                    if (buf.length() > 0) {\n<line12>                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n<line13>                        buf = line;\n<line14>                        return e;\n<line15>                    }\n<line16>                    buf = line;\n<line17>                } else if (buf.length() > 0) {\n<line18>                    buf += line + \"\\n\";\n<line19>                }\n<line20>            }\n<line21>        } catch (EOFException eof) {\n<line22>            // ignore, we've simply come to the end of the file\n<line23>        }\n<line24>        if (buf.length() > 0) {\n<line25>            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n<line26>            buf = \"\";\n<line27>            return e;\n<line28>        }\n<line29>    } catch (Exception e) {\n<line30>        LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n<line31>        return null;\n<line32>    }\n<line33>    return null;\n<line34>}"},{"input":"","instruction":"<line1>{\n<line2>    return null;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n<line3>    return null;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    file = new RandomAccessFile(f, \"r\");\n<line3>        try {\n<line4>        } catch (IOException ioe) {\n<line5>        }\n<line6>    }\n<line7>    buffer = new byte[DEFAULT_BUFFER_SIZE];\n<line8>    buffersize = 0;\n<line9>    bufferoffset = 0;\n<line10>    fileoffset = 0;\n<line11>    fp = 0;\n<line12>}","output":"<line1>{\n<line2>    file = new RandomAccessFile(f, \"r\");\n<line3>    if (LOG.isDebugEnabled()) {\n<line4>        try {\n<line5>            LOG.debug(\"Opened file(\" + f + \") with FD (\" + file.getFD() + \")\");\n<line6>        } catch (IOException ioe) {\n<line7>            LOG.debug(\"Opened file(\" + f + \") coulds get FD\");\n<line8>        }\n<line9>    }\n<line10>    buffer = new byte[DEFAULT_BUFFER_SIZE];\n<line11>    buffersize = 0;\n<line12>    bufferoffset = 0;\n<line13>    fileoffset = 0;\n<line14>    fp = 0;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>    } catch (IOException ioe) {\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.debug(\"Opened file(\" + f + \") with FD (\" + file.getFD() + \")\");\n<line4>    } catch (IOException ioe) {\n<line5>        LOG.debug(\"Opened file(\" + f + \") coulds get FD\");\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Opened file(\" + f + \") with FD (\" + file.getFD() + \")\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Opened file(\" + f + \") coulds get FD\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    fileoffset = fp;\n<line3>    int read = file.read(buffer, 0, buffer.length);\n<line4>        String buf = new String(buffer, 0, 40, \"UTF-8\");\n<line5>    }\n<line6>    if (read == -1) {\n<line7>        // eof reached\n<line8>        buffersize = 0;\n<line9>    } else {\n<line10>        buffersize = read;\n<line11>    }\n<line12>    fp += buffersize;\n<line13>    bufferoffset = 0;\n<line14>    return buffersize;\n<line15>}","output":"<line1>{\n<line2>    fileoffset = fp;\n<line3>    int read = file.read(buffer, 0, buffer.length);\n<line4>    if (LOG.isDebugEnabled()) {\n<line5>        String buf = new String(buffer, 0, 40, \"UTF-8\");\n<line6>        LOG.debug(\"fill(buffer=\" + buf + \")\");\n<line7>    }\n<line8>    if (read == -1) {\n<line9>        // eof reached\n<line10>        buffersize = 0;\n<line11>    } else {\n<line12>        buffersize = read;\n<line13>    }\n<line14>    fp += buffersize;\n<line15>    bufferoffset = 0;\n<line16>    return buffersize;\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    String buf = new String(buffer, 0, 40, \"UTF-8\");\n<line3>}","output":"<line1>{\n<line2>    String buf = new String(buffer, 0, 40, \"UTF-8\");\n<line3>    LOG.debug(\"fill(buffer=\" + buf + \")\");\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    file.seek(pos);\n<line4>    fp = pos;\n<line5>    // force a buffer fill on next read\n<line6>    buffersize = 0;\n<line7>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"seek(\" + pos + \")\");\n<line4>    }\n<line5>    file.seek(pos);\n<line6>    fp = pos;\n<line7>    // force a buffer fill on next read\n<line8>    buffersize = 0;\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"seek(\" + pos + \")\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    List<FrameworkMethod> list = defaultMethods;\n<line3>    String methodName = System.getProperty(\"test.method\");\n<line4>    if (methodName == null) {\n<line5>    } else {\n<line6>        try {\n<line7>            list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));\n<line8>        } catch (NoSuchMethodException nsme) {\n<line9>        }\n<line10>    }\n<line11>    return list;\n<line12>}","output":"<line1>{\n<line2>    List<FrameworkMethod> list = defaultMethods;\n<line3>    String methodName = System.getProperty(\"test.method\");\n<line4>    if (methodName == null) {\n<line5>        LOG.info(\"No test.method specified. using default methods.\");\n<line6>    } else {\n<line7>        LOG.info(\"Picked up test.method={}\", methodName);\n<line8>        try {\n<line9>            list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));\n<line10>        } catch (NoSuchMethodException nsme) {\n<line11>            LOG.warn(\"{} does not have test.method={}. failing to default methods.\", klass.getName(), methodName);\n<line12>        }\n<line13>    }\n<line14>    return list;\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"No test.method specified. using default methods.\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));\n<line4>    } catch (NoSuchMethodException nsme) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    LOG.info(\"Picked up test.method={}\", methodName);\n<line3>    try {\n<line4>        list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));\n<line5>    } catch (NoSuchMethodException nsme) {\n<line6>        LOG.warn(\"{} does not have test.method={}. failing to default methods.\", klass.getName(), methodName);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        super.evaluate();\n<line4>        Runtime rt = Runtime.getRuntime();\n<line5>        long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;\n<line6>        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n<line7>        while (tg.getParent() != null) {\n<line8>            tg = tg.getParent();\n<line9>        }\n<line10>    } catch (Throwable t) {\n<line11>        // The test method threw an exception, but it might be an\n<line12>        // expected exception as defined in the @Test annotation.\n<line13>        // Check the annotation and log an appropriate message.\n<line14>        Test annotation = this.method.getAnnotation(Test.class);\n<line15>        if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {\n<line16>        } else {\n<line17>        }\n<line18>        throw t;\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    LOG.info(\"RUNNING TEST METHOD {}\", name);\n<line3>    try {\n<line4>        super.evaluate();\n<line5>        Runtime rt = Runtime.getRuntime();\n<line6>        long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;\n<line7>        LOG.info(\"Memory used {}\", usedKB);\n<line8>        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n<line9>        while (tg.getParent() != null) {\n<line10>            tg = tg.getParent();\n<line11>        }\n<line12>        LOG.info(\"Number of threads {}\", tg.activeCount());\n<line13>    } catch (Throwable t) {\n<line14>        // The test method threw an exception, but it might be an\n<line15>        // expected exception as defined in the @Test annotation.\n<line16>        // Check the annotation and log an appropriate message.\n<line17>        Test annotation = this.method.getAnnotation(Test.class);\n<line18>        if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {\n<line19>            LOG.info(\"TEST METHOD {} THREW EXPECTED EXCEPTION {}\", name, annotation.expected());\n<line20>        } else {\n<line21>            LOG.warn(\"TEST METHOD FAILED {}\", name, t);\n<line22>        }\n<line23>        throw t;\n<line24>    }\n<line25>    LOG.info(\"FINISHED TEST METHOD {}\", name);\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    super.evaluate();\n<line3>    Runtime rt = Runtime.getRuntime();\n<line4>    long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;\n<line5>    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n<line6>    while (tg.getParent() != null) {\n<line7>        tg = tg.getParent();\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    super.evaluate();\n<line3>    Runtime rt = Runtime.getRuntime();\n<line4>    long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;\n<line5>    LOG.info(\"Memory used {}\", usedKB);\n<line6>    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n<line7>    while (tg.getParent() != null) {\n<line8>        tg = tg.getParent();\n<line9>    }\n<line10>    LOG.info(\"Number of threads {}\", tg.activeCount());\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // The test method threw an exception, but it might be an\n<line3>    // expected exception as defined in the @Test annotation.\n<line4>    // Check the annotation and log an appropriate message.\n<line5>    Test annotation = this.method.getAnnotation(Test.class);\n<line6>    if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {\n<line7>    } else {\n<line8>    }\n<line9>    throw t;\n<line10>}","output":"<line1>{\n<line2>    // The test method threw an exception, but it might be an\n<line3>    // expected exception as defined in the @Test annotation.\n<line4>    // Check the annotation and log an appropriate message.\n<line5>    Test annotation = this.method.getAnnotation(Test.class);\n<line6>    if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {\n<line7>        LOG.info(\"TEST METHOD {} THREW EXPECTED EXCEPTION {}\", name, annotation.expected());\n<line8>    } else {\n<line9>        LOG.warn(\"TEST METHOD FAILED {}\", name, t);\n<line10>    }\n<line11>    throw t;\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"TEST METHOD {} THREW EXPECTED EXCEPTION {}\", name, annotation.expected());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    System.out.println(\"Starting grizzly ...\");\n<line3>    boolean useSSL = cfg.useSSL();\n<line4>    String zkRestResourcesTempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\").toFile().getCanonicalPath();\n<line5>    gws = new GrizzlyWebServer(cfg.getPort(), zkRestResourcesTempPath, useSSL);\n<line6>    // BUG: Grizzly needs a doc root if you are going to register multiple adapters\n<line7>    for (Endpoint e : cfg.getEndpoints()) {\n<line8>        ZooKeeperService.mapContext(e.getContext(), e);\n<line9>        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });\n<line10>    }\n<line11>    if (useSSL) {\n<line12>        System.out.println(\"Starting SSL ...\");\n<line13>        String jks = cfg.getJKS(\"keys/rest.jks\");\n<line14>        String jksPassword = cfg.getJKSPassword();\n<line15>        SSLConfig sslConfig = new SSLConfig();\n<line16>        URL resource = getClass().getClassLoader().getResource(jks);\n<line17>        if (resource == null) {\n<line18>            System.exit(2);\n<line19>        }\n<line20>        try {\n<line21>            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n<line22>        } catch (URISyntaxException e1) {\n<line23>            System.exit(2);\n<line24>        }\n<line25>        sslConfig.setKeyStorePass(jksPassword);\n<line26>        gws.setSSLConfig(sslConfig);\n<line27>    }\n<line28>    gws.start();\n<line29>}","output":"<line1>{\n<line2>    System.out.println(\"Starting grizzly ...\");\n<line3>    boolean useSSL = cfg.useSSL();\n<line4>    String zkRestResourcesTempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\").toFile().getCanonicalPath();\n<line5>    gws = new GrizzlyWebServer(cfg.getPort(), zkRestResourcesTempPath, useSSL);\n<line6>    // BUG: Grizzly needs a doc root if you are going to register multiple adapters\n<line7>    for (Endpoint e : cfg.getEndpoints()) {\n<line8>        ZooKeeperService.mapContext(e.getContext(), e);\n<line9>        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });\n<line10>    }\n<line11>    if (useSSL) {\n<line12>        System.out.println(\"Starting SSL ...\");\n<line13>        String jks = cfg.getJKS(\"keys/rest.jks\");\n<line14>        String jksPassword = cfg.getJKSPassword();\n<line15>        SSLConfig sslConfig = new SSLConfig();\n<line16>        URL resource = getClass().getClassLoader().getResource(jks);\n<line17>        if (resource == null) {\n<line18>            LOG.error(\"Unable to find the keystore file: \" + jks);\n<line19>            System.exit(2);\n<line20>        }\n<line21>        try {\n<line22>            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n<line23>        } catch (URISyntaxException e1) {\n<line24>            LOG.error(\"Unable to load keystore: \" + jks, e1);\n<line25>            System.exit(2);\n<line26>        }\n<line27>        sslConfig.setKeyStorePass(jksPassword);\n<line28>        gws.setSSLConfig(sslConfig);\n<line29>    }\n<line30>    gws.start();\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    System.out.println(\"Starting SSL ...\");\n<line3>    String jks = cfg.getJKS(\"keys/rest.jks\");\n<line4>    String jksPassword = cfg.getJKSPassword();\n<line5>    SSLConfig sslConfig = new SSLConfig();\n<line6>    URL resource = getClass().getClassLoader().getResource(jks);\n<line7>    if (resource == null) {\n<line8>        System.exit(2);\n<line9>    }\n<line10>    try {\n<line11>        sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n<line12>    } catch (URISyntaxException e1) {\n<line13>        System.exit(2);\n<line14>    }\n<line15>    sslConfig.setKeyStorePass(jksPassword);\n<line16>    gws.setSSLConfig(sslConfig);\n<line17>}","output":"<line1>{\n<line2>    System.out.println(\"Starting SSL ...\");\n<line3>    String jks = cfg.getJKS(\"keys/rest.jks\");\n<line4>    String jksPassword = cfg.getJKSPassword();\n<line5>    SSLConfig sslConfig = new SSLConfig();\n<line6>    URL resource = getClass().getClassLoader().getResource(jks);\n<line7>    if (resource == null) {\n<line8>        LOG.error(\"Unable to find the keystore file: \" + jks);\n<line9>        System.exit(2);\n<line10>    }\n<line11>    try {\n<line12>        sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n<line13>    } catch (URISyntaxException e1) {\n<line14>        LOG.error(\"Unable to load keystore: \" + jks, e1);\n<line15>        System.exit(2);\n<line16>    }\n<line17>    sslConfig.setKeyStorePass(jksPassword);\n<line18>    gws.setSSLConfig(sslConfig);\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    System.exit(2);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to find the keystore file: \" + jks);\n<line3>    System.exit(2);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    System.exit(2);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Unable to load keystore: \" + jks, e1);\n<line3>    System.exit(2);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!op.equals(\"create\")) {\n<line3>        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n<line4>    }\n<line5>    int expireInSeconds;\n<line6>    try {\n<line7>        expireInSeconds = Integer.parseInt(expire);\n<line8>    } catch (NumberFormatException e) {\n<line9>        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n<line10>    }\n<line11>    String uuid = UUID.randomUUID().toString();\n<line12>    while (ZooKeeperService.isConnected(contextPath, uuid)) {\n<line13>        uuid = UUID.randomUUID().toString();\n<line14>    }\n<line15>    // establish the connection to the ZooKeeper cluster\n<line16>    try {\n<line17>        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n<line18>    } catch (IOException e) {\n<line19>        throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n<line20>    }\n<line21>    URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n<line22>    return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n<line23>}","output":"<line1>{\n<line2>    if (!op.equals(\"create\")) {\n<line3>        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n<line4>    }\n<line5>    int expireInSeconds;\n<line6>    try {\n<line7>        expireInSeconds = Integer.parseInt(expire);\n<line8>    } catch (NumberFormatException e) {\n<line9>        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n<line10>    }\n<line11>    String uuid = UUID.randomUUID().toString();\n<line12>    while (ZooKeeperService.isConnected(contextPath, uuid)) {\n<line13>        uuid = UUID.randomUUID().toString();\n<line14>    }\n<line15>    // establish the connection to the ZooKeeper cluster\n<line16>    try {\n<line17>        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n<line18>    } catch (IOException e) {\n<line19>        LOG.error(\"Failed while trying to create a new session\", e);\n<line20>        throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n<line21>    }\n<line22>    URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n<line23>    return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Failed while trying to create a new session\", e);\n<line3>    throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    ZooKeeperService.close(contextPath, session);\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isInfoEnabled()) {\n<line3>        LOG.info(String.format(\"Session '%s' expired after \" + \"'%d' milliseconds.\", session, delay));\n<line4>    }\n<line5>    ZooKeeperService.close(contextPath, session);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(String.format(\"Session '%s' expired after \" + \"'%d' milliseconds.\", session, delay));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    String uri = concat(contextPath, session);\n<line3>    TimerTask t = zkSessionTimers.remove(uri);\n<line4>    if (t != null) {\n<line5>        t.cancel();\n<line6>    }\n<line7>    ZooKeeper zk = zkMap.remove(uri);\n<line8>    if (zk == null) {\n<line9>        return;\n<line10>    }\n<line11>    try {\n<line12>        zk.close();\n<line13>    } catch (InterruptedException e) {\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    String uri = concat(contextPath, session);\n<line3>    TimerTask t = zkSessionTimers.remove(uri);\n<line4>    if (t != null) {\n<line5>        t.cancel();\n<line6>    }\n<line7>    ZooKeeper zk = zkMap.remove(uri);\n<line8>    if (zk == null) {\n<line9>        return;\n<line10>    }\n<line11>    try {\n<line12>        zk.close();\n<line13>    } catch (InterruptedException e) {\n<line14>        LOG.error(\"Interrupted while closing ZooKeeper connection.\", e);\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Interrupted while closing ZooKeeper connection.\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    final String connectionId = concat(contextPath, session);\n<line3>    ZooKeeper zk = zkMap.get(connectionId);\n<line4>    if (zk == null) {\n<line5>        }\n<line6>        Endpoint e = contextMap.get(contextPath);\n<line7>        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n<line8>        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n<line9>            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n<line10>        }\n<line11>        zkMap.put(connectionId, zk);\n<line12>        // a session should automatically expire after an amount of time\n<line13>        if (session != null) {\n<line14>            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n<line15>        }\n<line16>    }\n<line17>    return zk;\n<line18>}","output":"<line1>{\n<line2>    final String connectionId = concat(contextPath, session);\n<line3>    ZooKeeper zk = zkMap.get(connectionId);\n<line4>    if (zk == null) {\n<line5>        if (LOG.isInfoEnabled()) {\n<line6>            LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n<line7>        }\n<line8>        Endpoint e = contextMap.get(contextPath);\n<line9>        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n<line10>        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n<line11>            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n<line12>        }\n<line13>        zkMap.put(connectionId, zk);\n<line14>        // a session should automatically expire after an amount of time\n<line15>        if (session != null) {\n<line16>            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n<line17>        }\n<line18>    }\n<line19>    return zk;\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    Endpoint e = contextMap.get(contextPath);\n<line4>    zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n<line5>    for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n<line6>        zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n<line7>    }\n<line8>    zkMap.put(connectionId, zk);\n<line9>    // a session should automatically expire after an amount of time\n<line10>    if (session != null) {\n<line11>        zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    if (LOG.isInfoEnabled()) {\n<line3>        LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n<line4>    }\n<line5>    Endpoint e = contextMap.get(contextPath);\n<line6>    zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n<line7>    for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n<line8>        zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n<line9>    }\n<line10>    zkMap.put(connectionId, zk);\n<line11>    // a session should automatically expire after an amount of time\n<line12>    if (session != null) {\n<line13>        zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n<line14>    }\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    long interval = time / INTERVAL;\n<line3>    if (currentInterval == 0 || currentInterval > interval) {\n<line4>        return;\n<line5>    }\n<line6>    // We track totals by seconds\n<line7>    Long total = totalByTime.get(interval);\n<line8>    if (total == null) {\n<line9>        totalByTime.put(interval, (long) count);\n<line10>    } else {\n<line11>        totalByTime.put(interval, total.longValue() + count);\n<line12>    }\n<line13>    tf.println(interval + \" \" + count + \" \" + s);\n<line14>}","output":"<line1>{\n<line2>    long interval = time / INTERVAL;\n<line3>    if (currentInterval == 0 || currentInterval > interval) {\n<line4>        LOG.info(\"Dropping \" + count + \" for \" + new Date(time) + \" \" + currentInterval + \">\" + interval);\n<line5>        return;\n<line6>    }\n<line7>    // We track totals by seconds\n<line8>    Long total = totalByTime.get(interval);\n<line9>    if (total == null) {\n<line10>        totalByTime.put(interval, (long) count);\n<line11>    } else {\n<line12>        totalByTime.put(interval, total.longValue() + count);\n<line13>    }\n<line14>    tf.println(interval + \" \" + count + \" \" + s);\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Dropping \" + count + \" for \" + new Date(time) + \" \" + currentInterval + \">\" + interval);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line4>        String result;\n<line5>        while ((result = is.readLine()) != null) {\n<line6>            String[] timePercentCount = result.split(\" \");\n<line7>            if (timePercentCount.length != 5) {\n<line8>                throw new IOException(result);\n<line9>            }\n<line10>            long time = Long.parseLong(timePercentCount[0]);\n<line11>            // int percent = Integer.parseInt(timePercentCount[1]);\n<line12>            int count = Integer.parseInt(timePercentCount[2]);\n<line13>            int errs = Integer.parseInt(timePercentCount[3]);\n<line14>            if (errs > 0) {\n<line15>            }\n<line16>            add(time, count, s);\n<line17>        }\n<line18>    } catch (Exception e) {\n<line19>        e.printStackTrace();\n<line20>    } finally {\n<line21>        close();\n<line22>    }\n<line23>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"Connected to \" + s);\n<line4>        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line5>        String result;\n<line6>        while ((result = is.readLine()) != null) {\n<line7>            String[] timePercentCount = result.split(\" \");\n<line8>            if (timePercentCount.length != 5) {\n<line9>                LOG.error(\"Got \" + result + \" from \" + s + \" exitng.\");\n<line10>                throw new IOException(result);\n<line11>            }\n<line12>            long time = Long.parseLong(timePercentCount[0]);\n<line13>            // int percent = Integer.parseInt(timePercentCount[1]);\n<line14>            int count = Integer.parseInt(timePercentCount[2]);\n<line15>            int errs = Integer.parseInt(timePercentCount[3]);\n<line16>            if (errs > 0) {\n<line17>                LOG.error(s + \" Got an error! \" + errs);\n<line18>            }\n<line19>            add(time, count, s);\n<line20>        }\n<line21>    } catch (Exception e) {\n<line22>        e.printStackTrace();\n<line23>    } finally {\n<line24>        close();\n<line25>    }\n<line26>}"},{"input":"","instruction":"<line1>{\n<line2>    BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line3>    String result;\n<line4>    while ((result = is.readLine()) != null) {\n<line5>        String[] timePercentCount = result.split(\" \");\n<line6>        if (timePercentCount.length != 5) {\n<line7>            throw new IOException(result);\n<line8>        }\n<line9>        long time = Long.parseLong(timePercentCount[0]);\n<line10>        // int percent = Integer.parseInt(timePercentCount[1]);\n<line11>        int count = Integer.parseInt(timePercentCount[2]);\n<line12>        int errs = Integer.parseInt(timePercentCount[3]);\n<line13>        if (errs > 0) {\n<line14>        }\n<line15>        add(time, count, s);\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    LOG.info(\"Connected to \" + s);\n<line3>    BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line4>    String result;\n<line5>    while ((result = is.readLine()) != null) {\n<line6>        String[] timePercentCount = result.split(\" \");\n<line7>        if (timePercentCount.length != 5) {\n<line8>            LOG.error(\"Got \" + result + \" from \" + s + \" exitng.\");\n<line9>            throw new IOException(result);\n<line10>        }\n<line11>        long time = Long.parseLong(timePercentCount[0]);\n<line12>        // int percent = Integer.parseInt(timePercentCount[1]);\n<line13>        int count = Integer.parseInt(timePercentCount[2]);\n<line14>        int errs = Integer.parseInt(timePercentCount[3]);\n<line15>        if (errs > 0) {\n<line16>            LOG.error(s + \" Got an error! \" + errs);\n<line17>        }\n<line18>        add(time, count, s);\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] timePercentCount = result.split(\" \");\n<line3>    if (timePercentCount.length != 5) {\n<line4>        throw new IOException(result);\n<line5>    }\n<line6>    long time = Long.parseLong(timePercentCount[0]);\n<line7>    // int percent = Integer.parseInt(timePercentCount[1]);\n<line8>    int count = Integer.parseInt(timePercentCount[2]);\n<line9>    int errs = Integer.parseInt(timePercentCount[3]);\n<line10>    if (errs > 0) {\n<line11>    }\n<line12>    add(time, count, s);\n<line13>}","output":"<line1>{\n<line2>    String[] timePercentCount = result.split(\" \");\n<line3>    if (timePercentCount.length != 5) {\n<line4>        LOG.error(\"Got \" + result + \" from \" + s + \" exitng.\");\n<line5>        throw new IOException(result);\n<line6>    }\n<line7>    long time = Long.parseLong(timePercentCount[0]);\n<line8>    // int percent = Integer.parseInt(timePercentCount[1]);\n<line9>    int count = Integer.parseInt(timePercentCount[2]);\n<line10>    int errs = Integer.parseInt(timePercentCount[3]);\n<line11>    if (errs > 0) {\n<line12>        LOG.error(s + \" Got an error! \" + errs);\n<line13>    }\n<line14>    add(time, count, s);\n<line15>}"},{"input":"","instruction":"<line1>{\n<line2>    throw new IOException(result);\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Got \" + result + \" from \" + s + \" exitng.\");\n<line3>    throw new IOException(result);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(s + \" Got an error! \" + errs);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        slaves.remove(this);\n<line4>        s.close();\n<line5>    } catch (IOException e) {\n<line6>        e.printStackTrace();\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        LOG.info(\"Closing \" + s);\n<line4>        slaves.remove(this);\n<line5>        s.close();\n<line6>    } catch (IOException e) {\n<line7>        e.printStackTrace();\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    slaves.remove(this);\n<line3>    s.close();\n<line4>}","output":"<line1>{\n<line2>    LOG.info(\"Closing \" + s);\n<line3>    slaves.remove(this);\n<line4>    s.close();\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        while (true) {\n<line4>            Socket s = ss.accept();\n<line5>            slaves.add(new SlaveThread(s));\n<line6>        }\n<line7>    } catch (IOException e) {\n<line8>        e.printStackTrace();\n<line9>    } finally {\n<line10>        for (Iterator<SlaveThread> it = slaves.iterator(); it.hasNext(); ) {\n<line11>            SlaveThread st = it.next();\n<line12>            it.remove();\n<line13>            st.close();\n<line14>        }\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    try {\n<line3>        while (true) {\n<line4>            Socket s = ss.accept();\n<line5>            LOG.info(\"Accepted connection from \" + s);\n<line6>            slaves.add(new SlaveThread(s));\n<line7>        }\n<line8>    } catch (IOException e) {\n<line9>        e.printStackTrace();\n<line10>    } finally {\n<line11>        for (Iterator<SlaveThread> it = slaves.iterator(); it.hasNext(); ) {\n<line12>            SlaveThread st = it.next();\n<line13>            it.remove();\n<line14>            st.close();\n<line15>        }\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    while (true) {\n<line3>        Socket s = ss.accept();\n<line4>        slaves.add(new SlaveThread(s));\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    while (true) {\n<line3>        Socket s = ss.accept();\n<line4>        LOG.info(\"Accepted connection from \" + s);\n<line5>        slaves.add(new SlaveThread(s));\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    Socket s = ss.accept();\n<line3>    slaves.add(new SlaveThread(s));\n<line4>}","output":"<line1>{\n<line2>    Socket s = ss.accept();\n<line3>    LOG.info(\"Accepted connection from \" + s);\n<line4>    slaves.add(new SlaveThread(s));\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        currentInterval = Time.currentElapsedTime() / INTERVAL;\n<line4>        // Give things time to report;\n<line5>        Thread.sleep(INTERVAL * 2);\n<line6>        long min = 99999;\n<line7>        long max = 0;\n<line8>        long total = 0;\n<line9>        int number = 0;\n<line10>        while (true) {\n<line11>            long now = Time.currentElapsedTime();\n<line12>            long lastInterval = currentInterval;\n<line13>            currentInterval += 1;\n<line14>            long count = remove(lastInterval);\n<line15>            // Multiply by 1000 to get\n<line16>            count = count * 1000 / INTERVAL;\n<line17>            // reqs/sec\n<line18>            if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {\n<line19>                // We only want to print anything if things have had a\n<line20>                // chance to change\n<line21>                if (count < min) {\n<line22>                    min = count;\n<line23>                }\n<line24>                if (count > max) {\n<line25>                    max = count;\n<line26>                }\n<line27>                total += count;\n<line28>                number++;\n<line29>                Calendar calendar = Calendar.getInstance();\n<line30>                calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line31>                String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line32>                if (sf != null) {\n<line33>                    sf.println(report);\n<line34>                }\n<line35>            } else {\n<line36>                max = total = 0;\n<line37>                min = 999999999;\n<line38>                number = 0;\n<line39>            }\n<line40>            Thread.sleep(INTERVAL);\n<line41>        }\n<line42>    } catch (Exception e) {\n<line43>        e.printStackTrace();\n<line44>    }\n<line45>}","output":"<line1>{\n<line2>    try {\n<line3>        currentInterval = Time.currentElapsedTime() / INTERVAL;\n<line4>        // Give things time to report;\n<line5>        Thread.sleep(INTERVAL * 2);\n<line6>        long min = 99999;\n<line7>        long max = 0;\n<line8>        long total = 0;\n<line9>        int number = 0;\n<line10>        while (true) {\n<line11>            long now = Time.currentElapsedTime();\n<line12>            long lastInterval = currentInterval;\n<line13>            currentInterval += 1;\n<line14>            long count = remove(lastInterval);\n<line15>            // Multiply by 1000 to get\n<line16>            count = count * 1000 / INTERVAL;\n<line17>            // reqs/sec\n<line18>            if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {\n<line19>                // We only want to print anything if things have had a\n<line20>                // chance to change\n<line21>                if (count < min) {\n<line22>                    min = count;\n<line23>                }\n<line24>                if (count > max) {\n<line25>                    max = count;\n<line26>                }\n<line27>                total += count;\n<line28>                number++;\n<line29>                Calendar calendar = Calendar.getInstance();\n<line30>                calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line31>                String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line32>                LOG.info(report);\n<line33>                if (sf != null) {\n<line34>                    sf.println(report);\n<line35>                }\n<line36>            } else {\n<line37>                max = total = 0;\n<line38>                min = 999999999;\n<line39>                number = 0;\n<line40>            }\n<line41>            Thread.sleep(INTERVAL);\n<line42>        }\n<line43>    } catch (Exception e) {\n<line44>        e.printStackTrace();\n<line45>    }\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    currentInterval = Time.currentElapsedTime() / INTERVAL;\n<line3>    // Give things time to report;\n<line4>    Thread.sleep(INTERVAL * 2);\n<line5>    long min = 99999;\n<line6>    long max = 0;\n<line7>    long total = 0;\n<line8>    int number = 0;\n<line9>    while (true) {\n<line10>        long now = Time.currentElapsedTime();\n<line11>        long lastInterval = currentInterval;\n<line12>        currentInterval += 1;\n<line13>        long count = remove(lastInterval);\n<line14>        // Multiply by 1000 to get\n<line15>        count = count * 1000 / INTERVAL;\n<line16>        // reqs/sec\n<line17>        if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {\n<line18>            // We only want to print anything if things have had a\n<line19>            // chance to change\n<line20>            if (count < min) {\n<line21>                min = count;\n<line22>            }\n<line23>            if (count > max) {\n<line24>                max = count;\n<line25>            }\n<line26>            total += count;\n<line27>            number++;\n<line28>            Calendar calendar = Calendar.getInstance();\n<line29>            calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line30>            String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line31>            if (sf != null) {\n<line32>                sf.println(report);\n<line33>            }\n<line34>        } else {\n<line35>            max = total = 0;\n<line36>            min = 999999999;\n<line37>            number = 0;\n<line38>        }\n<line39>        Thread.sleep(INTERVAL);\n<line40>    }\n<line41>}","output":"<line1>{\n<line2>    currentInterval = Time.currentElapsedTime() / INTERVAL;\n<line3>    // Give things time to report;\n<line4>    Thread.sleep(INTERVAL * 2);\n<line5>    long min = 99999;\n<line6>    long max = 0;\n<line7>    long total = 0;\n<line8>    int number = 0;\n<line9>    while (true) {\n<line10>        long now = Time.currentElapsedTime();\n<line11>        long lastInterval = currentInterval;\n<line12>        currentInterval += 1;\n<line13>        long count = remove(lastInterval);\n<line14>        // Multiply by 1000 to get\n<line15>        count = count * 1000 / INTERVAL;\n<line16>        // reqs/sec\n<line17>        if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {\n<line18>            // We only want to print anything if things have had a\n<line19>            // chance to change\n<line20>            if (count < min) {\n<line21>                min = count;\n<line22>            }\n<line23>            if (count > max) {\n<line24>                max = count;\n<line25>            }\n<line26>            total += count;\n<line27>            number++;\n<line28>            Calendar calendar = Calendar.getInstance();\n<line29>            calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line30>            String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line31>            LOG.info(report);\n<line32>            if (sf != null) {\n<line33>                sf.println(report);\n<line34>            }\n<line35>        } else {\n<line36>            max = total = 0;\n<line37>            min = 999999999;\n<line38>            number = 0;\n<line39>        }\n<line40>        Thread.sleep(INTERVAL);\n<line41>    }\n<line42>}"},{"input":"","instruction":"<line1>{\n<line2>    long now = Time.currentElapsedTime();\n<line3>    long lastInterval = currentInterval;\n<line4>    currentInterval += 1;\n<line5>    long count = remove(lastInterval);\n<line6>    // Multiply by 1000 to get\n<line7>    count = count * 1000 / INTERVAL;\n<line8>    // reqs/sec\n<line9>    if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {\n<line10>        // We only want to print anything if things have had a\n<line11>        // chance to change\n<line12>        if (count < min) {\n<line13>            min = count;\n<line14>        }\n<line15>        if (count > max) {\n<line16>            max = count;\n<line17>        }\n<line18>        total += count;\n<line19>        number++;\n<line20>        Calendar calendar = Calendar.getInstance();\n<line21>        calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line22>        String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line23>        if (sf != null) {\n<line24>            sf.println(report);\n<line25>        }\n<line26>    } else {\n<line27>        max = total = 0;\n<line28>        min = 999999999;\n<line29>        number = 0;\n<line30>    }\n<line31>    Thread.sleep(INTERVAL);\n<line32>}","output":"<line1>{\n<line2>    long now = Time.currentElapsedTime();\n<line3>    long lastInterval = currentInterval;\n<line4>    currentInterval += 1;\n<line5>    long count = remove(lastInterval);\n<line6>    // Multiply by 1000 to get\n<line7>    count = count * 1000 / INTERVAL;\n<line8>    // reqs/sec\n<line9>    if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {\n<line10>        // We only want to print anything if things have had a\n<line11>        // chance to change\n<line12>        if (count < min) {\n<line13>            min = count;\n<line14>        }\n<line15>        if (count > max) {\n<line16>            max = count;\n<line17>        }\n<line18>        total += count;\n<line19>        number++;\n<line20>        Calendar calendar = Calendar.getInstance();\n<line21>        calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line22>        String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line23>        LOG.info(report);\n<line24>        if (sf != null) {\n<line25>            sf.println(report);\n<line26>        }\n<line27>    } else {\n<line28>        max = total = 0;\n<line29>        min = 999999999;\n<line30>        number = 0;\n<line31>    }\n<line32>    Thread.sleep(INTERVAL);\n<line33>}"},{"input":"","instruction":"<line1>{\n<line2>    // We only want to print anything if things have had a\n<line3>    // chance to change\n<line4>    if (count < min) {\n<line5>        min = count;\n<line6>    }\n<line7>    if (count > max) {\n<line8>        max = count;\n<line9>    }\n<line10>    total += count;\n<line11>    number++;\n<line12>    Calendar calendar = Calendar.getInstance();\n<line13>    calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line14>    String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line15>    if (sf != null) {\n<line16>        sf.println(report);\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    // We only want to print anything if things have had a\n<line3>    // chance to change\n<line4>    if (count < min) {\n<line5>        min = count;\n<line6>    }\n<line7>    if (count > max) {\n<line8>        max = count;\n<line9>    }\n<line10>    total += count;\n<line11>    number++;\n<line12>    Calendar calendar = Calendar.getInstance();\n<line13>    calendar.setTimeInMillis(lastInterval * INTERVAL);\n<line14>    String report = lastInterval + \" \" + calendar.get(Calendar.HOUR_OF_DAY) + \":\" + calendar.get(Calendar.MINUTE) + \":\" + calendar.get(Calendar.SECOND) + \" \" + percentage + \"% \" + count + \" \" + min + \" \" + ((double) total / (double) number) + \" \" + max;\n<line15>    LOG.info(report);\n<line16>    if (sf != null) {\n<line17>        sf.println(report);\n<line18>    }\n<line19>}"},{"input":"","instruction":"<line1>{\n<line2>    long now = Time.currentElapsedTime();\n<line3>    long start = now;\n<line4>    ReporterThread.percentage = percentage;\n<line5>    for (SlaveThread st : slaves.toArray(new SlaveThread[0])) {\n<line6>        st.send(percentage);\n<line7>    }\n<line8>    now = Time.currentElapsedTime();\n<line9>    long delay = now - start;\n<line10>    if (delay > 1000) {\n<line11>    }\n<line12>    lastChange = now;\n<line13>}","output":"<line1>{\n<line2>    long now = Time.currentElapsedTime();\n<line3>    long start = now;\n<line4>    ReporterThread.percentage = percentage;\n<line5>    for (SlaveThread st : slaves.toArray(new SlaveThread[0])) {\n<line6>        st.send(percentage);\n<line7>    }\n<line8>    now = Time.currentElapsedTime();\n<line9>    long delay = now - start;\n<line10>    if (delay > 1000) {\n<line11>        LOG.info(\"Delay of \" + delay + \" to send new percentage\");\n<line12>    }\n<line13>    lastChange = now;\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.info(\"Delay of \" + delay + \" to send new percentage\");\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zk = new ZooKeeper(host, 60000, this);\n<line4>        synchronized (this) {\n<line5>            if (!connected) {\n<line6>                wait(20000);\n<line7>            }\n<line8>        }\n<line9>        for (int i = 0; i < 300; i++) {\n<line10>            try {\n<line11>                Thread.sleep(100);\n<line12>                path = zk.create(\"/client\", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line13>                break;\n<line14>            } catch (KeeperException e) {\n<line15>            }\n<line16>        }\n<line17>        if (path == null) {\n<line18>            return;\n<line19>        }\n<line20>        while (alive) {\n<line21>            if (r.nextInt(100) < percentage) {\n<line22>                zk.setData(path, bytes, -1, this, System.currentTimeMillis());\n<line23>            } else {\n<line24>                zk.getData(path, false, this, System.currentTimeMillis());\n<line25>            }\n<line26>            incOutstanding();\n<line27>        }\n<line28>    } catch (Exception e) {\n<line29>        e.printStackTrace();\n<line30>    } finally {\n<line31>        alive = false;\n<line32>        try {\n<line33>            zk.close();\n<line34>        } catch (InterruptedException e) {\n<line35>            e.printStackTrace();\n<line36>        }\n<line37>    }\n<line38>}","output":"<line1>{\n<line2>    try {\n<line3>        zk = new ZooKeeper(host, 60000, this);\n<line4>        synchronized (this) {\n<line5>            if (!connected) {\n<line6>                wait(20000);\n<line7>            }\n<line8>        }\n<line9>        for (int i = 0; i < 300; i++) {\n<line10>            try {\n<line11>                Thread.sleep(100);\n<line12>                path = zk.create(\"/client\", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line13>                break;\n<line14>            } catch (KeeperException e) {\n<line15>                LOG.error(\"keeper exception thrown\", e);\n<line16>            }\n<line17>        }\n<line18>        if (path == null) {\n<line19>            LOG.error(\"Couldn't create a node in /!\");\n<line20>            return;\n<line21>        }\n<line22>        while (alive) {\n<line23>            if (r.nextInt(100) < percentage) {\n<line24>                zk.setData(path, bytes, -1, this, System.currentTimeMillis());\n<line25>            } else {\n<line26>                zk.getData(path, false, this, System.currentTimeMillis());\n<line27>            }\n<line28>            incOutstanding();\n<line29>        }\n<line30>    } catch (Exception e) {\n<line31>        e.printStackTrace();\n<line32>    } finally {\n<line33>        alive = false;\n<line34>        try {\n<line35>            zk.close();\n<line36>        } catch (InterruptedException e) {\n<line37>            e.printStackTrace();\n<line38>        }\n<line39>    }\n<line40>}"},{"input":"","instruction":"<line1>{\n<line2>    zk = new ZooKeeper(host, 60000, this);\n<line3>    synchronized (this) {\n<line4>        if (!connected) {\n<line5>            wait(20000);\n<line6>        }\n<line7>    }\n<line8>    for (int i = 0; i < 300; i++) {\n<line9>        try {\n<line10>            Thread.sleep(100);\n<line11>            path = zk.create(\"/client\", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line12>            break;\n<line13>        } catch (KeeperException e) {\n<line14>        }\n<line15>    }\n<line16>    if (path == null) {\n<line17>        return;\n<line18>    }\n<line19>    while (alive) {\n<line20>        if (r.nextInt(100) < percentage) {\n<line21>            zk.setData(path, bytes, -1, this, System.currentTimeMillis());\n<line22>        } else {\n<line23>            zk.getData(path, false, this, System.currentTimeMillis());\n<line24>        }\n<line25>        incOutstanding();\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    zk = new ZooKeeper(host, 60000, this);\n<line3>    synchronized (this) {\n<line4>        if (!connected) {\n<line5>            wait(20000);\n<line6>        }\n<line7>    }\n<line8>    for (int i = 0; i < 300; i++) {\n<line9>        try {\n<line10>            Thread.sleep(100);\n<line11>            path = zk.create(\"/client\", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line12>            break;\n<line13>        } catch (KeeperException e) {\n<line14>            LOG.error(\"keeper exception thrown\", e);\n<line15>        }\n<line16>    }\n<line17>    if (path == null) {\n<line18>        LOG.error(\"Couldn't create a node in /!\");\n<line19>        return;\n<line20>    }\n<line21>    while (alive) {\n<line22>        if (r.nextInt(100) < percentage) {\n<line23>            zk.setData(path, bytes, -1, this, System.currentTimeMillis());\n<line24>        } else {\n<line25>            zk.getData(path, false, this, System.currentTimeMillis());\n<line26>        }\n<line27>        incOutstanding();\n<line28>    }\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        Thread.sleep(100);\n<line4>        path = zk.create(\"/client\", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line5>        break;\n<line6>    } catch (KeeperException e) {\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        Thread.sleep(100);\n<line4>        path = zk.create(\"/client\", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n<line5>        break;\n<line6>    } catch (KeeperException e) {\n<line7>        LOG.error(\"keeper exception thrown\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"keeper exception thrown\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Couldn't create a node in /!\");\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (this) {\n<line3>        if (event.getType() == EventType.None) {\n<line4>            connected = (event.getState() == KeeperState.SyncConnected);\n<line5>            notifyAll();\n<line6>        }\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    LOG.info(event.toString());\n<line3>    synchronized (this) {\n<line4>        if (event.getType() == EventType.None) {\n<line5>            connected = (event.getState() == KeeperState.SyncConnected);\n<line6>            notifyAll();\n<line7>        }\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    decOutstanding();\n<line3>    synchronized (statSync) {\n<line4>        if (!alive) {\n<line5>            return;\n<line6>        }\n<line7>        if (rc != 0) {\n<line8>            errors++;\n<line9>        } else {\n<line10>            finished++;\n<line11>            rlatency += Time.currentElapsedTime() - (Long) ctx;\n<line12>            reads++;\n<line13>        }\n<line14>    }\n<line15>}","output":"<line1>{\n<line2>    decOutstanding();\n<line3>    synchronized (statSync) {\n<line4>        if (!alive) {\n<line5>            return;\n<line6>        }\n<line7>        if (rc != 0) {\n<line8>            LOG.info(\"Got rc = \" + rc);\n<line9>            errors++;\n<line10>        } else {\n<line11>            finished++;\n<line12>            rlatency += Time.currentElapsedTime() - (Long) ctx;\n<line13>            reads++;\n<line14>        }\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!alive) {\n<line3>        return;\n<line4>    }\n<line5>    if (rc != 0) {\n<line6>        errors++;\n<line7>    } else {\n<line8>        finished++;\n<line9>        rlatency += Time.currentElapsedTime() - (Long) ctx;\n<line10>        reads++;\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (!alive) {\n<line3>        return;\n<line4>    }\n<line5>    if (rc != 0) {\n<line6>        LOG.info(\"Got rc = \" + rc);\n<line7>        errors++;\n<line8>    } else {\n<line9>        finished++;\n<line10>        rlatency += Time.currentElapsedTime() - (Long) ctx;\n<line11>        reads++;\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    errors++;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Got rc = \" + rc);\n<line3>    errors++;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    decOutstanding();\n<line3>    synchronized (statSync) {\n<line4>        if (rc != 0) {\n<line5>            errors++;\n<line6>        } else {\n<line7>            finished++;\n<line8>            wlatency += Time.currentElapsedTime() - (Long) ctx;\n<line9>            writes++;\n<line10>        }\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    decOutstanding();\n<line3>    synchronized (statSync) {\n<line4>        if (rc != 0) {\n<line5>            LOG.info(\"Got rc = \" + rc);\n<line6>            errors++;\n<line7>        } else {\n<line8>            finished++;\n<line9>            wlatency += Time.currentElapsedTime() - (Long) ctx;\n<line10>            writes++;\n<line11>        }\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (rc != 0) {\n<line3>        errors++;\n<line4>    } else {\n<line5>        finished++;\n<line6>        wlatency += Time.currentElapsedTime() - (Long) ctx;\n<line7>        writes++;\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (rc != 0) {\n<line3>        LOG.info(\"Got rc = \" + rc);\n<line4>        errors++;\n<line5>    } else {\n<line6>        finished++;\n<line7>        wlatency += Time.currentElapsedTime() - (Long) ctx;\n<line8>        writes++;\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    errors++;\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Got rc = \" + rc);\n<line3>    errors++;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    new Thread() {\n<line3>\n<line4>        public void run() {\n<line5>            try {\n<line6>                String[] parts = params.split(\" \");\n<line7>                String[] hostPort = parts[1].split(\":\");\n<line8>                int bytesSize = 1024;\n<line9>                if (parts.length == 3) {\n<line10>                    try {\n<line11>                        bytesSize = Integer.parseInt(parts[2]);\n<line12>                    } catch (Exception e) {\n<line13>                    }\n<line14>                }\n<line15>                bytes = new byte[bytesSize];\n<line16>                s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));\n<line17>                zkThread = new ZooKeeperThread(parts[0]);\n<line18>                sendThread = new SenderThread(s);\n<line19>                BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line20>                String line;\n<line21>                while ((line = is.readLine()) != null) {\n<line22>                    percentage = Integer.parseInt(line);\n<line23>                }\n<line24>            } catch (Exception e) {\n<line25>                e.printStackTrace();\n<line26>            }\n<line27>        }\n<line28>    }.start();\n<line29>}","output":"<line1>{\n<line2>    LOG.info(\"Got \" + params);\n<line3>    new Thread() {\n<line4>\n<line5>        public void run() {\n<line6>            try {\n<line7>                String[] parts = params.split(\" \");\n<line8>                String[] hostPort = parts[1].split(\":\");\n<line9>                int bytesSize = 1024;\n<line10>                if (parts.length == 3) {\n<line11>                    try {\n<line12>                        bytesSize = Integer.parseInt(parts[2]);\n<line13>                    } catch (Exception e) {\n<line14>                        LOG.error(\"Not an integer: \" + parts[2]);\n<line15>                    }\n<line16>                }\n<line17>                bytes = new byte[bytesSize];\n<line18>                s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));\n<line19>                zkThread = new ZooKeeperThread(parts[0]);\n<line20>                sendThread = new SenderThread(s);\n<line21>                BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line22>                String line;\n<line23>                while ((line = is.readLine()) != null) {\n<line24>                    percentage = Integer.parseInt(line);\n<line25>                }\n<line26>            } catch (Exception e) {\n<line27>                e.printStackTrace();\n<line28>            }\n<line29>        }\n<line30>    }.start();\n<line31>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String[] parts = params.split(\" \");\n<line4>        String[] hostPort = parts[1].split(\":\");\n<line5>        int bytesSize = 1024;\n<line6>        if (parts.length == 3) {\n<line7>            try {\n<line8>                bytesSize = Integer.parseInt(parts[2]);\n<line9>            } catch (Exception e) {\n<line10>            }\n<line11>        }\n<line12>        bytes = new byte[bytesSize];\n<line13>        s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));\n<line14>        zkThread = new ZooKeeperThread(parts[0]);\n<line15>        sendThread = new SenderThread(s);\n<line16>        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line17>        String line;\n<line18>        while ((line = is.readLine()) != null) {\n<line19>            percentage = Integer.parseInt(line);\n<line20>        }\n<line21>    } catch (Exception e) {\n<line22>        e.printStackTrace();\n<line23>    }\n<line24>}","output":"<line1>{\n<line2>    try {\n<line3>        String[] parts = params.split(\" \");\n<line4>        String[] hostPort = parts[1].split(\":\");\n<line5>        int bytesSize = 1024;\n<line6>        if (parts.length == 3) {\n<line7>            try {\n<line8>                bytesSize = Integer.parseInt(parts[2]);\n<line9>            } catch (Exception e) {\n<line10>                LOG.error(\"Not an integer: \" + parts[2]);\n<line11>            }\n<line12>        }\n<line13>        bytes = new byte[bytesSize];\n<line14>        s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));\n<line15>        zkThread = new ZooKeeperThread(parts[0]);\n<line16>        sendThread = new SenderThread(s);\n<line17>        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line18>        String line;\n<line19>        while ((line = is.readLine()) != null) {\n<line20>            percentage = Integer.parseInt(line);\n<line21>        }\n<line22>    } catch (Exception e) {\n<line23>        e.printStackTrace();\n<line24>    }\n<line25>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] parts = params.split(\" \");\n<line3>    String[] hostPort = parts[1].split(\":\");\n<line4>    int bytesSize = 1024;\n<line5>    if (parts.length == 3) {\n<line6>        try {\n<line7>            bytesSize = Integer.parseInt(parts[2]);\n<line8>        } catch (Exception e) {\n<line9>        }\n<line10>    }\n<line11>    bytes = new byte[bytesSize];\n<line12>    s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));\n<line13>    zkThread = new ZooKeeperThread(parts[0]);\n<line14>    sendThread = new SenderThread(s);\n<line15>    BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line16>    String line;\n<line17>    while ((line = is.readLine()) != null) {\n<line18>        percentage = Integer.parseInt(line);\n<line19>    }\n<line20>}","output":"<line1>{\n<line2>    String[] parts = params.split(\" \");\n<line3>    String[] hostPort = parts[1].split(\":\");\n<line4>    int bytesSize = 1024;\n<line5>    if (parts.length == 3) {\n<line6>        try {\n<line7>            bytesSize = Integer.parseInt(parts[2]);\n<line8>        } catch (Exception e) {\n<line9>            LOG.error(\"Not an integer: \" + parts[2]);\n<line10>        }\n<line11>    }\n<line12>    bytes = new byte[bytesSize];\n<line13>    s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));\n<line14>    zkThread = new ZooKeeperThread(parts[0]);\n<line15>    sendThread = new SenderThread(s);\n<line16>    BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n<line17>    String line;\n<line18>    while ((line = is.readLine()) != null) {\n<line19>        percentage = Integer.parseInt(line);\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        bytesSize = Integer.parseInt(parts[2]);\n<line4>    } catch (Exception e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        bytesSize = Integer.parseInt(parts[2]);\n<line4>    } catch (Exception e) {\n<line5>        LOG.error(\"Not an integer: \" + parts[2]);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Not an integer: \" + parts[2]);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    args = processOptions(args);\n<line3>    if (args.length == 5) {\n<line4>        try {\n<line5>            StatusWatcher statusWatcher = new StatusWatcher();\n<line6>            ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);\n<line7>            if (!statusWatcher.waitConnected(5000)) {\n<line8>                return;\n<line9>            }\n<line10>            InstanceManager im = new InstanceManager(zk, args[1]);\n<line11>            ss = new ServerSocket(0);\n<line12>            int port = ss.getLocalPort();\n<line13>            int serverCount = Integer.parseInt(args[2]);\n<line14>            int clientCount = Integer.parseInt(args[3]);\n<line15>            StringBuilder quorumHostPort = new StringBuilder();\n<line16>            StringBuilder zkHostPort = new StringBuilder();\n<line17>            for (int i = 0; i < serverCount; i++) {\n<line18>                String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);\n<line19>                if (i > 0) {\n<line20>                    quorumHostPort.append(',');\n<line21>                    zkHostPort.append(',');\n<line22>                }\n<line23>                // r[0] == \"host:clientPort\"\n<line24>                zkHostPort.append(r[0]);\n<line25>                // r[1] == \"host:leaderPort:leaderElectionPort\"\n<line26>                quorumHostPort.append(r[1]);\n<line27>                // Appending \";clientPort\"\n<line28>                quorumHostPort.append(\";\" + (r[0].split(\":\"))[1]);\n<line29>            }\n<line30>            for (int i = 0; i < serverCount; i++) {\n<line31>                QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);\n<line32>            }\n<line33>            if (leaderOnly) {\n<line34>                int tries = 0;\n<line35>                outer: while (true) {\n<line36>                    Thread.sleep(1000);\n<line37>                    IOException lastException = null;\n<line38>                    String[] parts = zkHostPort.toString().split(\",\");\n<line39>                    for (int i = 0; i < parts.length; i++) {\n<line40>                        try {\n<line41>                            String mode = getMode(parts[i]);\n<line42>                            if (mode.equals(\"leader\")) {\n<line43>                                zkHostPort = new StringBuilder(parts[i]);\n<line44>                                break outer;\n<line45>                            }\n<line46>                        } catch (IOException e) {\n<line47>                            lastException = e;\n<line48>                        }\n<line49>                    }\n<line50>                    if (tries++ > 3) {\n<line51>                        throw lastException;\n<line52>                    }\n<line53>                }\n<line54>            }\n<line55>            for (int i = 0; i < clientCount; i++) {\n<line56>                im.assignInstance(\"client\" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);\n<line57>            }\n<line58>            new AcceptorThread();\n<line59>            new ReporterThread();\n<line60>            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n<line61>            String line;\n<line62>            while ((line = is.readLine()) != null) {\n<line63>                try {\n<line64>                    String[] cmdNumber = line.split(\" \");\n<line65>                    if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line66>                        int number = Integer.parseInt(cmdNumber[1]);\n<line67>                        if (number < 0 || number > 100) {\n<line68>                            throw new NumberFormatException(\"must be between 0 and 100\");\n<line69>                        }\n<line70>                        sendChange(number);\n<line71>                    } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line72>                        int number = Integer.parseInt(cmdNumber[1]);\n<line73>                        Thread.sleep(number * 1000);\n<line74>                    } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line75>                        sf = new PrintStream(cmdNumber[1]);\n<line76>                    } else {\n<line77>                    }\n<line78>                } catch (NumberFormatException e) {\n<line79>                }\n<line80>            }\n<line81>        } catch (NumberFormatException e) {\n<line82>            doUsage();\n<line83>        } catch (IOException e) {\n<line84>            e.printStackTrace();\n<line85>            System.exit(ExitCode.INVALID_INVOCATION.getValue());\n<line86>        }\n<line87>    } else {\n<line88>        doUsage();\n<line89>    }\n<line90>}","output":"<line1>{\n<line2>    args = processOptions(args);\n<line3>    if (args.length == 5) {\n<line4>        try {\n<line5>            StatusWatcher statusWatcher = new StatusWatcher();\n<line6>            ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);\n<line7>            if (!statusWatcher.waitConnected(5000)) {\n<line8>                LOG.error(\"Could not connect to \" + args[0]);\n<line9>                return;\n<line10>            }\n<line11>            InstanceManager im = new InstanceManager(zk, args[1]);\n<line12>            ss = new ServerSocket(0);\n<line13>            int port = ss.getLocalPort();\n<line14>            int serverCount = Integer.parseInt(args[2]);\n<line15>            int clientCount = Integer.parseInt(args[3]);\n<line16>            StringBuilder quorumHostPort = new StringBuilder();\n<line17>            StringBuilder zkHostPort = new StringBuilder();\n<line18>            for (int i = 0; i < serverCount; i++) {\n<line19>                String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);\n<line20>                if (i > 0) {\n<line21>                    quorumHostPort.append(',');\n<line22>                    zkHostPort.append(',');\n<line23>                }\n<line24>                // r[0] == \"host:clientPort\"\n<line25>                zkHostPort.append(r[0]);\n<line26>                // r[1] == \"host:leaderPort:leaderElectionPort\"\n<line27>                quorumHostPort.append(r[1]);\n<line28>                // Appending \";clientPort\"\n<line29>                quorumHostPort.append(\";\" + (r[0].split(\":\"))[1]);\n<line30>            }\n<line31>            for (int i = 0; i < serverCount; i++) {\n<line32>                QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);\n<line33>            }\n<line34>            if (leaderOnly) {\n<line35>                int tries = 0;\n<line36>                outer: while (true) {\n<line37>                    Thread.sleep(1000);\n<line38>                    IOException lastException = null;\n<line39>                    String[] parts = zkHostPort.toString().split(\",\");\n<line40>                    for (int i = 0; i < parts.length; i++) {\n<line41>                        try {\n<line42>                            String mode = getMode(parts[i]);\n<line43>                            if (mode.equals(\"leader\")) {\n<line44>                                zkHostPort = new StringBuilder(parts[i]);\n<line45>                                LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line46>                                break outer;\n<line47>                            }\n<line48>                        } catch (IOException e) {\n<line49>                            lastException = e;\n<line50>                        }\n<line51>                    }\n<line52>                    if (tries++ > 3) {\n<line53>                        throw lastException;\n<line54>                    }\n<line55>                }\n<line56>            }\n<line57>            for (int i = 0; i < clientCount; i++) {\n<line58>                im.assignInstance(\"client\" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);\n<line59>            }\n<line60>            new AcceptorThread();\n<line61>            new ReporterThread();\n<line62>            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n<line63>            String line;\n<line64>            while ((line = is.readLine()) != null) {\n<line65>                try {\n<line66>                    String[] cmdNumber = line.split(\" \");\n<line67>                    if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line68>                        int number = Integer.parseInt(cmdNumber[1]);\n<line69>                        if (number < 0 || number > 100) {\n<line70>                            throw new NumberFormatException(\"must be between 0 and 100\");\n<line71>                        }\n<line72>                        sendChange(number);\n<line73>                    } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line74>                        int number = Integer.parseInt(cmdNumber[1]);\n<line75>                        Thread.sleep(number * 1000);\n<line76>                    } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line77>                        sf = new PrintStream(cmdNumber[1]);\n<line78>                    } else {\n<line79>                        LOG.error(\"Commands must be:\");\n<line80>                        LOG.error(\"\\tpercentage new_write_percentage\");\n<line81>                        LOG.error(\"\\tsleep seconds_to_sleep\");\n<line82>                        LOG.error(\"\\tsave file_to_save_output\");\n<line83>                    }\n<line84>                } catch (NumberFormatException e) {\n<line85>                    LOG.error(\"Not a valid number: \" + e.getMessage());\n<line86>                }\n<line87>            }\n<line88>        } catch (NumberFormatException e) {\n<line89>            doUsage();\n<line90>        } catch (IOException e) {\n<line91>            e.printStackTrace();\n<line92>            System.exit(ExitCode.INVALID_INVOCATION.getValue());\n<line93>        }\n<line94>    } else {\n<line95>        doUsage();\n<line96>    }\n<line97>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        StatusWatcher statusWatcher = new StatusWatcher();\n<line4>        ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);\n<line5>        if (!statusWatcher.waitConnected(5000)) {\n<line6>            return;\n<line7>        }\n<line8>        InstanceManager im = new InstanceManager(zk, args[1]);\n<line9>        ss = new ServerSocket(0);\n<line10>        int port = ss.getLocalPort();\n<line11>        int serverCount = Integer.parseInt(args[2]);\n<line12>        int clientCount = Integer.parseInt(args[3]);\n<line13>        StringBuilder quorumHostPort = new StringBuilder();\n<line14>        StringBuilder zkHostPort = new StringBuilder();\n<line15>        for (int i = 0; i < serverCount; i++) {\n<line16>            String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);\n<line17>            if (i > 0) {\n<line18>                quorumHostPort.append(',');\n<line19>                zkHostPort.append(',');\n<line20>            }\n<line21>            // r[0] == \"host:clientPort\"\n<line22>            zkHostPort.append(r[0]);\n<line23>            // r[1] == \"host:leaderPort:leaderElectionPort\"\n<line24>            quorumHostPort.append(r[1]);\n<line25>            // Appending \";clientPort\"\n<line26>            quorumHostPort.append(\";\" + (r[0].split(\":\"))[1]);\n<line27>        }\n<line28>        for (int i = 0; i < serverCount; i++) {\n<line29>            QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);\n<line30>        }\n<line31>        if (leaderOnly) {\n<line32>            int tries = 0;\n<line33>            outer: while (true) {\n<line34>                Thread.sleep(1000);\n<line35>                IOException lastException = null;\n<line36>                String[] parts = zkHostPort.toString().split(\",\");\n<line37>                for (int i = 0; i < parts.length; i++) {\n<line38>                    try {\n<line39>                        String mode = getMode(parts[i]);\n<line40>                        if (mode.equals(\"leader\")) {\n<line41>                            zkHostPort = new StringBuilder(parts[i]);\n<line42>                            break outer;\n<line43>                        }\n<line44>                    } catch (IOException e) {\n<line45>                        lastException = e;\n<line46>                    }\n<line47>                }\n<line48>                if (tries++ > 3) {\n<line49>                    throw lastException;\n<line50>                }\n<line51>            }\n<line52>        }\n<line53>        for (int i = 0; i < clientCount; i++) {\n<line54>            im.assignInstance(\"client\" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);\n<line55>        }\n<line56>        new AcceptorThread();\n<line57>        new ReporterThread();\n<line58>        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n<line59>        String line;\n<line60>        while ((line = is.readLine()) != null) {\n<line61>            try {\n<line62>                String[] cmdNumber = line.split(\" \");\n<line63>                if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line64>                    int number = Integer.parseInt(cmdNumber[1]);\n<line65>                    if (number < 0 || number > 100) {\n<line66>                        throw new NumberFormatException(\"must be between 0 and 100\");\n<line67>                    }\n<line68>                    sendChange(number);\n<line69>                } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line70>                    int number = Integer.parseInt(cmdNumber[1]);\n<line71>                    Thread.sleep(number * 1000);\n<line72>                } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line73>                    sf = new PrintStream(cmdNumber[1]);\n<line74>                } else {\n<line75>                }\n<line76>            } catch (NumberFormatException e) {\n<line77>            }\n<line78>        }\n<line79>    } catch (NumberFormatException e) {\n<line80>        doUsage();\n<line81>    } catch (IOException e) {\n<line82>        e.printStackTrace();\n<line83>        System.exit(ExitCode.INVALID_INVOCATION.getValue());\n<line84>    }\n<line85>}","output":"<line1>{\n<line2>    try {\n<line3>        StatusWatcher statusWatcher = new StatusWatcher();\n<line4>        ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);\n<line5>        if (!statusWatcher.waitConnected(5000)) {\n<line6>            LOG.error(\"Could not connect to \" + args[0]);\n<line7>            return;\n<line8>        }\n<line9>        InstanceManager im = new InstanceManager(zk, args[1]);\n<line10>        ss = new ServerSocket(0);\n<line11>        int port = ss.getLocalPort();\n<line12>        int serverCount = Integer.parseInt(args[2]);\n<line13>        int clientCount = Integer.parseInt(args[3]);\n<line14>        StringBuilder quorumHostPort = new StringBuilder();\n<line15>        StringBuilder zkHostPort = new StringBuilder();\n<line16>        for (int i = 0; i < serverCount; i++) {\n<line17>            String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);\n<line18>            if (i > 0) {\n<line19>                quorumHostPort.append(',');\n<line20>                zkHostPort.append(',');\n<line21>            }\n<line22>            // r[0] == \"host:clientPort\"\n<line23>            zkHostPort.append(r[0]);\n<line24>            // r[1] == \"host:leaderPort:leaderElectionPort\"\n<line25>            quorumHostPort.append(r[1]);\n<line26>            // Appending \";clientPort\"\n<line27>            quorumHostPort.append(\";\" + (r[0].split(\":\"))[1]);\n<line28>        }\n<line29>        for (int i = 0; i < serverCount; i++) {\n<line30>            QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);\n<line31>        }\n<line32>        if (leaderOnly) {\n<line33>            int tries = 0;\n<line34>            outer: while (true) {\n<line35>                Thread.sleep(1000);\n<line36>                IOException lastException = null;\n<line37>                String[] parts = zkHostPort.toString().split(\",\");\n<line38>                for (int i = 0; i < parts.length; i++) {\n<line39>                    try {\n<line40>                        String mode = getMode(parts[i]);\n<line41>                        if (mode.equals(\"leader\")) {\n<line42>                            zkHostPort = new StringBuilder(parts[i]);\n<line43>                            LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line44>                            break outer;\n<line45>                        }\n<line46>                    } catch (IOException e) {\n<line47>                        lastException = e;\n<line48>                    }\n<line49>                }\n<line50>                if (tries++ > 3) {\n<line51>                    throw lastException;\n<line52>                }\n<line53>            }\n<line54>        }\n<line55>        for (int i = 0; i < clientCount; i++) {\n<line56>            im.assignInstance(\"client\" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);\n<line57>        }\n<line58>        new AcceptorThread();\n<line59>        new ReporterThread();\n<line60>        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n<line61>        String line;\n<line62>        while ((line = is.readLine()) != null) {\n<line63>            try {\n<line64>                String[] cmdNumber = line.split(\" \");\n<line65>                if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line66>                    int number = Integer.parseInt(cmdNumber[1]);\n<line67>                    if (number < 0 || number > 100) {\n<line68>                        throw new NumberFormatException(\"must be between 0 and 100\");\n<line69>                    }\n<line70>                    sendChange(number);\n<line71>                } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line72>                    int number = Integer.parseInt(cmdNumber[1]);\n<line73>                    Thread.sleep(number * 1000);\n<line74>                } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line75>                    sf = new PrintStream(cmdNumber[1]);\n<line76>                } else {\n<line77>                    LOG.error(\"Commands must be:\");\n<line78>                    LOG.error(\"\\tpercentage new_write_percentage\");\n<line79>                    LOG.error(\"\\tsleep seconds_to_sleep\");\n<line80>                    LOG.error(\"\\tsave file_to_save_output\");\n<line81>                }\n<line82>            } catch (NumberFormatException e) {\n<line83>                LOG.error(\"Not a valid number: \" + e.getMessage());\n<line84>            }\n<line85>        }\n<line86>    } catch (NumberFormatException e) {\n<line87>        doUsage();\n<line88>    } catch (IOException e) {\n<line89>        e.printStackTrace();\n<line90>        System.exit(ExitCode.INVALID_INVOCATION.getValue());\n<line91>    }\n<line92>}"},{"input":"","instruction":"<line1>{\n<line2>    StatusWatcher statusWatcher = new StatusWatcher();\n<line3>    ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);\n<line4>    if (!statusWatcher.waitConnected(5000)) {\n<line5>        return;\n<line6>    }\n<line7>    InstanceManager im = new InstanceManager(zk, args[1]);\n<line8>    ss = new ServerSocket(0);\n<line9>    int port = ss.getLocalPort();\n<line10>    int serverCount = Integer.parseInt(args[2]);\n<line11>    int clientCount = Integer.parseInt(args[3]);\n<line12>    StringBuilder quorumHostPort = new StringBuilder();\n<line13>    StringBuilder zkHostPort = new StringBuilder();\n<line14>    for (int i = 0; i < serverCount; i++) {\n<line15>        String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);\n<line16>        if (i > 0) {\n<line17>            quorumHostPort.append(',');\n<line18>            zkHostPort.append(',');\n<line19>        }\n<line20>        // r[0] == \"host:clientPort\"\n<line21>        zkHostPort.append(r[0]);\n<line22>        // r[1] == \"host:leaderPort:leaderElectionPort\"\n<line23>        quorumHostPort.append(r[1]);\n<line24>        // Appending \";clientPort\"\n<line25>        quorumHostPort.append(\";\" + (r[0].split(\":\"))[1]);\n<line26>    }\n<line27>    for (int i = 0; i < serverCount; i++) {\n<line28>        QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);\n<line29>    }\n<line30>    if (leaderOnly) {\n<line31>        int tries = 0;\n<line32>        outer: while (true) {\n<line33>            Thread.sleep(1000);\n<line34>            IOException lastException = null;\n<line35>            String[] parts = zkHostPort.toString().split(\",\");\n<line36>            for (int i = 0; i < parts.length; i++) {\n<line37>                try {\n<line38>                    String mode = getMode(parts[i]);\n<line39>                    if (mode.equals(\"leader\")) {\n<line40>                        zkHostPort = new StringBuilder(parts[i]);\n<line41>                        break outer;\n<line42>                    }\n<line43>                } catch (IOException e) {\n<line44>                    lastException = e;\n<line45>                }\n<line46>            }\n<line47>            if (tries++ > 3) {\n<line48>                throw lastException;\n<line49>            }\n<line50>        }\n<line51>    }\n<line52>    for (int i = 0; i < clientCount; i++) {\n<line53>        im.assignInstance(\"client\" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);\n<line54>    }\n<line55>    new AcceptorThread();\n<line56>    new ReporterThread();\n<line57>    BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n<line58>    String line;\n<line59>    while ((line = is.readLine()) != null) {\n<line60>        try {\n<line61>            String[] cmdNumber = line.split(\" \");\n<line62>            if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line63>                int number = Integer.parseInt(cmdNumber[1]);\n<line64>                if (number < 0 || number > 100) {\n<line65>                    throw new NumberFormatException(\"must be between 0 and 100\");\n<line66>                }\n<line67>                sendChange(number);\n<line68>            } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line69>                int number = Integer.parseInt(cmdNumber[1]);\n<line70>                Thread.sleep(number * 1000);\n<line71>            } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line72>                sf = new PrintStream(cmdNumber[1]);\n<line73>            } else {\n<line74>            }\n<line75>        } catch (NumberFormatException e) {\n<line76>        }\n<line77>    }\n<line78>}","output":"<line1>{\n<line2>    StatusWatcher statusWatcher = new StatusWatcher();\n<line3>    ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);\n<line4>    if (!statusWatcher.waitConnected(5000)) {\n<line5>        LOG.error(\"Could not connect to \" + args[0]);\n<line6>        return;\n<line7>    }\n<line8>    InstanceManager im = new InstanceManager(zk, args[1]);\n<line9>    ss = new ServerSocket(0);\n<line10>    int port = ss.getLocalPort();\n<line11>    int serverCount = Integer.parseInt(args[2]);\n<line12>    int clientCount = Integer.parseInt(args[3]);\n<line13>    StringBuilder quorumHostPort = new StringBuilder();\n<line14>    StringBuilder zkHostPort = new StringBuilder();\n<line15>    for (int i = 0; i < serverCount; i++) {\n<line16>        String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);\n<line17>        if (i > 0) {\n<line18>            quorumHostPort.append(',');\n<line19>            zkHostPort.append(',');\n<line20>        }\n<line21>        // r[0] == \"host:clientPort\"\n<line22>        zkHostPort.append(r[0]);\n<line23>        // r[1] == \"host:leaderPort:leaderElectionPort\"\n<line24>        quorumHostPort.append(r[1]);\n<line25>        // Appending \";clientPort\"\n<line26>        quorumHostPort.append(\";\" + (r[0].split(\":\"))[1]);\n<line27>    }\n<line28>    for (int i = 0; i < serverCount; i++) {\n<line29>        QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);\n<line30>    }\n<line31>    if (leaderOnly) {\n<line32>        int tries = 0;\n<line33>        outer: while (true) {\n<line34>            Thread.sleep(1000);\n<line35>            IOException lastException = null;\n<line36>            String[] parts = zkHostPort.toString().split(\",\");\n<line37>            for (int i = 0; i < parts.length; i++) {\n<line38>                try {\n<line39>                    String mode = getMode(parts[i]);\n<line40>                    if (mode.equals(\"leader\")) {\n<line41>                        zkHostPort = new StringBuilder(parts[i]);\n<line42>                        LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line43>                        break outer;\n<line44>                    }\n<line45>                } catch (IOException e) {\n<line46>                    lastException = e;\n<line47>                }\n<line48>            }\n<line49>            if (tries++ > 3) {\n<line50>                throw lastException;\n<line51>            }\n<line52>        }\n<line53>    }\n<line54>    for (int i = 0; i < clientCount; i++) {\n<line55>        im.assignInstance(\"client\" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);\n<line56>    }\n<line57>    new AcceptorThread();\n<line58>    new ReporterThread();\n<line59>    BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n<line60>    String line;\n<line61>    while ((line = is.readLine()) != null) {\n<line62>        try {\n<line63>            String[] cmdNumber = line.split(\" \");\n<line64>            if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line65>                int number = Integer.parseInt(cmdNumber[1]);\n<line66>                if (number < 0 || number > 100) {\n<line67>                    throw new NumberFormatException(\"must be between 0 and 100\");\n<line68>                }\n<line69>                sendChange(number);\n<line70>            } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line71>                int number = Integer.parseInt(cmdNumber[1]);\n<line72>                Thread.sleep(number * 1000);\n<line73>            } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line74>                sf = new PrintStream(cmdNumber[1]);\n<line75>            } else {\n<line76>                LOG.error(\"Commands must be:\");\n<line77>                LOG.error(\"\\tpercentage new_write_percentage\");\n<line78>                LOG.error(\"\\tsleep seconds_to_sleep\");\n<line79>                LOG.error(\"\\tsave file_to_save_output\");\n<line80>            }\n<line81>        } catch (NumberFormatException e) {\n<line82>            LOG.error(\"Not a valid number: \" + e.getMessage());\n<line83>        }\n<line84>    }\n<line85>}"},{"input":"","instruction":"<line1>{\n<line2>    return;\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Could not connect to \" + args[0]);\n<line3>    return;\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    int tries = 0;\n<line3>    outer: while (true) {\n<line4>        Thread.sleep(1000);\n<line5>        IOException lastException = null;\n<line6>        String[] parts = zkHostPort.toString().split(\",\");\n<line7>        for (int i = 0; i < parts.length; i++) {\n<line8>            try {\n<line9>                String mode = getMode(parts[i]);\n<line10>                if (mode.equals(\"leader\")) {\n<line11>                    zkHostPort = new StringBuilder(parts[i]);\n<line12>                    break outer;\n<line13>                }\n<line14>            } catch (IOException e) {\n<line15>                lastException = e;\n<line16>            }\n<line17>        }\n<line18>        if (tries++ > 3) {\n<line19>            throw lastException;\n<line20>        }\n<line21>    }\n<line22>}","output":"<line1>{\n<line2>    int tries = 0;\n<line3>    outer: while (true) {\n<line4>        Thread.sleep(1000);\n<line5>        IOException lastException = null;\n<line6>        String[] parts = zkHostPort.toString().split(\",\");\n<line7>        for (int i = 0; i < parts.length; i++) {\n<line8>            try {\n<line9>                String mode = getMode(parts[i]);\n<line10>                if (mode.equals(\"leader\")) {\n<line11>                    zkHostPort = new StringBuilder(parts[i]);\n<line12>                    LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line13>                    break outer;\n<line14>                }\n<line15>            } catch (IOException e) {\n<line16>                lastException = e;\n<line17>            }\n<line18>        }\n<line19>        if (tries++ > 3) {\n<line20>            throw lastException;\n<line21>        }\n<line22>    }\n<line23>}"},{"input":"","instruction":"<line1>{\n<line2>    Thread.sleep(1000);\n<line3>    IOException lastException = null;\n<line4>    String[] parts = zkHostPort.toString().split(\",\");\n<line5>    for (int i = 0; i < parts.length; i++) {\n<line6>        try {\n<line7>            String mode = getMode(parts[i]);\n<line8>            if (mode.equals(\"leader\")) {\n<line9>                zkHostPort = new StringBuilder(parts[i]);\n<line10>                break outer;\n<line11>            }\n<line12>        } catch (IOException e) {\n<line13>            lastException = e;\n<line14>        }\n<line15>    }\n<line16>    if (tries++ > 3) {\n<line17>        throw lastException;\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    Thread.sleep(1000);\n<line3>    IOException lastException = null;\n<line4>    String[] parts = zkHostPort.toString().split(\",\");\n<line5>    for (int i = 0; i < parts.length; i++) {\n<line6>        try {\n<line7>            String mode = getMode(parts[i]);\n<line8>            if (mode.equals(\"leader\")) {\n<line9>                zkHostPort = new StringBuilder(parts[i]);\n<line10>                LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line11>                break outer;\n<line12>            }\n<line13>        } catch (IOException e) {\n<line14>            lastException = e;\n<line15>        }\n<line16>    }\n<line17>    if (tries++ > 3) {\n<line18>        throw lastException;\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String mode = getMode(parts[i]);\n<line4>        if (mode.equals(\"leader\")) {\n<line5>            zkHostPort = new StringBuilder(parts[i]);\n<line6>            break outer;\n<line7>        }\n<line8>    } catch (IOException e) {\n<line9>        lastException = e;\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    try {\n<line3>        String mode = getMode(parts[i]);\n<line4>        if (mode.equals(\"leader\")) {\n<line5>            zkHostPort = new StringBuilder(parts[i]);\n<line6>            LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line7>            break outer;\n<line8>        }\n<line9>    } catch (IOException e) {\n<line10>        lastException = e;\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    String mode = getMode(parts[i]);\n<line3>    if (mode.equals(\"leader\")) {\n<line4>        zkHostPort = new StringBuilder(parts[i]);\n<line5>        break outer;\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    String mode = getMode(parts[i]);\n<line3>    if (mode.equals(\"leader\")) {\n<line4>        zkHostPort = new StringBuilder(parts[i]);\n<line5>        LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line6>        break outer;\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    zkHostPort = new StringBuilder(parts[i]);\n<line3>    break outer;\n<line4>}","output":"<line1>{\n<line2>    zkHostPort = new StringBuilder(parts[i]);\n<line3>    LOG.info(\"Connecting exclusively to \" + zkHostPort.toString());\n<line4>    break outer;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        String[] cmdNumber = line.split(\" \");\n<line4>        if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line5>            int number = Integer.parseInt(cmdNumber[1]);\n<line6>            if (number < 0 || number > 100) {\n<line7>                throw new NumberFormatException(\"must be between 0 and 100\");\n<line8>            }\n<line9>            sendChange(number);\n<line10>        } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line11>            int number = Integer.parseInt(cmdNumber[1]);\n<line12>            Thread.sleep(number * 1000);\n<line13>        } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line14>            sf = new PrintStream(cmdNumber[1]);\n<line15>        } else {\n<line16>        }\n<line17>    } catch (NumberFormatException e) {\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    try {\n<line3>        String[] cmdNumber = line.split(\" \");\n<line4>        if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line5>            int number = Integer.parseInt(cmdNumber[1]);\n<line6>            if (number < 0 || number > 100) {\n<line7>                throw new NumberFormatException(\"must be between 0 and 100\");\n<line8>            }\n<line9>            sendChange(number);\n<line10>        } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line11>            int number = Integer.parseInt(cmdNumber[1]);\n<line12>            Thread.sleep(number * 1000);\n<line13>        } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line14>            sf = new PrintStream(cmdNumber[1]);\n<line15>        } else {\n<line16>            LOG.error(\"Commands must be:\");\n<line17>            LOG.error(\"\\tpercentage new_write_percentage\");\n<line18>            LOG.error(\"\\tsleep seconds_to_sleep\");\n<line19>            LOG.error(\"\\tsave file_to_save_output\");\n<line20>        }\n<line21>    } catch (NumberFormatException e) {\n<line22>        LOG.error(\"Not a valid number: \" + e.getMessage());\n<line23>    }\n<line24>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] cmdNumber = line.split(\" \");\n<line3>    if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line4>        int number = Integer.parseInt(cmdNumber[1]);\n<line5>        if (number < 0 || number > 100) {\n<line6>            throw new NumberFormatException(\"must be between 0 and 100\");\n<line7>        }\n<line8>        sendChange(number);\n<line9>    } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line10>        int number = Integer.parseInt(cmdNumber[1]);\n<line11>        Thread.sleep(number * 1000);\n<line12>    } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line13>        sf = new PrintStream(cmdNumber[1]);\n<line14>    } else {\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    String[] cmdNumber = line.split(\" \");\n<line3>    if (cmdNumber[0].equals(\"percentage\") && cmdNumber.length > 1) {\n<line4>        int number = Integer.parseInt(cmdNumber[1]);\n<line5>        if (number < 0 || number > 100) {\n<line6>            throw new NumberFormatException(\"must be between 0 and 100\");\n<line7>        }\n<line8>        sendChange(number);\n<line9>    } else if (cmdNumber[0].equals(\"sleep\") && cmdNumber.length > 1) {\n<line10>        int number = Integer.parseInt(cmdNumber[1]);\n<line11>        Thread.sleep(number * 1000);\n<line12>    } else if (cmdNumber[0].equals(\"save\") && cmdNumber.length > 1) {\n<line13>        sf = new PrintStream(cmdNumber[1]);\n<line14>    } else {\n<line15>        LOG.error(\"Commands must be:\");\n<line16>        LOG.error(\"\\tpercentage new_write_percentage\");\n<line17>        LOG.error(\"\\tsleep seconds_to_sleep\");\n<line18>        LOG.error(\"\\tsave file_to_save_output\");\n<line19>    }\n<line20>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Commands must be:\");\n<line3>    LOG.error(\"\\tpercentage new_write_percentage\");\n<line4>    LOG.error(\"\\tsleep seconds_to_sleep\");\n<line5>    LOG.error(\"\\tsave file_to_save_output\");\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Not a valid number: \" + e.getMessage());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (rc != KeeperException.Code.OK.intValue()) {\n<line3>        zk.getChildren(statusNode, this, this, null);\n<line4>        return;\n<line5>    }\n<line6>    }\n<line7>    Map<String, HashSet<Assigned>> newAssignments = new HashMap<String, HashSet<Assigned>>();\n<line8>    for (String c : children) {\n<line9>        HashSet<Assigned> a = assignments.remove(c);\n<line10>        if (a != null) {\n<line11>            newAssignments.put(c, a);\n<line12>        } else {\n<line13>            newAssignments.put(c, new HashSet<Assigned>());\n<line14>        }\n<line15>    }\n<line16>    // Clean up the dead machines\n<line17>    for (String dead : assignments.keySet()) {\n<line18>        try {\n<line19>            removeInstance(dead);\n<line20>        } catch (KeeperException e) {\n<line21>            e.printStackTrace();\n<line22>        } catch (InterruptedException e) {\n<line23>            Thread.currentThread().interrupt();\n<line24>        }\n<line25>    }\n<line26>    assignments = newAssignments;\n<line27>}","output":"<line1>{\n<line2>    if (rc != KeeperException.Code.OK.intValue()) {\n<line3>        zk.getChildren(statusNode, this, this, null);\n<line4>        return;\n<line5>    }\n<line6>    if (LOG.isDebugEnabled()) {\n<line7>        LOG.debug(\"Got \" + children + \" children from \" + path);\n<line8>    }\n<line9>    Map<String, HashSet<Assigned>> newAssignments = new HashMap<String, HashSet<Assigned>>();\n<line10>    for (String c : children) {\n<line11>        HashSet<Assigned> a = assignments.remove(c);\n<line12>        if (a != null) {\n<line13>            newAssignments.put(c, a);\n<line14>        } else {\n<line15>            newAssignments.put(c, new HashSet<Assigned>());\n<line16>        }\n<line17>    }\n<line18>    // Clean up the dead machines\n<line19>    for (String dead : assignments.keySet()) {\n<line20>        try {\n<line21>            removeInstance(dead);\n<line22>        } catch (KeeperException e) {\n<line23>            e.printStackTrace();\n<line24>        } catch (InterruptedException e) {\n<line25>            Thread.currentThread().interrupt();\n<line26>        }\n<line27>    }\n<line28>    assignments = newAssignments;\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Got \" + children + \" children from \" + path);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    Assigned assigned = instanceToAssignment.get(name);\n<line4>    if (assigned == null) {\n<line5>        throw new NoAssignmentException();\n<line6>    }\n<line7>    KeeperException lastException = null;\n<line8>    for (int i = 0; i < maxTries; i++) {\n<line9>        try {\n<line10>            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n<line11>            break;\n<line12>        } catch (ConnectionLossException e) {\n<line13>            lastException = e;\n<line14>        }\n<line15>    }\n<line16>    if (lastException != null) {\n<line17>        throw lastException;\n<line18>    }\n<line19>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n<line4>    }\n<line5>    Assigned assigned = instanceToAssignment.get(name);\n<line6>    if (assigned == null) {\n<line7>        throw new NoAssignmentException();\n<line8>    }\n<line9>    KeeperException lastException = null;\n<line10>    for (int i = 0; i < maxTries; i++) {\n<line11>        try {\n<line12>            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n<line13>            break;\n<line14>        } catch (ConnectionLossException e) {\n<line15>            lastException = e;\n<line16>        }\n<line17>    }\n<line18>    if (lastException != null) {\n<line19>        throw lastException;\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    Stat stat = new Stat();\n<line3>    byte[] data = null;\n<line4>    long endTime = Time.currentElapsedTime() + timeout;\n<line5>    KeeperException lastException = null;\n<line6>    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n<line7>        try {\n<line8>            data = zk.getData(reportsNode + '/' + name, false, stat);\n<line9>            }\n<line10>            lastException = null;\n<line11>            break;\n<line12>        } catch (ConnectionLossException e) {\n<line13>            lastException = e;\n<line14>        } catch (NoNodeException e) {\n<line15>            final Object eventObj = new Object();\n<line16>            synchronized (eventObj) {\n<line17>                // wait for the node to appear\n<line18>                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n<line19>\n<line20>                    public void process(WatchedEvent event) {\n<line21>                        synchronized (eventObj) {\n<line22>                            eventObj.notifyAll();\n<line23>                        }\n<line24>                    }\n<line25>                });\n<line26>                if (eStat == null) {\n<line27>                    eventObj.wait(endTime - Time.currentElapsedTime());\n<line28>                }\n<line29>            }\n<line30>            lastException = e;\n<line31>        }\n<line32>    }\n<line33>    if (lastException != null) {\n<line34>        throw lastException;\n<line35>    }\n<line36>    return new String(data);\n<line37>}","output":"<line1>{\n<line2>    Stat stat = new Stat();\n<line3>    byte[] data = null;\n<line4>    long endTime = Time.currentElapsedTime() + timeout;\n<line5>    KeeperException lastException = null;\n<line6>    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n<line7>        try {\n<line8>            data = zk.getData(reportsNode + '/' + name, false, stat);\n<line9>            if (LOG.isDebugEnabled()) {\n<line10>                LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n<line11>            }\n<line12>            lastException = null;\n<line13>            break;\n<line14>        } catch (ConnectionLossException e) {\n<line15>            lastException = e;\n<line16>        } catch (NoNodeException e) {\n<line17>            final Object eventObj = new Object();\n<line18>            synchronized (eventObj) {\n<line19>                // wait for the node to appear\n<line20>                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n<line21>\n<line22>                    public void process(WatchedEvent event) {\n<line23>                        synchronized (eventObj) {\n<line24>                            eventObj.notifyAll();\n<line25>                        }\n<line26>                    }\n<line27>                });\n<line28>                if (eStat == null) {\n<line29>                    eventObj.wait(endTime - Time.currentElapsedTime());\n<line30>                }\n<line31>            }\n<line32>            lastException = e;\n<line33>        }\n<line34>    }\n<line35>    if (lastException != null) {\n<line36>        throw lastException;\n<line37>    }\n<line38>    return new String(data);\n<line39>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        data = zk.getData(reportsNode + '/' + name, false, stat);\n<line4>        }\n<line5>        lastException = null;\n<line6>        break;\n<line7>    } catch (ConnectionLossException e) {\n<line8>        lastException = e;\n<line9>    } catch (NoNodeException e) {\n<line10>        final Object eventObj = new Object();\n<line11>        synchronized (eventObj) {\n<line12>            // wait for the node to appear\n<line13>            Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n<line14>\n<line15>                public void process(WatchedEvent event) {\n<line16>                    synchronized (eventObj) {\n<line17>                        eventObj.notifyAll();\n<line18>                    }\n<line19>                }\n<line20>            });\n<line21>            if (eStat == null) {\n<line22>                eventObj.wait(endTime - Time.currentElapsedTime());\n<line23>            }\n<line24>        }\n<line25>        lastException = e;\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    try {\n<line3>        data = zk.getData(reportsNode + '/' + name, false, stat);\n<line4>        if (LOG.isDebugEnabled()) {\n<line5>            LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n<line6>        }\n<line7>        lastException = null;\n<line8>        break;\n<line9>    } catch (ConnectionLossException e) {\n<line10>        lastException = e;\n<line11>    } catch (NoNodeException e) {\n<line12>        final Object eventObj = new Object();\n<line13>        synchronized (eventObj) {\n<line14>            // wait for the node to appear\n<line15>            Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n<line16>\n<line17>                public void process(WatchedEvent event) {\n<line18>                    synchronized (eventObj) {\n<line19>                        eventObj.notifyAll();\n<line20>                    }\n<line21>                }\n<line22>            });\n<line23>            if (eStat == null) {\n<line24>                eventObj.wait(endTime - Time.currentElapsedTime());\n<line25>            }\n<line26>        }\n<line27>        lastException = e;\n<line28>    }\n<line29>}"},{"input":"","instruction":"<line1>{\n<line2>    data = zk.getData(reportsNode + '/' + name, false, stat);\n<line3>    }\n<line4>    lastException = null;\n<line5>    break;\n<line6>}","output":"<line1>{\n<line2>    data = zk.getData(reportsNode + '/' + name, false, stat);\n<line3>    if (LOG.isDebugEnabled()) {\n<line4>        LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n<line5>    }\n<line6>    lastException = null;\n<line7>    break;\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    configureServers(serverCount);\n<line3>    configureClients(clientCount, SimpleClient.class, getHostPort());\n<line4>    Stat stat = new Stat();\n<line5>    startServers();\n<line6>    ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n<line7>    waitForConnect(zk, 10000);\n<line8>    zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line9>    startClients();\n<line10>    // Check that all clients connect properly\n<line11>    for (int i = 0; i < getClientCount(); i++) {\n<line12>        for (int j = 0; j < maxTries; j++) {\n<line13>            try {\n<line14>                byte[] b = zk.getData(\"/simpleCase/\" + i, false, stat);\n<line15>                Assert.assertEquals(\"orig\", new String(b));\n<line16>            } catch (NoNodeException e) {\n<line17>                if (j + 1 == maxTries) {\n<line18>                    Assert.fail(\"Max tries exceeded on client \" + i);\n<line19>                }\n<line20>                Thread.sleep(1000);\n<line21>            }\n<line22>        }\n<line23>    }\n<line24>    // Kill half the servers, make a change, restart the dead\n<line25>    // servers, and then bounce the other servers one by one\n<line26>    for (int i = 0; i < getServerCount(); i++) {\n<line27>        stopServer(i);\n<line28>        if (i + 1 > getServerCount() / 2) {\n<line29>            startServer(i);\n<line30>        } else if (i + 1 == getServerCount() / 2) {\n<line31>            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line32>            try {\n<line33>                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line34>            } catch (ConnectionLossException e) {\n<line35>                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line36>                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line37>            }\n<line38>            for (int j = 0; j < i; j++) {\n<line39>                startServer(i);\n<line40>            }\n<line41>        }\n<line42>    }\n<line43>    // wait for things to stabilize\n<line44>    Thread.sleep(100);\n<line45>    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n<line46>    try {\n<line47>        zk.getData(\"/simpleCase\", false, stat);\n<line48>    } catch (ConnectionLossException e) {\n<line49>        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n<line50>    }\n<line51>    // check that the change has propagated to everyone\n<line52>    for (int i = 0; i < getClientCount(); i++) {\n<line53>        for (int j = 0; j < maxTries; j++) {\n<line54>            byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n<line55>            if (new String(data).equals(\"new\")) {\n<line56>                break;\n<line57>            }\n<line58>            if (j + 1 == maxTries) {\n<line59>                Assert.fail(\"max tries exceeded for \" + i);\n<line60>            }\n<line61>            Thread.sleep(1000);\n<line62>        }\n<line63>    }\n<line64>    // send out the kill signal\n<line65>    zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n<line66>    // watch for everyone to die\n<line67>    for (int i = 0; i < getClientCount(); i++) {\n<line68>        try {\n<line69>            for (int j = 0; j < maxTries; j++) {\n<line70>                zk.getData(\"/simpleCase/\" + i, false, stat);\n<line71>                if (j + 1 == maxTries) {\n<line72>                    Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n<line73>                }\n<line74>                Thread.sleep(200);\n<line75>            }\n<line76>        } catch (NoNodeException e) {\n<line77>            // Great this is what we were hoping for!\n<line78>        }\n<line79>    }\n<line80>    stopClients();\n<line81>    stopServers();\n<line82>}","output":"<line1>{\n<line2>    configureServers(serverCount);\n<line3>    configureClients(clientCount, SimpleClient.class, getHostPort());\n<line4>    Stat stat = new Stat();\n<line5>    startServers();\n<line6>    LOG.debug(\"Connecting to \" + getHostPort());\n<line7>    ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n<line8>    waitForConnect(zk, 10000);\n<line9>    zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n<line10>    startClients();\n<line11>    // Check that all clients connect properly\n<line12>    for (int i = 0; i < getClientCount(); i++) {\n<line13>        for (int j = 0; j < maxTries; j++) {\n<line14>            try {\n<line15>                byte[] b = zk.getData(\"/simpleCase/\" + i, false, stat);\n<line16>                Assert.assertEquals(\"orig\", new String(b));\n<line17>            } catch (NoNodeException e) {\n<line18>                if (j + 1 == maxTries) {\n<line19>                    Assert.fail(\"Max tries exceeded on client \" + i);\n<line20>                }\n<line21>                Thread.sleep(1000);\n<line22>            }\n<line23>        }\n<line24>    }\n<line25>    // Kill half the servers, make a change, restart the dead\n<line26>    // servers, and then bounce the other servers one by one\n<line27>    for (int i = 0; i < getServerCount(); i++) {\n<line28>        stopServer(i);\n<line29>        if (i + 1 > getServerCount() / 2) {\n<line30>            startServer(i);\n<line31>        } else if (i + 1 == getServerCount() / 2) {\n<line32>            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line33>            try {\n<line34>                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line35>            } catch (ConnectionLossException e) {\n<line36>                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line37>                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line38>            }\n<line39>            for (int j = 0; j < i; j++) {\n<line40>                LOG.info(\"Starting server \" + j);\n<line41>                startServer(i);\n<line42>            }\n<line43>        }\n<line44>    }\n<line45>    // wait for things to stabilize\n<line46>    Thread.sleep(100);\n<line47>    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n<line48>    try {\n<line49>        zk.getData(\"/simpleCase\", false, stat);\n<line50>    } catch (ConnectionLossException e) {\n<line51>        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n<line52>    }\n<line53>    // check that the change has propagated to everyone\n<line54>    for (int i = 0; i < getClientCount(); i++) {\n<line55>        for (int j = 0; j < maxTries; j++) {\n<line56>            byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n<line57>            if (new String(data).equals(\"new\")) {\n<line58>                break;\n<line59>            }\n<line60>            if (j + 1 == maxTries) {\n<line61>                Assert.fail(\"max tries exceeded for \" + i);\n<line62>            }\n<line63>            Thread.sleep(1000);\n<line64>        }\n<line65>    }\n<line66>    // send out the kill signal\n<line67>    zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n<line68>    // watch for everyone to die\n<line69>    for (int i = 0; i < getClientCount(); i++) {\n<line70>        try {\n<line71>            for (int j = 0; j < maxTries; j++) {\n<line72>                zk.getData(\"/simpleCase/\" + i, false, stat);\n<line73>                if (j + 1 == maxTries) {\n<line74>                    Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n<line75>                }\n<line76>                Thread.sleep(200);\n<line77>            }\n<line78>        } catch (NoNodeException e) {\n<line79>            // Great this is what we were hoping for!\n<line80>        }\n<line81>    }\n<line82>    stopClients();\n<line83>    stopServers();\n<line84>}"},{"input":"","instruction":"<line1>{\n<line2>    stopServer(i);\n<line3>    if (i + 1 > getServerCount() / 2) {\n<line4>        startServer(i);\n<line5>    } else if (i + 1 == getServerCount() / 2) {\n<line6>        Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line7>        try {\n<line8>            zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line9>        } catch (ConnectionLossException e) {\n<line10>            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line11>            zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line12>        }\n<line13>        for (int j = 0; j < i; j++) {\n<line14>            startServer(i);\n<line15>        }\n<line16>    }\n<line17>}","output":"<line1>{\n<line2>    stopServer(i);\n<line3>    if (i + 1 > getServerCount() / 2) {\n<line4>        startServer(i);\n<line5>    } else if (i + 1 == getServerCount() / 2) {\n<line6>        Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line7>        try {\n<line8>            zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line9>        } catch (ConnectionLossException e) {\n<line10>            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line11>            zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line12>        }\n<line13>        for (int j = 0; j < i; j++) {\n<line14>            LOG.info(\"Starting server \" + j);\n<line15>            startServer(i);\n<line16>        }\n<line17>    }\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line3>    try {\n<line4>        zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line5>    } catch (ConnectionLossException e) {\n<line6>        Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line7>        zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line8>    }\n<line9>    for (int j = 0; j < i; j++) {\n<line10>        startServer(i);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line3>    try {\n<line4>        zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line5>    } catch (ConnectionLossException e) {\n<line6>        Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n<line7>        zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n<line8>    }\n<line9>    for (int j = 0; j < i; j++) {\n<line10>        LOG.info(\"Starting server \" + j);\n<line11>        startServer(i);\n<line12>    }\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    startServer(i);\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Starting server \" + j);\n<line3>    startServer(i);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (KeeperState.Expired == event.getState()) {\n<line3>        // It's all over\n<line4>        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line5>    }\n<line6>    if (event.getPath() != null && event.getPath().equals(assignmentsNode)) {\n<line7>        // children have changed, so read in the new list\n<line8>        zk.getChildren(assignmentsNode, true, this, null);\n<line9>    }\n<line10>}","output":"<line1>{\n<line2>    if (KeeperState.Expired == event.getState()) {\n<line3>        // It's all over\n<line4>        LOG.error(\"Lost session\");\n<line5>        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line6>    }\n<line7>    if (event.getPath() != null && event.getPath().equals(assignmentsNode)) {\n<line8>        // children have changed, so read in the new list\n<line9>        zk.getChildren(assignmentsNode, true, this, null);\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    // It's all over\n<line3>    System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line4>}","output":"<line1>{\n<line2>    // It's all over\n<line3>    LOG.error(\"Lost session\");\n<line4>    System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (clientAddr == null) {\n<line3>        String[] parts = params.split(\" \");\n<line4>        // The first time we are configured, it is just to tell\n<line5>        // us which machine we are\n<line6>        serverId = Integer.parseInt(parts[0]);\n<line7>        }\n<line8>        if (parts.length > 1 && parts[1].equals(\"false\")) {\n<line9>            System.setProperty(\"zookeeper.leaderServes\", \"no\");\n<line10>        } else {\n<line11>            System.setProperty(\"zookeeper.leaderServes\", \"yes\");\n<line12>        }\n<line13>        // Let's grab two ports\n<line14>        try {\n<line15>            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line16>            clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line17>            ss.close();\n<line18>        } catch (IOException e) {\n<line19>            e.printStackTrace();\n<line20>        }\n<line21>        try {\n<line22>            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line23>            quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line24>            ss.close();\n<line25>        } catch (IOException e) {\n<line26>            e.printStackTrace();\n<line27>        }\n<line28>        try {\n<line29>            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line30>            quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line31>            ss.close();\n<line32>        } catch (IOException e) {\n<line33>            e.printStackTrace();\n<line34>        }\n<line35>        String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();\n<line36>        try {\n<line37>            }\n<line38>            r.report(report);\n<line39>        } catch (Exception e) {\n<line40>            e.printStackTrace();\n<line41>        }\n<line42>        return;\n<line43>    } else {\n<line44>        int spaceIndex = params.indexOf(' ');\n<line45>        if (spaceIndex == -1) {\n<line46>            return;\n<line47>        }\n<line48>        String quorumSpecs = params.substring(0, spaceIndex);\n<line49>        String cmd = params.substring(spaceIndex + 1);\n<line50>        }\n<line51>        if (!cmd.equals(\"start\")) {\n<line52>            if (peer != null) {\n<line53>                peer.shutdown();\n<line54>            }\n<line55>            peer = null;\n<line56>            try {\n<line57>                for (int i = 0; i < 5; i++) {\n<line58>                    Thread.sleep(500);\n<line59>                    try {\n<line60>                        // Wait until we can't connect\n<line61>                        new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line62>                    } catch (IOException e) {\n<line63>                        break;\n<line64>                    }\n<line65>                }\n<line66>                r.report(\"stopped\");\n<line67>            } catch (Exception e) {\n<line68>            }\n<line69>            return;\n<line70>        }\n<line71>        String[] parts = quorumSpecs.split(\",\");\n<line72>        peers = new HashMap<Long, QuorumServer>();\n<line73>        for (int i = 0; i < parts.length; i++) {\n<line74>            // parts[i] == \"host:leaderPort:leaderElectionPort;clientPort\"\n<line75>            String[] subparts = ((parts[i].split(\";\"))[0]).split(\":\");\n<line76>            String clientPort = (parts[i].split(\";\"))[1];\n<line77>            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));\n<line78>        }\n<line79>        try {\n<line80>            }\n<line81>            if (peer != null) {\n<line82>                return;\n<line83>            }\n<line84>            System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n<line85>            peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line86>            peer.start();\n<line87>            for (int i = 0; i < 5; i++) {\n<line88>                Thread.sleep(500);\n<line89>                try {\n<line90>                    // Wait until we can connect\n<line91>                    new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line92>                    break;\n<line93>                } catch (IOException e) {\n<line94>                }\n<line95>            }\n<line96>            r.report(\"started\");\n<line97>        } catch (Exception e) {\n<line98>        }\n<line99>    }\n<line100>}","output":"<line1>{\n<line2>    if (clientAddr == null) {\n<line3>        String[] parts = params.split(\" \");\n<line4>        // The first time we are configured, it is just to tell\n<line5>        // us which machine we are\n<line6>        serverId = Integer.parseInt(parts[0]);\n<line7>        if (LOG.isDebugEnabled()) {\n<line8>            LOG.debug(\"Setting up server \" + serverId);\n<line9>        }\n<line10>        if (parts.length > 1 && parts[1].equals(\"false\")) {\n<line11>            System.setProperty(\"zookeeper.leaderServes\", \"no\");\n<line12>        } else {\n<line13>            System.setProperty(\"zookeeper.leaderServes\", \"yes\");\n<line14>        }\n<line15>        // Let's grab two ports\n<line16>        try {\n<line17>            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line18>            clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line19>            ss.close();\n<line20>        } catch (IOException e) {\n<line21>            e.printStackTrace();\n<line22>        }\n<line23>        try {\n<line24>            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line25>            quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line26>            ss.close();\n<line27>        } catch (IOException e) {\n<line28>            e.printStackTrace();\n<line29>        }\n<line30>        try {\n<line31>            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line32>            quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line33>            ss.close();\n<line34>        } catch (IOException e) {\n<line35>            e.printStackTrace();\n<line36>        }\n<line37>        String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();\n<line38>        try {\n<line39>            if (LOG.isDebugEnabled()) {\n<line40>                LOG.debug(\"Reporting \" + report);\n<line41>            }\n<line42>            r.report(report);\n<line43>        } catch (Exception e) {\n<line44>            e.printStackTrace();\n<line45>        }\n<line46>        return;\n<line47>    } else {\n<line48>        int spaceIndex = params.indexOf(' ');\n<line49>        if (spaceIndex == -1) {\n<line50>            LOG.warn(\"looking for host:port,... start|stop, but found \" + params);\n<line51>            return;\n<line52>        }\n<line53>        String quorumSpecs = params.substring(0, spaceIndex);\n<line54>        String cmd = params.substring(spaceIndex + 1);\n<line55>        if (LOG.isDebugEnabled()) {\n<line56>            LOG.debug(\"Running command: \" + cmd);\n<line57>        }\n<line58>        if (!cmd.equals(\"start\")) {\n<line59>            if (peer != null) {\n<line60>                peer.shutdown();\n<line61>            }\n<line62>            peer = null;\n<line63>            try {\n<line64>                for (int i = 0; i < 5; i++) {\n<line65>                    Thread.sleep(500);\n<line66>                    try {\n<line67>                        // Wait until we can't connect\n<line68>                        new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line69>                    } catch (IOException e) {\n<line70>                        break;\n<line71>                    }\n<line72>                }\n<line73>                r.report(\"stopped\");\n<line74>            } catch (Exception e) {\n<line75>                LOG.error(\"Unhandled error\", e);\n<line76>            }\n<line77>            return;\n<line78>        }\n<line79>        String[] parts = quorumSpecs.split(\",\");\n<line80>        peers = new HashMap<Long, QuorumServer>();\n<line81>        for (int i = 0; i < parts.length; i++) {\n<line82>            // parts[i] == \"host:leaderPort:leaderElectionPort;clientPort\"\n<line83>            String[] subparts = ((parts[i].split(\";\"))[0]).split(\":\");\n<line84>            String clientPort = (parts[i].split(\";\"))[1];\n<line85>            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));\n<line86>        }\n<line87>        try {\n<line88>            if (LOG.isDebugEnabled()) {\n<line89>                LOG.debug(\"Starting quorumPeer \" + serverId + \" on port \" + clientAddr.getPort());\n<line90>            }\n<line91>            if (peer != null) {\n<line92>                LOG.warn(\"Peer \" + serverId + \" already started\");\n<line93>                return;\n<line94>            }\n<line95>            System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n<line96>            peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line97>            peer.start();\n<line98>            for (int i = 0; i < 5; i++) {\n<line99>                Thread.sleep(500);\n<line100>                try {\n<line101>                    // Wait until we can connect\n<line102>                    new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line103>                    break;\n<line104>                } catch (IOException e) {\n<line105>                }\n<line106>            }\n<line107>            r.report(\"started\");\n<line108>        } catch (Exception e) {\n<line109>            LOG.error(\"Unhandled exception\", e);\n<line110>        }\n<line111>    }\n<line112>}"},{"input":"","instruction":"<line1>{\n<line2>    String[] parts = params.split(\" \");\n<line3>    // The first time we are configured, it is just to tell\n<line4>    // us which machine we are\n<line5>    serverId = Integer.parseInt(parts[0]);\n<line6>    }\n<line7>    if (parts.length > 1 && parts[1].equals(\"false\")) {\n<line8>        System.setProperty(\"zookeeper.leaderServes\", \"no\");\n<line9>    } else {\n<line10>        System.setProperty(\"zookeeper.leaderServes\", \"yes\");\n<line11>    }\n<line12>    // Let's grab two ports\n<line13>    try {\n<line14>        ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line15>        clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line16>        ss.close();\n<line17>    } catch (IOException e) {\n<line18>        e.printStackTrace();\n<line19>    }\n<line20>    try {\n<line21>        ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line22>        quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line23>        ss.close();\n<line24>    } catch (IOException e) {\n<line25>        e.printStackTrace();\n<line26>    }\n<line27>    try {\n<line28>        ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line29>        quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line30>        ss.close();\n<line31>    } catch (IOException e) {\n<line32>        e.printStackTrace();\n<line33>    }\n<line34>    String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();\n<line35>    try {\n<line36>        }\n<line37>        r.report(report);\n<line38>    } catch (Exception e) {\n<line39>        e.printStackTrace();\n<line40>    }\n<line41>    return;\n<line42>}","output":"<line1>{\n<line2>    String[] parts = params.split(\" \");\n<line3>    // The first time we are configured, it is just to tell\n<line4>    // us which machine we are\n<line5>    serverId = Integer.parseInt(parts[0]);\n<line6>    if (LOG.isDebugEnabled()) {\n<line7>        LOG.debug(\"Setting up server \" + serverId);\n<line8>    }\n<line9>    if (parts.length > 1 && parts[1].equals(\"false\")) {\n<line10>        System.setProperty(\"zookeeper.leaderServes\", \"no\");\n<line11>    } else {\n<line12>        System.setProperty(\"zookeeper.leaderServes\", \"yes\");\n<line13>    }\n<line14>    // Let's grab two ports\n<line15>    try {\n<line16>        ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line17>        clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line18>        ss.close();\n<line19>    } catch (IOException e) {\n<line20>        e.printStackTrace();\n<line21>    }\n<line22>    try {\n<line23>        ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line24>        quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line25>        ss.close();\n<line26>    } catch (IOException e) {\n<line27>        e.printStackTrace();\n<line28>    }\n<line29>    try {\n<line30>        ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());\n<line31>        quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();\n<line32>        ss.close();\n<line33>    } catch (IOException e) {\n<line34>        e.printStackTrace();\n<line35>    }\n<line36>    String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();\n<line37>    try {\n<line38>        if (LOG.isDebugEnabled()) {\n<line39>            LOG.debug(\"Reporting \" + report);\n<line40>        }\n<line41>        r.report(report);\n<line42>    } catch (Exception e) {\n<line43>        e.printStackTrace();\n<line44>    }\n<line45>    return;\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Setting up server \" + serverId);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    r.report(report);\n<line4>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Reporting \" + report);\n<line4>    }\n<line5>    r.report(report);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Reporting \" + report);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    int spaceIndex = params.indexOf(' ');\n<line3>    if (spaceIndex == -1) {\n<line4>        return;\n<line5>    }\n<line6>    String quorumSpecs = params.substring(0, spaceIndex);\n<line7>    String cmd = params.substring(spaceIndex + 1);\n<line8>    }\n<line9>    if (!cmd.equals(\"start\")) {\n<line10>        if (peer != null) {\n<line11>            peer.shutdown();\n<line12>        }\n<line13>        peer = null;\n<line14>        try {\n<line15>            for (int i = 0; i < 5; i++) {\n<line16>                Thread.sleep(500);\n<line17>                try {\n<line18>                    // Wait until we can't connect\n<line19>                    new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line20>                } catch (IOException e) {\n<line21>                    break;\n<line22>                }\n<line23>            }\n<line24>            r.report(\"stopped\");\n<line25>        } catch (Exception e) {\n<line26>        }\n<line27>        return;\n<line28>    }\n<line29>    String[] parts = quorumSpecs.split(\",\");\n<line30>    peers = new HashMap<Long, QuorumServer>();\n<line31>    for (int i = 0; i < parts.length; i++) {\n<line32>        // parts[i] == \"host:leaderPort:leaderElectionPort;clientPort\"\n<line33>        String[] subparts = ((parts[i].split(\";\"))[0]).split(\":\");\n<line34>        String clientPort = (parts[i].split(\";\"))[1];\n<line35>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));\n<line36>    }\n<line37>    try {\n<line38>        }\n<line39>        if (peer != null) {\n<line40>            return;\n<line41>        }\n<line42>        System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n<line43>        peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line44>        peer.start();\n<line45>        for (int i = 0; i < 5; i++) {\n<line46>            Thread.sleep(500);\n<line47>            try {\n<line48>                // Wait until we can connect\n<line49>                new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line50>                break;\n<line51>            } catch (IOException e) {\n<line52>            }\n<line53>        }\n<line54>        r.report(\"started\");\n<line55>    } catch (Exception e) {\n<line56>    }\n<line57>}","output":"<line1>{\n<line2>    int spaceIndex = params.indexOf(' ');\n<line3>    if (spaceIndex == -1) {\n<line4>        LOG.warn(\"looking for host:port,... start|stop, but found \" + params);\n<line5>        return;\n<line6>    }\n<line7>    String quorumSpecs = params.substring(0, spaceIndex);\n<line8>    String cmd = params.substring(spaceIndex + 1);\n<line9>    if (LOG.isDebugEnabled()) {\n<line10>        LOG.debug(\"Running command: \" + cmd);\n<line11>    }\n<line12>    if (!cmd.equals(\"start\")) {\n<line13>        if (peer != null) {\n<line14>            peer.shutdown();\n<line15>        }\n<line16>        peer = null;\n<line17>        try {\n<line18>            for (int i = 0; i < 5; i++) {\n<line19>                Thread.sleep(500);\n<line20>                try {\n<line21>                    // Wait until we can't connect\n<line22>                    new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line23>                } catch (IOException e) {\n<line24>                    break;\n<line25>                }\n<line26>            }\n<line27>            r.report(\"stopped\");\n<line28>        } catch (Exception e) {\n<line29>            LOG.error(\"Unhandled error\", e);\n<line30>        }\n<line31>        return;\n<line32>    }\n<line33>    String[] parts = quorumSpecs.split(\",\");\n<line34>    peers = new HashMap<Long, QuorumServer>();\n<line35>    for (int i = 0; i < parts.length; i++) {\n<line36>        // parts[i] == \"host:leaderPort:leaderElectionPort;clientPort\"\n<line37>        String[] subparts = ((parts[i].split(\";\"))[0]).split(\":\");\n<line38>        String clientPort = (parts[i].split(\";\"))[1];\n<line39>        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));\n<line40>    }\n<line41>    try {\n<line42>        if (LOG.isDebugEnabled()) {\n<line43>            LOG.debug(\"Starting quorumPeer \" + serverId + \" on port \" + clientAddr.getPort());\n<line44>        }\n<line45>        if (peer != null) {\n<line46>            LOG.warn(\"Peer \" + serverId + \" already started\");\n<line47>            return;\n<line48>        }\n<line49>        System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n<line50>        peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line51>        peer.start();\n<line52>        for (int i = 0; i < 5; i++) {\n<line53>            Thread.sleep(500);\n<line54>            try {\n<line55>                // Wait until we can connect\n<line56>                new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line57>                break;\n<line58>            } catch (IOException e) {\n<line59>            }\n<line60>        }\n<line61>        r.report(\"started\");\n<line62>    } catch (Exception e) {\n<line63>        LOG.error(\"Unhandled exception\", e);\n<line64>    }\n<line65>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Running command: \" + cmd);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (peer != null) {\n<line3>        peer.shutdown();\n<line4>    }\n<line5>    peer = null;\n<line6>    try {\n<line7>        for (int i = 0; i < 5; i++) {\n<line8>            Thread.sleep(500);\n<line9>            try {\n<line10>                // Wait until we can't connect\n<line11>                new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line12>            } catch (IOException e) {\n<line13>                break;\n<line14>            }\n<line15>        }\n<line16>        r.report(\"stopped\");\n<line17>    } catch (Exception e) {\n<line18>    }\n<line19>    return;\n<line20>}","output":"<line1>{\n<line2>    if (peer != null) {\n<line3>        peer.shutdown();\n<line4>    }\n<line5>    peer = null;\n<line6>    try {\n<line7>        for (int i = 0; i < 5; i++) {\n<line8>            Thread.sleep(500);\n<line9>            try {\n<line10>                // Wait until we can't connect\n<line11>                new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line12>            } catch (IOException e) {\n<line13>                break;\n<line14>            }\n<line15>        }\n<line16>        r.report(\"stopped\");\n<line17>    } catch (Exception e) {\n<line18>        LOG.error(\"Unhandled error\", e);\n<line19>    }\n<line20>    return;\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unhandled error\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    if (peer != null) {\n<line4>        return;\n<line5>    }\n<line6>    System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n<line7>    peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line8>    peer.start();\n<line9>    for (int i = 0; i < 5; i++) {\n<line10>        Thread.sleep(500);\n<line11>        try {\n<line12>            // Wait until we can connect\n<line13>            new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line14>            break;\n<line15>        } catch (IOException e) {\n<line16>        }\n<line17>    }\n<line18>    r.report(\"started\");\n<line19>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Starting quorumPeer \" + serverId + \" on port \" + clientAddr.getPort());\n<line4>    }\n<line5>    if (peer != null) {\n<line6>        LOG.warn(\"Peer \" + serverId + \" already started\");\n<line7>        return;\n<line8>    }\n<line9>    System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n<line10>    peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n<line11>    peer.start();\n<line12>    for (int i = 0; i < 5; i++) {\n<line13>        Thread.sleep(500);\n<line14>        try {\n<line15>            // Wait until we can connect\n<line16>            new Socket(\"127.0.0.1\", clientAddr.getPort()).close();\n<line17>            break;\n<line18>        } catch (IOException e) {\n<line19>        }\n<line20>    }\n<line21>    r.report(\"started\");\n<line22>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Starting quorumPeer \" + serverId + \" on port \" + clientAddr.getPort());\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Unhandled exception\", e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    }\n<line3>    if (peer != null) {\n<line4>        peer.shutdown();\n<line5>    }\n<line6>    if (logDir != null) {\n<line7>        TestUtils.deleteFileRecursively(logDir);\n<line8>    }\n<line9>    if (snapDir != null) {\n<line10>        TestUtils.deleteFileRecursively(snapDir);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    if (LOG.isDebugEnabled()) {\n<line3>        LOG.debug(\"Stopping peer \" + serverId);\n<line4>    }\n<line5>    if (peer != null) {\n<line6>        peer.shutdown();\n<line7>    }\n<line8>    if (logDir != null) {\n<line9>        TestUtils.deleteFileRecursively(logDir);\n<line10>    }\n<line11>    if (snapDir != null) {\n<line12>        TestUtils.deleteFileRecursively(snapDir);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.debug(\"Stopping peer \" + serverId);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    latch.countDown();\n<line3>}","output":"<line1>{\n<line2>    LOG.debug(\"Watcher fired: {}\", event);\n<line3>    latch.countDown();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    state = State.START;\n<line3>    dispatchEvent(EventType.START);\n<line4>    if (zooKeeper == null) {\n<line5>        throw new IllegalStateException(\"No instance of zookeeper provided. Hint: use setZooKeeper()\");\n<line6>    }\n<line7>    if (hostName == null) {\n<line8>        throw new IllegalStateException(\"No hostname provided. Hint: use setHostName()\");\n<line9>    }\n<line10>    try {\n<line11>        makeOffer();\n<line12>        determineElectionStatus();\n<line13>    } catch (KeeperException | InterruptedException e) {\n<line14>        becomeFailed(e);\n<line15>    }\n<line16>}","output":"<line1>{\n<line2>    state = State.START;\n<line3>    dispatchEvent(EventType.START);\n<line4>    LOG.info(\"Starting leader election support\");\n<line5>    if (zooKeeper == null) {\n<line6>        throw new IllegalStateException(\"No instance of zookeeper provided. Hint: use setZooKeeper()\");\n<line7>    }\n<line8>    if (hostName == null) {\n<line9>        throw new IllegalStateException(\"No hostname provided. Hint: use setHostName()\");\n<line10>    }\n<line11>    try {\n<line12>        makeOffer();\n<line13>        determineElectionStatus();\n<line14>    } catch (KeeperException | InterruptedException e) {\n<line15>        becomeFailed(e);\n<line16>    }\n<line17>}"},{"input":"","instruction":"<line1>{\n<line2>    state = State.STOP;\n<line3>    dispatchEvent(EventType.STOP_START);\n<line4>    if (leaderOffer != null) {\n<line5>        try {\n<line6>            zooKeeper.delete(leaderOffer.getNodePath(), -1);\n<line7>        } catch (InterruptedException | KeeperException e) {\n<line8>            becomeFailed(e);\n<line9>        }\n<line10>    }\n<line11>    dispatchEvent(EventType.STOP_COMPLETE);\n<line12>}","output":"<line1>{\n<line2>    state = State.STOP;\n<line3>    dispatchEvent(EventType.STOP_START);\n<line4>    LOG.info(\"Stopping leader election support\");\n<line5>    if (leaderOffer != null) {\n<line6>        try {\n<line7>            zooKeeper.delete(leaderOffer.getNodePath(), -1);\n<line8>            LOG.info(\"Removed leader offer {}\", leaderOffer.getNodePath());\n<line9>        } catch (InterruptedException | KeeperException e) {\n<line10>            becomeFailed(e);\n<line11>        }\n<line12>    }\n<line13>    dispatchEvent(EventType.STOP_COMPLETE);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        zooKeeper.delete(leaderOffer.getNodePath(), -1);\n<line4>    } catch (InterruptedException | KeeperException e) {\n<line5>        becomeFailed(e);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    try {\n<line3>        zooKeeper.delete(leaderOffer.getNodePath(), -1);\n<line4>        LOG.info(\"Removed leader offer {}\", leaderOffer.getNodePath());\n<line5>    } catch (InterruptedException | KeeperException e) {\n<line6>        becomeFailed(e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    zooKeeper.delete(leaderOffer.getNodePath(), -1);\n<line3>}","output":"<line1>{\n<line2>    zooKeeper.delete(leaderOffer.getNodePath(), -1);\n<line3>    LOG.info(\"Removed leader offer {}\", leaderOffer.getNodePath());\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    state = State.OFFER;\n<line3>    dispatchEvent(EventType.OFFER_START);\n<line4>    LeaderOffer newLeaderOffer = new LeaderOffer();\n<line5>    byte[] hostnameBytes;\n<line6>    synchronized (this) {\n<line7>        newLeaderOffer.setHostName(hostName);\n<line8>        hostnameBytes = hostName.getBytes();\n<line9>        newLeaderOffer.setNodePath(zooKeeper.create(rootNodeName + \"/\" + \"n_\", hostnameBytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL));\n<line10>        leaderOffer = newLeaderOffer;\n<line11>    }\n<line12>    dispatchEvent(EventType.OFFER_COMPLETE);\n<line13>}","output":"<line1>{\n<line2>    state = State.OFFER;\n<line3>    dispatchEvent(EventType.OFFER_START);\n<line4>    LeaderOffer newLeaderOffer = new LeaderOffer();\n<line5>    byte[] hostnameBytes;\n<line6>    synchronized (this) {\n<line7>        newLeaderOffer.setHostName(hostName);\n<line8>        hostnameBytes = hostName.getBytes();\n<line9>        newLeaderOffer.setNodePath(zooKeeper.create(rootNodeName + \"/\" + \"n_\", hostnameBytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL));\n<line10>        leaderOffer = newLeaderOffer;\n<line11>    }\n<line12>    LOG.debug(\"Created leader offer {}\", leaderOffer);\n<line13>    dispatchEvent(EventType.OFFER_COMPLETE);\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    state = State.DETERMINE;\n<line3>    dispatchEvent(EventType.DETERMINE_START);\n<line4>    LeaderOffer currentLeaderOffer = getLeaderOffer();\n<line5>    String[] components = currentLeaderOffer.getNodePath().split(\"/\");\n<line6>    currentLeaderOffer.setId(Integer.valueOf(components[components.length - 1].substring(\"n_\".length())));\n<line7>    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));\n<line8>    /*\n<line9>         * For each leader offer, find out where we fit in. If we're first, we\n<line10>         * become the leader. If we're not elected the leader, attempt to stat the\n<line11>         * offer just less than us. If they exist, watch for their failure, but if\n<line12>         * they don't, become the leader.\n<line13>         */\n<line14>    for (int i = 0; i < leaderOffers.size(); i++) {\n<line15>        LeaderOffer leaderOffer = leaderOffers.get(i);\n<line16>        if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {\n<line17>            dispatchEvent(EventType.DETERMINE_COMPLETE);\n<line18>            if (i == 0) {\n<line19>                becomeLeader();\n<line20>            } else {\n<line21>                becomeReady(leaderOffers.get(i - 1));\n<line22>            }\n<line23>            /* Once we've figured out where we are, we're done. */\n<line24>            break;\n<line25>        }\n<line26>    }\n<line27>}","output":"<line1>{\n<line2>    state = State.DETERMINE;\n<line3>    dispatchEvent(EventType.DETERMINE_START);\n<line4>    LeaderOffer currentLeaderOffer = getLeaderOffer();\n<line5>    String[] components = currentLeaderOffer.getNodePath().split(\"/\");\n<line6>    currentLeaderOffer.setId(Integer.valueOf(components[components.length - 1].substring(\"n_\".length())));\n<line7>    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));\n<line8>    /*\n<line9>         * For each leader offer, find out where we fit in. If we're first, we\n<line10>         * become the leader. If we're not elected the leader, attempt to stat the\n<line11>         * offer just less than us. If they exist, watch for their failure, but if\n<line12>         * they don't, become the leader.\n<line13>         */\n<line14>    for (int i = 0; i < leaderOffers.size(); i++) {\n<line15>        LeaderOffer leaderOffer = leaderOffers.get(i);\n<line16>        if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {\n<line17>            LOG.debug(\"There are {} leader offers. I am {} in line.\", leaderOffers.size(), i);\n<line18>            dispatchEvent(EventType.DETERMINE_COMPLETE);\n<line19>            if (i == 0) {\n<line20>                becomeLeader();\n<line21>            } else {\n<line22>                becomeReady(leaderOffers.get(i - 1));\n<line23>            }\n<line24>            /* Once we've figured out where we are, we're done. */\n<line25>            break;\n<line26>        }\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    LeaderOffer leaderOffer = leaderOffers.get(i);\n<line3>    if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {\n<line4>        dispatchEvent(EventType.DETERMINE_COMPLETE);\n<line5>        if (i == 0) {\n<line6>            becomeLeader();\n<line7>        } else {\n<line8>            becomeReady(leaderOffers.get(i - 1));\n<line9>        }\n<line10>        /* Once we've figured out where we are, we're done. */\n<line11>        break;\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    LeaderOffer leaderOffer = leaderOffers.get(i);\n<line3>    if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {\n<line4>        LOG.debug(\"There are {} leader offers. I am {} in line.\", leaderOffers.size(), i);\n<line5>        dispatchEvent(EventType.DETERMINE_COMPLETE);\n<line6>        if (i == 0) {\n<line7>            becomeLeader();\n<line8>        } else {\n<line9>            becomeReady(leaderOffers.get(i - 1));\n<line10>        }\n<line11>        /* Once we've figured out where we are, we're done. */\n<line12>        break;\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    dispatchEvent(EventType.DETERMINE_COMPLETE);\n<line3>    if (i == 0) {\n<line4>        becomeLeader();\n<line5>    } else {\n<line6>        becomeReady(leaderOffers.get(i - 1));\n<line7>    }\n<line8>    /* Once we've figured out where we are, we're done. */\n<line9>    break;\n<line10>}","output":"<line1>{\n<line2>    LOG.debug(\"There are {} leader offers. I am {} in line.\", leaderOffers.size(), i);\n<line3>    dispatchEvent(EventType.DETERMINE_COMPLETE);\n<line4>    if (i == 0) {\n<line5>        becomeLeader();\n<line6>    } else {\n<line7>        becomeReady(leaderOffers.get(i - 1));\n<line8>    }\n<line9>    /* Once we've figured out where we are, we're done. */\n<line10>    break;\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>         * Make sure to pass an explicit Watcher because we could be sharing this\n<line4>         * zooKeeper instance with someone else.\n<line5>         */\n<line6>    Stat stat = zooKeeper.exists(neighborLeaderOffer.getNodePath(), this);\n<line7>    if (stat != null) {\n<line8>        dispatchEvent(EventType.READY_START);\n<line9>        state = State.READY;\n<line10>        dispatchEvent(EventType.READY_COMPLETE);\n<line11>    } else {\n<line12>        /*\n<line13>             * If the stat fails, the node has gone missing between the call to\n<line14>             * getChildren() and exists(). We need to try and become the leader.\n<line15>             */\n<line16>        determineElectionStatus();\n<line17>    }\n<line18>}","output":"<line1>{\n<line2>    LOG.info(\"{} not elected leader. Watching node: {}\", getLeaderOffer().getNodePath(), neighborLeaderOffer.getNodePath());\n<line3>    /*\n<line4>         * Make sure to pass an explicit Watcher because we could be sharing this\n<line5>         * zooKeeper instance with someone else.\n<line6>         */\n<line7>    Stat stat = zooKeeper.exists(neighborLeaderOffer.getNodePath(), this);\n<line8>    if (stat != null) {\n<line9>        dispatchEvent(EventType.READY_START);\n<line10>        LOG.debug(\"We're behind {} in line and they're alive. Keeping an eye on them.\", neighborLeaderOffer.getNodePath());\n<line11>        state = State.READY;\n<line12>        dispatchEvent(EventType.READY_COMPLETE);\n<line13>    } else {\n<line14>        /*\n<line15>             * If the stat fails, the node has gone missing between the call to\n<line16>             * getChildren() and exists(). We need to try and become the leader.\n<line17>             */\n<line18>        LOG.info(\"We were behind {} but it looks like they died. Back to determination.\", neighborLeaderOffer.getNodePath());\n<line19>        determineElectionStatus();\n<line20>    }\n<line21>}"},{"input":"","instruction":"<line1>{\n<line2>    dispatchEvent(EventType.READY_START);\n<line3>    state = State.READY;\n<line4>    dispatchEvent(EventType.READY_COMPLETE);\n<line5>}","output":"<line1>{\n<line2>    dispatchEvent(EventType.READY_START);\n<line3>    LOG.debug(\"We're behind {} in line and they're alive. Keeping an eye on them.\", neighborLeaderOffer.getNodePath());\n<line4>    state = State.READY;\n<line5>    dispatchEvent(EventType.READY_COMPLETE);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    /*\n<line3>             * If the stat fails, the node has gone missing between the call to\n<line4>             * getChildren() and exists(). We need to try and become the leader.\n<line5>             */\n<line6>    determineElectionStatus();\n<line7>}","output":"<line1>{\n<line2>    /*\n<line3>             * If the stat fails, the node has gone missing between the call to\n<line4>             * getChildren() and exists(). We need to try and become the leader.\n<line5>             */\n<line6>    LOG.info(\"We were behind {} but it looks like they died. Back to determination.\", neighborLeaderOffer.getNodePath());\n<line7>    determineElectionStatus();\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    state = State.ELECTED;\n<line3>    dispatchEvent(EventType.ELECTED_START);\n<line4>    dispatchEvent(EventType.ELECTED_COMPLETE);\n<line5>}","output":"<line1>{\n<line2>    state = State.ELECTED;\n<line3>    dispatchEvent(EventType.ELECTED_START);\n<line4>    LOG.info(\"Becoming leader with node: {}\", getLeaderOffer().getNodePath());\n<line5>    dispatchEvent(EventType.ELECTED_COMPLETE);\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    state = State.FAILED;\n<line3>    dispatchEvent(EventType.FAILED);\n<line4>}","output":"<line1>{\n<line2>    LOG.error(\"Failed in state {}\", state, e);\n<line3>    state = State.FAILED;\n<line4>    dispatchEvent(EventType.FAILED);\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    if (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) {\n<line3>        if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {\n<line4>            try {\n<line5>                determineElectionStatus();\n<line6>            } catch (KeeperException | InterruptedException e) {\n<line7>                becomeFailed(e);\n<line8>            }\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    if (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) {\n<line3>        if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {\n<line4>            LOG.debug(\"Node {} deleted. Need to run through the election process.\", event.getPath());\n<line5>            try {\n<line6>                determineElectionStatus();\n<line7>            } catch (KeeperException | InterruptedException e) {\n<line8>                becomeFailed(e);\n<line9>            }\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {\n<line3>        try {\n<line4>            determineElectionStatus();\n<line5>        } catch (KeeperException | InterruptedException e) {\n<line6>            becomeFailed(e);\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {\n<line3>        LOG.debug(\"Node {} deleted. Need to run through the election process.\", event.getPath());\n<line4>        try {\n<line5>            determineElectionStatus();\n<line6>        } catch (KeeperException | InterruptedException e) {\n<line7>            becomeFailed(e);\n<line8>        }\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        determineElectionStatus();\n<line4>    } catch (KeeperException | InterruptedException e) {\n<line5>        becomeFailed(e);\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    LOG.debug(\"Node {} deleted. Need to run through the election process.\", event.getPath());\n<line3>    try {\n<line4>        determineElectionStatus();\n<line5>    } catch (KeeperException | InterruptedException e) {\n<line6>        becomeFailed(e);\n<line7>    }\n<line8>}"},{"input":"","instruction":"<line1>{\n<line2>    synchronized (listeners) {\n<line3>        if (listeners.size() > 0) {\n<line4>            for (LeaderElectionAware observer : listeners) {\n<line5>                observer.onElectionEvent(eventType);\n<line6>            }\n<line7>        }\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    LOG.debug(\"Dispatching event: {}\", eventType);\n<line3>    synchronized (listeners) {\n<line4>        if (listeners.size() > 0) {\n<line5>            for (LeaderElectionAware observer : listeners) {\n<line6>                observer.onElectionEvent(eventType);\n<line7>            }\n<line8>        }\n<line9>    }\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    // lets either become the leader or watch the new/updated node\n<line3>    try {\n<line4>        lock();\n<line5>    } catch (Exception e) {\n<line6>    }\n<line7>}","output":"<line1>{\n<line2>    // lets either become the leader or watch the new/updated node\n<line3>    LOG.debug(\"Watcher fired: {}\", event);\n<line4>    try {\n<line5>        lock();\n<line6>    } catch (Exception e) {\n<line7>        LOG.warn(\"Failed to acquire lock\", e);\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    List<String> names = zookeeper.getChildren(dir, false);\n<line3>    for (String name : names) {\n<line4>        if (name.startsWith(prefix)) {\n<line5>            id = name;\n<line6>            break;\n<line7>        }\n<line8>    }\n<line9>    if (id == null) {\n<line10>        id = zookeeper.create(dir + \"/\" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    List<String> names = zookeeper.getChildren(dir, false);\n<line3>    for (String name : names) {\n<line4>        if (name.startsWith(prefix)) {\n<line5>            id = name;\n<line6>            LOG.debug(\"Found id created last time: {}\", id);\n<line7>            break;\n<line8>        }\n<line9>    }\n<line10>    if (id == null) {\n<line11>        id = zookeeper.create(dir + \"/\" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);\n<line12>        LOG.debug(\"Created id: {}\", id);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (name.startsWith(prefix)) {\n<line3>        id = name;\n<line4>        break;\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    if (name.startsWith(prefix)) {\n<line3>        id = name;\n<line4>        LOG.debug(\"Found id created last time: {}\", id);\n<line5>        break;\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    id = name;\n<line3>    break;\n<line4>}","output":"<line1>{\n<line2>    id = name;\n<line3>    LOG.debug(\"Found id created last time: {}\", id);\n<line4>    break;\n<line5>}"},{"input":"","instruction":"<line1>{\n<line2>    id = zookeeper.create(dir + \"/\" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);\n<line3>}","output":"<line1>{\n<line2>    id = zookeeper.create(dir + \"/\" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);\n<line3>    LOG.debug(\"Created id: {}\", id);\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    do {\n<line3>        if (id == null) {\n<line4>            long sessionId = zookeeper.getSessionId();\n<line5>            String prefix = \"x-\" + sessionId + \"-\";\n<line6>            // lets try look up the current ID if we failed\n<line7>            // in the middle of creating the znode\n<line8>            findPrefixInChildren(prefix, zookeeper, dir);\n<line9>            idName = new ZNodeName(id);\n<line10>        }\n<line11>        List<String> names = zookeeper.getChildren(dir, false);\n<line12>        if (names.isEmpty()) {\n<line13>            // lets force the recreation of the id\n<line14>            id = null;\n<line15>        } else {\n<line16>            // lets sort them explicitly (though they do seem to come back in order ususally :)\n<line17>            SortedSet<ZNodeName> sortedNames = new TreeSet<>();\n<line18>            for (String name : names) {\n<line19>                sortedNames.add(new ZNodeName(dir + \"/\" + name));\n<line20>            }\n<line21>            ownerId = sortedNames.first().getName();\n<line22>            SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);\n<line23>            if (!lessThanMe.isEmpty()) {\n<line24>                ZNodeName lastChildName = lessThanMe.last();\n<line25>                lastChildId = lastChildName.getName();\n<line26>                Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line27>                if (stat != null) {\n<line28>                    return Boolean.FALSE;\n<line29>                } else {\n<line30>                }\n<line31>            } else {\n<line32>                if (isOwner()) {\n<line33>                    LockListener lockListener = getLockListener();\n<line34>                    if (lockListener != null) {\n<line35>                        lockListener.lockAcquired();\n<line36>                    }\n<line37>                    return Boolean.TRUE;\n<line38>                }\n<line39>            }\n<line40>        }\n<line41>    } while (id == null);\n<line42>    return Boolean.FALSE;\n<line43>}","output":"<line1>{\n<line2>    do {\n<line3>        if (id == null) {\n<line4>            long sessionId = zookeeper.getSessionId();\n<line5>            String prefix = \"x-\" + sessionId + \"-\";\n<line6>            // lets try look up the current ID if we failed\n<line7>            // in the middle of creating the znode\n<line8>            findPrefixInChildren(prefix, zookeeper, dir);\n<line9>            idName = new ZNodeName(id);\n<line10>        }\n<line11>        List<String> names = zookeeper.getChildren(dir, false);\n<line12>        if (names.isEmpty()) {\n<line13>            LOG.warn(\"No children in: {} when we've just created one! Lets recreate it...\", dir);\n<line14>            // lets force the recreation of the id\n<line15>            id = null;\n<line16>        } else {\n<line17>            // lets sort them explicitly (though they do seem to come back in order ususally :)\n<line18>            SortedSet<ZNodeName> sortedNames = new TreeSet<>();\n<line19>            for (String name : names) {\n<line20>                sortedNames.add(new ZNodeName(dir + \"/\" + name));\n<line21>            }\n<line22>            ownerId = sortedNames.first().getName();\n<line23>            SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);\n<line24>            if (!lessThanMe.isEmpty()) {\n<line25>                ZNodeName lastChildName = lessThanMe.last();\n<line26>                lastChildId = lastChildName.getName();\n<line27>                LOG.debug(\"Watching less than me node: {}\", lastChildId);\n<line28>                Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line29>                if (stat != null) {\n<line30>                    return Boolean.FALSE;\n<line31>                } else {\n<line32>                    LOG.warn(\"Could not find the stats for less than me: {}\", lastChildName.getName());\n<line33>                }\n<line34>            } else {\n<line35>                if (isOwner()) {\n<line36>                    LockListener lockListener = getLockListener();\n<line37>                    if (lockListener != null) {\n<line38>                        lockListener.lockAcquired();\n<line39>                    }\n<line40>                    return Boolean.TRUE;\n<line41>                }\n<line42>            }\n<line43>        }\n<line44>    } while (id == null);\n<line45>    return Boolean.FALSE;\n<line46>}"},{"input":"","instruction":"<line1>{\n<line2>    if (id == null) {\n<line3>        long sessionId = zookeeper.getSessionId();\n<line4>        String prefix = \"x-\" + sessionId + \"-\";\n<line5>        // lets try look up the current ID if we failed\n<line6>        // in the middle of creating the znode\n<line7>        findPrefixInChildren(prefix, zookeeper, dir);\n<line8>        idName = new ZNodeName(id);\n<line9>    }\n<line10>    List<String> names = zookeeper.getChildren(dir, false);\n<line11>    if (names.isEmpty()) {\n<line12>        // lets force the recreation of the id\n<line13>        id = null;\n<line14>    } else {\n<line15>        // lets sort them explicitly (though they do seem to come back in order ususally :)\n<line16>        SortedSet<ZNodeName> sortedNames = new TreeSet<>();\n<line17>        for (String name : names) {\n<line18>            sortedNames.add(new ZNodeName(dir + \"/\" + name));\n<line19>        }\n<line20>        ownerId = sortedNames.first().getName();\n<line21>        SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);\n<line22>        if (!lessThanMe.isEmpty()) {\n<line23>            ZNodeName lastChildName = lessThanMe.last();\n<line24>            lastChildId = lastChildName.getName();\n<line25>            Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line26>            if (stat != null) {\n<line27>                return Boolean.FALSE;\n<line28>            } else {\n<line29>            }\n<line30>        } else {\n<line31>            if (isOwner()) {\n<line32>                LockListener lockListener = getLockListener();\n<line33>                if (lockListener != null) {\n<line34>                    lockListener.lockAcquired();\n<line35>                }\n<line36>                return Boolean.TRUE;\n<line37>            }\n<line38>        }\n<line39>    }\n<line40>}","output":"<line1>{\n<line2>    if (id == null) {\n<line3>        long sessionId = zookeeper.getSessionId();\n<line4>        String prefix = \"x-\" + sessionId + \"-\";\n<line5>        // lets try look up the current ID if we failed\n<line6>        // in the middle of creating the znode\n<line7>        findPrefixInChildren(prefix, zookeeper, dir);\n<line8>        idName = new ZNodeName(id);\n<line9>    }\n<line10>    List<String> names = zookeeper.getChildren(dir, false);\n<line11>    if (names.isEmpty()) {\n<line12>        LOG.warn(\"No children in: {} when we've just created one! Lets recreate it...\", dir);\n<line13>        // lets force the recreation of the id\n<line14>        id = null;\n<line15>    } else {\n<line16>        // lets sort them explicitly (though they do seem to come back in order ususally :)\n<line17>        SortedSet<ZNodeName> sortedNames = new TreeSet<>();\n<line18>        for (String name : names) {\n<line19>            sortedNames.add(new ZNodeName(dir + \"/\" + name));\n<line20>        }\n<line21>        ownerId = sortedNames.first().getName();\n<line22>        SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);\n<line23>        if (!lessThanMe.isEmpty()) {\n<line24>            ZNodeName lastChildName = lessThanMe.last();\n<line25>            lastChildId = lastChildName.getName();\n<line26>            LOG.debug(\"Watching less than me node: {}\", lastChildId);\n<line27>            Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line28>            if (stat != null) {\n<line29>                return Boolean.FALSE;\n<line30>            } else {\n<line31>                LOG.warn(\"Could not find the stats for less than me: {}\", lastChildName.getName());\n<line32>            }\n<line33>        } else {\n<line34>            if (isOwner()) {\n<line35>                LockListener lockListener = getLockListener();\n<line36>                if (lockListener != null) {\n<line37>                    lockListener.lockAcquired();\n<line38>                }\n<line39>                return Boolean.TRUE;\n<line40>            }\n<line41>        }\n<line42>    }\n<line43>}"},{"input":"","instruction":"<line1>{\n<line2>    // lets sort them explicitly (though they do seem to come back in order ususally :)\n<line3>    SortedSet<ZNodeName> sortedNames = new TreeSet<>();\n<line4>    for (String name : names) {\n<line5>        sortedNames.add(new ZNodeName(dir + \"/\" + name));\n<line6>    }\n<line7>    ownerId = sortedNames.first().getName();\n<line8>    SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);\n<line9>    if (!lessThanMe.isEmpty()) {\n<line10>        ZNodeName lastChildName = lessThanMe.last();\n<line11>        lastChildId = lastChildName.getName();\n<line12>        Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line13>        if (stat != null) {\n<line14>            return Boolean.FALSE;\n<line15>        } else {\n<line16>        }\n<line17>    } else {\n<line18>        if (isOwner()) {\n<line19>            LockListener lockListener = getLockListener();\n<line20>            if (lockListener != null) {\n<line21>                lockListener.lockAcquired();\n<line22>            }\n<line23>            return Boolean.TRUE;\n<line24>        }\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    // lets sort them explicitly (though they do seem to come back in order ususally :)\n<line3>    SortedSet<ZNodeName> sortedNames = new TreeSet<>();\n<line4>    for (String name : names) {\n<line5>        sortedNames.add(new ZNodeName(dir + \"/\" + name));\n<line6>    }\n<line7>    ownerId = sortedNames.first().getName();\n<line8>    SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);\n<line9>    if (!lessThanMe.isEmpty()) {\n<line10>        ZNodeName lastChildName = lessThanMe.last();\n<line11>        lastChildId = lastChildName.getName();\n<line12>        LOG.debug(\"Watching less than me node: {}\", lastChildId);\n<line13>        Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line14>        if (stat != null) {\n<line15>            return Boolean.FALSE;\n<line16>        } else {\n<line17>            LOG.warn(\"Could not find the stats for less than me: {}\", lastChildName.getName());\n<line18>        }\n<line19>    } else {\n<line20>        if (isOwner()) {\n<line21>            LockListener lockListener = getLockListener();\n<line22>            if (lockListener != null) {\n<line23>                lockListener.lockAcquired();\n<line24>            }\n<line25>            return Boolean.TRUE;\n<line26>        }\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    ZNodeName lastChildName = lessThanMe.last();\n<line3>    lastChildId = lastChildName.getName();\n<line4>    Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line5>    if (stat != null) {\n<line6>        return Boolean.FALSE;\n<line7>    } else {\n<line8>    }\n<line9>}","output":"<line1>{\n<line2>    ZNodeName lastChildName = lessThanMe.last();\n<line3>    lastChildId = lastChildName.getName();\n<line4>    LOG.debug(\"Watching less than me node: {}\", lastChildId);\n<line5>    Stat stat = zookeeper.exists(lastChildId, new LockWatcher());\n<line6>    if (stat != null) {\n<line7>        return Boolean.FALSE;\n<line8>    } else {\n<line9>        LOG.warn(\"Could not find the stats for less than me: {}\", lastChildName.getName());\n<line10>    }\n<line11>}"},{"input":"","instruction":"<line1>{\n<line2>    KeeperException exception = null;\n<line3>    for (int i = 0; i < RETRY_COUNT; i++) {\n<line4>        try {\n<line5>            return operation.execute();\n<line6>        } catch (KeeperException.SessionExpiredException e) {\n<line7>            throw e;\n<line8>        } catch (KeeperException.ConnectionLossException e) {\n<line9>            if (exception == null) {\n<line10>                exception = e;\n<line11>            }\n<line12>            retryDelay(i);\n<line13>        }\n<line14>    }\n<line15>    throw exception;\n<line16>}","output":"<line1>{\n<line2>    KeeperException exception = null;\n<line3>    for (int i = 0; i < RETRY_COUNT; i++) {\n<line4>        try {\n<line5>            return operation.execute();\n<line6>        } catch (KeeperException.SessionExpiredException e) {\n<line7>            LOG.warn(\"Session expired {}. Reconnecting...\", zookeeper, e);\n<line8>            throw e;\n<line9>        } catch (KeeperException.ConnectionLossException e) {\n<line10>            if (exception == null) {\n<line11>                exception = e;\n<line12>            }\n<line13>            LOG.debug(\"Attempt {} failed with connection loss. Reconnecting...\", i);\n<line14>            retryDelay(i);\n<line15>        }\n<line16>    }\n<line17>    throw exception;\n<line18>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        return operation.execute();\n<line4>    } catch (KeeperException.SessionExpiredException e) {\n<line5>        throw e;\n<line6>    } catch (KeeperException.ConnectionLossException e) {\n<line7>        if (exception == null) {\n<line8>            exception = e;\n<line9>        }\n<line10>        retryDelay(i);\n<line11>    }\n<line12>}","output":"<line1>{\n<line2>    try {\n<line3>        return operation.execute();\n<line4>    } catch (KeeperException.SessionExpiredException e) {\n<line5>        LOG.warn(\"Session expired {}. Reconnecting...\", zookeeper, e);\n<line6>        throw e;\n<line7>    } catch (KeeperException.ConnectionLossException e) {\n<line8>        if (exception == null) {\n<line9>            exception = e;\n<line10>        }\n<line11>        LOG.debug(\"Attempt {} failed with connection loss. Reconnecting...\", i);\n<line12>        retryDelay(i);\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (exception == null) {\n<line3>        exception = e;\n<line4>    }\n<line5>    retryDelay(i);\n<line6>}","output":"<line1>{\n<line2>    if (exception == null) {\n<line3>        exception = e;\n<line4>    }\n<line5>    LOG.debug(\"Attempt {} failed with connection loss. Reconnecting...\", i);\n<line6>    retryDelay(i);\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>    this.host = configuration.getProperty(\"httpHost\", \"0.0.0.0\");\n<line3>    this.port = Integer.parseInt(configuration.getProperty(\"httpPort\", \"7000\"));\n<line4>    this.exportJvmInfo = Boolean.parseBoolean(configuration.getProperty(\"exportJvmInfo\", \"true\"));\n<line5>    this.numWorkerThreads = Integer.parseInt(configuration.getProperty(NUM_WORKER_THREADS, \"1\"));\n<line6>    this.maxQueueSize = Integer.parseInt(configuration.getProperty(MAX_QUEUE_SIZE, \"1000000\"));\n<line7>    this.workerShutdownTimeoutMs = Long.parseLong(configuration.getProperty(WORKER_SHUTDOWN_TIMEOUT_MS, \"1000\"));\n<line8>}","output":"<line1>{\n<line2>    LOG.info(\"Initializing metrics, configuration: {}\", configuration);\n<line3>    this.host = configuration.getProperty(\"httpHost\", \"0.0.0.0\");\n<line4>    this.port = Integer.parseInt(configuration.getProperty(\"httpPort\", \"7000\"));\n<line5>    this.exportJvmInfo = Boolean.parseBoolean(configuration.getProperty(\"exportJvmInfo\", \"true\"));\n<line6>    this.numWorkerThreads = Integer.parseInt(configuration.getProperty(NUM_WORKER_THREADS, \"1\"));\n<line7>    this.maxQueueSize = Integer.parseInt(configuration.getProperty(MAX_QUEUE_SIZE, \"1000000\"));\n<line8>    this.workerShutdownTimeoutMs = Long.parseLong(configuration.getProperty(WORKER_SHUTDOWN_TIMEOUT_MS, \"1000\"));\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>    this.executorOptional = createExecutor();\n<line3>    try {\n<line4>        if (exportJvmInfo) {\n<line5>            DefaultExports.initialize();\n<line6>        }\n<line7>        server = new Server(new InetSocketAddress(host, port));\n<line8>        ServletContextHandler context = new ServletContextHandler();\n<line9>        context.setContextPath(\"/\");\n<line10>        constrainTraceMethod(context);\n<line11>        server.setHandler(context);\n<line12>        context.addServlet(new ServletHolder(servlet), \"/metrics\");\n<line13>        server.start();\n<line14>    } catch (Exception err) {\n<line15>        if (server != null) {\n<line16>            try {\n<line17>                server.stop();\n<line18>            } catch (Exception suppressed) {\n<line19>                err.addSuppressed(suppressed);\n<line20>            } finally {\n<line21>                server = null;\n<line22>            }\n<line23>        }\n<line24>        throw new MetricsProviderLifeCycleException(err);\n<line25>    }\n<line26>}","output":"<line1>{\n<line2>    this.executorOptional = createExecutor();\n<line3>    try {\n<line4>        LOG.info(\"Starting /metrics HTTP endpoint at host: {}, port: {}, exportJvmInfo: {}\", host, port, exportJvmInfo);\n<line5>        if (exportJvmInfo) {\n<line6>            DefaultExports.initialize();\n<line7>        }\n<line8>        server = new Server(new InetSocketAddress(host, port));\n<line9>        ServletContextHandler context = new ServletContextHandler();\n<line10>        context.setContextPath(\"/\");\n<line11>        constrainTraceMethod(context);\n<line12>        server.setHandler(context);\n<line13>        context.addServlet(new ServletHolder(servlet), \"/metrics\");\n<line14>        server.start();\n<line15>    } catch (Exception err) {\n<line16>        LOG.error(\"Cannot start /metrics server\", err);\n<line17>        if (server != null) {\n<line18>            try {\n<line19>                server.stop();\n<line20>            } catch (Exception suppressed) {\n<line21>                err.addSuppressed(suppressed);\n<line22>            } finally {\n<line23>                server = null;\n<line24>            }\n<line25>        }\n<line26>        throw new MetricsProviderLifeCycleException(err);\n<line27>    }\n<line28>}"},{"input":"","instruction":"<line1>{\n<line2>    if (exportJvmInfo) {\n<line3>        DefaultExports.initialize();\n<line4>    }\n<line5>    server = new Server(new InetSocketAddress(host, port));\n<line6>    ServletContextHandler context = new ServletContextHandler();\n<line7>    context.setContextPath(\"/\");\n<line8>    constrainTraceMethod(context);\n<line9>    server.setHandler(context);\n<line10>    context.addServlet(new ServletHolder(servlet), \"/metrics\");\n<line11>    server.start();\n<line12>}","output":"<line1>{\n<line2>    LOG.info(\"Starting /metrics HTTP endpoint at host: {}, port: {}, exportJvmInfo: {}\", host, port, exportJvmInfo);\n<line3>    if (exportJvmInfo) {\n<line4>        DefaultExports.initialize();\n<line5>    }\n<line6>    server = new Server(new InetSocketAddress(host, port));\n<line7>    ServletContextHandler context = new ServletContextHandler();\n<line8>    context.setContextPath(\"/\");\n<line9>    constrainTraceMethod(context);\n<line10>    server.setHandler(context);\n<line11>    context.addServlet(new ServletHolder(servlet), \"/metrics\");\n<line12>    server.start();\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    if (server != null) {\n<line3>        try {\n<line4>            server.stop();\n<line5>        } catch (Exception suppressed) {\n<line6>            err.addSuppressed(suppressed);\n<line7>        } finally {\n<line8>            server = null;\n<line9>        }\n<line10>    }\n<line11>    throw new MetricsProviderLifeCycleException(err);\n<line12>}","output":"<line1>{\n<line2>    LOG.error(\"Cannot start /metrics server\", err);\n<line3>    if (server != null) {\n<line4>        try {\n<line5>            server.stop();\n<line6>        } catch (Exception suppressed) {\n<line7>            err.addSuppressed(suppressed);\n<line8>        } finally {\n<line9>            server = null;\n<line10>        }\n<line11>    }\n<line12>    throw new MetricsProviderLifeCycleException(err);\n<line13>}"},{"input":"","instruction":"<line1>{\n<line2>    shutdownExecutor();\n<line3>    if (server != null) {\n<line4>        try {\n<line5>            server.stop();\n<line6>        } catch (Exception err) {\n<line7>        } finally {\n<line8>            server = null;\n<line9>        }\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    shutdownExecutor();\n<line3>    if (server != null) {\n<line4>        try {\n<line5>            server.stop();\n<line6>        } catch (Exception err) {\n<line7>            LOG.error(\"Cannot safely stop Jetty server\", err);\n<line8>        } finally {\n<line9>            server = null;\n<line10>        }\n<line11>    }\n<line12>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        server.stop();\n<line4>    } catch (Exception err) {\n<line5>    } finally {\n<line6>        server = null;\n<line7>    }\n<line8>}","output":"<line1>{\n<line2>    try {\n<line3>        server.stop();\n<line4>    } catch (Exception err) {\n<line5>        LOG.error(\"Cannot safely stop Jetty server\", err);\n<line6>    } finally {\n<line7>        server = null;\n<line8>    }\n<line9>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"Cannot safely stop Jetty server\", err);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        inner.inc(delta);\n<line4>    } catch (IllegalArgumentException err) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        inner.inc(delta);\n<line4>    } catch (IllegalArgumentException err) {\n<line5>        LOG.error(\"invalid delta {} for metric {}\", delta, name, err);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"invalid delta {} for metric {}\", delta, name, err);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        inner.labels(key).inc(delta);\n<line4>    } catch (final IllegalArgumentException e) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        inner.labels(key).inc(delta);\n<line4>    } catch (final IllegalArgumentException e) {\n<line5>        LOG.error(\"invalid delta {} for metric {} with key {}\", delta, name, key, e);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"invalid delta {} for metric {} with key {}\", delta, name, key, e);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        inner.observe(delta);\n<line4>    } catch (final IllegalArgumentException err) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        inner.observe(delta);\n<line4>    } catch (final IllegalArgumentException err) {\n<line5>        LOG.error(\"invalid delta {} for metric {}\", delta, name, err);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"invalid delta {} for metric {}\", delta, name, err);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    try {\n<line3>        inner.labels(key).observe(value);\n<line4>    } catch (final IllegalArgumentException err) {\n<line5>    }\n<line6>}","output":"<line1>{\n<line2>    try {\n<line3>        inner.labels(key).observe(value);\n<line4>    } catch (final IllegalArgumentException err) {\n<line5>        LOG.error(\"invalid value {} for metric {} with key {}\", value, name, key, err);\n<line6>    }\n<line7>}"},{"input":"","instruction":"<line1>{\n<line2>}","output":"<line1>{\n<line2>    LOG.error(\"invalid value {} for metric {} with key {}\", value, name, key, err);\n<line3>}"},{"input":"","instruction":"<line1>{\n<line2>    if (numWorkerThreads < 1) {\n<line3>        return Optional.empty();\n<line4>    }\n<line5>    final BlockingQueue<Runnable> queue = new LinkedBlockingQueue<>(maxQueueSize);\n<line6>    final ThreadPoolExecutor executor = new ThreadPoolExecutor(numWorkerThreads, numWorkerThreads, 0L, TimeUnit.MILLISECONDS, queue, new PrometheusWorkerThreadFactory());\n<line7>    return Optional.of(executor);\n<line8>}","output":"<line1>{\n<line2>    if (numWorkerThreads < 1) {\n<line3>        LOG.info(\"Executor service was not created as numWorkerThreads {} is less than 1\", numWorkerThreads);\n<line4>        return Optional.empty();\n<line5>    }\n<line6>    final BlockingQueue<Runnable> queue = new LinkedBlockingQueue<>(maxQueueSize);\n<line7>    final ThreadPoolExecutor executor = new ThreadPoolExecutor(numWorkerThreads, numWorkerThreads, 0L, TimeUnit.MILLISECONDS, queue, new PrometheusWorkerThreadFactory());\n<line8>    LOG.info(\"Executor service was created with numWorkerThreads {} and maxQueueSize {}\", numWorkerThreads, maxQueueSize);\n<line9>    return Optional.of(executor);\n<line10>}"},{"input":"","instruction":"<line1>{\n<line2>    return Optional.empty();\n<line3>}","output":"<line1>{\n<line2>    LOG.info(\"Executor service was not created as numWorkerThreads {} is less than 1\", numWorkerThreads);\n<line3>    return Optional.empty();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    if (executorOptional.isPresent()) {\n<line3>        final ExecutorService executor = executorOptional.get();\n<line4>        executor.shutdown();\n<line5>        try {\n<line6>            if (!executor.awaitTermination(workerShutdownTimeoutMs, TimeUnit.MILLISECONDS)) {\n<line7>                executor.shutdownNow();\n<line8>            }\n<line9>        } catch (final Exception e) {\n<line10>            executor.shutdownNow();\n<line11>        }\n<line12>    }\n<line13>}","output":"<line1>{\n<line2>    if (executorOptional.isPresent()) {\n<line3>        LOG.info(\"Shutdown executor service with timeout {}\", workerShutdownTimeoutMs);\n<line4>        final ExecutorService executor = executorOptional.get();\n<line5>        executor.shutdown();\n<line6>        try {\n<line7>            if (!executor.awaitTermination(workerShutdownTimeoutMs, TimeUnit.MILLISECONDS)) {\n<line8>                LOG.error(\"Not all the Prometheus worker threads terminated properly after {} timeout\", workerShutdownTimeoutMs);\n<line9>                executor.shutdownNow();\n<line10>            }\n<line11>        } catch (final Exception e) {\n<line12>            LOG.error(\"Error occurred while terminating Prometheus worker threads\", e);\n<line13>            executor.shutdownNow();\n<line14>        }\n<line15>    }\n<line16>}"},{"input":"","instruction":"<line1>{\n<line2>    final ExecutorService executor = executorOptional.get();\n<line3>    executor.shutdown();\n<line4>    try {\n<line5>        if (!executor.awaitTermination(workerShutdownTimeoutMs, TimeUnit.MILLISECONDS)) {\n<line6>            executor.shutdownNow();\n<line7>        }\n<line8>    } catch (final Exception e) {\n<line9>        executor.shutdownNow();\n<line10>    }\n<line11>}","output":"<line1>{\n<line2>    LOG.info(\"Shutdown executor service with timeout {}\", workerShutdownTimeoutMs);\n<line3>    final ExecutorService executor = executorOptional.get();\n<line4>    executor.shutdown();\n<line5>    try {\n<line6>        if (!executor.awaitTermination(workerShutdownTimeoutMs, TimeUnit.MILLISECONDS)) {\n<line7>            LOG.error(\"Not all the Prometheus worker threads terminated properly after {} timeout\", workerShutdownTimeoutMs);\n<line8>            executor.shutdownNow();\n<line9>        }\n<line10>    } catch (final Exception e) {\n<line11>        LOG.error(\"Error occurred while terminating Prometheus worker threads\", e);\n<line12>        executor.shutdownNow();\n<line13>    }\n<line14>}"},{"input":"","instruction":"<line1>{\n<line2>    if (!executor.awaitTermination(workerShutdownTimeoutMs, TimeUnit.MILLISECONDS)) {\n<line3>        executor.shutdownNow();\n<line4>    }\n<line5>}","output":"<line1>{\n<line2>    if (!executor.awaitTermination(workerShutdownTimeoutMs, TimeUnit.MILLISECONDS)) {\n<line3>        LOG.error(\"Not all the Prometheus worker threads terminated properly after {} timeout\", workerShutdownTimeoutMs);\n<line4>        executor.shutdownNow();\n<line5>    }\n<line6>}"},{"input":"","instruction":"<line1>{\n<line2>    executor.shutdownNow();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Not all the Prometheus worker threads terminated properly after {} timeout\", workerShutdownTimeoutMs);\n<line3>    executor.shutdownNow();\n<line4>}"},{"input":"","instruction":"<line1>{\n<line2>    executor.shutdownNow();\n<line3>}","output":"<line1>{\n<line2>    LOG.error(\"Error occurred while terminating Prometheus worker threads\", e);\n<line3>    executor.shutdownNow();\n<line4>}"}]